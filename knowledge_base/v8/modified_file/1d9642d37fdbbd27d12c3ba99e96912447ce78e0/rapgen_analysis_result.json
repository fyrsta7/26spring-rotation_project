{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1d9642d37fdbbd27d12c3ba99e96912447ce78e0",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1d9642d37fdbbd27d12c3ba99e96912447ce78e0/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1d9642d37fdbbd27d12c3ba99e96912447ce78e0/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/1d9642d37fdbbd27d12c3ba99e96912447ce78e0/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 838,
          "old_api": "std::numeric_limits<int>::max()",
          "new_api": "Start",
          "old_text": "std::numeric_limits<int>::max()",
          "new_text": "Start()",
          "old_line_content": "    const int kInvalidId = std::numeric_limits<int>::max();",
          "new_line_content": "    DCHECK(start > Start());",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "machine_type",
          "new_api": "Start",
          "old_text": "this->machine_type()",
          "new_text": "Start()",
          "old_line_content": "    LiveRange end_part(kInvalidId, this->machine_type(), nullptr);",
          "new_line_content": "    DCHECK(start < End() && Start() < end);",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "set_next",
          "new_api": "DetachAt",
          "old_text": "last_interval_->set_next(end_part.first_interval_)",
          "new_text": "DetachAt(start, result, zone)",
          "old_line_content": "    last_interval_->set_next(end_part.first_interval_);",
          "new_line_content": "    DetachAt(start, result, zone);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "SetSpillRange",
          "new_api": "SetSplinteredFrom",
          "old_text": "SetSpillRange(splinter_parent->spill_range_)",
          "new_text": "result->SetSplinteredFrom(this)",
          "old_line_content": "    SetSpillRange(splinter_parent->spill_range_);",
          "new_line_content": "  result->SetSplinteredFrom(this);",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "TopLevel",
          "new_api": "Start",
          "old_text": "merged->TopLevel()",
          "new_text": "Start()",
          "old_line_content": "  DCHECK(merged->TopLevel() == this);",
          "new_line_content": "  DCHECK(splinter_parent->Start() < Start());",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": "spill_type",
          "new_api": "HasSpillOperand",
          "old_text": "merged->spill_type()",
          "new_text": "HasSpillOperand()",
          "old_line_content": "    set_spill_type(merged->spill_type());",
          "new_line_content": "  if (!HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "size",
          "new_api": "SetSpillRange",
          "old_text": "GetSpillRange()->live_ranges().size()",
          "new_text": "SetSpillRange(splinter_parent->spill_range_)",
          "old_line_content": "    DCHECK(GetSpillRange()->live_ranges().size() > 0);",
          "new_line_content": "    SetSpillRange(splinter_parent->spill_range_);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "Start",
          "new_api": "size",
          "old_text": "other->Start()",
          "new_text": "GetSpillRange()->live_ranges().size()",
          "old_line_content": "  DCHECK(Start() < other->Start());",
          "new_line_content": "    DCHECK(GetSpillRange()->live_ranges().size() > 0);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "vreg",
          "new_api": "SpillTypeField::update(merged->bits_, SpillType::kNoSpillType)",
          "old_text": "other->vreg()",
          "new_text": "SpillTypeField::update(merged->bits_, SpillType::kNoSpillType)",
          "old_line_content": "  data->live_ranges()[other->vreg()] = nullptr;",
          "new_line_content": "        SpillTypeField::update(merged->bits_, SpillType::kNoSpillType);",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": "End",
          "new_api": "splintered_from",
          "old_text": "last_other->End()",
          "new_text": "other->splintered_from()",
          "old_line_content": "  DCHECK(last_me->End() > last_other->End());",
          "new_line_content": "  DCHECK(other->splintered_from() == this);",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": "Start",
          "new_api": "last_child",
          "old_text": "last_insertion_point_->Start()",
          "new_text": "other->last_child()",
          "old_line_content": "  if (other->Start() < last_insertion_point_->Start()) {",
          "new_line_content": "  LiveRange* last_other = other->last_child();",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": "next",
          "new_api": "AppendAsChild",
          "old_text": "last_insertion_point_->next()",
          "new_text": "last_me->AppendAsChild(other)",
          "old_line_content": "  for (; last_insertion_point_->next() != nullptr &&",
          "new_line_content": "  if (last_me->End() <= other->Start()) return last_me->AppendAsChild(other);",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": "next",
          "new_api": "End",
          "old_text": "last_insertion_point_->next()",
          "new_text": "last_other->End()",
          "old_line_content": "       last_insertion_point_ = last_insertion_point_->next()) {",
          "new_line_content": "  DCHECK(last_me->End() > last_other->End());",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "Start",
          "new_api": "next",
          "old_text": "other->Start()",
          "new_text": "last_insertion_point_->next()",
          "old_line_content": "  if (last_insertion_point_->End() > other->Start()) {",
          "new_line_content": "  for (; last_insertion_point_->next() != nullptr &&",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "allocation_zone",
          "new_api": "next",
          "old_text": "data->allocation_zone()",
          "new_text": "last_insertion_point_->next()",
          "old_line_content": "        last_insertion_point_->SplitAt(other->Start(), data->allocation_zone());",
          "new_line_content": "       last_insertion_point_ = last_insertion_point_->next()) {",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "TopLevel",
          "new_api": "allocation_zone",
          "old_text": "TopLevel()",
          "new_text": "data->allocation_zone()",
          "old_line_content": "  other->UpdateParentForAllChildren(TopLevel());",
          "new_line_content": "        last_insertion_point_->SplitAt(other->Start(), data->allocation_zone());",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "UpdateSpillRangePostMerge",
          "new_api": "spilled",
          "old_text": "TopLevel()->UpdateSpillRangePostMerge(other)",
          "new_text": "last_insertion_point_->spilled()",
          "old_line_content": "  TopLevel()->UpdateSpillRangePostMerge(other);",
          "new_line_content": "    new_after->set_spilled(last_insertion_point_->spilled());",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": "set_start",
          "new_api": "TopLevel",
          "old_text": "first_interval_->set_start(start)",
          "new_text": "TopLevel()",
          "old_line_content": "  first_interval_->set_start(start);",
          "new_line_content": "  other->UpdateParentForAllChildren(TopLevel());",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "value",
          "new_api": "DCHECK",
          "old_text": "end.value()",
          "new_text": "DCHECK(first_interval_ != nullptr)",
          "old_line_content": "        end.value());",
          "new_line_content": "  DCHECK(first_interval_ != nullptr);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": "start",
          "new_api": "end",
          "old_text": "first_interval_->start()",
          "new_text": "first_interval_->end()",
          "old_line_content": "  while (first_interval_ != nullptr && first_interval_->start() <= end) {",
          "new_line_content": "  DCHECK(start < first_interval_->end());",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "end",
          "new_api": "set_start",
          "old_text": "first_interval_->end()",
          "new_text": "first_interval_->set_start(start)",
          "old_line_content": "    if (first_interval_->end() > end) {",
          "new_line_content": "  first_interval_->set_start(start);",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "set_next",
          "new_api": "value",
          "old_text": "new_interval->set_next(first_interval_)",
          "new_text": "end.value()",
          "old_line_content": "  new_interval->set_next(first_interval_);",
          "new_line_content": "        end.value());",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": "next",
          "new_api": "start",
          "old_text": "new_interval->next()",
          "new_text": "first_interval_->start()",
          "old_line_content": "  if (new_interval->next() == nullptr) {",
          "new_line_content": "  while (first_interval_ != nullptr && first_interval_->start() <= end) {",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": "value",
          "new_api": "set_next",
          "old_text": "start.value()",
          "new_text": "new_interval->set_next(first_interval_)",
          "old_line_content": "  TRACE(\"Add to live range %d interval [%d %d[\\n\", vreg(), start.value(),",
          "new_line_content": "  new_interval->set_next(first_interval_);",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "set_next",
          "new_api": "value",
          "old_text": "interval->set_next(first_interval_)",
          "new_text": "end.value()",
          "old_line_content": "      interval->set_next(first_interval_);",
          "new_line_content": "        end.value());",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "end",
          "new_api": "start",
          "old_text": "first_interval_->end()",
          "new_text": "first_interval_->start()",
          "old_line_content": "      DCHECK(start < first_interval_->end());",
          "new_line_content": "    if (end == first_interval_->start()) {",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "start",
          "new_api": "set_start",
          "old_text": "first_interval_->start()",
          "new_text": "first_interval_->set_start(start)",
          "old_line_content": "      first_interval_->set_start(Min(start, first_interval_->start()));",
          "new_line_content": "      first_interval_->set_start(start);",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "end",
          "new_api": "start",
          "old_text": "first_interval_->end()",
          "new_text": "first_interval_->start()",
          "old_line_content": "      first_interval_->set_end(Max(end, first_interval_->end()));",
          "new_line_content": "    } else if (end < first_interval_->start()) {",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": "value",
          "new_api": "end",
          "old_text": "pos.value()",
          "new_text": "first_interval_->end()",
          "old_line_content": "  TRACE(\"Add to live range %d use position %d\\n\", vreg(), pos.value());",
          "new_line_content": "      DCHECK(start < first_interval_->end());",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "next",
          "new_api": "pos",
          "old_text": "prev->next()",
          "new_text": "current->pos()",
          "old_line_content": "    use_pos->set_next(prev->next());",
          "new_line_content": "  while (current != nullptr && current->pos() < pos) {",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "set_next",
          "new_api": "HasHint",
          "old_text": "prev->set_next(use_pos)",
          "new_text": "current->HasHint()",
          "old_line_content": "    prev->set_next(use_pos);",
          "new_line_content": "    prev_hint = current->HasHint() ? current : prev_hint;",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": "start",
          "new_api": "HasHint",
          "old_text": "interval2->start()",
          "new_text": "use_pos->HasHint()",
          "old_line_content": "      if (interval1->end() > interval2->start()) {",
          "new_line_content": "  if (prev_hint == nullptr && use_pos->HasHint()) {",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "relative_id",
          "new_api": "next",
          "old_text": "range->relative_id()",
          "new_text": "interval2->next()",
          "old_line_content": "  os << \"Range: \" << range->TopLevel()->vreg() << \":\" << range->relative_id()",
          "new_line_content": "      interval2 = interval2->next();",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "pos",
          "new_api": "TopLevel",
          "old_text": "use_pos->pos()",
          "new_text": "range->TopLevel()->is_phi()",
          "old_line_content": "    os << pio << use_pos->pos() << \" \";",
          "new_line_content": "  if (range->TopLevel()->is_phi()) os << \"phi \";",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": "next",
          "new_api": "TopLevel",
          "old_text": "use_pos->next()",
          "new_text": "range->TopLevel()->is_non_loop_phi()",
          "old_line_content": "    use_pos = use_pos->next();",
          "new_line_content": "  if (range->TopLevel()->is_non_loop_phi()) os << \"nlphi \";",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": "machine_type",
          "new_api": "next",
          "old_text": "parent->machine_type()",
          "new_text": "interval->next()",
          "old_line_content": "      byte_width_(GetByteWidth(parent->machine_type())),",
          "new_line_content": "    interval = interval->next();",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "first_interval",
          "new_api": "machine_type",
          "old_text": "range->first_interval()",
          "new_text": "parent->machine_type()",
          "old_line_content": "    auto src = range->first_interval();",
          "new_line_content": "      byte_width_(GetByteWidth(parent->machine_type())),",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "AreUseIntervalsIntersecting",
          "new_api": "machine_type",
          "old_text": "AreUseIntervalsIntersecting(use_interval_, other->use_interval_)",
          "new_text": "live_ranges_[0]->machine_type()",
          "old_line_content": "  return AreUseIntervalsIntersecting(use_interval_, other->use_interval_);",
          "new_line_content": "  return GetByteWidth(live_ranges_[0]->machine_type());",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "kind",
          "new_api": "start",
          "old_text": "other->live_ranges_[0]->kind()",
          "new_text": "other->use_interval_->start()",
          "old_line_content": "  if (live_ranges_[0]->kind() != other->live_ranges_[0]->kind() ||",
          "new_line_content": "      this->End() <= other->use_interval_->start() ||",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "IsIntersectingWith",
          "new_api": "start",
          "old_text": "IsIntersectingWith(other)",
          "new_text": "this->use_interval_->start()",
          "old_line_content": "      IsIntersectingWith(other)) {",
          "new_line_content": "      other->End() <= this->use_interval_->start()) {",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "MergeDisjointIntervals",
          "new_api": "IsIntersectingWith",
          "old_text": "MergeDisjointIntervals(other->use_interval_)",
          "new_text": "IsIntersectingWith(other)",
          "old_line_content": "  MergeDisjointIntervals(other->use_interval_);",
          "new_line_content": "      IsIntersectingWith(other)) {",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "GetSpillRange",
          "new_api": "LifetimePosition::MaxPosition()",
          "old_text": "range->GetSpillRange()",
          "new_text": "LifetimePosition::MaxPosition()",
          "old_line_content": "    DCHECK(range->GetSpillRange() == other);",
          "new_line_content": "  auto max = LifetimePosition::MaxPosition();",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "SetSpillRange",
          "new_api": "End",
          "old_text": "range->SetSpillRange(this)",
          "new_text": "other->End()",
          "old_line_content": "    range->SetSpillRange(this);",
          "new_line_content": "  if (End() < other->End() && other->End() != max) {",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "clear",
          "new_api": "MergeDisjointIntervals",
          "old_text": "other->live_ranges().clear()",
          "new_text": "MergeDisjointIntervals(other->use_interval_)",
          "old_line_content": "  other->live_ranges().clear();",
          "new_line_content": "  MergeDisjointIntervals(other->use_interval_);",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "config",
          "new_api": "allocation_zone",
          "old_text": "this->config()->num_general_registers()",
          "new_text": "allocation_zone()",
          "old_line_content": "  DCHECK(this->config()->num_general_registers() <=",
          "new_line_content": "                   allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": "config",
          "new_api": "allocation_zone",
          "old_text": "this->config()->num_double_registers()",
          "new_text": "allocation_zone()",
          "old_line_content": "  DCHECK(this->config()->num_double_registers() <=",
          "new_line_content": "                         allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "code_zone",
          "new_api": "allocation_zone",
          "old_text": "code_zone()",
          "new_text": "allocation_zone()",
          "old_line_content": "  assigned_registers_ = new (code_zone())",
          "new_line_content": "                                allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": "code_zone",
          "new_api": "allocation_zone",
          "old_text": "code_zone()",
          "new_text": "allocation_zone()",
          "old_line_content": "      BitVector(this->config()->num_general_registers(), code_zone());",
          "new_line_content": "      spill_ranges_(code->VirtualRegisterCount(), nullptr, allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "code_zone",
          "new_api": "allocation_zone",
          "old_text": "code_zone()",
          "new_text": "allocation_zone()",
          "old_line_content": "  assigned_double_registers_ = new (code_zone())",
          "new_line_content": "      delayed_references_(allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": "frame",
          "new_api": "VirtualRegisterCount",
          "old_text": "this->frame()->SetAllocatedDoubleRegisters(assigned_double_registers_)",
          "new_text": "code->VirtualRegisterCount()",
          "old_line_content": "  this->frame()->SetAllocatedDoubleRegisters(assigned_double_registers_);",
          "new_line_content": "      virtual_register_count_(code->VirtualRegisterCount()) {",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": "InstructionAt",
          "new_api": "code_zone",
          "old_text": "code()->InstructionAt(index)",
          "new_text": "code_zone()",
          "old_line_content": "  auto instr = code()->InstructionAt(index);",
          "new_line_content": "  assigned_double_registers_ = new (code_zone())",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "AddMove",
          "new_api": "frame",
          "old_text": "moves->AddMove(from, to)",
          "new_text": "this->frame()->SetAllocatedRegisters(assigned_registers_)",
          "old_line_content": "  return moves->AddMove(from, to);",
          "new_line_content": "  this->frame()->SetAllocatedRegisters(assigned_registers_);",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "MachineTypeFor",
          "new_api": "GetRepresentation",
          "old_text": "MachineTypeFor(index)",
          "new_text": "code()->GetRepresentation(virtual_register)",
          "old_line_content": "    result = NewLiveRange(index, MachineTypeFor(index));",
          "new_line_content": "  return code()->GetRepresentation(virtual_register);",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "NewLiveRange",
          "new_api": "size",
          "old_text": "NewLiveRange(vreg, machine_type)",
          "new_text": "live_ranges().size()",
          "old_line_content": "  TopLevelLiveRange* ret = NewLiveRange(vreg, machine_type);",
          "new_line_content": "  if (vreg >= static_cast<int>(live_ranges().size())) {",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "virtual_register",
          "new_api": "NewLiveRange",
          "old_text": "phi->virtual_register()",
          "new_text": "NewLiveRange(vreg, machine_type)",
          "old_line_content": "      phi_map_.insert(std::make_pair(phi->virtual_register(), map_value));",
          "new_line_content": "  TopLevelLiveRange* ret = NewLiveRange(vreg, machine_type);",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "end",
          "new_api": "virtual_register",
          "old_text": "phi_map_.end()",
          "new_text": "phi->virtual_register()",
          "old_line_content": "  DCHECK(it != phi_map_.end());",
          "new_line_content": "      phi_map_.insert(std::make_pair(phi->virtual_register(), map_value));",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": "PrintF",
          "new_api": "vreg",
          "old_text": "PrintF(\"Register allocator error: live v%d reached first block.\\n\",\n           operand_index)",
          "new_text": "top_range->vreg()",
          "old_line_content": "    PrintF(\"Register allocator error: live v%d reached first block.\\n\",",
          "new_line_content": "  return GetPhiMapValueFor(top_range->vreg());",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "debug_name",
          "new_api": "Done",
          "old_text": "debug_name()",
          "new_text": "iterator.Done()",
          "old_line_content": "      PrintF(\"  (function: %s)\\n\", debug_name());",
          "new_line_content": "  while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "Advance",
          "new_api": "Current",
          "old_text": "iterator.Advance()",
          "new_text": "iterator.Current()",
          "old_line_content": "    iterator.Advance();",
          "new_line_content": "    int operand_index = iterator.Current();",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "HasSpillOperand",
          "new_api": "debug_name",
          "old_text": "range->HasSpillOperand()",
          "new_text": "debug_name()",
          "old_line_content": "  DCHECK(!range->HasSpillOperand());",
          "new_line_content": "      PrintF(\"  (function: %s)\\n\", debug_name());",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": "GetAllocatedSpillRange",
          "new_api": "Advance",
          "old_text": "range->GetAllocatedSpillRange()",
          "new_text": "iterator.Advance()",
          "old_line_content": "  SpillRange* spill_range = range->GetAllocatedSpillRange();",
          "new_line_content": "    iterator.Advance();",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "vreg",
          "new_api": "HasSpillOperand",
          "old_text": "range->vreg()",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "      range->IsSplinter() ? range->splintered_from()->vreg() : range->vreg();",
          "new_line_content": "  DCHECK(!range->HasSpillOperand());",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "spill_ranges",
          "new_api": "GetAllocatedSpillRange",
          "old_text": "spill_ranges()",
          "new_text": "range->GetAllocatedSpillRange()",
          "old_line_content": "  spill_ranges()[spill_range_index] = spill_range;",
          "new_line_content": "  SpillRange* spill_range = range->GetAllocatedSpillRange();",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "HasSpillOperand",
          "new_api": "vreg",
          "old_text": "range->HasSpillOperand()",
          "new_text": "range->vreg()",
          "old_line_content": "  DCHECK(!range->HasSpillOperand());",
          "new_line_content": "      range->IsSplinter() ? range->splintered_from()->vreg() : range->vreg();",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "Add",
          "new_api": "HasSpillOperand",
          "old_text": "assigned_double_registers_->Add(index)",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    assigned_double_registers_->Add(index);",
          "new_line_content": "  DCHECK(!range->HasSpillOperand());",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "Add",
          "new_api": "allocation_zone",
          "old_text": "assigned_registers_->Add(index)",
          "new_text": "allocation_zone()",
          "old_line_content": "    assigned_registers_->Add(index);",
          "new_line_content": "      new (allocation_zone()) SpillRange(range, allocation_zone());",
          "content_same": false
        },
        {
          "line": 1369,
          "old_api": "ToInstructionIndex",
          "new_api": "Add",
          "old_text": "pos.ToInstructionIndex()",
          "new_text": "assigned_double_registers_->Add(index)",
          "old_line_content": "         code()->GetInstructionBlock(pos.ToInstructionIndex())->code_start() ==",
          "new_line_content": "    assigned_double_registers_->Add(index);",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": "config",
          "new_api": "IsFullStart",
          "old_text": "config()",
          "new_text": "pos.IsFullStart()",
          "old_line_content": "  wrapper.register_configuration_ = config();",
          "new_line_content": "  return pos.IsFullStart() &&",
          "content_same": false
        },
        {
          "line": 1418,
          "old_api": "destination",
          "new_api": "config",
          "old_text": "move->destination()",
          "new_text": "config()",
          "old_line_content": "  wrapper.op_ = move->destination();",
          "new_line_content": "  wrapper.register_configuration_ = config();",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "live_ranges",
          "new_api": "destination",
          "old_text": "spill_range->live_ranges()",
          "new_text": "move->destination()",
          "old_line_content": "  for (TopLevelLiveRange* range : spill_range->live_ranges()) {",
          "new_line_content": "  wrapper.op_ = move->destination();",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "IsFloatingPoint",
          "new_api": "virtual_register",
          "old_text": "IsFloatingPoint(machine_type)",
          "new_text": "operand->virtual_register()",
          "old_line_content": "        IsFloatingPoint(machine_type) ? AllocatedOperand::DOUBLE_STACK_SLOT",
          "new_line_content": "  TRACE(\"Allocating fixed reg for op %d\\n\", operand->virtual_register());",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "fixed_slot_index",
          "new_api": "InstructionSequence::DefaultRepresentation()",
          "old_text": "operand->fixed_slot_index()",
          "new_text": "InstructionSequence::DefaultRepresentation()",
          "old_line_content": "        AllocatedOperand(kind, machine_type, operand->fixed_slot_index());",
          "new_line_content": "  MachineType machine_type = InstructionSequence::DefaultRepresentation();",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": "HasFixedRegisterPolicy",
          "new_api": "virtual_register",
          "old_text": "operand->HasFixedRegisterPolicy()",
          "new_text": "operand->virtual_register()",
          "old_line_content": "  } else if (operand->HasFixedRegisterPolicy()) {",
          "new_line_content": "  int virtual_register = operand->virtual_register();",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "fixed_register_index",
          "new_api": "MachineTypeFor",
          "old_text": "operand->fixed_register_index()",
          "new_text": "data()->MachineTypeFor(virtual_register)",
          "old_line_content": "                                 operand->fixed_register_index());",
          "new_line_content": "    machine_type = data()->MachineTypeFor(virtual_register);",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "DCHECK_NE",
          "new_api": "HasFixedSlotPolicy",
          "old_text": "DCHECK_NE(InstructionOperand::kInvalidVirtualRegister, virtual_register)",
          "new_text": "operand->HasFixedSlotPolicy()",
          "old_line_content": "    DCHECK_NE(InstructionOperand::kInvalidVirtualRegister, virtual_register);",
          "new_line_content": "  if (operand->HasFixedSlotPolicy()) {",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "fixed_register_index",
          "new_api": "IsFloatingPoint",
          "old_text": "operand->fixed_register_index()",
          "new_text": "IsFloatingPoint(machine_type)",
          "old_line_content": "                                 machine_type, operand->fixed_register_index());",
          "new_line_content": "        IsFloatingPoint(machine_type) ? AllocatedOperand::DOUBLE_STACK_SLOT",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": "InstructionOperand::ReplaceWith(operand, &allocated)",
          "new_api": "HasFixedRegisterPolicy",
          "old_text": "InstructionOperand::ReplaceWith(operand, &allocated)",
          "new_text": "operand->HasFixedRegisterPolicy()",
          "old_line_content": "  InstructionOperand::ReplaceWith(operand, &allocated);",
          "new_line_content": "  } else if (operand->HasFixedRegisterPolicy()) {",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "TRACE",
          "new_api": "fixed_register_index",
          "old_text": "TRACE(\"Fixed reg is tagged at %d\\n\", pos)",
          "new_text": "operand->fixed_register_index()",
          "old_line_content": "    TRACE(\"Fixed reg is tagged at %d\\n\", pos);",
          "new_line_content": "                                 operand->fixed_register_index());",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "InstructionAt",
          "new_api": "HasFixedDoubleRegisterPolicy",
          "old_text": "code()->InstructionAt(pos)",
          "new_text": "operand->HasFixedDoubleRegisterPolicy()",
          "old_line_content": "    auto instr = code()->InstructionAt(pos);",
          "new_line_content": "  } else if (operand->HasFixedDoubleRegisterPolicy()) {",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "HasReferenceMap",
          "new_api": "DCHECK_NE",
          "old_text": "instr->HasReferenceMap()",
          "new_text": "DCHECK_NE(InstructionOperand::kInvalidVirtualRegister, virtual_register)",
          "old_line_content": "    if (instr->HasReferenceMap()) {",
          "new_line_content": "    DCHECK_NE(InstructionOperand::kInvalidVirtualRegister, virtual_register);",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": "AllocatedOperand::cast(operand)",
          "new_api": "fixed_register_index",
          "old_text": "AllocatedOperand::cast(operand)",
          "new_text": "AllocatedOperand(AllocatedOperand::DOUBLE_REGISTER,\n                                 machine_type, operand->fixed_register_index())",
          "old_line_content": "      instr->reference_map()->RecordReference(*AllocatedOperand::cast(operand));",
          "new_line_content": "    allocated = AllocatedOperand(AllocatedOperand::DOUBLE_REGISTER,",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "instruction_blocks",
          "new_api": "InstructionAt",
          "old_text": "code()->instruction_blocks()",
          "new_text": "code()->InstructionAt(pos)",
          "old_line_content": "  for (auto block : code()->instruction_blocks()) {",
          "new_line_content": "    auto instr = code()->InstructionAt(pos);",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "MeetRegisterConstraints",
          "new_api": "HasReferenceMap",
          "old_text": "MeetRegisterConstraints(block)",
          "new_text": "instr->HasReferenceMap()",
          "old_line_content": "    MeetRegisterConstraints(block);",
          "new_line_content": "    if (instr->HasReferenceMap()) {",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "MeetConstraintsBefore",
          "new_api": "MeetRegisterConstraints",
          "old_text": "MeetConstraintsBefore(i)",
          "new_text": "MeetRegisterConstraints(block)",
          "old_line_content": "    MeetConstraintsBefore(i);",
          "new_line_content": "    MeetRegisterConstraints(block);",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "last_instruction_index",
          "new_api": "MeetConstraintsBefore",
          "old_text": "block->last_instruction_index()",
          "new_text": "MeetConstraintsBefore(i)",
          "old_line_content": "  int end = block->last_instruction_index();",
          "new_line_content": "    MeetConstraintsBefore(i);",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": "InstructionAt",
          "new_api": "MeetConstraintsAfter",
          "old_text": "code()->InstructionAt(end)",
          "new_text": "MeetConstraintsAfter(i)",
          "old_line_content": "  auto last_instruction = code()->InstructionAt(end);",
          "new_line_content": "    if (i != end) MeetConstraintsAfter(i);",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": "IsConstant",
          "new_api": "MeetRegisterConstraintsForLastInstructionInBlock",
          "old_text": "output_operand->IsConstant()",
          "new_text": "MeetRegisterConstraintsForLastInstructionInBlock(block)",
          "old_line_content": "    DCHECK(!output_operand->IsConstant());",
          "new_line_content": "  MeetRegisterConstraintsForLastInstructionInBlock(block);",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "AllocateFixed",
          "new_api": "last_instruction_index",
          "old_text": "AllocateFixed(output, -1, false)",
          "new_text": "block->last_instruction_index()",
          "old_line_content": "      AllocateFixed(output, -1, false);",
          "new_line_content": "  int end = block->last_instruction_index();",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": "IsStackSlot",
          "new_api": "OutputCount",
          "old_text": "output->IsStackSlot()",
          "new_text": "last_instruction->OutputCount()",
          "old_line_content": "      if (output->IsStackSlot()) {",
          "new_line_content": "  for (size_t i = 0; i < last_instruction->OutputCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "index",
          "new_api": "OutputAt",
          "old_text": "StackSlotOperand::cast(output)->index()",
          "new_text": "last_instruction->OutputAt(i)",
          "old_line_content": "        DCHECK(StackSlotOperand::cast(output)->index() <",
          "new_line_content": "    auto output_operand = last_instruction->OutputAt(i);",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "frame",
          "new_api": "IsConstant",
          "old_text": "data()->frame()->GetSpillSlotCount()",
          "new_text": "output_operand->IsConstant()",
          "old_line_content": "               data()->frame()->GetSpillSlotCount());",
          "new_line_content": "    DCHECK(!output_operand->IsConstant());",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": "StackSlotOperand::cast(output)",
          "new_api": "UnallocatedOperand::cast(output_operand)",
          "old_text": "StackSlotOperand::cast(output)",
          "new_text": "UnallocatedOperand::cast(output_operand)",
          "old_line_content": "        range->SetSpillOperand(StackSlotOperand::cast(output));",
          "new_line_content": "    auto output = UnallocatedOperand::cast(output_operand);",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": "SetSpillStartIndex",
          "new_api": "virtual_register",
          "old_text": "range->SetSpillStartIndex(end)",
          "new_text": "output->virtual_register()",
          "old_line_content": "        range->SetSpillStartIndex(end);",
          "new_line_content": "    int output_vreg = output->virtual_register();",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "successors",
          "new_api": "AllocateFixed",
          "old_text": "block->successors()",
          "new_text": "AllocateFixed(output, -1, false)",
          "old_line_content": "      for (auto succ : block->successors()) {",
          "new_line_content": "      AllocateFixed(output, -1, false);",
          "content_same": false
        },
        {
          "line": 1528,
          "old_api": "PredecessorCount",
          "new_api": "IsStackSlot",
          "old_text": "successor->PredecessorCount()",
          "new_text": "output->IsStackSlot()",
          "old_line_content": "        DCHECK(successor->PredecessorCount() == 1);",
          "new_line_content": "      if (output->IsStackSlot()) {",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "first_instruction_index",
          "new_api": "index",
          "old_text": "successor->first_instruction_index()",
          "new_text": "StackSlotOperand::cast(output)->index()",
          "old_line_content": "        int gap_index = successor->first_instruction_index();",
          "new_line_content": "        DCHECK(StackSlotOperand::cast(output)->index() <",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": "successors",
          "new_api": "PredecessorCount",
          "old_text": "block->successors()",
          "new_text": "successor->PredecessorCount()",
          "old_line_content": "      for (auto succ : block->successors()) {",
          "new_line_content": "        DCHECK(successor->PredecessorCount() == 1);",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "InstructionBlockAt",
          "new_api": "first_instruction_index",
          "old_text": "code()->InstructionBlockAt(succ)",
          "new_text": "successor->first_instruction_index()",
          "old_line_content": "        const InstructionBlock* successor = code()->InstructionBlockAt(succ);",
          "new_line_content": "        int gap_index = successor->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "SetSpillStartIndex",
          "new_api": "AddGapMove",
          "old_text": "range->SetSpillStartIndex(gap_index)",
          "new_text": "data()->AddGapMove(gap_index, Instruction::START, *output, output_copy)",
          "old_line_content": "        range->SetSpillStartIndex(gap_index);",
          "new_line_content": "        data()->AddGapMove(gap_index, Instruction::START, *output, output_copy);",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": "InstructionAt",
          "new_api": "first_instruction_index",
          "old_text": "code()->InstructionAt(instr_index)",
          "new_text": "successor->first_instruction_index()",
          "old_line_content": "  auto first = code()->InstructionAt(instr_index);",
          "new_line_content": "        int gap_index = successor->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": "TempCount",
          "new_api": "SetSpillStartIndex",
          "old_text": "first->TempCount()",
          "new_text": "range->SetSpillStartIndex(gap_index)",
          "old_line_content": "  for (size_t i = 0; i < first->TempCount(); i++) {",
          "new_line_content": "        range->SetSpillStartIndex(gap_index);",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "virtual_register",
          "new_api": "InstructionAt",
          "old_text": "ConstantOperand::cast(output)->virtual_register()",
          "new_text": "code()->InstructionAt(instr_index)",
          "old_line_content": "      int output_vreg = ConstantOperand::cast(output)->virtual_register();",
          "new_line_content": "  auto first = code()->InstructionAt(instr_index);",
          "content_same": false
        },
        {
          "line": 1563,
          "old_api": "SetSpillStartIndex",
          "new_api": "TempCount",
          "old_text": "range->SetSpillStartIndex(instr_index + 1)",
          "new_text": "first->TempCount()",
          "old_line_content": "      range->SetSpillStartIndex(instr_index + 1);",
          "new_line_content": "  for (size_t i = 0; i < first->TempCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "SetSpillOperand",
          "new_api": "TempAt",
          "old_text": "range->SetSpillOperand(output)",
          "new_text": "first->TempAt(i)",
          "old_line_content": "      range->SetSpillOperand(output);",
          "new_line_content": "    auto temp = UnallocatedOperand::cast(first->TempAt(i));",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": "virtual_register",
          "new_api": "OutputAt",
          "old_text": "first_output->virtual_register()",
          "new_text": "first->OutputAt(i)",
          "old_line_content": "        data()->GetOrCreateLiveRangeFor(first_output->virtual_register());",
          "new_line_content": "    InstructionOperand* output = first->OutputAt(i);",
          "content_same": false
        },
        {
          "line": 1571,
          "old_api": "HasFixedPolicy",
          "new_api": "virtual_register",
          "old_text": "first_output->HasFixedPolicy()",
          "new_text": "ConstantOperand::cast(output)->virtual_register()",
          "old_line_content": "    if (first_output->HasFixedPolicy()) {",
          "new_line_content": "      int output_vreg = ConstantOperand::cast(output)->virtual_register();",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "virtual_register",
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": "first_output->virtual_register()",
          "new_text": "data()->GetOrCreateLiveRangeFor(output_vreg)",
          "old_line_content": "      int output_vreg = first_output->virtual_register();",
          "new_line_content": "      auto range = data()->GetOrCreateLiveRangeFor(output_vreg);",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "IsReference",
          "new_api": "SetSpillOperand",
          "old_text": "code()->IsReference(output_vreg)",
          "new_text": "range->SetSpillOperand(output)",
          "old_line_content": "      bool is_tagged = code()->IsReference(output_vreg);",
          "new_line_content": "      range->SetSpillOperand(output);",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "index",
          "new_api": "virtual_register",
          "old_text": "StackSlotOperand::cast(first_output)->index()",
          "new_text": "first_output->virtual_register()",
          "old_line_content": "        DCHECK(StackSlotOperand::cast(first_output)->index() <",
          "new_line_content": "        data()->GetOrCreateLiveRangeFor(first_output->virtual_register());",
          "content_same": false
        },
        {
          "line": 1581,
          "old_api": "StackSlotOperand::cast(first_output)",
          "new_api": "HasFixedPolicy",
          "old_text": "StackSlotOperand::cast(first_output)",
          "new_text": "first_output->HasFixedPolicy()",
          "old_line_content": "        range->SetSpillOperand(StackSlotOperand::cast(first_output));",
          "new_line_content": "    if (first_output->HasFixedPolicy()) {",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "SetSpillStartIndex",
          "new_api": "virtual_register",
          "old_text": "range->SetSpillStartIndex(instr_index + 1)",
          "new_text": "first_output->virtual_register()",
          "old_line_content": "        range->SetSpillStartIndex(instr_index + 1);",
          "new_line_content": "      int output_vreg = first_output->virtual_register();",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "AddGapMove",
          "new_api": "AllocateFixed",
          "old_text": "data()->AddGapMove(instr_index + 1, Instruction::START, *first_output,\n                         output_copy)",
          "new_text": "AllocateFixed(first_output, instr_index, is_tagged)",
          "old_line_content": "      data()->AddGapMove(instr_index + 1, Instruction::START, *first_output,",
          "new_line_content": "      AllocateFixed(first_output, instr_index, is_tagged);",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": "allocation_zone",
          "new_api": "StackSlotOperand::cast(first_output)",
          "old_text": "allocation_zone()",
          "new_text": "StackSlotOperand::cast(first_output)",
          "old_line_content": "      range->SpillAtDefinition(allocation_zone(), instr_index + 1,",
          "new_line_content": "        range->SetSpillOperand(StackSlotOperand::cast(first_output));",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "InputAt",
          "new_api": "SetSpillStartIndex",
          "old_text": "second->InputAt(i)",
          "new_text": "range->SetSpillStartIndex(instr_index + 1)",
          "old_line_content": "    auto input = second->InputAt(i);",
          "new_line_content": "      range->SetSpillStartIndex(instr_index + 1);",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "AllocateFixed",
          "new_api": "InstructionAt",
          "old_text": "AllocateFixed(cur_input, instr_index, is_tagged)",
          "new_text": "code()->InstructionAt(instr_index)",
          "old_line_content": "      AllocateFixed(cur_input, instr_index, is_tagged);",
          "new_line_content": "  auto second = code()->InstructionAt(instr_index);",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "OutputCount",
          "new_api": "UnallocatedOperand::cast(input)",
          "old_text": "second->OutputCount()",
          "new_text": "UnallocatedOperand::cast(input)",
          "old_line_content": "  for (size_t i = 0; i < second->OutputCount(); i++) {",
          "new_line_content": "    auto cur_input = UnallocatedOperand::cast(input);",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "OutputAt",
          "new_api": "HasFixedPolicy",
          "old_text": "second->OutputAt(i)",
          "new_text": "cur_input->HasFixedPolicy()",
          "old_line_content": "    auto output = second->OutputAt(i);",
          "new_line_content": "    if (cur_input->HasFixedPolicy()) {",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "IsUnallocated",
          "new_api": "virtual_register",
          "old_text": "output->IsUnallocated()",
          "new_text": "cur_input->virtual_register()",
          "old_line_content": "    if (!output->IsUnallocated()) continue;",
          "new_line_content": "      int input_vreg = cur_input->virtual_register();",
          "content_same": false
        },
        {
          "line": 1619,
          "old_api": "HasSameAsInputPolicy",
          "new_api": "IsReference",
          "old_text": "second_output->HasSameAsInputPolicy()",
          "new_text": "code()->IsReference(input_vreg)",
          "old_line_content": "    if (!second_output->HasSameAsInputPolicy()) continue;",
          "new_line_content": "      bool is_tagged = code()->IsReference(input_vreg);",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "DCHECK",
          "new_api": "AllocateFixed",
          "old_text": "DCHECK(i == 0)",
          "new_text": "AllocateFixed(cur_input, instr_index, is_tagged)",
          "old_line_content": "    DCHECK(i == 0);  // Only valid for first output.",
          "new_line_content": "      AllocateFixed(cur_input, instr_index, is_tagged);",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "virtual_register",
          "new_api": "OutputAt",
          "old_text": "second_output->virtual_register()",
          "new_text": "second->OutputAt(i)",
          "old_line_content": "    cur_input->set_virtual_register(second_output->virtual_register());",
          "new_line_content": "    auto output = second->OutputAt(i);",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "AddGapMove",
          "new_api": "IsUnallocated",
          "old_text": "data()->AddGapMove(instr_index, Instruction::END,\n                                       input_copy, *cur_input)",
          "new_text": "output->IsUnallocated()",
          "old_line_content": "    auto gap_move = data()->AddGapMove(instr_index, Instruction::END,",
          "new_line_content": "    if (!output->IsUnallocated()) continue;",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": "IsReference",
          "new_api": "HasSameAsInputPolicy",
          "old_text": "code()->IsReference(output_vreg)",
          "new_text": "second_output->HasSameAsInputPolicy()",
          "old_line_content": "    if (code()->IsReference(input_vreg) && !code()->IsReference(output_vreg)) {",
          "new_line_content": "    if (!second_output->HasSameAsInputPolicy()) continue;",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "HasReferenceMap",
          "new_api": "DCHECK",
          "old_text": "second->HasReferenceMap()",
          "new_text": "DCHECK(i == 0)",
          "old_line_content": "      if (second->HasReferenceMap()) {",
          "new_line_content": "    DCHECK(i == 0);  // Only valid for first output.",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "source",
          "new_api": "InputAt",
          "old_text": "gap_move->source()",
          "new_text": "second->InputAt(0)",
          "old_line_content": "            second->reference_map(), &gap_move->source()};",
          "new_line_content": "        UnallocatedOperand::cast(second->InputAt(0));",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": "push_back",
          "new_api": "virtual_register",
          "old_text": "data()->delayed_references().push_back(delayed_reference)",
          "new_text": "second_output->virtual_register()",
          "old_line_content": "        data()->delayed_references().push_back(delayed_reference);",
          "new_line_content": "    int output_vreg = second_output->virtual_register();",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "IsReference",
          "new_api": "virtual_register",
          "old_text": "code()->IsReference(output_vreg)",
          "new_text": "second_output->virtual_register()",
          "old_line_content": "               code()->IsReference(output_vreg)) {",
          "new_line_content": "    cur_input->set_virtual_register(second_output->virtual_register());",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": "output",
          "new_api": "instruction_blocks",
          "old_text": "phi->output()",
          "new_text": "code()->instruction_blocks()",
          "old_line_content": "    auto& output = phi->output();",
          "new_line_content": "  for (InstructionBlock* block : base::Reversed(code()->instruction_blocks())) {",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "destination",
          "new_api": "virtual_register",
          "old_text": "move->destination()",
          "new_text": "phi->virtual_register()",
          "old_line_content": "      map_value->AddOperand(&move->destination());",
          "new_line_content": "    int phi_vreg = phi->virtual_register();",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": "InstructionAt",
          "new_api": "InitializePhiMap",
          "old_text": "code()\n                  ->InstructionAt(cur_block->last_instruction_index())\n                  ->HasReferenceMap()",
          "new_text": "data()->InitializePhiMap(block, phi)",
          "old_line_content": "      DCHECK(!code()",
          "new_line_content": "    auto map_value = data()->InitializePhiMap(block, phi);",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "last_instruction_index",
          "new_api": "output",
          "old_text": "cur_block->last_instruction_index()",
          "new_text": "phi->output()",
          "old_line_content": "                  ->InstructionAt(cur_block->last_instruction_index())",
          "new_line_content": "    auto& output = phi->output();",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": "first_instruction_index",
          "new_api": "predecessors",
          "old_text": "block->first_instruction_index()",
          "new_text": "block->predecessors()",
          "old_line_content": "    int gap_index = block->first_instruction_index();",
          "new_line_content": "          code()->InstructionBlockAt(block->predecessors()[i]);",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "allocation_zone",
          "new_api": "operands",
          "old_text": "allocation_zone()",
          "new_text": "phi->operands()",
          "old_line_content": "    live_range->SpillAtDefinition(allocation_zone(), gap_index, &output);",
          "new_line_content": "      UnallocatedOperand input(UnallocatedOperand::ANY, phi->operands()[i]);",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "SetSpillStartIndex",
          "new_api": "last_instruction_index",
          "old_text": "live_range->SetSpillStartIndex(gap_index)",
          "new_text": "cur_block->last_instruction_index()",
          "old_line_content": "    live_range->SetSpillStartIndex(gap_index);",
          "new_line_content": "      auto move = data()->AddGapMove(cur_block->last_instruction_index(),",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "set_is_phi",
          "new_api": "destination",
          "old_text": "live_range->set_is_phi(true)",
          "new_text": "move->destination()",
          "old_line_content": "    live_range->set_is_phi(true);",
          "new_line_content": "      map_value->AddOperand(&move->destination());",
          "content_same": false
        },
        {
          "line": 1679,
          "old_api": "IsLoopHeader",
          "new_api": "InstructionAt",
          "old_text": "block->IsLoopHeader()",
          "new_text": "code()\n                  ->InstructionAt(cur_block->last_instruction_index())\n                  ->HasReferenceMap()",
          "old_line_content": "    live_range->set_is_non_loop_phi(!block->IsLoopHeader());",
          "new_line_content": "      DCHECK(!code()",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "successors",
          "new_api": "live_out_sets",
          "old_text": "block->successors()",
          "new_text": "data->live_out_sets()",
          "old_line_content": "    for (const RpoNumber& succ : block->successors()) {",
          "new_line_content": "  BitVector* live_out = data->live_out_sets()[block_index];",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "Union",
          "new_api": "allocation_zone",
          "old_text": "live_out->Union(*live_in)",
          "new_text": "data->allocation_zone()",
          "old_line_content": "      if (live_in != nullptr) live_out->Union(*live_in);",
          "new_line_content": "    Zone* zone = data->allocation_zone();",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "PredecessorCount",
          "new_api": "successors",
          "old_text": "successor->PredecessorCount()",
          "new_text": "block->successors()",
          "old_line_content": "      DCHECK(index < successor->PredecessorCount());",
          "new_line_content": "    for (const RpoNumber& succ : block->successors()) {",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "operands",
          "new_api": "rpo_number",
          "old_text": "phi->operands()",
          "new_text": "block->rpo_number()",
          "old_line_content": "        live_out->Add(phi->operands()[index]);",
          "new_line_content": "      if (succ <= block->rpo_number()) continue;",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "first_instruction_index",
          "new_api": "live_out_sets",
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "new_text": "data->live_out_sets()",
          "old_line_content": "  auto start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "    data->live_out_sets()[block_index] = live_out;",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": "num_general_registers",
          "new_api": "Done",
          "old_text": "config()->num_general_registers()",
          "new_text": "iterator.Done()",
          "old_line_content": "  return -index - 1 - config()->num_general_registers();",
          "new_line_content": "  while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "IsFixed",
          "new_api": "num_general_registers",
          "old_text": "result->IsFixed()",
          "new_text": "config()->num_general_registers()",
          "old_line_content": "    DCHECK(result->IsFixed());",
          "new_line_content": "  return -index - 1 - config()->num_general_registers();",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": "num_aliased_double_registers",
          "new_api": "IsFixed",
          "old_text": "config()->num_aliased_double_registers()",
          "new_text": "result->IsFixed()",
          "old_line_content": "  DCHECK(index < config()->num_aliased_double_registers());",
          "new_line_content": "    DCHECK(result->IsFixed());",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": "fixed_double_live_ranges",
          "new_api": "set_assigned_register",
          "old_text": "data()->fixed_double_live_ranges()",
          "new_text": "result->set_assigned_register(index)",
          "old_line_content": "  auto result = data()->fixed_double_live_ranges()[index];",
          "new_line_content": "    result->set_assigned_register(index);",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": "FixedDoubleLiveRangeID",
          "new_api": "fixed_live_ranges",
          "old_text": "FixedDoubleLiveRangeID(index)",
          "new_text": "data()->fixed_live_ranges()",
          "old_line_content": "    result = data()->NewLiveRange(FixedDoubleLiveRangeID(index), kRepFloat64);",
          "new_line_content": "    data()->fixed_live_ranges()[index] = result;",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "IsUnallocated",
          "new_api": "IsFixed",
          "old_text": "operand->IsUnallocated()",
          "new_text": "result->IsFixed()",
          "old_line_content": "  if (operand->IsUnallocated()) {",
          "new_line_content": "    DCHECK(result->IsFixed());",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": "set_assigned_register",
          "old_text": "data()->GetOrCreateLiveRangeFor(\n        UnallocatedOperand::cast(operand)->virtual_register())",
          "new_text": "result->set_assigned_register(index)",
          "old_line_content": "    return data()->GetOrCreateLiveRangeFor(",
          "new_line_content": "    result->set_assigned_register(index);",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "virtual_register",
          "new_api": "MarkAllocated",
          "old_text": "UnallocatedOperand::cast(operand)->virtual_register()",
          "new_text": "data()->MarkAllocated(DOUBLE_REGISTERS, index)",
          "old_line_content": "        UnallocatedOperand::cast(operand)->virtual_register());",
          "new_line_content": "    data()->MarkAllocated(DOUBLE_REGISTERS, index);",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "IsConstant",
          "new_api": "fixed_double_live_ranges",
          "old_text": "operand->IsConstant()",
          "new_text": "data()->fixed_double_live_ranges()",
          "old_line_content": "  } else if (operand->IsConstant()) {",
          "new_line_content": "    data()->fixed_double_live_ranges()[index] = result;",
          "content_same": false
        },
        {
          "line": 1786,
          "old_api": "index",
          "new_api": "IsUnallocated",
          "old_text": "DoubleRegisterOperand::cast(operand)->index()",
          "new_text": "operand->IsUnallocated()",
          "old_line_content": "        DoubleRegisterOperand::cast(operand)->index());",
          "new_line_content": "  if (operand->IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": "Start",
          "new_api": "allocation_zone",
          "old_text": "range->Start()",
          "new_text": "allocation_zone()",
          "old_line_content": "  if (range->IsEmpty() || range->Start() > position) {",
          "new_line_content": "  return new (allocation_zone()) UsePosition(pos, operand, hint, hint_type);",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "IsUnallocated",
          "new_api": "LiveRangeFor",
          "old_text": "operand->IsUnallocated()",
          "new_text": "LiveRangeFor(operand)",
          "old_line_content": "  if (!operand->IsUnallocated()) return nullptr;",
          "new_line_content": "  auto range = LiveRangeFor(operand);",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": "AddUsePosition",
          "new_api": "Start",
          "old_text": "range->AddUsePosition(use_pos)",
          "new_text": "range->Start()",
          "old_line_content": "  range->AddUsePosition(use_pos);",
          "new_line_content": "  if (range->IsEmpty() || range->Start() > position) {",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "LiveRangeFor",
          "new_api": "NewUsePosition",
          "old_text": "LiveRangeFor(operand)",
          "new_text": "NewUsePosition(position, unalloc_operand, hint, hint_type)",
          "old_line_content": "  auto range = LiveRangeFor(operand);",
          "new_line_content": "  auto use_pos = NewUsePosition(position, unalloc_operand, hint, hint_type);",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": "first_instruction_index",
          "new_api": "NewUsePosition",
          "old_text": "block->first_instruction_index()",
          "new_text": "NewUsePosition(position, unalloc_operand, hint, hint_type)",
          "old_line_content": "  int block_start = block->first_instruction_index();",
          "new_line_content": "    use_pos = NewUsePosition(position, unalloc_operand, hint, hint_type);",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "IsInstructionPosition",
          "new_api": "first_instruction_index",
          "old_text": "curr_position.IsInstructionPosition()",
          "new_text": "block->first_instruction_index()",
          "old_line_content": "    DCHECK(curr_position.IsInstructionPosition());",
          "new_line_content": "  int block_start = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": "OutputCount",
          "new_api": "LifetimePosition::GapFromInstructionIndex(block_start)",
          "old_text": "instr->OutputCount()",
          "new_text": "LifetimePosition::GapFromInstructionIndex(block_start)",
          "old_line_content": "    for (size_t i = 0; i < instr->OutputCount(); i++) {",
          "new_line_content": "      LifetimePosition::GapFromInstructionIndex(block_start);",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": "IsUnallocated",
          "new_api": "last_instruction_index",
          "old_text": "output->IsUnallocated()",
          "new_text": "block->last_instruction_index()",
          "old_line_content": "      if (output->IsUnallocated()) {",
          "new_line_content": "  for (int index = block->last_instruction_index(); index >= block_start;",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "virtual_register",
          "new_api": "LifetimePosition::InstructionFromInstructionIndex(index)",
          "old_text": "UnallocatedOperand::cast(output)->virtual_register()",
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(index)",
          "old_line_content": "        int out_vreg = UnallocatedOperand::cast(output)->virtual_register();",
          "new_line_content": "        LifetimePosition::InstructionFromInstructionIndex(index);",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "Remove",
          "new_api": "InstructionAt",
          "old_text": "live->Remove(out_vreg)",
          "new_text": "code()->InstructionAt(index)",
          "old_line_content": "        live->Remove(out_vreg);",
          "new_line_content": "    auto instr = code()->InstructionAt(index);",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "IsConstant",
          "new_api": "DCHECK",
          "old_text": "output->IsConstant()",
          "new_text": "DCHECK(instr != nullptr)",
          "old_line_content": "      } else if (output->IsConstant()) {",
          "new_line_content": "    DCHECK(instr != nullptr);",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": "virtual_register",
          "new_api": "IsInstructionPosition",
          "old_text": "ConstantOperand::cast(output)->virtual_register()",
          "new_text": "curr_position.IsInstructionPosition()",
          "old_line_content": "        int out_vreg = ConstantOperand::cast(output)->virtual_register();",
          "new_line_content": "    DCHECK(curr_position.IsInstructionPosition());",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": "IsHandler",
          "new_api": "OutputAt",
          "old_text": "block->IsHandler()",
          "new_text": "instr->OutputAt(i)",
          "old_line_content": "      if (block->IsHandler() && index == block_start) {",
          "new_line_content": "      auto output = instr->OutputAt(i);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "LifetimePosition::GapFromInstructionIndex(index)",
          "new_api": "Remove",
          "old_text": "LifetimePosition::GapFromInstructionIndex(index)",
          "new_text": "live->Remove(out_vreg)",
          "old_line_content": "        Define(LifetimePosition::GapFromInstructionIndex(index), output);",
          "new_line_content": "        live->Remove(out_vreg);",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "Define",
          "new_api": "virtual_register",
          "old_text": "Define(curr_position, output)",
          "new_text": "ConstantOperand::cast(output)->virtual_register()",
          "old_line_content": "        Define(curr_position, output);",
          "new_line_content": "        int out_vreg = ConstantOperand::cast(output)->virtual_register();",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "End",
          "new_api": "LifetimePosition::GapFromInstructionIndex(index)",
          "old_text": "curr_position.End()",
          "new_text": "LifetimePosition::GapFromInstructionIndex(index)",
          "old_line_content": "          range->AddUseInterval(curr_position, curr_position.End(),",
          "new_line_content": "        Define(LifetimePosition::GapFromInstructionIndex(index), output);",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "ClobbersDoubleRegisters",
          "new_api": "ClobbersRegisters",
          "old_text": "instr->ClobbersDoubleRegisters()",
          "new_text": "instr->ClobbersRegisters()",
          "old_line_content": "    if (instr->ClobbersDoubleRegisters()) {",
          "new_line_content": "    if (instr->ClobbersRegisters()) {",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": "num_aliased_double_registers",
          "new_api": "num_general_registers",
          "old_text": "config()->num_aliased_double_registers()",
          "new_text": "config()->num_general_registers()",
          "old_line_content": "      for (int i = 0; i < config()->num_aliased_double_registers(); ++i) {",
          "new_line_content": "      for (int i = 0; i < config()->num_general_registers(); ++i) {",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": "IsOutputDoubleRegisterOf",
          "new_api": "IsOutputRegisterOf",
          "old_text": "IsOutputDoubleRegisterOf(instr, i)",
          "new_text": "IsOutputRegisterOf(instr, i)",
          "old_line_content": "        if (!IsOutputDoubleRegisterOf(instr, i)) {",
          "new_line_content": "        if (!IsOutputRegisterOf(instr, i)) {",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": "FixedDoubleLiveRangeFor",
          "new_api": "FixedLiveRangeFor",
          "old_text": "FixedDoubleLiveRangeFor(i)",
          "new_text": "FixedLiveRangeFor(i)",
          "old_line_content": "          auto range = FixedDoubleLiveRangeFor(i);",
          "new_line_content": "          auto range = FixedLiveRangeFor(i);",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": "InputCount",
          "new_api": "ClobbersDoubleRegisters",
          "old_text": "instr->InputCount()",
          "new_text": "instr->ClobbersDoubleRegisters()",
          "old_line_content": "    for (size_t i = 0; i < instr->InputCount(); i++) {",
          "new_line_content": "    if (instr->ClobbersDoubleRegisters()) {",
          "content_same": false
        },
        {
          "line": 1896,
          "old_api": "InputAt",
          "new_api": "num_aliased_double_registers",
          "old_text": "instr->InputAt(i)",
          "new_text": "config()->num_aliased_double_registers()",
          "old_line_content": "      auto input = instr->InputAt(i);",
          "new_line_content": "      for (int i = 0; i < config()->num_aliased_double_registers(); ++i) {",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": "IsImmediate",
          "new_api": "IsOutputDoubleRegisterOf",
          "old_text": "input->IsImmediate()",
          "new_text": "IsOutputDoubleRegisterOf(instr, i)",
          "old_line_content": "      if (input->IsImmediate()) continue;  // Ignore immediates.",
          "new_line_content": "        if (!IsOutputDoubleRegisterOf(instr, i)) {",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": "IsUnallocated",
          "new_api": "End",
          "old_text": "input->IsUnallocated()",
          "new_text": "curr_position.End()",
          "old_line_content": "      if (input->IsUnallocated() &&",
          "new_line_content": "          range->AddUseInterval(curr_position, curr_position.End(),",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": "IsUsedAtStart",
          "new_api": "allocation_zone",
          "old_text": "UnallocatedOperand::cast(input)->IsUsedAtStart()",
          "new_text": "allocation_zone()",
          "old_line_content": "          UnallocatedOperand::cast(input)->IsUsedAtStart()) {",
          "new_line_content": "                                allocation_zone());",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "IsUnallocated",
          "new_api": "InputAt",
          "old_text": "input->IsUnallocated()",
          "new_text": "instr->InputAt(i)",
          "old_line_content": "      if (input->IsUnallocated()) {",
          "new_line_content": "      auto input = instr->InputAt(i);",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": "UnallocatedOperand::cast(input)",
          "new_api": "IsImmediate",
          "old_text": "UnallocatedOperand::cast(input)",
          "new_text": "input->IsImmediate()",
          "old_line_content": "        UnallocatedOperand* unalloc = UnallocatedOperand::cast(input);",
          "new_line_content": "      if (input->IsImmediate()) continue;  // Ignore immediates.",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "Add",
          "new_api": "IsUnallocated",
          "old_text": "live->Add(vreg)",
          "new_text": "input->IsUnallocated()",
          "old_line_content": "        live->Add(vreg);",
          "new_line_content": "      if (input->IsUnallocated() &&",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": "HasSlotPolicy",
          "new_api": "IsUsedAtStart",
          "old_text": "unalloc->HasSlotPolicy()",
          "new_text": "UnallocatedOperand::cast(input)->IsUsedAtStart()",
          "old_line_content": "        if (unalloc->HasSlotPolicy()) {",
          "new_line_content": "          UnallocatedOperand::cast(input)->IsUsedAtStart()) {",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": "TempCount",
          "new_api": "UnallocatedOperand::cast(input)",
          "old_text": "instr->TempCount()",
          "new_text": "UnallocatedOperand::cast(input)",
          "old_line_content": "    for (size_t i = 0; i < instr->TempCount(); i++) {",
          "new_line_content": "        UnallocatedOperand* unalloc = UnallocatedOperand::cast(input);",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "TempAt",
          "new_api": "virtual_register",
          "old_text": "instr->TempAt(i)",
          "new_text": "unalloc->virtual_register()",
          "old_line_content": "      auto temp = instr->TempAt(i);",
          "new_line_content": "        int vreg = unalloc->virtual_register();",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "IsUnallocated",
          "new_api": "HasSlotPolicy",
          "old_text": "temp->IsUnallocated()",
          "new_text": "unalloc->HasSlotPolicy()",
          "old_line_content": "      DCHECK_IMPLIES(temp->IsUnallocated(),",
          "new_line_content": "        if (unalloc->HasSlotPolicy()) {",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "HasSlotPolicy",
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": "UnallocatedOperand::cast(temp)->HasSlotPolicy()",
          "new_text": "data()->GetOrCreateLiveRangeFor(vreg)->set_has_slot_use(true)",
          "old_line_content": "                     !UnallocatedOperand::cast(temp)->HasSlotPolicy());",
          "new_line_content": "          data()->GetOrCreateLiveRangeFor(vreg)->set_has_slot_use(true);",
          "content_same": false
        },
        {
          "line": 1924,
          "old_api": "IsUnallocated",
          "new_api": "Use",
          "old_text": "temp->IsUnallocated()",
          "new_text": "Use(block_start_position, use_pos, input)",
          "old_line_content": "        if (temp->IsUnallocated()) {",
          "new_line_content": "      Use(block_start_position, use_pos, input);",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "End",
          "new_api": "HasSlotPolicy",
          "old_text": "curr_position.End()",
          "new_text": "UnallocatedOperand::cast(temp)->HasSlotPolicy()",
          "old_line_content": "      Use(block_start_position, curr_position.End(), temp);",
          "new_line_content": "                     !UnallocatedOperand::cast(temp)->HasSlotPolicy());",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "Define",
          "new_api": "ClobbersTemps",
          "old_text": "Define(curr_position, temp)",
          "new_text": "instr->ClobbersTemps()",
          "old_line_content": "      Define(curr_position, temp);",
          "new_line_content": "      if (instr->ClobbersTemps()) {",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": "GetParallelMove",
          "new_api": "End",
          "old_text": "instr->GetParallelMove(position)",
          "new_text": "curr_position.End()",
          "old_line_content": "      auto move = instr->GetParallelMove(position);",
          "new_line_content": "      Use(block_start_position, curr_position.End(), temp);",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "source",
          "new_api": "IsGapPosition",
          "old_text": "cur->source()",
          "new_text": "curr_position.IsGapPosition()",
          "old_line_content": "        auto& from = cur->source();",
          "new_line_content": "    DCHECK(curr_position.IsGapPosition());",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "virtual_register",
          "new_api": "Start",
          "old_text": "UnallocatedOperand::cast(to).virtual_register()",
          "new_text": "curr_position.Start()",
          "old_line_content": "          int to_vreg = UnallocatedOperand::cast(to).virtual_register();",
          "new_line_content": "        curr_position = curr_position.Start();",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": "is_non_loop_phi",
          "new_api": "destination",
          "old_text": "to_range->is_non_loop_phi()",
          "new_text": "cur->destination()",
          "old_line_content": "            if (to_range->is_non_loop_phi()) {",
          "new_line_content": "        auto& to = cur->destination();",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "GetPhiMapValueFor",
          "new_api": "virtual_register",
          "old_text": "data()->GetPhiMapValueFor(to_vreg)",
          "new_text": "UnallocatedOperand::cast(to).virtual_register()",
          "old_line_content": "              hint = data()->GetPhiMapValueFor(to_vreg);",
          "new_line_content": "          int to_vreg = UnallocatedOperand::cast(to).virtual_register();",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": "Define",
          "new_api": "is_non_loop_phi",
          "old_text": "Define(curr_position, &to, &from,\n                              UsePosition::HintTypeForOperand(from))",
          "new_text": "to_range->is_non_loop_phi()",
          "old_line_content": "              to_use = Define(curr_position, &to, &from,",
          "new_line_content": "            if (to_range->is_non_loop_phi()) {",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "UsePosition::HintTypeForOperand(from)",
          "new_api": "current_hint_position",
          "old_text": "UsePosition::HintTypeForOperand(from)",
          "new_text": "to_range->current_hint_position()",
          "old_line_content": "                              UsePosition::HintTypeForOperand(from));",
          "new_line_content": "              hint = to_range->current_hint_position();",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "Define",
          "new_api": "Contains",
          "old_text": "Define(curr_position, &to)",
          "new_text": "live->Contains(to_vreg)",
          "old_line_content": "          Define(curr_position, &to);",
          "new_line_content": "            if (live->Contains(to_vreg)) {",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "Use",
          "new_api": "Remove",
          "old_text": "Use(block_start_position, curr_position, &from, hint, hint_type)",
          "new_text": "live->Remove(to_vreg)",
          "old_line_content": "            Use(block_start_position, curr_position, &from, hint, hint_type);",
          "new_line_content": "              live->Remove(to_vreg);",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "IsUnallocated",
          "new_api": "Eliminate",
          "old_text": "from.IsUnallocated()",
          "new_text": "cur->Eliminate()",
          "old_line_content": "        if (from.IsUnallocated()) {",
          "new_line_content": "              cur->Eliminate();",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "ResolveHint",
          "new_api": "Define",
          "old_text": "to_use->ResolveHint(from_use)",
          "new_text": "Define(curr_position, &to)",
          "old_line_content": "          to_use->ResolveHint(from_use);",
          "new_line_content": "          Define(curr_position, &to);",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": "IsResolved",
          "new_api": "Use",
          "old_text": "to_use->IsResolved()",
          "new_text": "Use(block_start_position, curr_position, &from, hint, hint_type)",
          "old_line_content": "        DCHECK_IMPLIES(to_use != nullptr, to_use->IsResolved());",
          "new_line_content": "            Use(block_start_position, curr_position, &from, hint, hint_type);",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "ResolvePhiHint",
          "new_api": "virtual_register",
          "old_text": "ResolvePhiHint(&from, from_use)",
          "new_text": "UnallocatedOperand::cast(from).virtual_register()",
          "old_line_content": "        if (phi_vreg != -1) ResolvePhiHint(&from, from_use);",
          "new_line_content": "          live->Add(UnallocatedOperand::cast(from).virtual_register());",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": "IsUnallocated",
          "new_api": "phis",
          "old_text": "to.IsUnallocated()",
          "new_text": "block->phis()",
          "old_line_content": "      if (to.IsUnallocated() &&",
          "new_line_content": "  for (auto phi : block->phis()) {",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": "DCHECK",
          "new_api": "InstructionBlockAt",
          "old_text": "DCHECK(hint != nullptr)",
          "new_text": "GetLastInstruction(\n        code(), code()->InstructionBlockAt(block->predecessors()[0]))",
          "old_line_content": "    DCHECK(hint != nullptr);",
          "new_line_content": "    auto instr = GetLastInstruction(",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "first_instruction_index",
          "new_api": "predecessors",
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n        block->first_instruction_index())",
          "new_text": "block->predecessors()",
          "old_line_content": "    auto block_start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "        code(), code()->InstructionBlockAt(block->predecessors()[0]));",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": "first_instruction_index",
          "new_api": "GetParallelMove",
          "old_text": "block->first_instruction_index()",
          "new_text": "instr->GetParallelMove(Instruction::END)",
          "old_line_content": "        block->first_instruction_index());",
          "new_line_content": "    for (auto move : *instr->GetParallelMove(Instruction::END)) {",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "output",
          "new_api": "destination",
          "old_text": "phi->output()",
          "new_text": "move->destination()",
          "old_line_content": "    auto use_pos = Define(block_start, &phi->output(), hint,",
          "new_line_content": "      auto& to = move->destination();",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": "UsePosition::HintTypeForOperand(*hint)",
          "new_api": "IsUnallocated",
          "old_text": "UsePosition::HintTypeForOperand(*hint)",
          "new_text": "to.IsUnallocated()",
          "old_line_content": "                          UsePosition::HintTypeForOperand(*hint));",
          "new_line_content": "      if (to.IsUnallocated() &&",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "MapPhiHint",
          "new_api": "virtual_register",
          "old_text": "MapPhiHint(hint, use_pos)",
          "new_text": "UnallocatedOperand::cast(to).virtual_register()",
          "old_line_content": "    MapPhiHint(hint, use_pos);",
          "new_line_content": "          UnallocatedOperand::cast(to).virtual_register() == phi_vreg) {",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "IsLoopHeader",
          "new_api": "first_instruction_index",
          "old_text": "block->IsLoopHeader()",
          "new_text": "block->first_instruction_index()",
          "old_line_content": "  DCHECK(block->IsLoopHeader());",
          "new_line_content": "        block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": "IsLoopHeader",
          "old_text": "data()->GetOrCreateLiveRangeFor(operand_index)",
          "new_text": "block->IsLoopHeader()",
          "old_line_content": "    TopLevelLiveRange* range = data()->GetOrCreateLiveRangeFor(operand_index);",
          "new_line_content": "  DCHECK(block->IsLoopHeader());",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "ToInt",
          "new_api": "first_instruction_index",
          "old_text": "block->loop_end().ToInt()",
          "new_text": "block->first_instruction_index()",
          "old_line_content": "  for (int i = block->rpo_number().ToInt() + 1; i < block->loop_end().ToInt();",
          "new_line_content": "      block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": "Union",
          "new_api": "LastLoopInstructionIndex",
          "old_text": "live_in_sets()[i]->Union(*live)",
          "new_text": "code()->LastLoopInstructionIndex(block)",
          "old_line_content": "    live_in_sets()[i]->Union(*live);",
          "new_line_content": "                 code()->LastLoopInstructionIndex(block)).NextFullStart();",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "data",
          "new_api": "Union",
          "old_text": "data()",
          "new_text": "live_in_sets()[i]->Union(*live)",
          "old_line_content": "    auto live = ComputeLiveOut(block, data());",
          "new_line_content": "    live_in_sets()[i]->Union(*live);",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "HasNoSpillType",
          "new_api": "ProcessPhis",
          "old_text": "range->HasNoSpillType()",
          "new_text": "ProcessPhis(block, live)",
          "old_line_content": "    if (range->has_slot_use() && range->HasNoSpillType()) {",
          "new_line_content": "    ProcessPhis(block, live);",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": "GetSpillOperand",
          "new_api": "live_ranges",
          "old_text": "range->GetSpillOperand()->IsConstant()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "    if (range->HasSpillOperand() && range->GetSpillOperand()->IsConstant()) {",
          "new_line_content": "  for (auto range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": "USE",
          "new_api": "Verify",
          "old_text": "USE(res)",
          "new_text": "Verify()",
          "old_line_content": "  USE(res);",
          "new_line_content": "  Verify();",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "end",
          "new_api": "IsResolved",
          "old_text": "phi_hints_.end()",
          "new_text": "use_pos->IsResolved()",
          "old_line_content": "  if (it == phi_hints_.end()) return;",
          "new_line_content": "  DCHECK(!use_pos->IsResolved());",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "IsResolved",
          "new_api": "std::make_pair(operand, use_pos)",
          "old_text": "it->second->IsResolved()",
          "new_text": "std::make_pair(operand, use_pos)",
          "old_line_content": "  DCHECK(!it->second->IsResolved());",
          "new_line_content": "  auto res = phi_hints_.insert(std::make_pair(operand, use_pos));",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": "ResolveHint",
          "new_api": "DCHECK",
          "old_text": "it->second->ResolveHint(use_pos)",
          "new_text": "DCHECK(res.second)",
          "old_line_content": "  it->second->ResolveHint(use_pos);",
          "new_line_content": "  DCHECK(res.second);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "live_ranges",
          "new_api": "end",
          "old_text": "data()->live_ranges()",
          "new_text": "phi_hints_.end()",
          "old_line_content": "  for (LiveRange* current : data()->live_ranges()) {",
          "new_line_content": "  if (it == phi_hints_.end()) return;",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "Verify",
          "new_api": "IsResolved",
          "old_text": "current->Verify()",
          "new_text": "it->second->IsResolved()",
          "old_line_content": "    if (current != nullptr) current->Verify();",
          "new_line_content": "  DCHECK(!it->second->IsResolved());",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "config",
          "new_api": "live_ranges",
          "old_text": "data->config()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      num_registers_(GetRegisterCount(data->config(), kind)) {}",
          "new_line_content": "  for (LiveRange* current : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": "ToInstructionIndex",
          "new_api": "TopLevel",
          "old_text": "pos.ToInstructionIndex()",
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "          pos.ToInstructionIndex()));",
          "new_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": "allocation_zone",
          "new_api": "value",
          "old_text": "allocation_zone()",
          "new_text": "pos.value()",
          "old_line_content": "  LiveRange* result = range->SplitAt(pos, allocation_zone());",
          "new_line_content": "        range->relative_id(), pos.value());",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "TopLevel",
          "new_api": "ToInstructionIndex",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "new_line_content": "          pos.ToInstructionIndex()));",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "value",
          "new_api": "allocation_zone",
          "old_text": "start.value()",
          "new_text": "allocation_zone()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id(), start.value(),",
          "new_line_content": "  LiveRange* result = range->SplitAt(pos, allocation_zone());",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "ToInstructionIndex",
          "new_api": "value",
          "old_text": "start.ToInstructionIndex()",
          "new_text": "end.value()",
          "old_line_content": "  int start_instr = start.ToInstructionIndex();",
          "new_line_content": "        end.value());",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "DCHECK",
          "new_api": "FindOptimalSplitPos",
          "old_text": "DCHECK(start_instr <= end_instr)",
          "new_text": "FindOptimalSplitPos(start, end)",
          "old_line_content": "  DCHECK(start_instr <= end_instr);",
          "new_line_content": "  auto split_pos = FindOptimalSplitPos(start, end);",
          "content_same": false
        },
        {
          "line": 2201,
          "old_api": "first_instruction_index",
          "new_api": "code",
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "new_text": "code()",
          "old_line_content": "  return LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "  while (GetContainingLoop(code(), block) != nullptr &&",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": "first_instruction_index",
          "new_api": "code",
          "old_text": "block->first_instruction_index()",
          "new_text": "code()",
          "old_line_content": "      block->first_instruction_index());",
          "new_line_content": "         GetContainingLoop(code(), block)->rpo_number().ToInt() >",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "first_instruction_index",
          "new_api": "code",
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n        loop_header->first_instruction_index())",
          "new_text": "code()",
          "old_line_content": "    auto loop_start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "      block->IsLoopHeader() ? block : GetContainingLoop(code(), block);",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": "pos",
          "new_api": "PreviousUsePositionRegisterIsBeneficial",
          "old_text": "prev_use->pos()",
          "new_text": "range->PreviousUsePositionRegisterIsBeneficial(pos)",
          "old_line_content": "      if (prev_use == nullptr || prev_use->pos() < loop_start) {",
          "new_line_content": "  auto prev_use = range->PreviousUsePositionRegisterIsBeneficial(pos);",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "code",
          "new_api": "first_instruction_index",
          "old_text": "code()",
          "new_text": "loop_header->first_instruction_index()",
          "old_line_content": "    loop_header = GetContainingLoop(code(), loop_header);",
          "new_line_content": "        loop_header->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2241,
          "old_api": "relative_id",
          "new_api": "code",
          "old_text": "range->relative_id()",
          "new_text": "code()",
          "old_line_content": "  TRACE(\"Spilling live range %d:%d\\n\", first->vreg(), range->relative_id());",
          "new_line_content": "    loop_header = GetContainingLoop(code(), loop_header);",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": "fixed_live_ranges",
          "new_api": "HasNoSpillType",
          "old_text": "data()->fixed_live_ranges()",
          "new_text": "first->HasNoSpillType()",
          "old_line_content": "                                    : data()->fixed_live_ranges();",
          "new_line_content": "  if (first->HasNoSpillType()) {",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": "empty",
          "new_api": "reserve",
          "old_text": "unhandled_live_ranges().empty()",
          "new_text": "active_live_ranges().reserve(8)",
          "old_line_content": "  DCHECK(unhandled_live_ranges().empty());",
          "new_line_content": "  active_live_ranges().reserve(8);",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": "empty",
          "new_api": "reserve",
          "old_text": "active_live_ranges().empty()",
          "new_text": "inactive_live_ranges().reserve(8)",
          "old_line_content": "  DCHECK(active_live_ranges().empty());",
          "new_line_content": "  inactive_live_ranges().reserve(8);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": "live_ranges",
          "new_api": "data",
          "old_text": "data()->live_ranges()",
          "new_text": "DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=\n         this->data()->config()->num_general_registers())",
          "old_line_content": "  for (LiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "SortUnhandled",
          "new_api": "empty",
          "old_text": "SortUnhandled()",
          "new_text": "unhandled_live_ranges().empty()",
          "old_line_content": "  SortUnhandled();",
          "new_line_content": "  DCHECK(unhandled_live_ranges().empty());",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": "UnhandledIsSorted",
          "new_api": "empty",
          "old_text": "UnhandledIsSorted()",
          "new_text": "active_live_ranges().empty()",
          "old_line_content": "  DCHECK(UnhandledIsSorted());",
          "new_line_content": "  DCHECK(active_live_ranges().empty());",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": "kind",
          "new_api": "mode",
          "old_text": "current->kind()",
          "new_text": "mode()",
          "old_line_content": "      DCHECK_EQ(mode(), current->kind());",
          "new_line_content": "    if (range->kind() == mode()) {",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "AddToInactive",
          "new_api": "AddToUnhandledUnsorted",
          "old_text": "AddToInactive(current)",
          "new_text": "AddToUnhandledUnsorted(range)",
          "old_line_content": "      AddToInactive(current);",
          "new_line_content": "      AddToUnhandledUnsorted(range);",
          "content_same": false
        },
        {
          "line": 2305,
          "old_api": "empty",
          "new_api": "UnhandledIsSorted",
          "old_text": "unhandled_live_ranges().empty()",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "  while (!unhandled_live_ranges().empty()) {",
          "new_line_content": "  DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "back",
          "new_api": "GetFixedRegisters",
          "old_text": "unhandled_live_ranges().back()",
          "new_text": "GetFixedRegisters()",
          "old_line_content": "    auto current = unhandled_live_ranges().back();",
          "new_line_content": "  auto& fixed_ranges = GetFixedRegisters();",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "Start",
          "new_api": "kind",
          "old_text": "current->Start()",
          "new_text": "current->kind()",
          "old_line_content": "    auto position = current->Start();",
          "new_line_content": "      DCHECK_EQ(mode(), current->kind());",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "value",
          "new_api": "empty",
          "old_text": "position.value()",
          "new_text": "unhandled_live_ranges().empty()",
          "old_line_content": "          current->relative_id(), position.value());",
          "new_line_content": "  while (!unhandled_live_ranges().empty()) {",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "TopLevel",
          "new_api": "back",
          "old_text": "current->TopLevel()->HasNoSpillType()",
          "new_text": "unhandled_live_ranges().back()",
          "old_line_content": "    if (current->IsTopLevel() && !current->TopLevel()->HasNoSpillType()) {",
          "new_line_content": "    auto current = unhandled_live_ranges().back();",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "TopLevel",
          "new_api": "pop_back",
          "old_text": "TRACE(\"Live range %d:%d already has a spill operand\\n\",\n            current->TopLevel()->vreg(), current->relative_id())",
          "new_text": "unhandled_live_ranges().pop_back()",
          "old_line_content": "      TRACE(\"Live range %d:%d already has a spill operand\\n\",",
          "new_line_content": "    unhandled_live_ranges().pop_back();",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": "relative_id",
          "new_api": "UnhandledIsSorted",
          "old_text": "current->relative_id()",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "            current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "NextUsePositionRegisterIsBeneficial",
          "new_api": "TopLevel",
          "old_text": "current->NextUsePositionRegisterIsBeneficial(next_pos)",
          "new_text": "current->TopLevel()->vreg()",
          "old_line_content": "      auto pos = current->NextUsePositionRegisterIsBeneficial(next_pos);",
          "new_line_content": "    TRACE(\"Processing interval %d:%d start=%d\\n\", current->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": "Spill",
          "new_api": "TopLevel",
          "old_text": "Spill(current)",
          "new_text": "TRACE(\"Live range %d:%d already has a spill operand\\n\",\n            current->TopLevel()->vreg(), current->relative_id())",
          "old_line_content": "        Spill(current);",
          "new_line_content": "      TRACE(\"Live range %d:%d already has a spill operand\\n\",",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": "UnhandledIsSorted",
          "new_api": "NextUsePositionRegisterIsBeneficial",
          "old_text": "UnhandledIsSorted()",
          "new_text": "current->NextUsePositionRegisterIsBeneficial(next_pos)",
          "old_line_content": "        DCHECK(UnhandledIsSorted());",
          "new_line_content": "      auto pos = current->NextUsePositionRegisterIsBeneficial(next_pos);",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": "active_live_ranges",
          "new_api": "pos",
          "old_text": "active_live_ranges()",
          "new_text": "pos->pos()",
          "old_line_content": "      auto cur_active = active_live_ranges()[i];",
          "new_line_content": "        SpillBetween(current, current->Start(), pos->pos());",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "End",
          "new_api": "UnhandledIsSorted",
          "old_text": "cur_active->End()",
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "      if (cur_active->End() <= position) {",
          "new_line_content": "        DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "size",
          "new_api": "active_live_ranges",
          "old_text": "inactive_live_ranges().size()",
          "new_text": "active_live_ranges()",
          "old_line_content": "    for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "new_line_content": "      auto cur_active = active_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": "inactive_live_ranges",
          "new_api": "End",
          "old_text": "inactive_live_ranges()",
          "new_text": "cur_active->End()",
          "old_line_content": "      auto cur_inactive = inactive_live_ranges()[i];",
          "new_line_content": "      if (cur_active->End() <= position) {",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": "End",
          "new_api": "ActiveToHandled",
          "old_text": "cur_inactive->End()",
          "new_text": "ActiveToHandled(cur_active)",
          "old_line_content": "      if (cur_inactive->End() <= position) {",
          "new_line_content": "        ActiveToHandled(cur_active);",
          "content_same": false
        },
        {
          "line": 2358,
          "old_api": "Covers",
          "new_api": "ActiveToInactive",
          "old_text": "cur_inactive->Covers(position)",
          "new_text": "ActiveToInactive(cur_active)",
          "old_line_content": "      } else if (cur_inactive->Covers(position)) {",
          "new_line_content": "        ActiveToInactive(cur_active);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": "spilled",
          "new_api": "inactive_live_ranges",
          "old_text": "current->spilled()",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "    DCHECK(!current->HasRegisterAssigned() && !current->spilled());",
          "new_line_content": "      auto cur_inactive = inactive_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "TryAllocateFreeReg",
          "new_api": "InactiveToHandled",
          "old_text": "TryAllocateFreeReg(current)",
          "new_text": "InactiveToHandled(cur_inactive)",
          "old_line_content": "    bool result = TryAllocateFreeReg(current);",
          "new_line_content": "        InactiveToHandled(cur_inactive);",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "HasRegisterAssigned",
          "new_api": "Covers",
          "old_text": "current->HasRegisterAssigned()",
          "new_text": "cur_inactive->Covers(position)",
          "old_line_content": "    if (current->HasRegisterAssigned()) {",
          "new_line_content": "      } else if (cur_inactive->Covers(position)) {",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "AddToActive",
          "new_api": "InactiveToActive",
          "old_text": "AddToActive(current)",
          "new_text": "InactiveToActive(cur_inactive)",
          "old_line_content": "      AddToActive(current);",
          "new_line_content": "        InactiveToActive(cur_inactive);",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": "kind",
          "new_api": "AllocateBlockedReg",
          "old_text": "range->kind()",
          "new_text": "AllocateBlockedReg(current)",
          "old_line_content": "  data()->MarkAllocated(range->kind(), reg);",
          "new_line_content": "    if (!result) AllocateBlockedReg(current);",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "set_assigned_register",
          "new_api": "HasRegisterAssigned",
          "old_text": "range->set_assigned_register(reg)",
          "new_text": "current->HasRegisterAssigned()",
          "old_line_content": "  range->set_assigned_register(reg);",
          "new_line_content": "    if (current->HasRegisterAssigned()) {",
          "content_same": false
        },
        {
          "line": 2379,
          "old_api": "SetUseHints",
          "new_api": "AddToActive",
          "old_text": "range->SetUseHints(reg)",
          "new_text": "AddToActive(current)",
          "old_line_content": "  range->SetUseHints(reg);",
          "new_line_content": "      AddToActive(current);",
          "content_same": false
        },
        {
          "line": 2387,
          "old_api": "TopLevel",
          "new_api": "kind",
          "old_text": "range->TopLevel()->vreg()",
          "new_text": "range->kind()",
          "old_line_content": "  TRACE(\"Add live range %d:%d to active\\n\", range->TopLevel()->vreg(),",
          "new_line_content": "  data()->MarkAllocated(range->kind(), reg);",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": "relative_id",
          "new_api": "set_assigned_register",
          "old_text": "range->relative_id()",
          "new_text": "range->set_assigned_register(reg)",
          "old_line_content": "        range->relative_id());",
          "new_line_content": "  range->set_assigned_register(reg);",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "push_back",
          "new_api": "SetUseHints",
          "old_text": "active_live_ranges().push_back(range)",
          "new_text": "range->SetUseHints(reg)",
          "old_line_content": "  active_live_ranges().push_back(range);",
          "new_line_content": "  range->SetUseHints(reg);",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": "size",
          "new_api": "TopLevel",
          "old_text": "unhandled_live_ranges().size()",
          "new_text": "range->TopLevel()->vreg()",
          "old_line_content": "  for (int i = static_cast<int>(unhandled_live_ranges().size() - 1); i >= 0;",
          "new_line_content": "  TRACE(\"Add live range %d:%d to inactive\\n\", range->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2406,
          "old_api": "at",
          "new_api": "push_back",
          "old_text": "unhandled_live_ranges().at(i)",
          "new_text": "inactive_live_ranges().push_back(range)",
          "old_line_content": "    auto cur_range = unhandled_live_ranges().at(i);",
          "new_line_content": "  inactive_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "insert",
          "new_api": "IsEmpty",
          "old_text": "unhandled_live_ranges().insert(it, range)",
          "new_text": "range->IsEmpty()",
          "old_line_content": "    unhandled_live_ranges().insert(it, range);",
          "new_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "UnhandledIsSorted",
          "new_api": "spilled",
          "old_text": "UnhandledIsSorted()",
          "new_text": "range->spilled()",
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "relative_id",
          "new_api": "at",
          "old_text": "range->relative_id()",
          "new_text": "unhandled_live_ranges().at(i)",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "    auto cur_range = unhandled_live_ranges().at(i);",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "begin",
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": "unhandled_live_ranges().begin()",
          "new_text": "range->ShouldBeAllocatedBefore(cur_range)",
          "old_line_content": "  unhandled_live_ranges().insert(unhandled_live_ranges().begin(), range);",
          "new_line_content": "    if (!range->ShouldBeAllocatedBefore(cur_range)) continue;",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "UnhandledIsSorted",
          "new_api": "TopLevel",
          "old_text": "UnhandledIsSorted()",
          "new_text": "TRACE(\"Add live range %d:%d to unhandled at %d\\n\",\n          range->TopLevel()->vreg(), range->relative_id(), i + 1)",
          "old_line_content": "  DCHECK(UnhandledIsSorted());",
          "new_line_content": "    TRACE(\"Add live range %d:%d to unhandled at %d\\n\",",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "push_back",
          "new_api": "begin",
          "old_text": "unhandled_live_ranges().push_back(range)",
          "new_text": "unhandled_live_ranges().begin()",
          "old_line_content": "  unhandled_live_ranges().push_back(range);",
          "new_line_content": "  unhandled_live_ranges().insert(unhandled_live_ranges().begin(), range);",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": "IsEmpty",
          "old_text": "a->ShouldBeAllocatedBefore(b)",
          "new_text": "range->IsEmpty()",
          "old_line_content": "  if (a->ShouldBeAllocatedBefore(b)) return false;",
          "new_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": "spilled",
          "old_text": "b->ShouldBeAllocatedBefore(a)",
          "new_text": "range->spilled()",
          "old_line_content": "  if (b->ShouldBeAllocatedBefore(a)) return true;",
          "new_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "TRACE",
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": "TRACE(\"Sort unhandled\\n\")",
          "new_text": "a->ShouldBeAllocatedBefore(b)",
          "old_line_content": "  TRACE(\"Sort unhandled\\n\");",
          "new_line_content": "  if (a->ShouldBeAllocatedBefore(b)) return false;",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "end",
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": "unhandled_live_ranges().end()",
          "new_text": "b->ShouldBeAllocatedBefore(a)",
          "old_line_content": "  std::sort(unhandled_live_ranges().begin(), unhandled_live_ranges().end(),",
          "new_line_content": "  if (b->ShouldBeAllocatedBefore(a)) return true;",
          "content_same": false
        },
        {
          "line": 2453,
          "old_api": "at",
          "new_api": "TRACE",
          "old_text": "unhandled_live_ranges().at(i)",
          "new_text": "TRACE(\"Sort unhandled\\n\")",
          "old_line_content": "    auto b = unhandled_live_ranges().at(i);",
          "new_line_content": "  TRACE(\"Sort unhandled\\n\");",
          "content_same": false
        },
        {
          "line": 2454,
          "old_api": "Start",
          "new_api": "end",
          "old_text": "b->Start()",
          "new_text": "unhandled_live_ranges().end()",
          "old_line_content": "    if (a->Start() < b->Start()) return false;",
          "new_line_content": "  std::sort(unhandled_live_ranges().begin(), unhandled_live_ranges().end(),",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "TopLevel",
          "new_api": "at",
          "old_text": "TRACE(\"Moving live range %d:%d from active to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": "unhandled_live_ranges().at(i - 1)",
          "old_line_content": "  TRACE(\"Moving live range %d:%d from active to handled\\n\",",
          "new_line_content": "    auto a = unhandled_live_ranges().at(i - 1);",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": "relative_id",
          "new_api": "at",
          "old_text": "range->relative_id()",
          "new_text": "unhandled_live_ranges().at(i)",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "    auto b = unhandled_live_ranges().at(i);",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": "relative_id",
          "new_api": "active_live_ranges",
          "old_text": "range->relative_id()",
          "new_text": "active_live_ranges()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "relative_id",
          "new_api": "active_live_ranges",
          "old_text": "range->relative_id()",
          "new_text": "active_live_ranges()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "relative_id",
          "new_api": "inactive_live_ranges",
          "old_text": "range->relative_id()",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "new_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "num_registers",
          "new_api": "inactive_live_ranges",
          "old_text": "num_registers()",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "new_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": "LifetimePosition::MaxPosition()",
          "new_api": "push_back",
          "old_text": "LifetimePosition::MaxPosition()",
          "new_text": "active_live_ranges().push_back(range)",
          "old_line_content": "    free_until_pos[i] = LifetimePosition::MaxPosition();",
          "new_line_content": "  active_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2503,
          "old_api": "Start",
          "new_api": "num_registers",
          "old_text": "current->Start()",
          "new_text": "num_registers()",
          "old_line_content": "    DCHECK(cur_inactive->End() > current->Start());",
          "new_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "FirstIntersection",
          "new_api": "LifetimePosition::MaxPosition()",
          "old_text": "cur_inactive->FirstIntersection(current)",
          "new_text": "LifetimePosition::MaxPosition()",
          "old_line_content": "    auto next_intersection = cur_inactive->FirstIntersection(current);",
          "new_line_content": "    free_until_pos[i] = LifetimePosition::MaxPosition();",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": "Min",
          "new_api": "active_live_ranges",
          "old_text": "Min(free_until_pos[cur_reg], next_intersection)",
          "new_text": "active_live_ranges()",
          "old_line_content": "    free_until_pos[cur_reg] = Min(free_until_pos[cur_reg], next_intersection);",
          "new_line_content": "  for (auto cur_active : active_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2512,
          "old_api": "value",
          "new_api": "inactive_live_ranges",
          "old_text": "TRACE(\n        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",\n        RegisterName(hint_register), free_until_pos[hint_register].value(),\n        current->TopLevel()->vreg(), current->relative_id(),\n        current->End().value())",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "    TRACE(",
          "new_line_content": "  for (auto cur_inactive : inactive_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "value",
          "new_api": "FirstIntersection",
          "old_text": "free_until_pos[hint_register].value()",
          "new_text": "cur_inactive->FirstIntersection(current)",
          "old_line_content": "        RegisterName(hint_register), free_until_pos[hint_register].value(),",
          "new_line_content": "    auto next_intersection = cur_inactive->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "relative_id",
          "new_api": "IsValid",
          "old_text": "current->relative_id()",
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id(),",
          "new_line_content": "    if (!next_intersection.IsValid()) continue;",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": "value",
          "new_api": "assigned_register",
          "old_text": "current->End().value()",
          "new_text": "cur_inactive->assigned_register()",
          "old_line_content": "        current->End().value());",
          "new_line_content": "    int cur_reg = cur_inactive->assigned_register();",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "TopLevel",
          "new_api": "FirstHintPosition",
          "old_text": "current->TopLevel()->vreg()",
          "new_text": "current->FirstHintPosition(&hint_register)",
          "old_line_content": "            RegisterName(hint_register), current->TopLevel()->vreg(),",
          "new_line_content": "  if (current->FirstHintPosition(&hint_register) != nullptr) {",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "relative_id",
          "new_api": "value",
          "old_text": "current->relative_id()",
          "new_text": "TRACE(\n        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",\n        RegisterName(hint_register), free_until_pos[hint_register].value(),\n        current->TopLevel()->vreg(), current->relative_id(),\n        current->End().value())",
          "old_line_content": "            current->relative_id());",
          "new_line_content": "    TRACE(",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": "num_registers",
          "new_api": "TopLevel",
          "old_text": "num_registers()",
          "new_text": "TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",\n            RegisterName(hint_register), current->TopLevel()->vreg(),\n            current->relative_id())",
          "old_line_content": "  for (int i = 1; i < num_registers(); ++i) {",
          "new_line_content": "      TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": "RegisterName",
          "new_api": "End",
          "old_text": "RegisterName(reg)",
          "new_text": "current->End()",
          "old_line_content": "  TRACE(\"Assigning free reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "new_line_content": "  if (pos < current->End()) {",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": "Start",
          "new_api": "End",
          "old_text": "current->Start()",
          "new_text": "current->End()",
          "old_line_content": "  auto register_use = current->NextRegisterPosition(current->Start());",
          "new_line_content": "  DCHECK(pos >= current->End());",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": "End",
          "new_api": "active_live_ranges",
          "old_text": "range->End()",
          "new_text": "active_live_ranges()",
          "old_line_content": "        use_pos[cur_reg] = range->End();",
          "new_line_content": "  for (auto range : active_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "pos",
          "new_api": "TopLevel",
          "old_text": "next_use->pos()",
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "        use_pos[cur_reg] = next_use->pos();",
          "new_line_content": "    if (range->TopLevel()->IsFixed() ||",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": "IsValid",
          "new_api": "End",
          "old_text": "next_intersection.IsValid()",
          "new_text": "range->End()",
          "old_line_content": "    if (!next_intersection.IsValid()) continue;",
          "new_line_content": "        use_pos[cur_reg] = range->End();",
          "content_same": false
        },
        {
          "line": 2599,
          "old_api": "TopLevel",
          "new_api": "pos",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "next_use->pos()",
          "old_line_content": "    if (range->TopLevel()->IsFixed()) {",
          "new_line_content": "        use_pos[cur_reg] = next_use->pos();",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": "num_registers",
          "new_api": "assigned_register",
          "old_text": "num_registers()",
          "new_text": "range->assigned_register()",
          "old_line_content": "  for (int i = 1; i < num_registers(); ++i) {",
          "new_line_content": "    int cur_reg = range->assigned_register();",
          "content_same": false
        },
        {
          "line": 2633,
          "old_api": "RegisterName",
          "new_api": "End",
          "old_text": "RegisterName(reg)",
          "new_text": "current->End()",
          "old_line_content": "  TRACE(\"Assigning blocked reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "new_line_content": "  if (block_pos[reg] < current->End()) {",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "HasRegisterAssigned",
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": "current->HasRegisterAssigned()",
          "new_text": "SetLiveRangeAssignedRegister(current, reg)",
          "old_line_content": "  DCHECK(current->HasRegisterAssigned());",
          "new_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "assigned_register",
          "new_api": "SplitAndSpillIntersecting",
          "old_text": "range->assigned_register()",
          "new_text": "SplitAndSpillIntersecting(current)",
          "old_line_content": "    if (range->assigned_register() == reg) {",
          "new_line_content": "  SplitAndSpillIntersecting(current);",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "pos",
          "new_api": "SpillAfter",
          "old_text": "next_pos->pos()",
          "new_text": "SpillAfter(range, spill_pos)",
          "old_line_content": "        SpillBetweenUntil(range, spill_pos, current->Start(), next_pos->pos());",
          "new_line_content": "        SpillAfter(range, spill_pos);",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": "TopLevel",
          "new_api": "pos",
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": "next_pos->pos()",
          "old_line_content": "    if (range->assigned_register() == reg && !range->TopLevel()->IsFixed()) {",
          "new_line_content": "        SpillBetweenUntil(range, spill_pos, current->Start(), next_pos->pos());",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": "IsValid",
          "new_api": "ActiveToHandled",
          "old_text": "next_intersection.IsValid()",
          "new_text": "ActiveToHandled(range)",
          "old_line_content": "      if (next_intersection.IsValid()) {",
          "new_line_content": "      ActiveToHandled(range);",
          "content_same": false
        },
        {
          "line": 2681,
          "old_api": "pos",
          "new_api": "size",
          "old_text": "next_pos->pos()",
          "new_text": "inactive_live_ranges().size()",
          "old_line_content": "          next_intersection = Min(next_intersection, next_pos->pos());",
          "new_line_content": "  for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": "SpillBetween",
          "new_api": "inactive_live_ranges",
          "old_text": "SpillBetween(range, split_pos, next_intersection)",
          "new_text": "inactive_live_ranges()",
          "old_line_content": "          SpillBetween(range, split_pos, next_intersection);",
          "new_line_content": "    auto range = inactive_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2684,
          "old_api": "InactiveToHandled",
          "new_api": "TopLevel",
          "old_text": "InactiveToHandled(range)",
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "        InactiveToHandled(range);",
          "new_line_content": "    if (range->assigned_register() == reg && !range->TopLevel()->IsFixed()) {",
          "content_same": false
        },
        {
          "line": 2703,
          "old_api": "operands",
          "new_api": "is_phi",
          "old_text": "phi->operands()",
          "new_text": "range->is_phi()",
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "  if (!range->is_phi()) return false;",
          "content_same": false
        },
        {
          "line": 2705,
          "old_api": "TopLevel",
          "new_api": "HasSpillOperand",
          "old_text": "op_range->TopLevel()->HasSpillRange()",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    if (!op_range->TopLevel()->HasSpillRange()) continue;",
          "new_line_content": "  DCHECK(!range->HasSpillOperand());",
          "content_same": false
        },
        {
          "line": 2706,
          "old_api": "predecessors",
          "new_api": "GetPhiMapValueFor",
          "old_text": "block->predecessors()",
          "new_text": "data()->GetPhiMapValueFor(range)",
          "old_line_content": "    auto pred = code()->InstructionBlockAt(block->predecessors()[i]);",
          "new_line_content": "  auto phi_map_value = data()->GetPhiMapValueFor(range);",
          "content_same": false
        },
        {
          "line": 2707,
          "old_api": "last_instruction_index",
          "new_api": "phi",
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n        pred->last_instruction_index())",
          "new_text": "phi_map_value->phi()",
          "old_line_content": "    auto pred_end = LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "  auto phi = phi_map_value->phi();",
          "content_same": false
        },
        {
          "line": 2708,
          "old_api": "last_instruction_index",
          "new_api": "block",
          "old_text": "pred->last_instruction_index()",
          "new_text": "phi_map_value->block()",
          "old_line_content": "        pred->last_instruction_index());",
          "new_line_content": "  auto block = phi_map_value->block();",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": "spilled",
          "new_api": "size",
          "old_text": "op_range->spilled()",
          "new_text": "phi->operands().size()",
          "old_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "new_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "operands",
          "new_api": "size",
          "old_text": "phi->operands()",
          "new_text": "phi->operands().size()",
          "old_line_content": "    int op = phi->operands()[i];",
          "new_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "size",
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": "phi->operands().size()",
          "new_text": "data()->GetOrCreateLiveRangeFor(op)",
          "old_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "new_line_content": "    auto op_range = data()->GetOrCreateLiveRangeFor(op);",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": "interval",
          "new_api": "HasSpillRange",
          "old_text": "first_op_spill->interval()",
          "new_text": "op_range->HasSpillRange()",
          "old_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "new_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 2744,
          "old_api": "first_interval",
          "new_api": "GetSpillRange",
          "old_text": "range->first_interval()",
          "new_text": "op_range->GetSpillRange()",
          "old_line_content": "                                  range->first_interval())) {",
          "new_line_content": "    auto op_spill = op_range->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "NextUsePositionRegisterIsBeneficial",
          "new_api": "size",
          "old_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "new_text": "phi->operands().size()",
          "old_line_content": "  auto pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "new_line_content": "  if (num_merged * 2 <= phi->operands().size() ||",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": "Spill",
          "new_api": "Start",
          "old_text": "Spill(range)",
          "new_text": "range->Start()",
          "old_line_content": "    Spill(range);",
          "new_line_content": "  auto next_pos = range->Start();",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": "NextStart",
          "new_api": "NextUsePositionRegisterIsBeneficial",
          "old_text": "range->Start().NextStart()",
          "new_text": "range->NextUsePositionRegisterIsBeneficial(next_pos)",
          "old_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "new_line_content": "  auto pos = range->NextUsePositionRegisterIsBeneficial(next_pos);",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "TryMerge",
          "new_api": "TopLevel",
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": "range->TopLevel()",
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 2768,
          "old_api": "CHECK",
          "new_api": "TryMerge",
          "old_text": "CHECK(merged)",
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "    CHECK(merged);",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "pos",
          "new_api": "CHECK",
          "old_text": "pos->pos()",
          "new_text": "CHECK(merged)",
          "old_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "new_line_content": "    CHECK(merged);",
          "content_same": false
        },
        {
          "line": 2770,
          "old_api": "UnhandledIsSorted",
          "new_api": "Spill",
          "old_text": "UnhandledIsSorted()",
          "new_text": "Spill(range)",
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "    Spill(range);",
          "content_same": false
        },
        {
          "line": 2778,
          "old_api": "SplitRangeAt",
          "new_api": "CHECK",
          "old_text": "SplitRangeAt(range, pos)",
          "new_text": "CHECK(merged)",
          "old_line_content": "  auto second_part = SplitRangeAt(range, pos);",
          "new_line_content": "    CHECK(merged);",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": "Spill",
          "new_api": "pos",
          "old_text": "Spill(second_part)",
          "new_text": "pos->pos()",
          "old_line_content": "  Spill(second_part);",
          "new_line_content": "    SpillBetween(range, range->Start(), pos->pos());",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": "End",
          "new_api": "SplitRangeAt",
          "old_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "new_text": "SplitRangeAt(range, start)",
          "old_line_content": "    auto third_part = SplitBetween(",
          "new_line_content": "  auto second_part = SplitRangeAt(range, start);",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": "AddToUnhandledSorted",
          "new_api": "PrevStart",
          "old_text": "AddToUnhandledSorted(third_part)",
          "new_text": "end.PrevStart().End()",
          "old_line_content": "    AddToUnhandledSorted(third_part);",
          "new_line_content": "    auto third_part_end = end.PrevStart().End();",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": "AddToUnhandledSorted",
          "new_api": "End",
          "old_text": "AddToUnhandledSorted(second_part)",
          "new_text": "SplitBetween(\n        second_part, Max(second_part->Start().End(), until), third_part_end)",
          "old_line_content": "    AddToUnhandledSorted(second_part);",
          "new_line_content": "    auto third_part = SplitBetween(",
          "content_same": false
        },
        {
          "line": 2824,
          "old_api": "code",
          "new_api": "AddToUnhandledSorted",
          "old_text": "data()->code()",
          "new_text": "AddToUnhandledSorted(second_part)",
          "old_line_content": "  auto code = data()->code();",
          "new_line_content": "    AddToUnhandledSorted(second_part);",
          "content_same": false
        },
        {
          "line": 2842,
          "old_api": "spill_ranges",
          "new_api": "GetInstructionBlock",
          "old_text": "data()->spill_ranges()",
          "new_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "old_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "new_line_content": "      code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "frame",
          "new_api": "IsEmpty",
          "old_text": "data()->frame()->AllocateSpillSlot(byte_width)",
          "new_text": "other->IsEmpty()",
          "old_line_content": "    int index = data()->frame()->AllocateSpillSlot(byte_width);",
          "new_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": "set_assigned_slot",
          "new_api": "TryMerge",
          "old_text": "range->set_assigned_slot(index)",
          "new_text": "range->TryMerge(other)",
          "old_line_content": "    range->set_assigned_slot(index);",
          "new_line_content": "        range->TryMerge(other);",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": "live_ranges",
          "new_api": "IsEmpty",
          "old_text": "data()->live_ranges()",
          "new_text": "range->IsEmpty()",
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": "HasSpillOperand",
          "new_api": "frame",
          "old_text": "top_range->HasSpillOperand()",
          "new_text": "data()->frame()->AllocateSpillSlot(byte_width)",
          "old_line_content": "    if (top_range->HasSpillOperand()) {",
          "new_line_content": "    int index = data()->frame()->AllocateSpillSlot(byte_width);",
          "content_same": false
        },
        {
          "line": 2871,
          "old_api": "TopLevel",
          "new_api": "set_assigned_slot",
          "old_text": "top_range->TopLevel()->GetSpillOperand()",
          "new_text": "range->set_assigned_slot(index)",
          "old_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "new_line_content": "    range->set_assigned_slot(index);",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": "GetAssignedOperand",
          "new_api": "live_ranges",
          "old_text": "top_range->GetAssignedOperand()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "          top_range->GetAssignedOperand());",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": "next",
          "new_api": "HasSpillOperand",
          "old_text": "range->next()",
          "new_text": "top_range->HasSpillOperand()",
          "old_line_content": "         range = range->next()) {",
          "new_line_content": "    if (top_range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 2881,
          "old_api": "GetAssignedOperand",
          "new_api": "TopLevel",
          "old_text": "range->GetAssignedOperand()",
          "new_text": "top_range->TopLevel()->GetSpillOperand()",
          "old_line_content": "      auto assigned = range->GetAssignedOperand();",
          "new_line_content": "      spill_operand = *top_range->TopLevel()->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 2882,
          "old_api": "ConvertUsesToOperand",
          "new_api": "TopLevel",
          "old_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "new_text": "top_range->TopLevel()->HasSpillRange()",
          "old_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "new_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "IsInvalid",
          "new_api": "is_phi",
          "old_text": "spill_operand.IsInvalid()",
          "new_text": "top_range->is_phi()",
          "old_line_content": "    if (!spill_operand.IsInvalid()) {",
          "new_line_content": "    if (top_range->is_phi()) {",
          "content_same": false
        },
        {
          "line": 2927,
          "old_api": "delayed_references",
          "new_api": "instruction_position",
          "old_text": "data()->delayed_references()",
          "new_text": "map->instruction_position()",
          "old_line_content": "  for (auto& delayed_reference : data()->delayed_references()) {",
          "new_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "content_same": false
        },
        {
          "line": 2928,
          "old_api": "RecordReference",
          "new_api": "instruction_position",
          "old_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "new_text": "map->instruction_position()",
          "old_line_content": "    delayed_reference.map->RecordReference(",
          "new_line_content": "    safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 2935,
          "old_api": "begin",
          "new_api": "SafePointsAreInOrder",
          "old_text": "reference_maps->begin()",
          "new_text": "SafePointsAreInOrder()",
          "old_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "new_line_content": "  DCHECK(SafePointsAreInOrder());",
          "content_same": false
        },
        {
          "line": 2939,
          "old_api": "IsReference",
          "new_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_text": "data()->IsReference(range)",
          "new_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "old_line_content": "    if (!data()->IsReference(range)) continue;",
          "new_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "content_same": false
        },
        {
          "line": 2944,
          "old_api": "ToInstructionIndex",
          "new_api": "code",
          "old_text": "range->Start().ToInstructionIndex()",
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "    int start = range->Start().ToInstructionIndex();",
          "new_line_content": "  auto reference_maps = data()->code()->reference_maps();",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": "next",
          "new_api": "live_ranges",
          "old_text": "cur->next()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": "ToInstructionIndex",
          "new_api": "IsReference",
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": "data()->IsReference(range)",
          "old_line_content": "        end = this_end.ToInstructionIndex();",
          "new_line_content": "    if (!data()->IsReference(range)) continue;",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "end",
          "new_api": "ToInstructionIndex",
          "old_text": "reference_maps->end()",
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "new_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "content_same": false
        },
        {
          "line": 2970,
          "old_api": "GetSpillOperand",
          "new_api": "end",
          "old_text": "range->GetSpillOperand()",
          "new_text": "reference_maps->end()",
          "old_line_content": "        spill_operand = *range->GetSpillOperand();",
          "new_line_content": "    for (; first_it != reference_maps->end(); ++first_it) {",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": "GetSpillRangeOperand",
          "new_api": "instruction_position",
          "old_text": "range->GetSpillRangeOperand()",
          "new_text": "map->instruction_position()",
          "old_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "new_line_content": "      if (map->instruction_position() >= start) break;",
          "content_same": false
        },
        {
          "line": 2976,
          "old_api": "machine_type",
          "new_api": "HasSpillOperand",
          "old_text": "AllocatedOperand::cast(spill_operand).machine_type()",
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "                AllocatedOperand::cast(spill_operand).machine_type());",
          "new_line_content": "    if (((range->HasSpillOperand() &&",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "end",
          "new_api": "GetSpillOperand",
          "old_text": "reference_maps->end()",
          "new_text": "range->GetSpillOperand()",
          "old_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "new_line_content": "        spill_operand = *range->GetSpillOperand();",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "instruction_position",
          "new_api": "GetSpillRangeOperand",
          "old_text": "map->instruction_position()",
          "new_text": "range->GetSpillRangeOperand()",
          "old_line_content": "      int safe_point = map->instruction_position();",
          "new_line_content": "        spill_operand = range->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_api": "end",
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "new_text": "reference_maps->end()",
          "old_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "new_line_content": "    for (auto it = first_it; it != reference_maps->end(); ++it) {",
          "content_same": false
        },
        {
          "line": 2992,
          "old_api": "Covers",
          "new_api": "instruction_position",
          "old_text": "cur->Covers(safe_point_pos)",
          "new_text": "map->instruction_position()",
          "old_line_content": "      while (cur != nullptr && !cur->Covers(safe_point_pos)) {",
          "new_line_content": "      int safe_point = map->instruction_position();",
          "content_same": false
        },
        {
          "line": 3000,
          "old_api": "ToInstructionIndex",
          "new_api": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(safe_point)",
          "old_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "new_line_content": "          LifetimePosition::InstructionFromInstructionIndex(safe_point);",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": "IsInvalid",
          "new_api": "next",
          "old_text": "spill_operand.IsInvalid()",
          "new_text": "cur->next()",
          "old_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "new_line_content": "        cur = cur->next();",
          "content_same": false
        },
        {
          "line": 3009,
          "old_api": "spilled",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "cur->spilled()",
          "new_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "      if (!cur->spilled()) {",
          "new_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "content_same": false
        },
        {
          "line": 3010,
          "old_api": "value",
          "new_api": "ToInstructionIndex",
          "old_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "new_text": "cur->Start().ToInstructionIndex()",
          "old_line_content": "        TRACE(",
          "new_line_content": "                            ? cur->Start().ToInstructionIndex()",
          "content_same": false
        },
        {
          "line": 3013,
          "old_api": "value",
          "new_api": "IsInvalid",
          "old_text": "cur->Start().value()",
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "new_line_content": "      if (!spill_operand.IsInvalid() && safe_point >= spill_index) {",
          "content_same": false
        },
        {
          "line": 3015,
          "old_api": "GetAssignedOperand",
          "new_api": "vreg",
          "old_text": "cur->GetAssignedOperand()",
          "new_text": "range->vreg()",
          "old_line_content": "        auto operand = cur->GetAssignedOperand();",
          "new_line_content": "              range->vreg(), spill_index, safe_point);",
          "content_same": false
        },
        {
          "line": 3016,
          "old_api": "IsStackSlot",
          "new_api": "AllocatedOperand::cast(spill_operand)",
          "old_text": "operand.IsStackSlot()",
          "new_text": "AllocatedOperand::cast(spill_operand)",
          "old_line_content": "        DCHECK(!operand.IsStackSlot());",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "DCHECK",
          "new_api": "next",
          "old_text": "DCHECK(right_index > current_index)",
          "new_text": "i->next()",
          "old_line_content": "      DCHECK(right_index > current_index);",
          "new_line_content": "    for (auto i = range; i != nullptr; i = i->next(), ++curr) {",
          "content_same": false
        },
        {
          "line": 3089,
          "old_api": "last_instruction_index",
          "new_api": "DCHECK",
          "old_text": "pred->last_instruction_index()",
          "new_text": "DCHECK(left_index < current_index)",
          "old_line_content": "        pred->last_instruction_index());",
          "new_line_content": "        DCHECK(left_index < current_index);",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "first_instruction_index",
          "new_api": "Find",
          "old_text": "block->first_instruction_index()",
          "new_text": "Find(succ_start)",
          "old_line_content": "        block->first_instruction_index());",
          "new_line_content": "    return Find(succ_start);",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": "Find",
          "new_api": "last_instruction_index",
          "old_text": "Find(cur_start)",
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    result->cur_cover_ = Find(cur_start)->range_;",
          "new_line_content": "        pred->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 3113,
          "old_api": "DCHECK",
          "new_api": "Find",
          "old_text": "DCHECK(result->pred_cover_ != nullptr && result->cur_cover_ != nullptr)",
          "new_text": "Find(pred_end)",
          "old_line_content": "    DCHECK(result->pred_cover_ != nullptr && result->cur_cover_ != nullptr);",
          "new_line_content": "    auto bound = Find(pred_end);",
          "content_same": false
        },
        {
          "line": 3138,
          "old_api": "live_ranges",
          "new_api": "size",
          "old_text": "data_->live_ranges()",
          "new_text": "data_->live_ranges().size()",
          "old_line_content": "    auto range = data_->live_ranges()[operand_index];",
          "new_line_content": "        bounds_length_(static_cast<int>(data_->live_ranges().size())),",
          "content_same": false
        },
        {
          "line": 3139,
          "old_api": "IsEmpty",
          "new_api": "zone->NewArray<LiveRangeBoundArray>(bounds_length_)",
          "old_text": "range->IsEmpty()",
          "new_text": "zone->NewArray<LiveRangeBoundArray>(bounds_length_)",
          "old_line_content": "    DCHECK(range != nullptr && !range->IsEmpty());",
          "new_line_content": "        bounds_(zone->NewArray<LiveRangeBoundArray>(bounds_length_)),",
          "content_same": false
        },
        {
          "line": 3193,
          "old_api": "CanEagerlyResolveControlFlow",
          "new_api": "PredecessorCount",
          "old_text": "CanEagerlyResolveControlFlow(block)",
          "new_text": "block->PredecessorCount()",
          "old_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "new_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "content_same": false
        },
        {
          "line": 3194,
          "old_api": "ToInt",
          "new_api": "rpo_number",
          "old_text": "block->rpo_number().ToInt()",
          "new_text": "block->rpo_number()",
          "old_line_content": "    auto live = live_in_sets[block->rpo_number().ToInt()];",
          "new_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": "Find",
          "new_api": "live_in_sets",
          "old_text": "array->Find(block, pred_block, &result)",
          "new_text": "data()->live_in_sets()",
          "old_line_content": "        array->Find(block, pred_block, &result);",
          "new_line_content": "  auto& live_in_sets = data()->live_in_sets();",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": "TopLevel",
          "new_api": "CanEagerlyResolveControlFlow",
          "old_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "new_text": "CanEagerlyResolveControlFlow(block)",
          "old_line_content": "            (!result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "new_line_content": "    if (CanEagerlyResolveControlFlow(block)) continue;",
          "content_same": false
        },
        {
          "line": 3204,
          "old_api": "spilled",
          "new_api": "ToInt",
          "old_text": "result.cur_cover_->spilled()",
          "new_text": "block->rpo_number().ToInt()",
          "old_line_content": "             result.cur_cover_->spilled()))",
          "new_line_content": "    auto live = live_in_sets[block->rpo_number().ToInt()];",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": "GetAssignedOperand",
          "new_api": "Done",
          "old_text": "result.pred_cover_->GetAssignedOperand()",
          "new_text": "iterator.Done()",
          "old_line_content": "        auto pred_op = result.pred_cover_->GetAssignedOperand();",
          "new_line_content": "    while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 3207,
          "old_api": "GetAssignedOperand",
          "new_api": "Current",
          "old_text": "result.cur_cover_->GetAssignedOperand()",
          "new_text": "iterator.Current()",
          "old_line_content": "        auto cur_op = result.cur_cover_->GetAssignedOperand();",
          "new_line_content": "      auto* array = finder.ArrayFor(iterator.Current());",
          "content_same": false
        },
        {
          "line": 3208,
          "old_api": "Equals",
          "new_api": "predecessors",
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": "block->predecessors()",
          "old_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "new_line_content": "      for (auto pred : block->predecessors()) {",
          "content_same": false
        },
        {
          "line": 3211,
          "old_api": "Advance",
          "new_api": "Find",
          "old_text": "iterator.Advance()",
          "new_text": "array->Find(block, pred_block, &result)",
          "old_line_content": "      iterator.Advance();",
          "new_line_content": "        array->Find(block, pred_block, &result);",
          "content_same": false
        },
        {
          "line": 3221,
          "old_api": "Equals",
          "new_api": "Advance",
          "old_text": "pred_op.Equals(cur_op)",
          "new_text": "iterator.Advance()",
          "old_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "new_line_content": "      iterator.Advance();",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": "AddGapMove",
          "new_api": "first_instruction_index",
          "old_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "new_text": "block->first_instruction_index()",
          "old_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "new_line_content": "    gap_index = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 3245,
          "old_api": "next",
          "new_api": "AddGapMove",
          "old_text": "first_range->next()",
          "new_text": "data()->AddGapMove(gap_index, position, pred_op, cur_op)",
          "old_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "new_line_content": "  data()->AddGapMove(gap_index, position, pred_op, cur_op);",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": "End",
          "new_api": "live_ranges",
          "old_text": "first_range->End()",
          "new_text": "data()->live_ranges()",
          "old_line_content": "      if (first_range->End() != pos) continue;",
          "new_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 3253,
          "old_api": "code",
          "new_api": "IsSpilledOnlyInDeferredBlocks",
          "old_text": "code()",
          "new_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "new_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": "GetAssignedOperand",
          "new_api": "next",
          "old_text": "first_range->GetAssignedOperand()",
          "new_text": "second_range->next()",
          "old_line_content": "      auto prev_operand = first_range->GetAssignedOperand();",
          "new_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": "GetAssignedOperand",
          "new_api": "Start",
          "old_text": "second_range->GetAssignedOperand()",
          "new_text": "second_range->Start()",
          "old_line_content": "      auto cur_operand = second_range->GetAssignedOperand();",
          "new_line_content": "      auto pos = second_range->Start();",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": "ToInstructionIndex",
          "new_api": "End",
          "old_text": "pos.ToInstructionIndex()",
          "new_text": "first_range->End()",
          "old_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "new_line_content": "      if (first_range->End() != pos) continue;",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": "IsGapPosition",
          "new_api": "IsBlockBoundary",
          "old_text": "pos.IsGapPosition()",
          "new_text": "data()->IsBlockBoundary(pos)",
          "old_line_content": "      if (pos.IsGapPosition()) {",
          "new_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": "IsStart",
          "new_api": "code",
          "old_text": "pos.IsStart()",
          "new_text": "code()",
          "old_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "new_line_content": "          !CanEagerlyResolveControlFlow(GetInstructionBlock(code(), pos))) {",
          "content_same": false
        },
        {
          "line": 3272,
          "old_api": "InstructionAt",
          "new_api": "IsGapPosition",
          "old_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n          gap_pos, code_zone())",
          "new_text": "pos.IsGapPosition()",
          "old_line_content": "      auto move = code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "new_line_content": "      if (pos.IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": "code_zone",
          "new_api": "IsStart",
          "old_text": "code_zone()",
          "new_text": "pos.IsStart()",
          "old_line_content": "          gap_pos, code_zone());",
          "new_line_content": "        gap_pos = pos.IsStart() ? Instruction::START : Instruction::END;",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": "AddMove",
          "new_api": "IsStart",
          "old_text": "move->AddMove(prev_operand, cur_operand)",
          "new_text": "pos.IsStart()",
          "old_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "new_line_content": "        if (pos.IsStart()) {",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "empty",
          "new_api": "InstructionAt",
          "old_text": "delayed_insertion_map.empty()",
          "new_text": "code()->InstructionAt(gap_index)->GetOrCreateParallelMove(\n          gap_pos, code_zone())",
          "old_line_content": "  if (delayed_insertion_map.empty()) return;",
          "new_line_content": "      auto move = code()->InstructionAt(gap_index)->GetOrCreateParallelMove(",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": "reserve",
          "new_api": "insert",
          "old_text": "to_eliminate.reserve(4)",
          "new_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "old_line_content": "  to_eliminate.reserve(4);",
          "new_line_content": "        delayed_insertion_map.insert(",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": "begin",
          "new_api": "std::make_pair(move, prev_operand)",
          "old_text": "delayed_insertion_map.begin()",
          "new_text": "std::make_pair(move, prev_operand)",
          "old_line_content": "  auto moves = delayed_insertion_map.begin()->first.first;",
          "new_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": "push_back",
          "new_api": "reserve",
          "old_text": "moves->push_back(move)",
          "new_text": "to_eliminate.reserve(4)",
          "old_line_content": "        moves->push_back(move);",
          "new_line_content": "  to_eliminate.reserve(4);",
          "content_same": false
        },
        {
          "line": 3307,
          "old_api": "PrepareInsertAfter",
          "new_api": "push_back",
          "old_text": "moves->PrepareInsertAfter(move)",
          "new_text": "moves->push_back(move)",
          "old_line_content": "    auto eliminate = moves->PrepareInsertAfter(move);",
          "new_line_content": "        moves->push_back(move);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "NextFullStart",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n                 code()->LastLoopInstructionIndex(block)).NextFullStart()",
          "old_line_content": "       ++i) {",
          "new_line_content": "  auto end = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2050,
          "old_api": null,
          "new_api": "Done",
          "old_text": null,
          "new_text": "iterator.Done()",
          "old_line_content": "  }",
          "new_line_content": "  while (!iterator.Done()) {",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "}",
          "new_line_content": "    int operand_index = iterator.Current();",
          "content_same": false
        },
        {
          "line": 2052,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(operand_index)",
          "old_line_content": "",
          "new_line_content": "    TopLevelLiveRange* range = data()->GetOrCreateLiveRangeFor(operand_index);",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "",
          "new_line_content": "    range->EnsureInterval(start, end, allocation_zone());",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "Advance",
          "old_text": null,
          "new_text": "iterator.Advance()",
          "old_line_content": "void LiveRangeBuilder::BuildLiveRanges() {",
          "new_line_content": "    iterator.Advance();",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "block->loop_end().ToInt()",
          "old_line_content": "       --block_id) {",
          "new_line_content": "  for (int i = block->rpo_number().ToInt() + 1; i < block->loop_end().ToInt();",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "InstructionBlockCount",
          "old_text": null,
          "new_text": "code()->InstructionBlockCount()",
          "old_line_content": "    // All phi output operands are killed by this block.",
          "new_line_content": "  for (int block_id = code()->InstructionBlockCount() - 1; block_id >= 0;",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": null,
          "new_api": "RpoNumber::FromInt(block_id)",
          "old_text": null,
          "new_text": "RpoNumber::FromInt(block_id)",
          "old_line_content": "    // Now live is live_in for this block except not including values live",
          "new_line_content": "    auto block = code()->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "data()",
          "old_line_content": "    // out on backward successor edges.",
          "new_line_content": "    auto live = ComputeLiveOut(block, data());",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": null,
          "new_api": "AddInitialIntervals",
          "old_text": null,
          "new_text": "AddInitialIntervals(block, live)",
          "old_line_content": "  }",
          "new_line_content": "    AddInitialIntervals(block, live);",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "ProcessInstructions",
          "old_text": null,
          "new_text": "ProcessInstructions(block, live)",
          "old_line_content": "    if (range == nullptr) continue;",
          "new_line_content": "    ProcessInstructions(block, live);",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "ProcessLoopHeader",
          "old_text": null,
          "new_text": "ProcessLoopHeader(block, live)",
          "old_line_content": "    // TODO(bmeurer): This is a horrible hack to make sure that for constant",
          "new_line_content": "    if (block->IsLoopHeader()) ProcessLoopHeader(block, live);",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": null,
          "new_api": "live_in_sets",
          "old_text": null,
          "new_text": "live_in_sets()",
          "old_line_content": "    // live ranges, every use requires the constant to be in a register.",
          "new_line_content": "    live_in_sets()[block_id] = live;",
          "content_same": false
        },
        {
          "line": 2087,
          "old_api": null,
          "new_api": "HasNoSpillType",
          "old_text": null,
          "new_text": "range->HasNoSpillType()",
          "old_line_content": "        UsePositionType new_type = UsePositionType::kAny;",
          "new_line_content": "    if (range->has_slot_use() && range->HasNoSpillType()) {",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": null,
          "new_api": "AssignSpillRangeToLiveRange",
          "old_text": null,
          "new_text": "data()->AssignSpillRangeToLiveRange(range)",
          "old_line_content": "        // Can't mark phis as needing a register.",
          "new_line_content": "      data()->AssignSpillRangeToLiveRange(range);",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": null,
          "new_api": "GetSpillOperand",
          "old_text": null,
          "new_text": "range->GetSpillOperand()->IsConstant()",
          "old_line_content": "    }",
          "new_line_content": "    if (range->HasSpillOperand() && range->GetSpillOperand()->IsConstant()) {",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "pos->next()",
          "old_line_content": "  }",
          "new_line_content": "      for (auto pos = range->first_pos(); pos != nullptr; pos = pos->next()) {",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "pos->type()",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "        if (pos->type() == UsePositionType::kRequiresSlot) continue;",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": null,
          "new_api": "IsGapPosition",
          "old_text": null,
          "new_text": "pos->pos().IsGapPosition()",
          "old_line_content": "}",
          "new_line_content": "        if (!pos->pos().IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": null,
          "new_api": "set_type",
          "old_text": null,
          "new_text": "pos->set_type(new_type, true)",
          "old_line_content": "void LiveRangeBuilder::MapPhiHint(InstructionOperand* operand,",
          "new_line_content": "        pos->set_type(new_type, true);",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(res)",
          "old_line_content": "}",
          "new_line_content": "  USE(res);",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "phi_hints_.find(operand)",
          "old_line_content": "  }",
          "new_line_content": "  auto it = phi_hints_.find(operand);",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "ResolveHint",
          "old_text": null,
          "new_text": "it->second->ResolveHint(use_pos)",
          "old_line_content": "  }",
          "new_line_content": "  it->second->ResolveHint(use_pos);",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": null,
          "new_api": "IsResolved",
          "old_text": null,
          "new_text": "hint.second->IsResolved()",
          "old_line_content": "    : data_(data),",
          "new_line_content": "    CHECK(hint.second->IsResolved());",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": null,
          "new_api": "Verify",
          "old_text": null,
          "new_text": "current->Verify()",
          "old_line_content": "",
          "new_line_content": "    if (current != nullptr) current->Verify();",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "data->config()",
          "old_line_content": "",
          "new_line_content": "      num_registers_(GetRegisterCount(data->config(), kind)) {}",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->vreg()",
          "old_line_content": "",
          "new_line_content": "  TRACE(\"Splitting live range %d:%d at %d\\n\", range->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "range->Start()",
          "old_line_content": "}",
          "new_line_content": "  if (pos <= range->Start()) return range;",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": null,
          "new_api": "IsGapPosition",
          "old_text": null,
          "new_text": "pos.IsGapPosition()",
          "old_line_content": "                                           LifetimePosition start,",
          "new_line_content": "  DCHECK(pos.IsStart() || pos.IsGapPosition() ||",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "                                           LifetimePosition end) {",
          "new_line_content": "         (GetInstructionBlock(code(), pos)->last_instruction_index() !=",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",\n        range->TopLevel()->vreg(), range->relative_id(), start.value(),\n        end.value())",
          "old_line_content": "LifetimePosition RegisterAllocator::FindOptimalSplitPos(LifetimePosition start,",
          "new_line_content": "  TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start.value()",
          "old_line_content": "                                                        LifetimePosition end) {",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id(), start.value(),",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(split_pos >= start)",
          "old_line_content": "",
          "new_line_content": "  DCHECK(split_pos >= start);",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, split_pos)",
          "old_line_content": "  // We have no choice",
          "new_line_content": "  return SplitRangeAt(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "start.ToInstructionIndex()",
          "old_line_content": "  if (end_block == start_block) {",
          "new_line_content": "  int start_instr = start.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "end.ToInstructionIndex()",
          "old_line_content": "    // The interval is split in the same basic block. Split at the latest",
          "new_line_content": "  int end_instr = end.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(start_instr <= end_instr)",
          "old_line_content": "    // possible position.",
          "new_line_content": "  DCHECK(start_instr <= end_instr);",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "  // Find header of outermost loop.",
          "new_line_content": "  auto start_block = GetInstructionBlock(code(), start);",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "  // TODO(titzer): fix redundancy below.",
          "new_line_content": "  auto end_block = GetInstructionBlock(code(), end);",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": null,
          "new_api": "ToInt",
          "old_text": null,
          "new_text": "start_block->rpo_number().ToInt()",
          "old_line_content": "}",
          "new_line_content": "             start_block->rpo_number().ToInt()) {",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "code()",
          "old_line_content": "",
          "new_line_content": "    block = GetContainingLoop(code(), block);",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": null,
          "new_api": "IsLoopHeader",
          "old_text": null,
          "new_text": "end_block->IsLoopHeader()",
          "old_line_content": "  auto loop_header =",
          "new_line_content": "  if (block == end_block && !end_block->IsLoopHeader()) return end;",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "old_line_content": "",
          "new_line_content": "  return LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "  if (loop_header == nullptr) return pos;",
          "new_line_content": "      block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "pos.Start()",
          "old_line_content": "    // If possible try to move spilling position backwards to loop header.",
          "new_line_content": "  auto block = GetInstructionBlock(code(), pos.Start());",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n        loop_header->first_instruction_index())",
          "old_line_content": "    // Try hoisting out to an outer loop.",
          "new_line_content": "    auto loop_start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "range->Covers(loop_start)",
          "old_line_content": "",
          "new_line_content": "    if (range->Covers(loop_start)) {",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "prev_use->pos()",
          "old_line_content": "  return pos;",
          "new_line_content": "      if (prev_use == nullptr || prev_use->pos() < loop_start) {",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "range->spilled()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(!range->spilled());",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "const ZoneVector<TopLevelLiveRange*>& RegisterAllocator::GetFixedRegisters()",
          "new_line_content": "  TopLevelLiveRange* first = range->TopLevel();",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "    const {",
          "new_line_content": "  TRACE(\"Spilling live range %d:%d\\n\", first->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": null,
          "new_api": "AssignSpillRangeToLiveRange",
          "old_text": null,
          "new_text": "data()->AssignSpillRangeToLiveRange(first)",
          "old_line_content": "}",
          "new_line_content": "    data()->AssignSpillRangeToLiveRange(first);",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "range->Spill()",
          "old_line_content": "",
          "new_line_content": "  range->Spill();",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "fixed_double_live_ranges",
          "old_text": null,
          "new_text": "data()->fixed_double_live_ranges()",
          "old_line_content": "  }",
          "new_line_content": "  return mode() == DOUBLE_REGISTERS ? data()->fixed_double_live_ranges()",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": null,
          "new_api": "fixed_live_ranges",
          "old_text": null,
          "new_text": "data()->fixed_live_ranges()",
          "old_line_content": "}",
          "new_line_content": "                                    : data()->fixed_live_ranges();",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": null,
          "new_api": "mode",
          "old_text": null,
          "new_text": "mode()",
          "old_line_content": "    : RegisterAllocator(data, kind),",
          "new_line_content": "  if (mode() == GENERAL_REGISTERS) {",
          "content_same": false
        },
        {
          "line": 2269,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "data()->config()->general_register_name(allocation_index)",
          "old_line_content": "      unhandled_live_ranges_(local_zone),",
          "new_line_content": "    return data()->config()->general_register_name(allocation_index);",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "data()->config()->double_register_name(allocation_index)",
          "old_line_content": "      inactive_live_ranges_(local_zone) {",
          "new_line_content": "    return data()->config()->double_register_name(allocation_index);",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "unhandled_live_ranges().reserve(\n      static_cast<size_t>(code()->VirtualRegisterCount() * 2))",
          "old_line_content": "",
          "new_line_content": "  unhandled_live_ranges().reserve(",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": null,
          "new_api": "VirtualRegisterCount",
          "old_text": null,
          "new_text": "code()->VirtualRegisterCount()",
          "old_line_content": "void LinearScanAllocator::AllocateRegisters() {",
          "new_line_content": "      static_cast<size_t>(code()->VirtualRegisterCount() * 2));",
          "content_same": false
        },
        {
          "line": 2289,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "this->data()->config()->num_general_registers()",
          "old_line_content": "    if (range == nullptr) continue;",
          "new_line_content": "         this->data()->config()->num_general_registers());",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "inactive_live_ranges().empty()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(inactive_live_ranges().empty());",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "  for (auto current : fixed_ranges) {",
          "new_line_content": "  for (LiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": null,
          "new_api": "SortUnhandled",
          "old_text": null,
          "new_text": "SortUnhandled()",
          "old_line_content": "",
          "new_line_content": "  SortUnhandled();",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": null,
          "new_api": "AddToInactive",
          "old_text": null,
          "new_text": "AddToInactive(current)",
          "old_line_content": "#ifdef DEBUG",
          "new_line_content": "      AddToInactive(current);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": null,
          "new_api": "UnhandledIsSorted",
          "old_text": null,
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "      auto next_pos = position;",
          "new_line_content": "    auto position = current->Start();",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "position.value()",
          "old_line_content": "      // If the range already has a spill operand and it doesn't need a",
          "new_line_content": "          current->relative_id(), position.value());",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "current->TopLevel()->HasNoSpillType()",
          "old_line_content": "      if (pos == nullptr) {",
          "new_line_content": "    if (current->IsTopLevel() && !current->TopLevel()->HasNoSpillType()) {",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "        continue;",
          "new_line_content": "            current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "IsGapPosition",
          "old_text": null,
          "new_text": "next_pos.IsGapPosition()",
          "old_line_content": "        // Do not spill live range eagerly if use position that can benefit from",
          "new_line_content": "      if (next_pos.IsGapPosition()) {",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "next_pos.NextStart()",
          "old_line_content": "        // the register is too close to the start of live range.",
          "new_line_content": "        next_pos = next_pos.NextStart();",
          "content_same": false
        },
        {
          "line": 2338,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(current)",
          "old_line_content": "",
          "new_line_content": "        Spill(current);",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "current->Start().NextStart()",
          "old_line_content": "      continue;",
          "new_line_content": "      } else if (pos->pos() > current->Start().NextStart()) {",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "current->TopLevel()",
          "old_line_content": "        --i;  // The live range was removed from the list of active live ranges.",
          "new_line_content": "    if (current->IsTopLevel() && TryReuseSpillForPhi(current->TopLevel()))",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "    for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur_active->Covers(position)",
          "old_line_content": "        --i;  // Live range was removed from the list of inactive live ranges.",
          "new_line_content": "      } else if (!cur_active->Covers(position)) {",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inactive_live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "    for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "cur_inactive->End()",
          "old_line_content": "",
          "new_line_content": "      if (cur_inactive->End() <= position) {",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "current->spilled()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(!current->HasRegisterAssigned() && !current->spilled());",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": null,
          "new_api": "TryAllocateFreeReg",
          "old_text": null,
          "new_text": "TryAllocateFreeReg(current)",
          "old_line_content": "                                                       int reg) {",
          "new_line_content": "    bool result = TryAllocateFreeReg(current);",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->is_phi()",
          "old_line_content": "}",
          "new_line_content": "  if (range->IsTopLevel() && range->TopLevel()->is_phi()) {",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "",
          "new_line_content": "    data()->GetPhiMapValueFor(range->TopLevel())->set_assigned_register(reg);",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->vreg()",
          "old_line_content": "}",
          "new_line_content": "  TRACE(\"Add live range %d:%d to active\\n\", range->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->relative_id());",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "active_live_ranges().push_back(range)",
          "old_line_content": "",
          "new_line_content": "  active_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2405,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "       --i) {",
          "new_line_content": "        range->relative_id());",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "range->Start()",
          "old_line_content": "    return;",
          "new_line_content": "  DCHECK(allocation_finger_ <= range->Start());",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "unhandled_live_ranges().size()",
          "old_line_content": "  }",
          "new_line_content": "  for (int i = static_cast<int>(unhandled_live_ranges().size() - 1); i >= 0;",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "}",
          "new_line_content": "          range->TopLevel()->vreg(), range->relative_id(), i + 1);",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "unhandled_live_ranges().begin()",
          "old_line_content": "",
          "new_line_content": "    auto it = unhandled_live_ranges().begin() + (i + 1);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "unhandled_live_ranges().insert(it, range)",
          "old_line_content": "",
          "new_line_content": "    unhandled_live_ranges().insert(it, range);",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": null,
          "new_api": "UnhandledIsSorted",
          "old_text": null,
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "void LinearScanAllocator::AddToUnhandledUnsorted(LiveRange* range) {",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "UnhandledIsSorted",
          "old_text": null,
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "}",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "unhandled_live_ranges().push_back(range)",
          "old_line_content": "",
          "new_line_content": "  unhandled_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": null,
          "new_api": "ShouldBeAllocatedBefore",
          "old_text": null,
          "new_text": "b->ShouldBeAllocatedBefore(a)",
          "old_line_content": "void LinearScanAllocator::SortUnhandled() {",
          "new_line_content": "  DCHECK(!a->ShouldBeAllocatedBefore(b) || !b->ShouldBeAllocatedBefore(a));",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "b->TopLevel()->vreg()",
          "old_line_content": "            &UnhandledSortHelper);",
          "new_line_content": "  return a->TopLevel()->vreg() < b->TopLevel()->vreg();",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "unhandled_live_ranges().size()",
          "old_line_content": "void LinearScanAllocator::ActiveToHandled(LiveRange* range) {",
          "new_line_content": "  size_t len = unhandled_live_ranges().size();",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "b->Start()",
          "old_line_content": "}",
          "new_line_content": "    if (a->Start() < b->Start()) return false;",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Moving live range %d:%d from active to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "}",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from active to handled\\n\",",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "inactive_live_ranges().push_back(range)",
          "old_line_content": "}",
          "new_line_content": "  inactive_live_ranges().push_back(range);",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Moving live range %d:%d from active to inactive\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from active to inactive\\n\",",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Moving live range %d:%d from inactive to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "}",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from inactive to handled\\n\",",
          "content_same": false
        },
        {
          "line": 2488,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "TRACE(\"Moving live range %d:%d from inactive to active\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "old_line_content": "  }",
          "new_line_content": "  TRACE(\"Moving live range %d:%d from inactive to active\\n\",",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "",
          "new_line_content": "        range->TopLevel()->vreg(), range->relative_id());",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "cur_active->assigned_register()",
          "old_line_content": "  }",
          "new_line_content": "    free_until_pos[cur_active->assigned_register()] =",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": null,
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "",
          "new_line_content": "        LifetimePosition::GapFromInstructionIndex(0);",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",",
          "new_line_content": "    DCHECK(cur_inactive->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(free_until_pos[cur_reg], next_intersection)",
          "old_line_content": "",
          "new_line_content": "    free_until_pos[cur_reg] = Min(free_until_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "free_until_pos[hint_register].value()",
          "old_line_content": "      return true;",
          "new_line_content": "        RegisterName(hint_register), free_until_pos[hint_register].value(),",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "    }",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id(),",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "current->End().value()",
          "old_line_content": "  }",
          "new_line_content": "        current->End().value());",
          "content_same": false
        },
        {
          "line": 2529,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "  int reg = 0;",
          "new_line_content": "    if (free_until_pos[hint_register] >= current->End()) {",
          "content_same": false
        },
        {
          "line": 2531,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "current->TopLevel()->vreg()",
          "old_line_content": "    if (free_until_pos[i] > free_until_pos[reg]) {",
          "new_line_content": "            RegisterName(hint_register), current->TopLevel()->vreg(),",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "      reg = i;",
          "new_line_content": "            current->relative_id());",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": null,
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": null,
          "new_text": "SetLiveRangeAssignedRegister(current, hint_register)",
          "old_line_content": "    }",
          "new_line_content": "      SetLiveRangeAssignedRegister(current, hint_register);",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": null,
          "new_api": "num_registers",
          "old_text": null,
          "new_text": "num_registers()",
          "old_line_content": "    return false;",
          "new_line_content": "  for (int i = 1; i < num_registers(); ++i) {",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "  }",
          "new_line_content": "  if (pos <= current->Start()) {",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(current, pos)",
          "old_line_content": "",
          "new_line_content": "    auto tail = SplitRangeAt(current, pos);",
          "content_same": false
        },
        {
          "line": 2557,
          "old_api": null,
          "new_api": "AddToUnhandledSorted",
          "old_text": null,
          "new_text": "AddToUnhandledSorted(tail)",
          "old_line_content": "  return true;",
          "new_line_content": "    AddToUnhandledSorted(tail);",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "RegisterName",
          "old_text": null,
          "new_text": "RegisterName(reg)",
          "old_line_content": "  if (register_use == nullptr) {",
          "new_line_content": "  TRACE(\"Assigning free reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "content_same": false
        },
        {
          "line": 2564,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "    // There is no use in the current live range that requires a register.",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 2565,
          "old_api": null,
          "new_api": "SetLiveRangeAssignedRegister",
          "old_text": null,
          "new_text": "SetLiveRangeAssignedRegister(current, reg)",
          "old_line_content": "    // We can just spill it.",
          "new_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "",
          "new_line_content": "  auto register_use = current->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 2576,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(current)",
          "old_line_content": "",
          "new_line_content": "    Spill(current);",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": null,
          "new_api": "num_registers",
          "old_text": null,
          "new_text": "num_registers()",
          "old_line_content": "    } else {",
          "new_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": null,
          "new_api": "LifetimePosition::MaxPosition()",
          "old_text": null,
          "new_text": "LifetimePosition::MaxPosition()",
          "old_line_content": "      auto next_use =",
          "new_line_content": "    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "      } else {",
          "new_line_content": "    int cur_reg = range->assigned_register();",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "      }",
          "new_line_content": "        !range->CanBeSpilled(current->Start())) {",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": null,
          "new_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "old_line_content": "  }",
          "new_line_content": "          LifetimePosition::GapFromInstructionIndex(0);",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": null,
          "new_api": "inactive_live_ranges",
          "old_text": null,
          "new_text": "inactive_live_ranges()",
          "old_line_content": "    }",
          "new_line_content": "  for (auto range : inactive_live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "  }",
          "new_line_content": "    DCHECK(range->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": null,
          "new_api": "FirstIntersection",
          "old_text": null,
          "new_text": "range->FirstIntersection(current)",
          "old_line_content": "",
          "new_line_content": "    auto next_intersection = range->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "  int reg = 0;",
          "new_line_content": "    if (!next_intersection.IsValid()) continue;",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->IsFixed()",
          "old_line_content": "    if (use_pos[i] > use_pos[reg]) {",
          "new_line_content": "    if (range->TopLevel()->IsFixed()) {",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[cur_reg], next_intersection)",
          "old_line_content": "      reg = i;",
          "new_line_content": "      block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 2611,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(block_pos[cur_reg], use_pos[cur_reg])",
          "old_line_content": "    }",
          "new_line_content": "      use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(use_pos[cur_reg], next_intersection)",
          "old_line_content": "",
          "new_line_content": "      use_pos[cur_reg] = Min(use_pos[cur_reg], next_intersection);",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": null,
          "new_api": "num_registers",
          "old_text": null,
          "new_text": "num_registers()",
          "old_line_content": "    // Spill starting part of live range up to that use.",
          "new_line_content": "  for (int i = 1; i < num_registers(); ++i) {",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "register_use->pos()",
          "old_line_content": "    LiveRange* tail =",
          "new_line_content": "  if (pos < register_use->pos()) {",
          "content_same": false
        },
        {
          "line": 2629,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "register_use->pos()",
          "old_line_content": "  }",
          "new_line_content": "    SpillBetween(current, current->Start(), register_use->pos());",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "block_pos[reg].Start()",
          "old_line_content": "  // This register was not free. Thus we need to find and spill",
          "new_line_content": "        SplitBetween(current, current->Start(), block_pos[reg].Start());",
          "content_same": false
        },
        {
          "line": 2638,
          "old_api": null,
          "new_api": "AddToUnhandledSorted",
          "old_text": null,
          "new_text": "AddToUnhandledSorted(tail)",
          "old_line_content": "  // parts of active and inactive live regions that use the same register",
          "new_line_content": "    AddToUnhandledSorted(tail);",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "current->End()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(block_pos[reg] >= current->End());",
          "content_same": false
        },
        {
          "line": 2643,
          "old_api": null,
          "new_api": "RegisterName",
          "old_text": null,
          "new_text": "RegisterName(reg)",
          "old_line_content": "",
          "new_line_content": "  TRACE(\"Assigning blocked reg %s to live range %d:%d\\n\", RegisterName(reg),",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "current->relative_id()",
          "old_line_content": "void LinearScanAllocator::SplitAndSpillIntersecting(LiveRange* current) {",
          "new_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": null,
          "new_api": "HasRegisterAssigned",
          "old_text": null,
          "new_text": "current->HasRegisterAssigned()",
          "old_line_content": "      } else {",
          "new_line_content": "  DCHECK(current->HasRegisterAssigned());",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "current->assigned_register()",
          "old_line_content": "        // When spilling between spill_pos and next_pos ensure that the range",
          "new_line_content": "  int reg = current->assigned_register();",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "        // remains spilled at least until the start of the current live range.",
          "new_line_content": "  auto split_pos = current->Start();",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "active_live_ranges().size()",
          "old_line_content": "        // This guarantees that we will not introduce new unhandled ranges that",
          "new_line_content": "  for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": null,
          "new_api": "active_live_ranges",
          "old_text": null,
          "new_text": "active_live_ranges()",
          "old_line_content": "        // start before the current range as this violates allocation invariant",
          "new_line_content": "    auto range = active_live_ranges()[i];",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "range->assigned_register()",
          "old_line_content": "        // and will lead to an inconsistent state of active and inactive",
          "new_line_content": "    if (range->assigned_register() == reg) {",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "        // live-ranges: ranges are allocated in order of their start positions,",
          "new_line_content": "      auto next_pos = range->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": null,
          "new_api": "FindOptimalSpillingPos",
          "old_text": null,
          "new_text": "FindOptimalSpillingPos(range, split_pos)",
          "old_line_content": "        // ranges are retired from active/inactive when the start of the",
          "new_line_content": "      auto spill_pos = FindOptimalSpillingPos(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2683,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "        }",
          "new_line_content": "    DCHECK(range->End() > current->Start());",
          "content_same": false
        },
        {
          "line": 2685,
          "old_api": null,
          "new_api": "FirstIntersection",
          "old_text": null,
          "new_text": "range->FirstIntersection(current)",
          "old_line_content": "        --i;",
          "new_line_content": "      LifetimePosition next_intersection = range->FirstIntersection(current);",
          "content_same": false
        },
        {
          "line": 2686,
          "old_api": null,
          "new_api": "IsValid",
          "old_text": null,
          "new_text": "next_intersection.IsValid()",
          "old_line_content": "      }",
          "new_line_content": "      if (next_intersection.IsValid()) {",
          "content_same": false
        },
        {
          "line": 2687,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "current->Start()",
          "old_line_content": "    }",
          "new_line_content": "        UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": null,
          "new_api": "SpillAfter",
          "old_text": null,
          "new_text": "SpillAfter(range, split_pos)",
          "old_line_content": "}",
          "new_line_content": "          SpillAfter(range, split_pos);",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "next_pos->pos()",
          "old_line_content": "",
          "new_line_content": "          next_intersection = Min(next_intersection, next_pos->pos());",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": null,
          "new_api": "SpillBetween",
          "old_text": null,
          "new_text": "SpillBetween(range, split_pos, next_intersection)",
          "old_line_content": "bool LinearScanAllocator::TryReuseSpillForPhi(TopLevelLiveRange* range) {",
          "new_line_content": "          SpillBetween(range, split_pos, next_intersection);",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": null,
          "new_api": "InactiveToHandled",
          "old_text": null,
          "new_text": "InactiveToHandled(range)",
          "old_line_content": "",
          "new_line_content": "        InactiveToHandled(range);",
          "content_same": false
        },
        {
          "line": 2713,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "phi->operands()",
          "old_line_content": "      spilled_count++;",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 2714,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(op)",
          "old_line_content": "      if (first_op == nullptr) {",
          "new_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": null,
          "new_api": "predecessors",
          "old_text": null,
          "new_text": "block->predecessors()",
          "old_line_content": "      }",
          "new_line_content": "    auto pred = code()->InstructionBlockAt(block->predecessors()[i]);",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n        pred->last_instruction_index())",
          "old_line_content": "    }",
          "new_line_content": "    auto pred_end = LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "  }",
          "new_line_content": "        pred->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": null,
          "new_api": "CanCover",
          "old_text": null,
          "new_text": "op_range->CanCover(pred_end)",
          "old_line_content": "",
          "new_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "op_range->next()",
          "old_line_content": "  // Only continue if more than half of the operands are spilled.",
          "new_line_content": "      op_range = op_range->next();",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "op_range->spilled()",
          "old_line_content": "    return false;",
          "new_line_content": "    if (op_range != nullptr && op_range->spilled()) {",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "op_range->TopLevel()",
          "old_line_content": "  // Try to merge the spilled operands and count the number of merged spilled",
          "new_line_content": "        first_op = op_range->TopLevel();",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(first_op != nullptr)",
          "old_line_content": "    }",
          "new_line_content": "  DCHECK(first_op != nullptr);",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "first_op->TopLevel()->GetSpillRange()",
          "old_line_content": "  }",
          "new_line_content": "  auto first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "content_same": false
        },
        {
          "line": 2740,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "  // Only continue if enough operands could be merged to the",
          "new_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "phi->operands()",
          "old_line_content": "  // same spill slot.",
          "new_line_content": "    int op = phi->operands()[i];",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "first_op_spill->TryMerge(op_spill)",
          "old_line_content": "    return false;",
          "new_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": null,
          "new_api": "interval",
          "old_text": null,
          "new_text": "first_op_spill->interval()",
          "old_line_content": "  if (pos == nullptr) {",
          "new_line_content": "      AreUseIntervalsIntersecting(first_op_spill->interval(),",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": null,
          "new_api": "first_interval",
          "old_text": null,
          "new_text": "range->first_interval()",
          "old_line_content": "    auto spill_range =",
          "new_line_content": "                                  range->first_interval())) {",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "next_pos.NextStart()",
          "old_line_content": "    return true;",
          "new_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "content_same": false
        },
        {
          "line": 2772,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "range->Start().NextStart()",
          "old_line_content": "  }",
          "new_line_content": "  } else if (pos->pos() > range->Start().NextStart()) {",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->HasSpillRange()",
          "old_line_content": "}",
          "new_line_content": "        range->TopLevel()->HasSpillRange()",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()->GetSpillRange()",
          "old_line_content": "",
          "new_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "range->TopLevel()",
          "old_line_content": "",
          "new_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "TryMerge",
          "old_text": null,
          "new_text": "first_op_spill->TryMerge(spill_range)",
          "old_line_content": "void LinearScanAllocator::SpillAfter(LiveRange* range, LifetimePosition pos) {",
          "new_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "content_same": false
        },
        {
          "line": 2780,
          "old_api": null,
          "new_api": "UnhandledIsSorted",
          "old_text": null,
          "new_text": "UnhandledIsSorted()",
          "old_line_content": "}",
          "new_line_content": "    DCHECK(UnhandledIsSorted());",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": null,
          "new_api": "SplitRangeAt",
          "old_text": null,
          "new_text": "SplitRangeAt(range, pos)",
          "old_line_content": "",
          "new_line_content": "  auto second_part = SplitRangeAt(range, pos);",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(second_part)",
          "old_line_content": "void LinearScanAllocator::SpillBetweenUntil(LiveRange* range,",
          "new_line_content": "  Spill(second_part);",
          "content_same": false
        },
        {
          "line": 2795,
          "old_api": null,
          "new_api": "SpillBetweenUntil",
          "old_text": null,
          "new_text": "SpillBetweenUntil(range, start, start, end)",
          "old_line_content": "",
          "new_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "content_same": false
        },
        {
          "line": 2803,
          "old_api": null,
          "new_api": "CHECK",
          "old_text": null,
          "new_text": "CHECK(start < end)",
          "old_line_content": "    }",
          "new_line_content": "  CHECK(start < end);",
          "content_same": false
        },
        {
          "line": 2806,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "second_part->Start()",
          "old_line_content": "",
          "new_line_content": "  if (second_part->Start() < end) {",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "  } else {",
          "new_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "end.Start()",
          "old_line_content": "    // The split result does not intersect with [start, end[.",
          "new_line_content": "      third_part_end = end.Start();",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "second_part->Start().End()",
          "old_line_content": "  }",
          "new_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(third_part != second_part)",
          "old_line_content": "",
          "new_line_content": "    DCHECK(third_part != second_part);",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": null,
          "new_api": "Spill",
          "old_text": null,
          "new_text": "Spill(second_part)",
          "old_line_content": "SpillSlotLocator::SpillSlotLocator(RegisterAllocationData* data)",
          "new_line_content": "    Spill(second_part);",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": null,
          "new_api": "AddToUnhandledSorted",
          "old_text": null,
          "new_text": "AddToUnhandledSorted(third_part)",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "    AddToUnhandledSorted(third_part);",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "  }",
          "new_line_content": "  auto code = data()->code();",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data()->live_ranges()",
          "old_line_content": "}",
          "new_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "",
          "new_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "OperandAssigner::OperandAssigner(RegisterAllocationData* data) : data_(data) {}",
          "new_line_content": "    if (!range->HasSpillRange()) continue;",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": null,
          "new_api": "spills_at_definition",
          "old_text": null,
          "new_text": "range->spills_at_definition()",
          "old_line_content": "",
          "new_line_content": "    auto spills = range->spills_at_definition();",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "DCHECK_NOT_NULL",
          "old_text": null,
          "new_text": "DCHECK_NOT_NULL(spills)",
          "old_line_content": "",
          "new_line_content": "    DCHECK_NOT_NULL(spills);",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": null,
          "new_api": "spill_ranges",
          "old_text": null,
          "new_text": "data()->spill_ranges()",
          "old_line_content": "      }",
          "new_line_content": "  ZoneVector<SpillRange*>& spill_ranges = data()->spill_ranges();",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "spill_ranges.size()",
          "old_line_content": "  }",
          "new_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 2858,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "spill_ranges.size()",
          "old_line_content": "    // Allocate a new operand referring to the spill slot.",
          "new_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": null,
          "new_api": "ByteWidth",
          "old_text": null,
          "new_text": "range->ByteWidth()",
          "old_line_content": "    InstructionOperand spill_operand;",
          "new_line_content": "    int byte_width = range->ByteWidth();",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "top_range->IsEmpty()",
          "old_line_content": "    }",
          "new_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "End()",
          "old_line_content": "    next_ = nullptr;",
          "new_line_content": "    DCHECK(end < End());",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": null,
          "new_api": "DetachAt",
          "old_text": null,
          "new_text": "DetachAt(end, result, zone)",
          "old_line_content": "  } else {",
          "new_line_content": "    DetachAt(end, result, zone);",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "old_line_content": "    }",
          "new_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "End()",
          "old_line_content": "",
          "new_line_content": "  } else if (end >= End()) {",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": null,
          "new_api": "GetPhiMapValueFor",
          "old_text": null,
          "new_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "old_line_content": "      // If this top level range has a child spilled in a deferred block, we use",
          "new_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": null,
          "new_api": "DetachAt",
          "old_text": null,
          "new_text": "DetachAt(start, result, zone)",
          "old_line_content": "",
          "new_line_content": "    DetachAt(start, result, zone);",
          "content_same": false
        },
        {
          "line": 2887,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "top_range->GetAssignedOperand()",
          "old_line_content": "      // the range and control flow connection mechanism instead of spilling at",
          "new_line_content": "          top_range->GetAssignedOperand());",
          "content_same": false
        },
        {
          "line": 2890,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "range->next()",
          "old_line_content": "      // connecting move when a successor child range is spilled - because the",
          "new_line_content": "         range = range->next()) {",
          "content_same": false
        },
        {
          "line": 2891,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "range->GetAssignedOperand()",
          "old_line_content": "      // spilled range picks up its value from the slot which was assigned at",
          "new_line_content": "      auto assigned = range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "std::numeric_limits<int>::max()",
          "old_text": null,
          "new_text": "std::numeric_limits<int>::max()",
          "old_line_content": "",
          "new_line_content": "    const int kInvalidId = std::numeric_limits<int>::max();",
          "content_same": false
        },
        {
          "line": 2892,
          "old_api": null,
          "new_api": "ConvertUsesToOperand",
          "old_text": null,
          "new_text": "range->ConvertUsesToOperand(assigned, spill_operand)",
          "old_line_content": "      // definition. For ranges that are determined to spill only in deferred",
          "new_line_content": "      range->ConvertUsesToOperand(assigned, spill_operand);",
          "content_same": false
        },
        {
          "line": 2895,
          "old_api": null,
          "new_api": "IsInvalid",
          "old_text": null,
          "new_text": "spill_operand.IsInvalid()",
          "old_line_content": "      // deferred blocks, this amounts to spilling and filling inside such",
          "new_line_content": "    if (!spill_operand.IsInvalid()) {",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "machine_type",
          "old_text": null,
          "new_text": "this->machine_type()",
          "old_line_content": "",
          "new_line_content": "    LiveRange end_part(kInvalidId, this->machine_type(), nullptr);",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "DetachAt",
          "old_text": null,
          "new_text": "result->DetachAt(end, &end_part, zone)",
          "old_line_content": "",
          "new_line_content": "    result->DetachAt(end, &end_part, zone);",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "last_interval_->set_next(end_part.first_interval_)",
          "old_line_content": "    } else {",
          "new_line_content": "    last_interval_->set_next(end_part.first_interval_);",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "}",
          "new_line_content": "      if (!top_range->TryCommitSpillInDeferredBlock(data()->code(),",
          "content_same": false
        },
        {
          "line": 2911,
          "old_api": null,
          "new_api": "CommitSpillsAtDefinition",
          "old_text": null,
          "new_text": "top_range->CommitSpillsAtDefinition(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "        top_range->CommitSpillsAtDefinition(",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "pos->next()",
          "old_line_content": "",
          "new_line_content": "      for (; pos->next() != nullptr; pos = pos->next()) {",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()",
          "old_line_content": "",
          "new_line_content": "            data()->code(), spill_operand,",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "pos->set_next(end_part.first_pos_)",
          "old_line_content": "void TopLevelLiveRange::SetSplinteredFrom(TopLevelLiveRange* splinter_parent) {",
          "new_line_content": "      pos->set_next(end_part.first_pos_);",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "top_range->spilled()",
          "old_line_content": "",
          "new_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data()->code()->reference_maps()",
          "old_line_content": "  // Map all delayed references.",
          "new_line_content": "  for (auto map : *data()->code()->reference_maps()) {",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "merged->TopLevel()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(merged->TopLevel() == this);",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": null,
          "new_api": "delayed_references",
          "old_text": null,
          "new_text": "data()->delayed_references()",
          "old_line_content": "    if (range == nullptr) continue;",
          "new_line_content": "  for (auto& delayed_reference : data()->delayed_references()) {",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "merged->HasSpillRange()",
          "old_line_content": "void TopLevelLiveRange::Merge(TopLevelLiveRange* other,",
          "new_line_content": "  if (HasNoSpillType() && merged->HasSpillRange()) {",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": null,
          "new_api": "spill_type",
          "old_text": null,
          "new_text": "merged->spill_type()",
          "old_line_content": "                              RegisterAllocationData* data) {",
          "new_line_content": "    set_spill_type(merged->spill_type());",
          "content_same": false
        },
        {
          "line": 2938,
          "old_api": null,
          "new_api": "RecordReference",
          "old_text": null,
          "new_text": "delayed_reference.map->RecordReference(\n        AllocatedOperand::cast(*delayed_reference.operand))",
          "old_line_content": "    // Skip non-reference values.",
          "new_line_content": "    delayed_reference.map->RecordReference(",
          "content_same": false
        },
        {
          "line": 2945,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "reference_maps->begin()",
          "old_line_content": "    int end = 0;",
          "new_line_content": "  ReferenceMapDeque::const_iterator first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "other->Start()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(Start() < other->Start());",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "    }",
          "new_line_content": "    if (range->IsEmpty()) continue;",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "other->vreg()",
          "old_line_content": "  // In the more general case, we need to find the ranges between which to",
          "new_line_content": "  data->live_ranges()[other->vreg()] = nullptr;",
          "content_same": false
        },
        {
          "line": 2954,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "range->Start().ToInstructionIndex()",
          "old_line_content": "    // step backwards and reset the first_it so we don't miss any safe points.",
          "new_line_content": "    int start = range->Start().ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "last_child",
          "old_text": null,
          "new_text": "last_child()",
          "old_line_content": "    last_insertion_point_ = this;",
          "new_line_content": "  LiveRange* last_me = last_child();",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "cur->next()",
          "old_line_content": "    last_range_start = start;",
          "new_line_content": "    for (LiveRange* cur = range; cur != nullptr; cur = cur->next()) {",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "cur->End()",
          "old_line_content": "",
          "new_line_content": "      auto this_end = cur->End();",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "    // Step across all the safe points that are before the start of this range,",
          "new_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "content_same": false
        },
        {
          "line": 2959,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "this_end.ToInstructionIndex()",
          "old_line_content": "    // recording how far we step in order to save doing this for the next range.",
          "new_line_content": "        end = this_end.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 917,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "last_insertion_point_->Start()",
          "old_line_content": "  // into one range without children, but with discontinuities. To merge the",
          "new_line_content": "  if (other->Start() < last_insertion_point_->Start()) {",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "reference_maps->begin()",
          "old_line_content": "    InstructionOperand spill_operand;",
          "new_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "other->Start()",
          "old_line_content": "    LiveRange* new_after =",
          "new_line_content": "         last_insertion_point_->next()->Start() <= other->Start();",
          "content_same": false
        },
        {
          "line": 2977,
          "old_api": null,
          "new_api": "GetSpillOperand",
          "old_text": null,
          "new_text": "range->GetSpillOperand()->IsConstant()",
          "old_line_content": "    }",
          "new_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "last_insertion_point_->next()",
          "old_line_content": "",
          "new_line_content": "  LiveRange* after = last_insertion_point_->next();",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": null,
          "new_api": "Start",
          "old_text": null,
          "new_text": "other->Start()",
          "old_line_content": "  last_other->next_ = after;",
          "new_line_content": "  if (last_insertion_point_->End() > other->Start()) {",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": null,
          "new_api": "HasSpillRange",
          "old_text": null,
          "new_text": "range->HasSpillRange()",
          "old_line_content": "",
          "new_line_content": "         range->HasSpillRange())) {",
          "content_same": false
        },
        {
          "line": 2979,
          "old_api": null,
          "new_api": "HasSpillOperand",
          "old_text": null,
          "new_text": "range->HasSpillOperand()",
          "old_line_content": "    // Step through the safe points to see whether they are in the range.",
          "new_line_content": "      if (range->HasSpillOperand()) {",
          "content_same": false
        },
        {
          "line": 935,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "new_after->spilled()",
          "old_line_content": "}",
          "new_line_content": "    if (!new_after->spilled())",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "set_assigned_register",
          "old_text": null,
          "new_text": "new_after->set_assigned_register(\n          last_insertion_point_->assigned_register())",
          "old_line_content": "",
          "new_line_content": "      new_after->set_assigned_register(",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": null,
          "new_api": "assigned_register",
          "old_text": null,
          "new_text": "last_insertion_point_->assigned_register()",
          "old_line_content": "",
          "new_line_content": "          last_insertion_point_->assigned_register());",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "spill_operand.IsStackSlot()",
          "old_line_content": "      // The safe points are sorted so we can stop searching here.",
          "new_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 2985,
          "old_api": null,
          "new_api": "machine_type",
          "old_text": null,
          "new_text": "DCHECK_EQ(kRepTagged,\n                AllocatedOperand::cast(spill_operand).machine_type())",
          "old_line_content": "      if (safe_point - 1 > end) break;",
          "new_line_content": "      DCHECK_EQ(kRepTagged,",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": null,
          "new_api": "machine_type",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(spill_operand).machine_type()",
          "old_line_content": "",
          "new_line_content": "                AllocatedOperand::cast(spill_operand).machine_type());",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": null,
          "new_api": "UpdateSpillRangePostMerge",
          "old_text": null,
          "new_text": "TopLevel()->UpdateSpillRangePostMerge(other)",
          "old_line_content": "}",
          "new_line_content": "  TopLevel()->UpdateSpillRangePostMerge(other);",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "first_interval_->start()",
          "old_line_content": "  auto new_end = end;",
          "new_line_content": "  DCHECK(first_interval_->start() <= start);",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": null,
          "new_api": "Covers",
          "old_text": null,
          "new_text": "cur->Covers(safe_point_pos)",
          "old_line_content": "",
          "new_line_content": "      while (cur != nullptr && !cur->Covers(safe_point_pos)) {",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start.value()",
          "old_line_content": "  auto new_interval = new (zone) UseInterval(start, new_end);",
          "new_line_content": "  TRACE(\"Ensure live range %d in interval [%d %d[\\n\", vreg(), start.value(),",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "first_interval_->end()",
          "old_line_content": "    last_interval_ = new_interval;",
          "new_line_content": "    if (first_interval_->end() > end) {",
          "content_same": false
        },
        {
          "line": 964,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "first_interval_->end()",
          "old_line_content": "  }",
          "new_line_content": "      new_end = first_interval_->end();",
          "content_same": false
        },
        {
          "line": 3011,
          "old_api": null,
          "new_api": "spill_start_index",
          "old_text": null,
          "new_text": "range->spill_start_index()",
          "old_line_content": "            \"Pointer in register for range %d:%d (start at %d) \"",
          "new_line_content": "                            : range->spill_start_index();",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "first_interval_->next()",
          "old_line_content": "",
          "new_line_content": "    first_interval_ = first_interval_->next();",
          "content_same": false
        },
        {
          "line": 3014,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "old_line_content": "            safe_point);",
          "new_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "content_same": false
        },
        {
          "line": 3019,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "cur->spilled()",
          "old_line_content": "      }",
          "new_line_content": "      if (!cur->spilled()) {",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "new_interval->next()",
          "old_line_content": "  if (first_interval_ == nullptr) {",
          "new_line_content": "  if (new_interval->next() == nullptr) {",
          "content_same": false
        },
        {
          "line": 3020,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "TRACE(\n            \"Pointer in register for range %d:%d (start at %d) \"\n            \"at safe point %d\\n\",\n            range->vreg(), cur->relative_id(), cur->Start().value(),\n            safe_point)",
          "old_line_content": "    }",
          "new_line_content": "        TRACE(",
          "content_same": false
        },
        {
          "line": 3023,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "cur->Start().value()",
          "old_line_content": "",
          "new_line_content": "            range->vreg(), cur->relative_id(), cur->Start().value(),",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "cur->GetAssignedOperand()",
          "old_line_content": "namespace {",
          "new_line_content": "        auto operand = cur->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3026,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "operand.IsStackSlot()",
          "old_line_content": "",
          "new_line_content": "        DCHECK(!operand.IsStackSlot());",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": null,
          "new_api": "machine_type",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand).machine_type()",
          "old_line_content": "class LiveRangeBound {",
          "new_line_content": "        DCHECK_EQ(kRepTagged, AllocatedOperand::cast(operand).machine_type());",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "start.value()",
          "old_line_content": "      auto interval = new (zone) UseInterval(start, end);",
          "new_line_content": "  TRACE(\"Add to live range %d interval [%d %d[\\n\", vreg(), start.value(),",
          "content_same": false
        },
        {
          "line": 3028,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand)",
          "old_line_content": " public:",
          "new_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "interval->set_next(first_interval_)",
          "old_line_content": "  }",
          "new_line_content": "      interval->set_next(first_interval_);",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  const LifetimePosition start_;",
          "new_line_content": "  explicit LiveRangeBound(const LiveRange* range)",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "range->End()",
          "old_line_content": "  const LifetimePosition end_;",
          "new_line_content": "      : range_(range), start_(range->Start()), end_(range->End()) {",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(!range->IsEmpty());",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "first_interval_->start()",
          "old_line_content": "  UsePosition* prev_hint = nullptr;",
          "new_line_content": "      first_interval_->set_start(Min(start, first_interval_->start()));",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "first_interval_->end()",
          "old_line_content": "  UsePosition* prev = nullptr;",
          "new_line_content": "      first_interval_->set_end(Max(end, first_interval_->end()));",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "use_pos->pos()",
          "old_line_content": "",
          "new_line_content": "  auto pos = use_pos->pos();",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "pos.value()",
          "old_line_content": "  if (prev == nullptr) {",
          "new_line_content": "  TRACE(\"Add to live range %d use position %d\\n\", vreg(), pos.value());",
          "content_same": false
        },
        {
          "line": 1014,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "current->next()",
          "old_line_content": "",
          "new_line_content": "    current = current->next();",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "use_pos->set_next(first_pos_)",
          "old_line_content": "}",
          "new_line_content": "    use_pos->set_next(first_pos_);",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "prev->next()",
          "old_line_content": "static bool AreUseIntervalsIntersecting(UseInterval* interval1,",
          "new_line_content": "    use_pos->set_next(prev->next());",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "prev->set_next(use_pos)",
          "old_line_content": "                                        UseInterval* interval2) {",
          "new_line_content": "    prev->set_next(use_pos);",
          "content_same": false
        },
        {
          "line": 3071,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "i->next()",
          "old_line_content": "    size_t left_index = 0;",
          "new_line_content": "    for (auto i = range; i != nullptr; i = i->next()) length++;",
          "content_same": false
        },
        {
          "line": 3072,
          "old_api": null,
          "new_api": "zone->NewArray<LiveRangeBound>(length)",
          "old_text": null,
          "new_text": "zone->NewArray<LiveRangeBound>(length)",
          "old_line_content": "    size_t right_index = length_;",
          "new_line_content": "    start_ = zone->NewArray<LiveRangeBound>(length);",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "interval2->start()",
          "old_line_content": "    }",
          "new_line_content": "    if (interval1->start() < interval2->start()) {",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "interval2->start()",
          "old_line_content": "  }",
          "new_line_content": "      if (interval1->end() > interval2->start()) {",
          "content_same": false
        },
        {
          "line": 3085,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(right_index > current_index)",
          "old_line_content": "  }",
          "new_line_content": "      DCHECK(right_index > current_index);",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "interval1->next()",
          "old_line_content": "",
          "new_line_content": "      interval1 = interval1->next();",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "interval1->start()",
          "old_line_content": "std::ostream& operator<<(std::ostream& os,",
          "new_line_content": "      if (interval2->end() > interval1->start()) {",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n        pred->last_instruction_index())",
          "old_line_content": "",
          "new_line_content": "    auto pred_end = LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "  void Find(const InstructionBlock* block, const InstructionBlock* pred,",
          "new_line_content": "        pred->last_instruction_index());",
          "content_same": false
        },
        {
          "line": 3100,
          "old_api": null,
          "new_api": "Find",
          "old_text": null,
          "new_text": "Find(pred_end)",
          "old_line_content": "            FindResult* result) const {",
          "new_line_content": "    return Find(pred_end);",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": null,
          "new_api": "relative_id",
          "old_text": null,
          "new_text": "range->relative_id()",
          "old_line_content": "  while (use_pos != nullptr) {",
          "new_line_content": "  os << \"Range: \" << range->TopLevel()->vreg() << \":\" << range->relative_id()",
          "content_same": false
        },
        {
          "line": 3104,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n        succ->first_instruction_index())",
          "old_line_content": "    result->pred_cover_ = bound->range_;",
          "new_line_content": "    auto succ_start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": null,
          "new_api": "first_interval",
          "old_text": null,
          "new_text": "range->first_interval()",
          "old_line_content": "",
          "new_line_content": "  auto interval = range->first_interval();",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "first_pos",
          "old_text": null,
          "new_text": "range->first_pos()",
          "old_line_content": "  while (interval != nullptr) {",
          "new_line_content": "  auto use_pos = range->first_pos();",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n        pred->last_instruction_index())",
          "old_line_content": "    }",
          "new_line_content": "    auto pred_end = LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": null,
          "new_api": "operand",
          "old_text": null,
          "new_text": "use_pos->operand()",
          "old_line_content": "  }",
          "new_line_content": "    pio.op_ = *use_pos->operand();",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "pos",
          "old_text": null,
          "new_text": "use_pos->pos()",
          "old_line_content": "  os << \"}\";",
          "new_line_content": "    os << pio << use_pos->pos() << \" \";",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "use_pos->next()",
          "old_line_content": "  return os;",
          "new_line_content": "    use_pos = use_pos->next();",
          "content_same": false
        },
        {
          "line": 3115,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n        block->first_instruction_index())",
          "old_line_content": "",
          "new_line_content": "    auto cur_start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 3116,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": " private:",
          "new_line_content": "        block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 3118,
          "old_api": null,
          "new_api": "CanCover",
          "old_text": null,
          "new_text": "bound->CanCover(cur_start)",
          "old_line_content": "  LiveRangeBound* start_;",
          "new_line_content": "    if (bound->CanCover(cur_start)) {",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "interval->end()",
          "old_line_content": "    : live_ranges_(zone),",
          "new_line_content": "    os << '[' << interval->start() << \", \" << interval->end() << ')'",
          "content_same": false
        },
        {
          "line": 3122,
          "old_api": null,
          "new_api": "Find",
          "old_text": null,
          "new_text": "Find(cur_start)",
          "old_line_content": "",
          "new_line_content": "    result->cur_cover_ = Find(cur_start)->range_;",
          "content_same": false
        },
        {
          "line": 3123,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(result->pred_cover_ != nullptr && result->cur_cover_ != nullptr)",
          "old_line_content": "",
          "new_line_content": "    DCHECK(result->pred_cover_ != nullptr && result->cur_cover_ != nullptr);",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "kind",
          "old_text": null,
          "new_text": "parent->kind()",
          "old_line_content": "    while (src != nullptr) {",
          "new_line_content": "      kind_(parent->kind()) {",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "IsSplinter",
          "old_text": null,
          "new_text": "parent->IsSplinter()",
          "old_line_content": "      } else {",
          "new_line_content": "  DCHECK(!parent->IsSplinter());",
          "content_same": false
        },
        {
          "line": 3136,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "  LiveRangeBoundArray* ArrayFor(int operand_index) {",
          "new_line_content": "  explicit LiveRangeFinder(const RegisterAllocationData* data, Zone* zone)",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "first_interval",
          "old_text": null,
          "new_text": "range->first_interval()",
          "old_line_content": "    }",
          "new_line_content": "    auto src = range->first_interval();",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "src->end()",
          "old_line_content": "  use_interval_ = result;",
          "new_line_content": "      auto new_node = new (zone) UseInterval(src->start(), src->end());",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "node->set_next(new_node)",
          "old_line_content": "}",
          "new_line_content": "        node->set_next(new_node);",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(operand_index < bounds_length_)",
          "old_line_content": " private:",
          "new_line_content": "    DCHECK(operand_index < bounds_length_);",
          "content_same": false
        },
        {
          "line": 3148,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "data_->live_ranges()",
          "old_line_content": "  const RegisterAllocationData* const data_;",
          "new_line_content": "    auto range = data_->live_ranges()[operand_index];",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "src->next()",
          "old_line_content": "int SpillRange::ByteWidth() const {",
          "new_line_content": "      src = src->next();",
          "content_same": false
        },
        {
          "line": 3149,
          "old_api": null,
          "new_api": "IsEmpty",
          "old_text": null,
          "new_text": "range->IsEmpty()",
          "old_line_content": "  const int bounds_length_;",
          "new_line_content": "    DCHECK(range != nullptr && !range->IsEmpty());",
          "content_same": false
        },
        {
          "line": 3151,
          "old_api": null,
          "new_api": "ShouldInitialize",
          "old_text": null,
          "new_text": "array->ShouldInitialize()",
          "old_line_content": "  Zone* const zone_;",
          "new_line_content": "    if (array->ShouldInitialize()) {",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": null,
          "new_api": "Initialize",
          "old_text": null,
          "new_text": "array->Initialize(zone_, range)",
          "old_line_content": "",
          "new_line_content": "      array->Initialize(zone_, range);",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "live_ranges().push_back(parent)",
          "old_line_content": "",
          "new_line_content": "  live_ranges().push_back(parent);",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "node->end()",
          "old_line_content": "bool SpillRange::IsIntersectingWith(SpillRange* other) const {",
          "new_line_content": "  end_position_ = node->end();",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "SetSpillRange",
          "old_text": null,
          "new_text": "parent->SetSpillRange(this)",
          "old_line_content": "  if (this->use_interval_ == nullptr || other->use_interval_ == nullptr ||",
          "new_line_content": "  parent->SetSpillRange(this);",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": null,
          "new_api": "AreUseIntervalsIntersecting",
          "old_text": null,
          "new_text": "AreUseIntervalsIntersecting(use_interval_, other->use_interval_)",
          "old_line_content": "",
          "new_line_content": "  return AreUseIntervalsIntersecting(use_interval_, other->use_interval_);",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "a.second.Compare(b.second)",
          "old_line_content": "}  // namespace",
          "new_line_content": "      return a.second.Compare(b.second);",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "kind",
          "old_text": null,
          "new_text": "other->live_ranges_[0]->kind()",
          "old_line_content": "",
          "new_line_content": "  if (live_ranges_[0]->kind() != other->live_ranges_[0]->kind() ||",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "other->End()",
          "old_line_content": "  }",
          "new_line_content": "    end_position_ = other->End();",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "other->live_ranges()",
          "old_line_content": "}",
          "new_line_content": "  for (auto range : other->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "GetSpillRange",
          "old_text": null,
          "new_text": "range->GetSpillRange()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(range->GetSpillRange() == other);",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "SetSpillRange",
          "old_text": null,
          "new_text": "range->SetSpillRange(this)",
          "old_line_content": "",
          "new_line_content": "    range->SetSpillRange(this);",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "other->live_ranges().begin()",
          "old_line_content": "  auto current = use_interval_;",
          "new_line_content": "  live_ranges().insert(live_ranges().end(), other->live_ranges().begin(),",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "other->live_ranges().end()",
          "old_line_content": "  while (other != nullptr) {",
          "new_line_content": "                       other->live_ranges().end());",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "other->live_ranges().clear()",
          "old_line_content": "    // Make sure the 'current' list starts first",
          "new_line_content": "  other->live_ranges().clear();",
          "content_same": false
        },
        {
          "line": 3202,
          "old_api": null,
          "new_api": "instruction_blocks",
          "old_text": null,
          "new_text": "code()->instruction_blocks()",
          "old_line_content": "        if (result.cur_cover_ == result.pred_cover_ ||",
          "new_line_content": "  for (auto block : code()->instruction_blocks()) {",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "other->start()",
          "old_line_content": "    }",
          "new_line_content": "    if (current == nullptr || current->start() > other->start()) {",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "std::swap(current, other)",
          "old_text": null,
          "new_text": "std::swap(current, other)",
          "old_line_content": "    tail = current;",
          "new_line_content": "      std::swap(current, other);",
          "content_same": false
        },
        {
          "line": 3210,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code()->InstructionBlockAt(pred)",
          "old_line_content": "      }",
          "new_line_content": "        const auto* pred_block = code()->InstructionBlockAt(pred);",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "start",
          "old_text": null,
          "new_text": "other->start()",
          "old_line_content": "  // Other list is empty => we are done",
          "new_line_content": "    DCHECK(other == nullptr || current->end() <= other->start());",
          "content_same": false
        },
        {
          "line": 3213,
          "old_api": null,
          "new_api": "TopLevel",
          "old_text": null,
          "new_text": "result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks()",
          "old_line_content": "  }",
          "new_line_content": "            (!result.cur_cover_->TopLevel()->IsSpilledOnlyInDeferredBlocks() &&",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "result.cur_cover_->spilled()",
          "old_line_content": "}",
          "new_line_content": "             result.cur_cover_->spilled()))",
          "content_same": false
        },
        {
          "line": 3216,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "result.pred_cover_->GetAssignedOperand()",
          "old_line_content": "",
          "new_line_content": "        auto pred_op = result.pred_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3217,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "result.cur_cover_->GetAssignedOperand()",
          "old_line_content": "void LiveRangeConnector::ResolveControlFlow(const InstructionBlock* block,",
          "new_line_content": "        auto cur_op = result.cur_cover_->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "set_next",
          "old_text": null,
          "new_text": "tail->set_next(current)",
          "old_line_content": "                                                 const InstructionBlock* block,",
          "new_line_content": "      tail->set_next(current);",
          "content_same": false
        },
        {
          "line": 3218,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "                                            const InstructionOperand& cur_op,",
          "new_line_content": "        if (pred_op.Equals(cur_op)) continue;",
          "content_same": false
        },
        {
          "line": 3219,
          "old_api": null,
          "new_api": "ResolveControlFlow",
          "old_text": null,
          "new_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "old_line_content": "                                            const InstructionBlock* pred,",
          "new_line_content": "        ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "current->next()",
          "old_line_content": "      block_(block),",
          "new_line_content": "    current = current->next();",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "pred_op.Equals(cur_op)",
          "old_line_content": "                ->HasReferenceMap());",
          "new_line_content": "  DCHECK(!pred_op.Equals(cur_op));",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "void RegisterAllocationData::PhiMapValue::CommitAssignment(",
          "new_line_content": "  incoming_operands_.reserve(phi->operands().size());",
          "content_same": false
        },
        {
          "line": 3234,
          "old_api": null,
          "new_api": "PredecessorCount",
          "old_text": null,
          "new_text": "block->PredecessorCount()",
          "old_line_content": "  }",
          "new_line_content": "  if (block->PredecessorCount() == 1) {",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "SuccessorCount",
          "old_text": null,
          "new_text": "pred->SuccessorCount()",
          "old_line_content": "",
          "new_line_content": "    DCHECK(pred->SuccessorCount() == 1);",
          "content_same": false
        },
        {
          "line": 3239,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "old_line_content": "void LiveRangeConnector::ConnectRanges(Zone* local_zone) {",
          "new_line_content": "    DCHECK(!code()",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "incoming_operands_.push_back(operand)",
          "old_line_content": "",
          "new_line_content": "  incoming_operands_.push_back(operand);",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "  DelayedInsertionMap delayed_insertion_map(local_zone);",
          "new_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "content_same": false
        },
        {
          "line": 3242,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "pred->last_instruction_index()",
          "old_line_content": "    if (top_range == nullptr) continue;",
          "new_line_content": "    gap_index = pred->last_instruction_index();",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "InstructionOperand::ReplaceWith(operand, &assigned)",
          "old_text": null,
          "new_text": "InstructionOperand::ReplaceWith(operand, &assigned)",
          "old_line_content": "      code_(code),",
          "new_line_content": "    InstructionOperand::ReplaceWith(operand, &assigned);",
          "content_same": false
        },
        {
          "line": 3255,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "first_range->next()",
          "old_line_content": "      }",
          "new_line_content": "    for (LiveRange *second_range = first_range->next(); second_range != nullptr;",
          "content_same": false
        },
        {
          "line": 3260,
          "old_api": null,
          "new_api": "spilled",
          "old_text": null,
          "new_text": "second_range->spilled()",
          "old_line_content": "      Instruction::GapPosition gap_pos;",
          "new_line_content": "      if (!connect_spilled && second_range->spilled()) continue;",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "      assigned_registers_(nullptr),",
          "new_line_content": "      live_in_sets_(code->InstructionBlockCount(), nullptr, allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "      assigned_double_registers_(nullptr),",
          "new_line_content": "      live_out_sets_(code->InstructionBlockCount(), nullptr, allocation_zone()),",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "this->config()->num_general_registers()",
          "old_line_content": "         RegisterConfiguration::kMaxGeneralRegisters);",
          "new_line_content": "      fixed_live_ranges_(this->config()->num_general_registers(), nullptr,",
          "content_same": false
        },
        {
          "line": 3266,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "first_range->GetAssignedOperand()",
          "old_line_content": "          delay_insertion = true;",
          "new_line_content": "      auto prev_operand = first_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "this->config()->num_double_registers()",
          "old_line_content": "         RegisterConfiguration::kMaxDoubleRegisters);",
          "new_line_content": "      fixed_double_live_ranges_(this->config()->num_double_registers(), nullptr,",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": null,
          "new_api": "GetAssignedOperand",
          "old_text": null,
          "new_text": "second_range->GetAssignedOperand()",
          "old_line_content": "        } else {",
          "new_line_content": "      auto cur_operand = second_range->GetAssignedOperand();",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": null,
          "new_api": "Equals",
          "old_text": null,
          "new_text": "prev_operand.Equals(cur_operand)",
          "old_line_content": "          gap_index++;",
          "new_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "      }",
          "new_line_content": "      int gap_index = pos.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "this->config()->num_general_registers()",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(this->config()->num_general_registers() <=",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "this->config()->num_double_registers()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(this->config()->num_double_registers() <=",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "    int index, Instruction::GapPosition position,",
          "new_line_content": "  assigned_registers_ = new (code_zone())",
          "content_same": false
        },
        {
          "line": 1231,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "    const InstructionOperand& from, const InstructionOperand& to) {",
          "new_line_content": "      BitVector(this->config()->num_general_registers(), code_zone());",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "this->frame()->SetAllocatedDoubleRegisters(assigned_double_registers_)",
          "old_line_content": "}",
          "new_line_content": "  this->frame()->SetAllocatedDoubleRegisters(assigned_double_registers_);",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "  // Insert all the moves which should occur after the stored move.",
          "new_line_content": "          gap_pos, code_zone());",
          "content_same": false
        },
        {
          "line": 3285,
          "old_api": null,
          "new_api": "AddMove",
          "old_text": null,
          "new_text": "move->AddMove(prev_operand, cur_operand)",
          "old_line_content": "  ZoneVector<MoveOperands*> to_eliminate(local_zone);",
          "new_line_content": "        move->AddMove(prev_operand, cur_operand);",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()->InstructionAt(index)",
          "old_line_content": "",
          "new_line_content": "  auto instr = code()->InstructionAt(index);",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "",
          "new_line_content": "  auto moves = instr->GetOrCreateParallelMove(position, code_zone());",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": null,
          "new_api": "AddMove",
          "old_text": null,
          "new_text": "moves->AddMove(from, to)",
          "old_line_content": "TopLevelLiveRange* RegisterAllocationData::GetOrCreateLiveRangeFor(int index) {",
          "new_line_content": "  return moves->AddMove(from, to);",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "delayed_insertion_map.empty()",
          "old_line_content": "      // Commit the MoveOperands for current ParallelMove.",
          "new_line_content": "  if (delayed_insertion_map.empty()) return;",
          "content_same": false
        },
        {
          "line": 3296,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "to_insert.reserve(4)",
          "old_line_content": "      for (auto move : to_insert) {",
          "new_line_content": "  to_insert.reserve(4);",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "VirtualRegisterCount",
          "old_text": null,
          "new_text": "code()->VirtualRegisterCount()",
          "old_line_content": "  if (result == nullptr) {",
          "new_line_content": "  DCHECK_LT(virtual_register, code()->VirtualRegisterCount());",
          "content_same": false
        },
        {
          "line": 3298,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "      }",
          "new_line_content": "  auto moves = delayed_insertion_map.begin()->first.first;",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "delayed_insertion_map.begin()",
          "old_line_content": "      if (done) break;",
          "new_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "delayed_insertion_map.end()",
          "old_line_content": "      // Reset state.",
          "new_line_content": "    bool done = it == delayed_insertion_map.end();",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "live_ranges().size()",
          "old_line_content": "",
          "new_line_content": "  if (index >= static_cast<int>(live_ranges().size())) {",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "live_ranges().resize(index + 1, nullptr)",
          "old_line_content": "",
          "new_line_content": "    live_ranges().resize(index + 1, nullptr);",
          "content_same": false
        },
        {
          "line": 3304,
          "old_api": null,
          "new_api": "Eliminate",
          "old_text": null,
          "new_text": "move->Eliminate()",
          "old_line_content": "    }",
          "new_line_content": "        move->Eliminate();",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "live_ranges()",
          "old_line_content": "    int index, MachineType machine_type) {",
          "new_line_content": "  auto result = live_ranges()[index];",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": null,
          "new_api": "MachineTypeFor",
          "old_text": null,
          "new_text": "MachineTypeFor(index)",
          "old_line_content": "}",
          "new_line_content": "    result = NewLiveRange(index, MachineTypeFor(index));",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "live_ranges()",
          "old_line_content": "",
          "new_line_content": "    live_ranges()[index] = result;",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_eliminate.clear()",
          "old_line_content": "}",
          "new_line_content": "      to_eliminate.clear();",
          "content_same": false
        },
        {
          "line": 3312,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "to_insert.clear()",
          "old_line_content": "",
          "new_line_content": "      to_insert.clear();",
          "content_same": false
        },
        {
          "line": 3316,
          "old_api": null,
          "new_api": "code_zone",
          "old_text": null,
          "new_text": "code_zone()",
          "old_line_content": "}  // namespace v8",
          "new_line_content": "    auto move = new (code_zone()) MoveOperands(it->first.second, it->second);",
          "content_same": false
        },
        {
          "line": 1269,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "}",
          "new_line_content": "  return new (allocation_zone()) TopLevelLiveRange(index, machine_type);",
          "content_same": false
        },
        {
          "line": 3317,
          "old_api": null,
          "new_api": "PrepareInsertAfter",
          "old_text": null,
          "new_text": "moves->PrepareInsertAfter(move)",
          "old_line_content": "",
          "new_line_content": "    auto eliminate = moves->PrepareInsertAfter(move);",
          "content_same": false
        },
        {
          "line": 3318,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "to_insert.push_back(move)",
          "old_line_content": "",
          "new_line_content": "    to_insert.push_back(move);",
          "content_same": false
        },
        {
          "line": 3319,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "to_eliminate.push_back(eliminate)",
          "old_line_content": "",
          "new_line_content": "    if (eliminate != nullptr) to_eliminate.push_back(eliminate);",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "live_ranges().resize(vreg + 1, nullptr)",
          "old_line_content": "  return ret;",
          "new_line_content": "    live_ranges().resize(vreg + 1, nullptr);",
          "content_same": false
        },
        {
          "line": 1284,
          "old_api": null,
          "new_api": "GetNextLiveRangeId",
          "old_text": null,
          "new_text": "GetNextLiveRangeId()",
          "old_line_content": "  auto res =",
          "new_line_content": "  int vreg = GetNextLiveRangeId();",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "RegisterAllocationData::PhiMapValue* RegisterAllocationData::GetPhiMapValueFor(",
          "new_line_content": "  auto map_value = new (allocation_zone())",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "    int virtual_register) {",
          "new_line_content": "      RegisterAllocationData::PhiMapValue(phi, block, allocation_zone());",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(res.second)",
          "old_line_content": "  return it->second;",
          "new_line_content": "  DCHECK(res.second);",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "USE",
          "old_text": null,
          "new_text": "USE(res)",
          "old_line_content": "}",
          "new_line_content": "  USE(res);",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": null,
          "new_api": "find",
          "old_text": null,
          "new_text": "phi_map_.find(virtual_register)",
          "old_line_content": "",
          "new_line_content": "  auto it = phi_map_.find(virtual_register);",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "phi_map_.end()",
          "old_line_content": "",
          "new_line_content": "  DCHECK(it != phi_map_.end());",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"Register allocator error: live v%d reached first block.\\n\",\n           operand_index)",
          "old_line_content": "  }",
          "new_line_content": "    PrintF(\"Register allocator error: live v%d reached first block.\\n\",",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "GetOrCreateLiveRangeFor(operand_index)",
          "old_line_content": "}",
          "new_line_content": "    LiveRange* range = GetOrCreateLiveRangeFor(operand_index);",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "range->first_pos()->pos().value()",
          "old_line_content": "",
          "new_line_content": "    PrintF(\"  (first use is at %d)\\n\", range->first_pos()->pos().value());",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": null,
          "new_api": "debug_name",
          "old_text": null,
          "new_text": "debug_name()",
          "old_line_content": "",
          "new_line_content": "    if (debug_name() == nullptr) {",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": null,
          "new_api": "PrintF",
          "old_text": null,
          "new_text": "PrintF(\"\\n\")",
          "old_line_content": "SpillRange* RegisterAllocationData::AssignSpillRangeToLiveRange(",
          "new_line_content": "      PrintF(\"\\n\");",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": null,
          "new_api": "IsSplinter",
          "old_text": null,
          "new_text": "range->IsSplinter()",
          "old_line_content": "  return spill_range;",
          "new_line_content": "    DCHECK(!range->IsSplinter());",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "}",
          "new_line_content": "    spill_range = new (allocation_zone()) SpillRange(range, allocation_zone());",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": null,
          "new_api": "set_spill_type",
          "old_text": null,
          "new_text": "range->set_spill_type(TopLevelLiveRange::SpillType::kSpillRange)",
          "old_line_content": "",
          "new_line_content": "  range->set_spill_type(TopLevelLiveRange::SpillType::kSpillRange);",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": null,
          "new_api": "spill_ranges",
          "old_text": null,
          "new_text": "spill_ranges()",
          "old_line_content": "  auto spill_range =",
          "new_line_content": "  spill_ranges()[spill_range_index] = spill_range;",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "IsSplinter",
          "old_text": null,
          "new_text": "range->IsSplinter()",
          "old_line_content": "  } else {",
          "new_line_content": "  DCHECK(!range->IsSplinter());",
          "content_same": false
        },
        {
          "line": 1371,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(kind == GENERAL_REGISTERS)",
          "old_line_content": "}",
          "new_line_content": "    DCHECK(kind == GENERAL_REGISTERS);",
          "content_same": false
        },
        {
          "line": 1372,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "assigned_registers_->Add(index)",
          "old_line_content": "",
          "new_line_content": "    assigned_registers_->Add(index);",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "  wrapper.sequence_ = instructionSequence;",
          "new_line_content": "         code()->GetInstructionBlock(pos.ToInstructionIndex())->code_start() ==",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "ToInstructionIndex",
          "old_text": null,
          "new_text": "pos.ToInstructionIndex()",
          "old_line_content": "  os << wrapper << std::endl;",
          "new_line_content": "             pos.ToInstructionIndex();",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "config()",
          "old_line_content": "    wrapper.range_ = i;",
          "new_line_content": "  wrapper.register_configuration_ = config();",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "config()",
          "old_line_content": "  OFStream os(stdout);",
          "new_line_content": "  wrapper.register_configuration_ = config();",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "i->next()",
          "old_line_content": "  PrintableInstructionOperand wrapper;",
          "new_line_content": "  for (const LiveRange* i = range; i != nullptr; i = i->next()) {",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": null,
          "new_api": "config",
          "old_text": null,
          "new_text": "config()",
          "old_line_content": "  os << \"{\" << std::endl;",
          "new_line_content": "  wrapper.register_configuration_ = config();",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "move->source()",
          "old_line_content": "  }",
          "new_line_content": "  wrapper.op_ = move->source();",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": null,
          "new_api": "live_ranges",
          "old_text": null,
          "new_text": "spill_range->live_ranges()",
          "old_line_content": "  os << \"}\" << std::endl;",
          "new_line_content": "  for (TopLevelLiveRange* range : spill_range->live_ranges()) {",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": null,
          "new_api": "vreg",
          "old_text": null,
          "new_text": "range->vreg()",
          "old_line_content": "}",
          "new_line_content": "    os << range->vreg() << \" \";",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "interval",
          "old_text": null,
          "new_text": "spill_range->interval()",
          "old_line_content": "    : data_(data) {}",
          "new_line_content": "  for (UseInterval* interval = spill_range->interval(); interval != nullptr;",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "interval->next()",
          "old_line_content": "",
          "new_line_content": "       interval = interval->next()) {",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "interval->end()",
          "old_line_content": "",
          "new_line_content": "    os << '[' << interval->start() << \", \" << interval->end() << ')'",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": null,
          "new_api": "HasFixedPolicy",
          "old_text": null,
          "new_text": "operand->HasFixedPolicy()",
          "old_line_content": "                                      : AllocatedOperand::STACK_SLOT;",
          "new_line_content": "  DCHECK(operand->HasFixedPolicy());",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": null,
          "new_api": "fixed_slot_index",
          "old_text": null,
          "new_text": "operand->fixed_slot_index()",
          "old_line_content": "  }",
          "new_line_content": "        AllocatedOperand(kind, machine_type, operand->fixed_slot_index());",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "fixed_register_index",
          "old_text": null,
          "new_text": "AllocatedOperand(AllocatedOperand::REGISTER, machine_type,\n                                 operand->fixed_register_index())",
          "old_line_content": "  if (is_tagged) {",
          "new_line_content": "    allocated = AllocatedOperand(AllocatedOperand::REGISTER, machine_type,",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": null,
          "new_api": "fixed_register_index",
          "old_text": null,
          "new_text": "operand->fixed_register_index()",
          "old_line_content": "    }",
          "new_line_content": "                                 machine_type, operand->fixed_register_index());",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": null,
          "new_api": "UNREACHABLE",
          "old_text": null,
          "new_text": "UNREACHABLE()",
          "old_line_content": "  return operand;",
          "new_line_content": "    UNREACHABLE();",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "InstructionOperand::ReplaceWith(operand, &allocated)",
          "old_text": null,
          "new_text": "InstructionOperand::ReplaceWith(operand, &allocated)",
          "old_line_content": "",
          "new_line_content": "  InstructionOperand::ReplaceWith(operand, &allocated);",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": null,
          "new_api": "TRACE",
          "old_text": null,
          "new_text": "TRACE(\"Fixed reg is tagged at %d\\n\", pos)",
          "old_line_content": "void ConstraintBuilder::MeetRegisterConstraints() {",
          "new_line_content": "    TRACE(\"Fixed reg is tagged at %d\\n\", pos);",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "AllocatedOperand::cast(operand)",
          "old_text": null,
          "new_text": "AllocatedOperand::cast(operand)",
          "old_line_content": "  }",
          "new_line_content": "      instr->reference_map()->RecordReference(*AllocatedOperand::cast(operand));",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "instruction_blocks",
          "old_text": null,
          "new_text": "code()->instruction_blocks()",
          "old_line_content": "  for (int i = start; i <= end; ++i) {",
          "new_line_content": "  for (auto block : code()->instruction_blocks()) {",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "",
          "new_line_content": "  int start = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "block->last_instruction_index()",
          "old_line_content": "",
          "new_line_content": "  int end = block->last_instruction_index();",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": null,
          "new_api": "DCHECK_NE",
          "old_text": null,
          "new_text": "DCHECK_NE(-1, start)",
          "old_line_content": "void ConstraintBuilder::MeetRegisterConstraintsForLastInstructionInBlock(",
          "new_line_content": "  DCHECK_NE(-1, start);",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": null,
          "new_api": "InstructionAt",
          "old_text": null,
          "new_text": "code()->InstructionAt(end)",
          "old_line_content": "      // This value is produced on the stack, we never need to spill it.",
          "new_line_content": "  auto last_instruction = code()->InstructionAt(end);",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(output_vreg)",
          "old_line_content": "        assigned = true;",
          "new_line_content": "    auto range = data()->GetOrCreateLiveRangeFor(output_vreg);",
          "content_same": false
        },
        {
          "line": 1525,
          "old_api": null,
          "new_api": "HasFixedPolicy",
          "old_text": null,
          "new_text": "output->HasFixedPolicy()",
          "old_line_content": "",
          "new_line_content": "    if (output->HasFixedPolicy()) {",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "data()->frame()->GetSpillSlotCount()",
          "old_line_content": "        // Create an unconstrained operand for the same virtual register",
          "new_line_content": "               data()->frame()->GetSpillSlotCount());",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": null,
          "new_api": "StackSlotOperand::cast(output)",
          "old_text": null,
          "new_text": "StackSlotOperand::cast(output)",
          "old_line_content": "        // and insert a gap move from the fixed output to the operand.",
          "new_line_content": "        range->SetSpillOperand(StackSlotOperand::cast(output));",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": null,
          "new_api": "SetSpillStartIndex",
          "old_text": null,
          "new_text": "range->SetSpillStartIndex(end)",
          "old_line_content": "        UnallocatedOperand output_copy(UnallocatedOperand::ANY, output_vreg);",
          "new_line_content": "        range->SetSpillStartIndex(end);",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": null,
          "new_api": "successors",
          "old_text": null,
          "new_text": "block->successors()",
          "old_line_content": "",
          "new_line_content": "      for (auto succ : block->successors()) {",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code()->InstructionBlockAt(succ)",
          "old_line_content": "    if (!assigned) {",
          "new_line_content": "        const InstructionBlock* successor = code()->InstructionBlockAt(succ);",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": null,
          "new_api": "successors",
          "old_text": null,
          "new_text": "block->successors()",
          "old_line_content": "",
          "new_line_content": "      for (auto succ : block->successors()) {",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code()->InstructionBlockAt(succ)",
          "old_line_content": "",
          "new_line_content": "        const InstructionBlock* successor = code()->InstructionBlockAt(succ);",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": null,
          "new_api": "PredecessorCount",
          "old_text": null,
          "new_text": "successor->PredecessorCount()",
          "old_line_content": "void ConstraintBuilder::MeetConstraintsAfter(int instr_index) {",
          "new_line_content": "        DCHECK(successor->PredecessorCount() == 1);",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "  // Handle fixed temporaries.",
          "new_line_content": "        range->SpillAtDefinition(allocation_zone(), gap_index, output);",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "AllocateFixed",
          "old_text": null,
          "new_text": "AllocateFixed(temp, instr_index, false)",
          "old_line_content": "      continue;",
          "new_line_content": "    if (temp->HasFixedPolicy()) AllocateFixed(temp, instr_index, false);",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": null,
          "new_api": "OutputCount",
          "old_text": null,
          "new_text": "first->OutputCount()",
          "old_line_content": "    auto range =",
          "new_line_content": "  for (size_t i = 0; i < first->OutputCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": null,
          "new_api": "IsConstant",
          "old_text": null,
          "new_text": "output->IsConstant()",
          "old_line_content": "    bool assigned = false;",
          "new_line_content": "    if (output->IsConstant()) {",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "SetSpillStartIndex",
          "old_text": null,
          "new_text": "range->SetSpillStartIndex(instr_index + 1)",
          "old_line_content": "      UnallocatedOperand output_copy(UnallocatedOperand::ANY, output_vreg);",
          "new_line_content": "      range->SetSpillStartIndex(instr_index + 1);",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": null,
          "new_api": "UnallocatedOperand::cast(output)",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(output)",
          "old_line_content": "      // This value is produced on the stack, we never need to spill it.",
          "new_line_content": "    auto first_output = UnallocatedOperand::cast(output);",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": null,
          "new_api": "IsReference",
          "old_text": null,
          "new_text": "code()->IsReference(output_vreg)",
          "old_line_content": "      }",
          "new_line_content": "      bool is_tagged = code()->IsReference(output_vreg);",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": null,
          "new_api": "IsStackSlot",
          "old_text": null,
          "new_text": "first_output->IsStackSlot()",
          "old_line_content": "    // Make sure we add a gap move for spilling (if we have not done",
          "new_line_content": "      if (first_output->IsStackSlot()) {",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "StackSlotOperand::cast(first_output)->index()",
          "old_line_content": "    // so already).",
          "new_line_content": "        DCHECK(StackSlotOperand::cast(first_output)->index() <",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": null,
          "new_api": "frame",
          "old_text": null,
          "new_text": "data()->frame()->GetTotalFrameSlotCount()",
          "old_line_content": "    if (!assigned) {",
          "new_line_content": "               data()->frame()->GetTotalFrameSlotCount());",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "SetSpillStartIndex",
          "old_text": null,
          "new_text": "range->SetSpillStartIndex(instr_index + 1)",
          "old_line_content": "                               first_output);",
          "new_line_content": "        range->SetSpillStartIndex(instr_index + 1);",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": null,
          "new_api": "AddGapMove",
          "old_text": null,
          "new_text": "data()->AddGapMove(instr_index + 1, Instruction::START, *first_output,\n                         output_copy)",
          "old_line_content": "  }",
          "new_line_content": "      data()->AddGapMove(instr_index + 1, Instruction::START, *first_output,",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "  // Handle fixed input operands of second instruction.",
          "new_line_content": "      range->SpillAtDefinition(allocation_zone(), instr_index + 1,",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": null,
          "new_api": "InputCount",
          "old_text": null,
          "new_text": "second->InputCount()",
          "old_line_content": "    }",
          "new_line_content": "  for (size_t i = 0; i < second->InputCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "second->InputAt(i)",
          "old_line_content": "  }",
          "new_line_content": "    auto input = second->InputAt(i);",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "IsImmediate",
          "old_text": null,
          "new_text": "input->IsImmediate()",
          "old_line_content": "  // Handle \"output same as input\" for second instruction.",
          "new_line_content": "    if (input->IsImmediate()) continue;  // Ignore immediates.",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "AddGapMove",
          "old_text": null,
          "new_text": "data()->AddGapMove(instr_index, Instruction::END, input_copy, *cur_input)",
          "old_line_content": "    UnallocatedOperand* cur_input =",
          "new_line_content": "      data()->AddGapMove(instr_index, Instruction::END, input_copy, *cur_input);",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "OutputCount",
          "old_text": null,
          "new_text": "second->OutputCount()",
          "old_line_content": "    UnallocatedOperand input_copy(UnallocatedOperand::ANY, input_vreg);",
          "new_line_content": "  for (size_t i = 0; i < second->OutputCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": null,
          "new_api": "UnallocatedOperand::cast(output)",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(output)",
          "old_line_content": "                                       input_copy, *cur_input);",
          "new_line_content": "    auto second_output = UnallocatedOperand::cast(output);",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "cur_input->virtual_register()",
          "old_line_content": "      }",
          "new_line_content": "    int input_vreg = cur_input->virtual_register();",
          "content_same": false
        },
        {
          "line": 1637,
          "old_api": null,
          "new_api": "AddGapMove",
          "old_text": null,
          "new_text": "data()->AddGapMove(instr_index, Instruction::END,\n                                       input_copy, *cur_input)",
          "old_line_content": "      // The input is assumed to immediately have a tagged representation,",
          "new_line_content": "    auto gap_move = data()->AddGapMove(instr_index, Instruction::END,",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "IsReference",
          "old_text": null,
          "new_text": "code()->IsReference(output_vreg)",
          "old_line_content": "      // instruction will include the output operand (whose value at the",
          "new_line_content": "    if (code()->IsReference(input_vreg) && !code()->IsReference(output_vreg)) {",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": null,
          "new_api": "HasReferenceMap",
          "old_text": null,
          "new_text": "second->HasReferenceMap()",
          "old_line_content": "      // beginning of the instruction is equal to the input operand). If",
          "new_line_content": "      if (second->HasReferenceMap()) {",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "gap_move->source()",
          "old_line_content": "      // to be adjusted manually.",
          "new_line_content": "            second->reference_map(), &gap_move->source()};",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "data()->delayed_references().push_back(delayed_reference)",
          "old_line_content": "    }",
          "new_line_content": "        data()->delayed_references().push_back(delayed_reference);",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": null,
          "new_api": "IsReference",
          "old_text": null,
          "new_text": "code()->IsReference(input_vreg)",
          "old_line_content": "}",
          "new_line_content": "    } else if (!code()->IsReference(input_vreg) &&",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": null,
          "new_api": "IsReference",
          "old_text": null,
          "new_text": "code()->IsReference(output_vreg)",
          "old_line_content": "",
          "new_line_content": "               code()->IsReference(output_vreg)) {",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "ResolvePhis",
          "old_text": null,
          "new_text": "ResolvePhis(block)",
          "old_line_content": "    // Map the destination operands, so the commitment phase can find them.",
          "new_line_content": "    ResolvePhis(block);",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "phis",
          "old_text": null,
          "new_text": "block->phis()",
          "old_line_content": "                                     Instruction::END, input, output);",
          "new_line_content": "  for (auto phi : block->phis()) {",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "phi->operands().size()",
          "old_line_content": "    }",
          "new_line_content": "    for (size_t i = 0; i < phi->operands().size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "cur_block->last_instruction_index()",
          "old_line_content": "  }",
          "new_line_content": "                  ->InstructionAt(cur_block->last_instruction_index())",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(phi_vreg)",
          "old_line_content": "",
          "new_line_content": "    auto live_range = data()->GetOrCreateLiveRangeFor(phi_vreg);",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "LiveRangeBuilder::LiveRangeBuilder(RegisterAllocationData* data,",
          "new_line_content": "    int gap_index = block->first_instruction_index();",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "                                   Zone* local_zone)",
          "new_line_content": "    live_range->SpillAtDefinition(allocation_zone(), gap_index, &output);",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": null,
          "new_api": "SetSpillStartIndex",
          "old_text": null,
          "new_text": "live_range->SetSpillStartIndex(gap_index)",
          "old_line_content": "    : data_(data), phi_hints_(local_zone) {}",
          "new_line_content": "    live_range->SetSpillStartIndex(gap_index);",
          "content_same": false
        },
        {
          "line": 1688,
          "old_api": null,
          "new_api": "set_is_phi",
          "old_text": null,
          "new_text": "live_range->set_is_phi(true)",
          "old_line_content": "",
          "new_line_content": "    live_range->set_is_phi(true);",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "IsLoopHeader",
          "old_text": null,
          "new_text": "block->IsLoopHeader()",
          "old_line_content": "BitVector* LiveRangeBuilder::ComputeLiveOut(const InstructionBlock* block,",
          "new_line_content": "    live_range->set_is_non_loop_phi(!block->IsLoopHeader());",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "ToSize",
          "old_text": null,
          "new_text": "block->rpo_number().ToSize()",
          "old_line_content": "    // Process all successor blocks.",
          "new_line_content": "  size_t block_index = block->rpo_number().ToSize();",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "data->code()",
          "old_line_content": "",
          "new_line_content": "    const InstructionSequence* code = data->code();",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": null,
          "new_api": "VirtualRegisterCount",
          "old_text": null,
          "new_text": "code->VirtualRegisterCount()",
          "old_line_content": "      // out from this block.",
          "new_line_content": "    live_out = new (zone) BitVector(code->VirtualRegisterCount(), zone);",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "ToSize",
          "old_text": null,
          "new_text": "succ.ToSize()",
          "old_line_content": "      }",
          "new_line_content": "      BitVector* live_in = data->live_in_sets()[succ.ToSize()];",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "Union",
          "old_text": null,
          "new_text": "live_out->Union(*live_in)",
          "old_line_content": "    }",
          "new_line_content": "      if (live_in != nullptr) live_out->Union(*live_in);",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": null,
          "new_api": "InstructionBlockAt",
          "old_text": null,
          "new_text": "code->InstructionBlockAt(succ)",
          "old_line_content": "}",
          "new_line_content": "      auto successor = code->InstructionBlockAt(succ);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "rpo_number",
          "old_text": null,
          "new_text": "block->rpo_number()",
          "old_line_content": "",
          "new_line_content": "      size_t index = successor->PredecessorIndexOf(block->rpo_number());",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "PredecessorCount",
          "old_text": null,
          "new_text": "successor->PredecessorCount()",
          "old_line_content": "",
          "new_line_content": "      DCHECK(index < successor->PredecessorCount());",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "phis",
          "old_text": null,
          "new_text": "successor->phis()",
          "old_line_content": "void LiveRangeBuilder::AddInitialIntervals(const InstructionBlock* block,",
          "new_line_content": "      for (PhiInstruction* phi : successor->phis()) {",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": null,
          "new_api": "operands",
          "old_text": null,
          "new_text": "phi->operands()",
          "old_line_content": "                                           BitVector* live_out) {",
          "new_line_content": "        live_out->Add(phi->operands()[index]);",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "old_line_content": "  }",
          "new_line_content": "  auto start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "block->first_instruction_index()",
          "old_line_content": "}",
          "new_line_content": "      block->first_instruction_index());",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "LifetimePosition::InstructionFromInstructionIndex(\n                 block->last_instruction_index()).NextStart()",
          "old_line_content": "",
          "new_line_content": "  auto end = LifetimePosition::InstructionFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": null,
          "new_api": "last_instruction_index",
          "old_text": null,
          "new_text": "block->last_instruction_index()",
          "old_line_content": "",
          "new_line_content": "                 block->last_instruction_index()).NextStart();",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "Current",
          "old_text": null,
          "new_text": "iterator.Current()",
          "old_line_content": "}",
          "new_line_content": "    int operand_index = iterator.Current();",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(operand_index)",
          "old_line_content": "",
          "new_line_content": "    auto range = data()->GetOrCreateLiveRangeFor(operand_index);",
          "content_same": false
        },
        {
          "line": 1745,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "",
          "new_line_content": "    range->AddUseInterval(start, end, allocation_zone());",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": null,
          "new_api": "Advance",
          "old_text": null,
          "new_text": "iterator.Advance()",
          "old_line_content": "TopLevelLiveRange* LiveRangeBuilder::FixedLiveRangeFor(int index) {",
          "new_line_content": "    iterator.Advance();",
          "content_same": false
        },
        {
          "line": 1757,
          "old_api": null,
          "new_api": "num_general_registers",
          "old_text": null,
          "new_text": "config()->num_general_registers()",
          "old_line_content": "  return result;",
          "new_line_content": "  DCHECK(index < config()->num_general_registers());",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "fixed_live_ranges",
          "old_text": null,
          "new_text": "data()->fixed_live_ranges()",
          "old_line_content": "}",
          "new_line_content": "  auto result = data()->fixed_live_ranges()[index];",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "FixedLiveRangeID",
          "old_text": null,
          "new_text": "FixedLiveRangeID(index)",
          "old_line_content": "",
          "new_line_content": "    result = data()->NewLiveRange(FixedLiveRangeID(index),",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": null,
          "new_api": "InstructionSequence::DefaultRepresentation()",
          "old_text": null,
          "new_text": "InstructionSequence::DefaultRepresentation()",
          "old_line_content": "TopLevelLiveRange* LiveRangeBuilder::FixedDoubleLiveRangeFor(int index) {",
          "new_line_content": "                                  InstructionSequence::DefaultRepresentation());",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": null,
          "new_api": "MarkAllocated",
          "old_text": null,
          "new_text": "data()->MarkAllocated(GENERAL_REGISTERS, index)",
          "old_line_content": "  if (result == nullptr) {",
          "new_line_content": "    data()->MarkAllocated(GENERAL_REGISTERS, index);",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": null,
          "new_api": "num_aliased_double_registers",
          "old_text": null,
          "new_text": "config()->num_aliased_double_registers()",
          "old_line_content": "}",
          "new_line_content": "  DCHECK(index < config()->num_aliased_double_registers());",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": null,
          "new_api": "fixed_double_live_ranges",
          "old_text": null,
          "new_text": "data()->fixed_double_live_ranges()",
          "old_line_content": "",
          "new_line_content": "  auto result = data()->fixed_double_live_ranges()[index];",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": null,
          "new_api": "FixedDoubleLiveRangeID",
          "old_text": null,
          "new_text": "FixedDoubleLiveRangeID(index)",
          "old_line_content": "TopLevelLiveRange* LiveRangeBuilder::LiveRangeFor(InstructionOperand* operand) {",
          "new_line_content": "    result = data()->NewLiveRange(FixedDoubleLiveRangeID(index), kRepFloat64);",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(\n        UnallocatedOperand::cast(operand)->virtual_register())",
          "old_line_content": "  } else {",
          "new_line_content": "    return data()->GetOrCreateLiveRangeFor(",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(operand)->virtual_register()",
          "old_line_content": "    return nullptr;",
          "new_line_content": "        UnallocatedOperand::cast(operand)->virtual_register());",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": null,
          "new_api": "IsConstant",
          "old_text": null,
          "new_text": "operand->IsConstant()",
          "old_line_content": "  }",
          "new_line_content": "  } else if (operand->IsConstant()) {",
          "content_same": false
        },
        {
          "line": 1790,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(\n        ConstantOperand::cast(operand)->virtual_register())",
          "old_line_content": "}",
          "new_line_content": "    return data()->GetOrCreateLiveRangeFor(",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "ConstantOperand::cast(operand)->virtual_register()",
          "old_line_content": "",
          "new_line_content": "        ConstantOperand::cast(operand)->virtual_register());",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "IsRegister",
          "old_text": null,
          "new_text": "operand->IsRegister()",
          "old_line_content": "",
          "new_line_content": "  } else if (operand->IsRegister()) {",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "RegisterOperand::cast(operand)->index()",
          "old_line_content": "UsePosition* LiveRangeBuilder::NewUsePosition(LifetimePosition pos,",
          "new_line_content": "    return FixedLiveRangeFor(RegisterOperand::cast(operand)->index());",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": null,
          "new_api": "IsDoubleRegister",
          "old_text": null,
          "new_text": "operand->IsDoubleRegister()",
          "old_line_content": "                                              InstructionOperand* operand,",
          "new_line_content": "  } else if (operand->IsDoubleRegister()) {",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "FixedDoubleLiveRangeFor(\n        DoubleRegisterOperand::cast(operand)->index())",
          "old_line_content": "                                              void* hint,",
          "new_line_content": "    return FixedDoubleLiveRangeFor(",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "index",
          "old_text": null,
          "new_text": "DoubleRegisterOperand::cast(operand)->index()",
          "old_line_content": "                                              UsePositionHintType hint_type) {",
          "new_line_content": "        DoubleRegisterOperand::cast(operand)->index());",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "}",
          "new_line_content": "    range->AddUseInterval(position, position.NextStart(), allocation_zone());",
          "content_same": false
        },
        {
          "line": 1820,
          "old_api": null,
          "new_api": "NextStart",
          "old_text": null,
          "new_text": "position.NextStart()",
          "old_line_content": "",
          "new_line_content": "    range->AddUsePosition(NewUsePosition(position.NextStart()));",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": null,
          "new_api": "ShortenTo",
          "old_text": null,
          "new_text": "range->ShortenTo(position)",
          "old_line_content": "UsePosition* LiveRangeBuilder::Use(LifetimePosition block_start,",
          "new_line_content": "    range->ShortenTo(position);",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "operand->IsUnallocated()",
          "old_line_content": "                                   InstructionOperand* operand, void* hint,",
          "new_line_content": "  if (!operand->IsUnallocated()) return nullptr;",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": null,
          "new_api": "UnallocatedOperand::cast(operand)",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(operand)",
          "old_line_content": "                                   UsePositionHintType hint_type) {",
          "new_line_content": "  auto unalloc_operand = UnallocatedOperand::cast(operand);",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": null,
          "new_api": "AddUsePosition",
          "old_text": null,
          "new_text": "range->AddUsePosition(use_pos)",
          "old_line_content": "  if (range == nullptr) return nullptr;",
          "new_line_content": "  range->AddUsePosition(use_pos);",
          "content_same": false
        },
        {
          "line": 1836,
          "old_api": null,
          "new_api": "LiveRangeFor",
          "old_text": null,
          "new_text": "LiveRangeFor(operand)",
          "old_line_content": "}",
          "new_line_content": "  auto range = LiveRangeFor(operand);",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "operand->IsUnallocated()",
          "old_line_content": "void LiveRangeBuilder::ProcessInstructions(const InstructionBlock* block,",
          "new_line_content": "  if (operand->IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": null,
          "new_api": "UnallocatedOperand::cast(operand)",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(operand)",
          "old_line_content": "                                           BitVector* live) {",
          "new_line_content": "    UnallocatedOperand* unalloc_operand = UnallocatedOperand::cast(operand);",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": null,
          "new_api": "AddUsePosition",
          "old_text": null,
          "new_text": "range->AddUsePosition(use_pos)",
          "old_line_content": "  auto block_start_position =",
          "new_line_content": "    range->AddUsePosition(use_pos);",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": null,
          "new_api": "allocation_zone",
          "old_text": null,
          "new_text": "allocation_zone()",
          "old_line_content": "",
          "new_line_content": "  range->AddUseInterval(block_start, position, allocation_zone());",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": null,
          "new_api": "OutputCount",
          "old_text": null,
          "new_text": "instr->OutputCount()",
          "old_line_content": "      }",
          "new_line_content": "    for (size_t i = 0; i < instr->OutputCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "output->IsUnallocated()",
          "old_line_content": "        // The register defined here is blocked from gap start - it is the",
          "new_line_content": "      if (output->IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": null,
          "new_api": "HasSlotPolicy",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(output)->HasSlotPolicy()",
          "old_line_content": "        // TODO(mtrofin): should we explore an explicit opcode for",
          "new_line_content": "        DCHECK(!UnallocatedOperand::cast(output)->HasSlotPolicy());",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(output)->virtual_register()",
          "old_line_content": "        // the first instruction in the handler?",
          "new_line_content": "        int out_vreg = UnallocatedOperand::cast(output)->virtual_register();",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "IsConstant",
          "old_text": null,
          "new_text": "output->IsConstant()",
          "old_line_content": "      } else {",
          "new_line_content": "      } else if (output->IsConstant()) {",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "Remove",
          "old_text": null,
          "new_text": "live->Remove(out_vreg)",
          "old_line_content": "      }",
          "new_line_content": "        live->Remove(out_vreg);",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "IsHandler",
          "old_text": null,
          "new_text": "block->IsHandler()",
          "old_line_content": "",
          "new_line_content": "      if (block->IsHandler() && index == block_start) {",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": null,
          "new_api": "Define",
          "old_text": null,
          "new_text": "Define(curr_position, output)",
          "old_line_content": "        }",
          "new_line_content": "        Define(curr_position, output);",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "FixedDoubleLiveRangeFor",
          "old_text": null,
          "new_text": "FixedDoubleLiveRangeFor(i)",
          "old_line_content": "      LifetimePosition use_pos;",
          "new_line_content": "          auto range = FixedDoubleLiveRangeFor(i);",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": null,
          "new_api": "InputCount",
          "old_text": null,
          "new_text": "instr->InputCount()",
          "old_line_content": "",
          "new_line_content": "    for (size_t i = 0; i < instr->InputCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "curr_position.End()",
          "old_line_content": "      }",
          "new_line_content": "        use_pos = curr_position.End();",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "input->IsUnallocated()",
          "old_line_content": "",
          "new_line_content": "      if (input->IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": null,
          "new_api": "Add",
          "old_text": null,
          "new_text": "live->Add(vreg)",
          "old_line_content": "      // Unsupported.",
          "new_line_content": "        live->Add(vreg);",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": null,
          "new_api": "TempCount",
          "old_text": null,
          "new_text": "instr->TempCount()",
          "old_line_content": "            continue;",
          "new_line_content": "    for (size_t i = 0; i < instr->TempCount(); i++) {",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": null,
          "new_api": "TempAt",
          "old_text": null,
          "new_text": "instr->TempAt(i)",
          "old_line_content": "          }",
          "new_line_content": "      auto temp = instr->TempAt(i);",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "temp->IsUnallocated()",
          "old_line_content": "      }",
          "new_line_content": "      DCHECK_IMPLIES(temp->IsUnallocated(),",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": null,
          "new_api": "IsRegister",
          "old_text": null,
          "new_text": "temp->IsRegister()",
          "old_line_content": "    }",
          "new_line_content": "        if (temp->IsRegister()) continue;",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "temp->IsUnallocated()",
          "old_line_content": "",
          "new_line_content": "        if (temp->IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1935,
          "old_api": null,
          "new_api": "UnallocatedOperand::cast(temp)",
          "old_text": null,
          "new_text": "UnallocatedOperand::cast(temp)",
          "old_line_content": "    // Process the moves of the instruction's gaps, making their sources live.",
          "new_line_content": "          UnallocatedOperand* temp_unalloc = UnallocatedOperand::cast(temp);",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": null,
          "new_api": "HasFixedPolicy",
          "old_text": null,
          "new_text": "temp_unalloc->HasFixedPolicy()",
          "old_line_content": "    const Instruction::GapPosition kPositions[] = {Instruction::END,",
          "new_line_content": "          if (temp_unalloc->HasFixedPolicy()) {",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "Define",
          "old_text": null,
          "new_text": "Define(curr_position, temp)",
          "old_line_content": "      if (move == nullptr) continue;",
          "new_line_content": "      Define(curr_position, temp);",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": null,
          "new_api": "PrevStart",
          "old_text": null,
          "new_text": "curr_position.PrevStart()",
          "old_line_content": "      for (auto cur : *move) {",
          "new_line_content": "    curr_position = curr_position.PrevStart();",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": null,
          "new_api": "GetParallelMove",
          "old_text": null,
          "new_text": "instr->GetParallelMove(position)",
          "old_line_content": "        void* hint = &to;",
          "new_line_content": "      auto move = instr->GetParallelMove(position);",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": null,
          "new_api": "End",
          "old_text": null,
          "new_text": "curr_position.End()",
          "old_line_content": "        int phi_vreg = -1;",
          "new_line_content": "        curr_position = curr_position.End();",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "cur->source()",
          "old_line_content": "            phi_vreg = to_vreg;",
          "new_line_content": "        auto& from = cur->source();",
          "content_same": false
        },
        {
          "line": 1962,
          "old_api": null,
          "new_api": "UsePosition::HintTypeForOperand(to)",
          "old_text": null,
          "new_text": "UsePosition::HintTypeForOperand(to)",
          "old_line_content": "              hint_type = hint == nullptr ? UsePositionHintType::kNone",
          "new_line_content": "        UsePositionHintType hint_type = UsePosition::HintTypeForOperand(to);",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "to.IsUnallocated()",
          "old_line_content": "              hint_type = UsePositionHintType::kPhi;",
          "new_line_content": "        if (to.IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": null,
          "new_api": "GetOrCreateLiveRangeFor",
          "old_text": null,
          "new_text": "data()->GetOrCreateLiveRangeFor(to_vreg)",
          "old_line_content": "            }",
          "new_line_content": "          auto to_range = data()->GetOrCreateLiveRangeFor(to_vreg);",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": null,
          "new_api": "is_phi",
          "old_text": null,
          "new_text": "to_range->is_phi()",
          "old_line_content": "          } else {",
          "new_line_content": "          if (to_range->is_phi()) {",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "GetPhiMapValueFor",
          "old_text": null,
          "new_text": "data()->GetPhiMapValueFor(to_vreg)",
          "old_line_content": "            }",
          "new_line_content": "              hint = data()->GetPhiMapValueFor(to_vreg);",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": null,
          "new_api": "Define",
          "old_text": null,
          "new_text": "Define(curr_position, &to, &from,\n                              UsePosition::HintTypeForOperand(from))",
          "old_line_content": "        }",
          "new_line_content": "              to_use = Define(curr_position, &to, &from,",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": null,
          "new_api": "UsePosition::HintTypeForOperand(from)",
          "old_text": null,
          "new_text": "UsePosition::HintTypeForOperand(from)",
          "old_line_content": "        auto from_use =",
          "new_line_content": "                              UsePosition::HintTypeForOperand(from));",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "IsUnallocated",
          "old_text": null,
          "new_text": "from.IsUnallocated()",
          "old_line_content": "        // Potentially resolve phi hint.",
          "new_line_content": "        if (from.IsUnallocated()) {",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "ResolveHint",
          "old_text": null,
          "new_text": "to_use->ResolveHint(from_use)",
          "old_line_content": "}",
          "new_line_content": "          to_use->ResolveHint(from_use);",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": null,
          "new_api": "ResolveHint",
          "old_text": null,
          "new_text": "from_use->ResolveHint(to_use)",
          "old_line_content": "",
          "new_line_content": "          from_use->ResolveHint(to_use);",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "IsResolved",
          "old_text": null,
          "new_text": "to_use->IsResolved()",
          "old_line_content": "void LiveRangeBuilder::ProcessPhis(const InstructionBlock* block,",
          "new_line_content": "        DCHECK_IMPLIES(to_use != nullptr, to_use->IsResolved());",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": null,
          "new_api": "IsResolved",
          "old_text": null,
          "new_text": "from_use->IsResolved()",
          "old_line_content": "                                   BitVector* live) {",
          "new_line_content": "        DCHECK_IMPLIES(from_use != nullptr, from_use->IsResolved());",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": null,
          "new_api": "ResolvePhiHint",
          "old_text": null,
          "new_text": "ResolvePhiHint(&from, from_use)",
          "old_line_content": "    // The live range interval already ends at the first instruction of the",
          "new_line_content": "        if (phi_vreg != -1) ResolvePhiHint(&from, from_use);",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": null,
          "new_api": "virtual_register",
          "old_text": null,
          "new_text": "phi->virtual_register()",
          "old_line_content": "        break;",
          "new_line_content": "    int phi_vreg = phi->virtual_register();",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": null,
          "new_api": "Remove",
          "old_text": null,
          "new_text": "live->Remove(phi_vreg)",
          "old_line_content": "      }",
          "new_line_content": "    live->Remove(phi_vreg);",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": null,
          "new_api": "source",
          "old_text": null,
          "new_text": "move->source()",
          "old_line_content": "  }",
          "new_line_content": "        hint = &move->source();",
          "content_same": false
        },
        {
          "line": 2030,
          "old_api": null,
          "new_api": "DCHECK",
          "old_text": null,
          "new_text": "DCHECK(hint != nullptr)",
          "old_line_content": "void LiveRangeBuilder::ProcessLoopHeader(const InstructionBlock* block,",
          "new_line_content": "    DCHECK(hint != nullptr);",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n        block->first_instruction_index())",
          "old_line_content": "                                         BitVector* live) {",
          "new_line_content": "    auto block_start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": null,
          "new_api": "output",
          "old_text": null,
          "new_text": "phi->output()",
          "old_line_content": "  // Add a live range stretching from the first loop instruction to the last",
          "new_line_content": "    auto use_pos = Define(block_start, &phi->output(), hint,",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "UsePosition::HintTypeForOperand(*hint)",
          "old_text": null,
          "new_text": "UsePosition::HintTypeForOperand(*hint)",
          "old_line_content": "  // for each value live on entry to the header.",
          "new_line_content": "                          UsePosition::HintTypeForOperand(*hint));",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": null,
          "new_api": "MapPhiHint",
          "old_text": null,
          "new_text": "MapPhiHint(hint, use_pos)",
          "old_line_content": "  BitVector::Iterator iterator(live);",
          "new_line_content": "    MapPhiHint(hint, use_pos);",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": null,
          "new_api": "first_instruction_index",
          "old_text": null,
          "new_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "old_line_content": "  // Insert all values into the live in sets of all blocks in the loop.",
          "new_line_content": "  auto start = LifetimePosition::GapFromInstructionIndex(",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2056,
          "old_api": "InstructionBlockCount",
          "new_api": null,
          "old_text": "code()->InstructionBlockCount()",
          "new_text": null,
          "old_line_content": "  for (int block_id = code()->InstructionBlockCount() - 1; block_id >= 0;",
          "new_line_content": "  // Insert all values into the live in sets of all blocks in the loop.",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "RpoNumber::FromInt(block_id)",
          "new_api": null,
          "old_text": "RpoNumber::FromInt(block_id)",
          "new_text": null,
          "old_line_content": "    auto block = code()->InstructionBlockAt(RpoNumber::FromInt(block_id));",
          "new_line_content": "       ++i) {",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": "AddInitialIntervals",
          "new_api": null,
          "old_text": "AddInitialIntervals(block, live)",
          "new_text": null,
          "old_line_content": "    AddInitialIntervals(block, live);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "ProcessInstructions",
          "new_api": null,
          "old_text": "ProcessInstructions(block, live)",
          "new_text": null,
          "old_line_content": "    ProcessInstructions(block, live);",
          "new_line_content": "  // Process the blocks in reverse order.",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": "ProcessPhis",
          "new_api": null,
          "old_text": "ProcessPhis(block, live)",
          "new_text": null,
          "old_line_content": "    ProcessPhis(block, live);",
          "new_line_content": "       --block_id) {",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": "ProcessLoopHeader",
          "new_api": null,
          "old_text": "ProcessLoopHeader(block, live)",
          "new_text": null,
          "old_line_content": "    if (block->IsLoopHeader()) ProcessLoopHeader(block, live);",
          "new_line_content": "    // Initially consider all live_out values live for the entire block. We",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": "live_in_sets",
          "new_api": null,
          "old_text": "live_in_sets()",
          "new_text": null,
          "old_line_content": "    live_in_sets()[block_id] = live;",
          "new_line_content": "    // will shorten these intervals if necessary.",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto range : data()->live_ranges()) {",
          "new_line_content": "    // live values.",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "AssignSpillRangeToLiveRange",
          "new_api": null,
          "old_text": "data()->AssignSpillRangeToLiveRange(range)",
          "new_text": null,
          "old_line_content": "      data()->AssignSpillRangeToLiveRange(range);",
          "new_line_content": "    // Now live is live_in for this block except not including values live",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "next",
          "new_api": null,
          "old_text": "pos->next()",
          "new_text": null,
          "old_line_content": "      for (auto pos = range->first_pos(); pos != nullptr; pos = pos->next()) {",
          "new_line_content": "    if (range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": "type",
          "new_api": null,
          "old_text": "pos->type()",
          "new_text": null,
          "old_line_content": "        if (pos->type() == UsePositionType::kRequiresSlot) continue;",
          "new_line_content": "    // Give slots to all ranges with a non fixed slot use.",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "pos->pos().IsGapPosition()",
          "new_text": null,
          "old_line_content": "        if (!pos->pos().IsGapPosition()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "set_type",
          "new_api": null,
          "old_text": "pos->set_type(new_type, true)",
          "new_text": null,
          "old_line_content": "        pos->set_type(new_type, true);",
          "new_line_content": "    // Without this hack, all uses with \"any\" policy would get the constant",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": "Verify",
          "new_api": null,
          "old_text": "Verify()",
          "new_text": null,
          "old_line_content": "  Verify();",
          "new_line_content": "        UsePositionType new_type = UsePositionType::kAny;",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "IsResolved",
          "new_api": null,
          "old_text": "use_pos->IsResolved()",
          "new_text": null,
          "old_line_content": "  DCHECK(!use_pos->IsResolved());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2105,
          "old_api": "std::make_pair(operand, use_pos)",
          "new_api": null,
          "old_text": "std::make_pair(operand, use_pos)",
          "new_text": null,
          "old_line_content": "  auto res = phi_hints_.insert(std::make_pair(operand, use_pos));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(res.second)",
          "new_text": null,
          "old_line_content": "  DCHECK(res.second);",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": "find",
          "new_api": null,
          "old_text": "phi_hints_.find(operand)",
          "new_text": null,
          "old_line_content": "  auto it = phi_hints_.find(operand);",
          "new_line_content": "                                  UsePosition* use_pos) {",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "IsResolved",
          "new_api": null,
          "old_text": "hint.second->IsResolved()",
          "new_text": null,
          "old_line_content": "    CHECK(hint.second->IsResolved());",
          "new_line_content": "                                      UsePosition* use_pos) {",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->TopLevel()->IsFixed());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->vreg()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Splitting live range %d:%d at %d\\n\", range->TopLevel()->vreg(),",
          "new_line_content": "RegisterAllocator::RegisterAllocator(RegisterAllocationData* data,",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": "value",
          "new_api": null,
          "old_text": "pos.value()",
          "new_text": null,
          "old_line_content": "        range->relative_id(), pos.value());",
          "new_line_content": "                                     RegisterKind kind)",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "  if (pos <= range->Start()) return range;",
          "new_line_content": "      mode_(kind),",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "pos.IsGapPosition()",
          "new_text": null,
          "old_line_content": "  DCHECK(pos.IsStart() || pos.IsGapPosition() ||",
          "new_line_content": "LiveRange* RegisterAllocator::SplitRangeAt(LiveRange* range,",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "         (GetInstructionBlock(code(), pos)->last_instruction_index() !=",
          "new_line_content": "                                           LifetimePosition pos) {",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "value",
          "new_api": null,
          "old_text": "TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",\n        range->TopLevel()->vreg(), range->relative_id(), start.value(),\n        end.value())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Splitting live range %d:%d in position between [%d, %d]\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2162,
          "old_api": "value",
          "new_api": null,
          "old_text": "end.value()",
          "new_text": null,
          "old_line_content": "        end.value());",
          "new_line_content": "  return result;",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": "FindOptimalSplitPos",
          "new_api": null,
          "old_text": "FindOptimalSplitPos(start, end)",
          "new_text": null,
          "old_line_content": "  auto split_pos = FindOptimalSplitPos(start, end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(split_pos >= start)",
          "new_text": null,
          "old_line_content": "  DCHECK(split_pos >= start);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(range, split_pos)",
          "new_text": null,
          "old_line_content": "  return SplitRangeAt(range, split_pos);",
          "new_line_content": "LiveRange* RegisterAllocator::SplitBetween(LiveRange* range,",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "end.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "  int end_instr = end.ToInstructionIndex();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "  auto start_block = GetInstructionBlock(code(), start);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2180,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "  auto end_block = GetInstructionBlock(code(), end);",
          "new_line_content": "LifetimePosition RegisterAllocator::FindOptimalSplitPos(LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "  while (GetContainingLoop(code(), block) != nullptr &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2192,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "         GetContainingLoop(code(), block)->rpo_number().ToInt() >",
          "new_line_content": "  if (end_block == start_block) {",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": "ToInt",
          "new_api": null,
          "old_text": "start_block->rpo_number().ToInt()",
          "new_text": null,
          "old_line_content": "             start_block->rpo_number().ToInt()) {",
          "new_line_content": "    // The interval is split in the same basic block. Split at the latest",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "    block = GetContainingLoop(code(), block);",
          "new_line_content": "    // possible position.",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "IsLoopHeader",
          "new_api": null,
          "old_text": "end_block->IsLoopHeader()",
          "new_text": null,
          "old_line_content": "  if (block == end_block && !end_block->IsLoopHeader()) return end;",
          "new_line_content": "  // Find header of outermost loop.",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": "Start",
          "new_api": null,
          "old_text": "pos.Start()",
          "new_text": null,
          "old_line_content": "  auto block = GetInstructionBlock(code(), pos.Start());",
          "new_line_content": "  // position unless end_block is a loop header itself.",
          "content_same": false
        },
        {
          "line": 2210,
          "old_api": "code",
          "new_api": null,
          "old_text": "code()",
          "new_text": null,
          "old_line_content": "      block->IsLoopHeader() ? block : GetContainingLoop(code(), block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "PreviousUsePositionRegisterIsBeneficial",
          "new_api": null,
          "old_text": "range->PreviousUsePositionRegisterIsBeneficial(pos)",
          "new_text": null,
          "old_line_content": "  auto prev_use = range->PreviousUsePositionRegisterIsBeneficial(pos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "loop_header->first_instruction_index()",
          "new_text": null,
          "old_line_content": "        loop_header->first_instruction_index());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "Covers",
          "new_api": null,
          "old_text": "range->Covers(loop_start)",
          "new_text": null,
          "old_line_content": "    if (range->Covers(loop_start)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->spilled());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2240,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()",
          "new_text": null,
          "old_line_content": "  TopLevelLiveRange* first = range->TopLevel();",
          "new_line_content": "    // Try hoisting out to an outer loop.",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "HasNoSpillType",
          "new_api": null,
          "old_text": "first->HasNoSpillType()",
          "new_text": null,
          "old_line_content": "  if (first->HasNoSpillType()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": "AssignSpillRangeToLiveRange",
          "new_api": null,
          "old_text": "data()->AssignSpillRangeToLiveRange(first)",
          "new_text": null,
          "old_line_content": "    data()->AssignSpillRangeToLiveRange(first);",
          "new_line_content": "  return pos;",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "range->Spill()",
          "new_text": null,
          "old_line_content": "  range->Spill();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2252,
          "old_api": "fixed_double_live_ranges",
          "new_api": null,
          "old_text": "data()->fixed_double_live_ranges()",
          "new_text": null,
          "old_line_content": "  return mode() == DOUBLE_REGISTERS ? data()->fixed_double_live_ranges()",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "mode",
          "new_api": null,
          "old_text": "mode()",
          "new_text": null,
          "old_line_content": "  if (mode() == GENERAL_REGISTERS) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "config",
          "new_api": null,
          "old_text": "data()->config()->general_register_name(allocation_index)",
          "new_text": null,
          "old_line_content": "    return data()->config()->general_register_name(allocation_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "config",
          "new_api": null,
          "old_text": "data()->config()->double_register_name(allocation_index)",
          "new_text": null,
          "old_line_content": "    return data()->config()->double_register_name(allocation_index);",
          "new_line_content": "    const {",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "unhandled_live_ranges().reserve(\n      static_cast<size_t>(code()->VirtualRegisterCount() * 2))",
          "new_text": null,
          "old_line_content": "  unhandled_live_ranges().reserve(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "VirtualRegisterCount",
          "new_api": null,
          "old_text": "code()->VirtualRegisterCount()",
          "new_text": null,
          "old_line_content": "      static_cast<size_t>(code()->VirtualRegisterCount() * 2));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "active_live_ranges().reserve(8)",
          "new_text": null,
          "old_line_content": "  active_live_ranges().reserve(8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "inactive_live_ranges().reserve(8)",
          "new_text": null,
          "old_line_content": "  inactive_live_ranges().reserve(8);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": "data",
          "new_api": null,
          "old_text": "DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=\n         this->data()->config()->num_general_registers())",
          "new_text": null,
          "old_line_content": "  DCHECK(RegisterConfiguration::kMaxDoubleRegisters >=",
          "new_line_content": "    : RegisterAllocator(data, kind),",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "data",
          "new_api": null,
          "old_text": "this->data()->config()->num_general_registers()",
          "new_text": null,
          "old_line_content": "         this->data()->config()->num_general_registers());",
          "new_line_content": "      unhandled_live_ranges_(local_zone),",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "empty",
          "new_api": null,
          "old_text": "inactive_live_ranges().empty()",
          "new_text": null,
          "old_line_content": "  DCHECK(inactive_live_ranges().empty());",
          "new_line_content": "  // TryAllocateFreeReg and AllocateBlockedReg assume this",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": "mode",
          "new_api": null,
          "old_text": "mode()",
          "new_text": null,
          "old_line_content": "    if (range->kind() == mode()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "AddToUnhandledUnsorted",
          "new_api": null,
          "old_text": "AddToUnhandledUnsorted(range)",
          "new_text": null,
          "old_line_content": "      AddToUnhandledUnsorted(range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "GetFixedRegisters",
          "new_api": null,
          "old_text": "GetFixedRegisters()",
          "new_text": null,
          "old_line_content": "  auto& fixed_ranges = GetFixedRegisters();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": "UnhandledIsSorted",
          "new_api": null,
          "old_text": "UnhandledIsSorted()",
          "new_text": null,
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "unhandled_live_ranges().pop_back()",
          "new_text": null,
          "old_line_content": "    unhandled_live_ranges().pop_back();",
          "new_line_content": "  for (auto current : fixed_ranges) {",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": "UnhandledIsSorted",
          "new_api": null,
          "old_text": "UnhandledIsSorted()",
          "new_text": null,
          "old_line_content": "    DCHECK(UnhandledIsSorted());",
          "new_line_content": "    if (current != nullptr) {",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "current->TopLevel()->vreg()",
          "new_text": null,
          "old_line_content": "    TRACE(\"Processing interval %d:%d start=%d\\n\", current->TopLevel()->vreg(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "next_pos.IsGapPosition()",
          "new_text": null,
          "old_line_content": "      if (next_pos.IsGapPosition()) {",
          "new_line_content": "#ifdef DEBUG",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "next_pos.NextStart()",
          "new_text": null,
          "old_line_content": "        next_pos = next_pos.NextStart();",
          "new_line_content": "    allocation_finger_ = position;",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "current->Start().NextStart()",
          "new_text": null,
          "old_line_content": "      } else if (pos->pos() > current->Start().NextStart()) {",
          "new_line_content": "      auto next_pos = position;",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "pos",
          "new_api": null,
          "old_text": "pos->pos()",
          "new_text": null,
          "old_line_content": "        SpillBetween(current, current->Start(), pos->pos());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "current->TopLevel()",
          "new_text": null,
          "old_line_content": "    if (current->IsTopLevel() && TryReuseSpillForPhi(current->TopLevel()))",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": "size",
          "new_api": null,
          "old_text": "active_live_ranges().size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "new_line_content": "        // the register is too close to the start of live range.",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "ActiveToHandled",
          "new_api": null,
          "old_text": "ActiveToHandled(cur_active)",
          "new_text": null,
          "old_line_content": "        ActiveToHandled(cur_active);",
          "new_line_content": "        continue;",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": "Covers",
          "new_api": null,
          "old_text": "cur_active->Covers(position)",
          "new_text": null,
          "old_line_content": "      } else if (!cur_active->Covers(position)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "ActiveToInactive",
          "new_api": null,
          "old_text": "ActiveToInactive(cur_active)",
          "new_text": null,
          "old_line_content": "        ActiveToInactive(cur_active);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": "InactiveToHandled",
          "new_api": null,
          "old_text": "InactiveToHandled(cur_inactive)",
          "new_text": null,
          "old_line_content": "        InactiveToHandled(cur_inactive);",
          "new_line_content": "        --i;  // The live range was removed from the list of active live ranges.",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "InactiveToActive",
          "new_api": null,
          "old_text": "InactiveToActive(cur_inactive)",
          "new_text": null,
          "old_line_content": "        InactiveToActive(cur_inactive);",
          "new_line_content": "        --i;  // The live range was removed from the list of active live ranges.",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "AllocateBlockedReg",
          "new_api": null,
          "old_text": "AllocateBlockedReg(current)",
          "new_text": null,
          "old_line_content": "    if (!result) AllocateBlockedReg(current);",
          "new_line_content": "        --i;  // Live range was removed from the list of inactive live ranges.",
          "content_same": false
        },
        {
          "line": 2380,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->is_phi()",
          "new_text": null,
          "old_line_content": "  if (range->IsTopLevel() && range->TopLevel()->is_phi()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()",
          "new_text": null,
          "old_line_content": "    data()->GetPhiMapValueFor(range->TopLevel())->set_assigned_register(reg);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->vreg()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Add live range %d:%d to inactive\\n\", range->TopLevel()->vreg(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "        range->relative_id());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "inactive_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  inactive_live_ranges().push_back(range);",
          "new_line_content": "void LinearScanAllocator::AddToActive(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "  DCHECK(allocation_finger_ <= range->Start());",
          "new_line_content": "void LinearScanAllocator::AddToInactive(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2407,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": null,
          "old_text": "range->ShouldBeAllocatedBefore(cur_range)",
          "new_text": null,
          "old_line_content": "    if (!range->ShouldBeAllocatedBefore(cur_range)) continue;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Add live range %d:%d to unhandled at %d\\n\",\n          range->TopLevel()->vreg(), range->relative_id(), i + 1)",
          "new_text": null,
          "old_line_content": "    TRACE(\"Add live range %d:%d to unhandled at %d\\n\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "range->relative_id()",
          "new_text": null,
          "old_line_content": "          range->TopLevel()->vreg(), range->relative_id(), i + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": "begin",
          "new_api": null,
          "old_text": "unhandled_live_ranges().begin()",
          "new_text": null,
          "old_line_content": "    auto it = unhandled_live_ranges().begin() + (i + 1);",
          "new_line_content": "void LinearScanAllocator::AddToUnhandledSorted(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Add live range %d:%d to unhandled at start\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Add live range %d:%d to unhandled at start\\n\",",
          "new_line_content": "       --i) {",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "  if (range == nullptr || range->IsEmpty()) return;",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "range->spilled()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->HasRegisterAssigned() && !range->spilled());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "ShouldBeAllocatedBefore",
          "new_api": null,
          "old_text": "b->ShouldBeAllocatedBefore(a)",
          "new_text": null,
          "old_line_content": "  DCHECK(!a->ShouldBeAllocatedBefore(b) || !b->ShouldBeAllocatedBefore(a));",
          "new_line_content": "void LinearScanAllocator::AddToUnhandledUnsorted(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2450,
          "old_api": "size",
          "new_api": null,
          "old_text": "unhandled_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  size_t len = unhandled_live_ranges().size();",
          "new_line_content": "// at the end of the array list.  This is convenient for the register allocation",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": "at",
          "new_api": null,
          "old_text": "unhandled_live_ranges().at(i - 1)",
          "new_text": null,
          "old_line_content": "    auto a = unhandled_live_ranges().at(i - 1);",
          "new_line_content": "void LinearScanAllocator::SortUnhandled() {",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "new_line_content": "  for (size_t i = 1; i < len; i++) {",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "  RemoveElement(&active_live_ranges(), range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "inactive_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  inactive_live_ranges().push_back(range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Moving live range %d:%d from active to inactive\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Moving live range %d:%d from active to inactive\\n\",",
          "new_line_content": "void LinearScanAllocator::ActiveToHandled(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Moving live range %d:%d from inactive to handled\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Moving live range %d:%d from inactive to handled\\n\",",
          "new_line_content": "void LinearScanAllocator::ActiveToInactive(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "  RemoveElement(&inactive_live_ranges(), range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2484,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "active_live_ranges().push_back(range)",
          "new_text": null,
          "old_line_content": "  active_live_ranges().push_back(range);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2485,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Moving live range %d:%d from inactive to active\\n\",\n        range->TopLevel()->vreg(), range->relative_id())",
          "new_text": null,
          "old_line_content": "  TRACE(\"Moving live range %d:%d from inactive to active\\n\",",
          "new_line_content": "void LinearScanAllocator::InactiveToHandled(LiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2497,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto cur_active : active_live_ranges()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "cur_active->assigned_register()",
          "new_text": null,
          "old_line_content": "    free_until_pos[cur_active->assigned_register()] =",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": null,
          "old_line_content": "        LifetimePosition::GapFromInstructionIndex(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto cur_inactive : inactive_live_ranges()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "IsValid",
          "new_api": null,
          "old_text": "next_intersection.IsValid()",
          "new_text": null,
          "old_line_content": "    if (!next_intersection.IsValid()) continue;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "cur_inactive->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = cur_inactive->assigned_register();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "FirstHintPosition",
          "new_api": null,
          "old_text": "current->FirstHintPosition(&hint_register)",
          "new_text": null,
          "old_line_content": "  if (current->FirstHintPosition(&hint_register) != nullptr) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2519,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "    if (free_until_pos[hint_register] >= current->End()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",\n            RegisterName(hint_register), current->TopLevel()->vreg(),\n            current->relative_id())",
          "new_text": null,
          "old_line_content": "      TRACE(\"Assigning preferred reg %s to live range %d:%d\\n\",",
          "new_line_content": "  int hint_register;",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, hint_register)",
          "new_text": null,
          "old_line_content": "      SetLiveRangeAssignedRegister(current, hint_register);",
          "new_line_content": "        \"Found reg hint %s (free until [%d) for live range %d:%d (end %d[).\\n\",",
          "content_same": false
        },
        {
          "line": 2538,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  if (pos <= current->Start()) {",
          "new_line_content": "  // Find the register which stays free for the longest time.",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  if (pos < current->End()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(current, pos)",
          "new_text": null,
          "old_line_content": "    auto tail = SplitRangeAt(current, pos);",
          "new_line_content": "  auto pos = free_until_pos[reg];",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "AddToUnhandledSorted",
          "new_api": null,
          "old_text": "AddToUnhandledSorted(tail)",
          "new_text": null,
          "old_line_content": "    AddToUnhandledSorted(tail);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  DCHECK(pos >= current->End());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "current->relative_id()",
          "new_text": null,
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "    // Register reg is available at the range start but becomes blocked before",
          "content_same": false
        },
        {
          "line": 2555,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, reg)",
          "new_text": null,
          "old_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "new_line_content": "    // the range end. Split current at position where it becomes blocked.",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(current)",
          "new_text": null,
          "old_line_content": "    Spill(current);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2573,
          "old_api": "num_registers",
          "new_api": null,
          "old_text": "num_registers()",
          "new_text": null,
          "old_line_content": "  for (int i = 0; i < num_registers(); i++) {",
          "new_line_content": "  if (register_use == nullptr) {",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": "LifetimePosition::MaxPosition()",
          "new_api": null,
          "old_text": "LifetimePosition::MaxPosition()",
          "new_text": null,
          "old_line_content": "    use_pos[i] = block_pos[i] = LifetimePosition::MaxPosition();",
          "new_line_content": "    // There is no use in the current live range that requires a register.",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto range : active_live_ranges()) {",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 2578,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = range->assigned_register();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->IsFixed()",
          "new_text": null,
          "old_line_content": "    if (range->TopLevel()->IsFixed() ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "        !range->CanBeSpilled(current->Start())) {",
          "new_line_content": "  LifetimePosition use_pos[RegisterConfiguration::kMaxDoubleRegisters];",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(0)",
          "new_text": null,
          "old_line_content": "          LifetimePosition::GapFromInstructionIndex(0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "          range->NextUsePositionRegisterIsBeneficial(current->Start());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2594,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto range : inactive_live_ranges()) {",
          "new_line_content": "      auto next_use =",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": "FirstIntersection",
          "new_api": null,
          "old_text": "range->FirstIntersection(current)",
          "new_text": null,
          "old_line_content": "    auto next_intersection = range->FirstIntersection(current);",
          "new_line_content": "      if (next_use == nullptr) {",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "range->assigned_register()",
          "new_text": null,
          "old_line_content": "    int cur_reg = range->assigned_register();",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(block_pos[cur_reg], next_intersection)",
          "new_text": null,
          "old_line_content": "      block_pos[cur_reg] = Min(block_pos[cur_reg], next_intersection);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(block_pos[cur_reg], use_pos[cur_reg])",
          "new_text": null,
          "old_line_content": "      use_pos[cur_reg] = Min(block_pos[cur_reg], use_pos[cur_reg]);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(use_pos[cur_reg], next_intersection)",
          "new_text": null,
          "old_line_content": "      use_pos[cur_reg] = Min(use_pos[cur_reg], next_intersection);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": "pos",
          "new_api": null,
          "old_text": "register_use->pos()",
          "new_text": null,
          "old_line_content": "  if (pos < register_use->pos()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": "pos",
          "new_api": null,
          "old_text": "register_use->pos()",
          "new_text": null,
          "old_line_content": "    SpillBetween(current, current->Start(), register_use->pos());",
          "new_line_content": "    if (use_pos[i] > use_pos[reg]) {",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  if (block_pos[reg] < current->End()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": "Start",
          "new_api": null,
          "old_text": "block_pos[reg].Start()",
          "new_text": null,
          "old_line_content": "        SplitBetween(current, current->Start(), block_pos[reg].Start());",
          "new_line_content": "    // All registers are blocked before the first use that requires a register.",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": "AddToUnhandledSorted",
          "new_api": null,
          "old_text": "AddToUnhandledSorted(tail)",
          "new_text": null,
          "old_line_content": "    AddToUnhandledSorted(tail);",
          "new_line_content": "    // Spill starting part of live range up to that use.",
          "content_same": false
        },
        {
          "line": 2632,
          "old_api": "End",
          "new_api": null,
          "old_text": "current->End()",
          "new_text": null,
          "old_line_content": "  DCHECK(block_pos[reg] >= current->End());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": "relative_id",
          "new_api": null,
          "old_text": "current->relative_id()",
          "new_text": null,
          "old_line_content": "        current->TopLevel()->vreg(), current->relative_id());",
          "new_line_content": "    // Register becomes blocked before the current range end. Split before that",
          "content_same": false
        },
        {
          "line": 2635,
          "old_api": "SetLiveRangeAssignedRegister",
          "new_api": null,
          "old_text": "SetLiveRangeAssignedRegister(current, reg)",
          "new_text": null,
          "old_line_content": "  SetLiveRangeAssignedRegister(current, reg);",
          "new_line_content": "    // position.",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": "SplitAndSpillIntersecting",
          "new_api": null,
          "old_text": "SplitAndSpillIntersecting(current)",
          "new_text": null,
          "old_line_content": "  SplitAndSpillIntersecting(current);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "current->assigned_register()",
          "new_text": null,
          "old_line_content": "  int reg = current->assigned_register();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "  auto split_pos = current->Start();",
          "new_line_content": "  // This register was not free. Thus we need to find and spill",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "size",
          "new_api": null,
          "old_text": "active_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < active_live_ranges().size(); ++i) {",
          "new_line_content": "  // parts of active and inactive live regions that use the same register",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "active_live_ranges",
          "new_api": null,
          "old_text": "active_live_ranges()",
          "new_text": null,
          "old_line_content": "    auto range = active_live_ranges()[i];",
          "new_line_content": "  // at the same lifetime positions as current.",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "      auto next_pos = range->NextRegisterPosition(current->Start());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "FindOptimalSpillingPos",
          "new_api": null,
          "old_text": "FindOptimalSpillingPos(range, split_pos)",
          "new_text": null,
          "old_line_content": "      auto spill_pos = FindOptimalSpillingPos(range, split_pos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "SpillAfter",
          "new_api": null,
          "old_text": "SpillAfter(range, spill_pos)",
          "new_text": null,
          "old_line_content": "        SpillAfter(range, spill_pos);",
          "new_line_content": "void LinearScanAllocator::SplitAndSpillIntersecting(LiveRange* current) {",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": "ActiveToHandled",
          "new_api": null,
          "old_text": "ActiveToHandled(range)",
          "new_text": null,
          "old_line_content": "      ActiveToHandled(range);",
          "new_line_content": "        // When spilling between spill_pos and next_pos ensure that the range",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "size",
          "new_api": null,
          "old_text": "inactive_live_ranges().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < inactive_live_ranges().size(); ++i) {",
          "new_line_content": "        // live-ranges: ranges are allocated in order of their start positions,",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "inactive_live_ranges",
          "new_api": null,
          "old_text": "inactive_live_ranges()",
          "new_text": null,
          "old_line_content": "    auto range = inactive_live_ranges()[i];",
          "new_line_content": "        // ranges are retired from active/inactive when the start of the",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(range->End() > current->Start());",
          "new_line_content": "        // current live-range is larger than their end.",
          "content_same": false
        },
        {
          "line": 2675,
          "old_api": "FirstIntersection",
          "new_api": null,
          "old_text": "range->FirstIntersection(current)",
          "new_text": null,
          "old_line_content": "      LifetimePosition next_intersection = range->FirstIntersection(current);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": "Start",
          "new_api": null,
          "old_text": "current->Start()",
          "new_text": null,
          "old_line_content": "        UsePosition* next_pos = range->NextRegisterPosition(current->Start());",
          "new_line_content": "      --i;",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": "SpillAfter",
          "new_api": null,
          "old_text": "SpillAfter(range, split_pos)",
          "new_text": null,
          "old_line_content": "          SpillAfter(range, split_pos);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "is_phi",
          "new_api": null,
          "old_text": "range->is_phi()",
          "new_text": null,
          "old_line_content": "  if (!range->is_phi()) return false;",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->HasSpillOperand());",
          "new_line_content": "        --i;",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": "GetPhiMapValueFor",
          "new_api": null,
          "old_text": "data()->GetPhiMapValueFor(range)",
          "new_text": null,
          "old_line_content": "  auto phi_map_value = data()->GetPhiMapValueFor(range);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "phi",
          "new_api": null,
          "old_text": "phi_map_value->phi()",
          "new_text": null,
          "old_line_content": "  auto phi = phi_map_value->phi();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "block",
          "new_api": null,
          "old_text": "phi_map_value->block()",
          "new_text": null,
          "old_line_content": "  auto block = phi_map_value->block();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < phi->operands().size(); i++) {",
          "new_line_content": "bool LinearScanAllocator::TryReuseSpillForPhi(TopLevelLiveRange* range) {",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(op)",
          "new_text": null,
          "old_line_content": "    LiveRange* op_range = data()->GetOrCreateLiveRangeFor(op);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": "CanCover",
          "new_api": null,
          "old_text": "op_range->CanCover(pred_end)",
          "new_text": null,
          "old_line_content": "    while (op_range != nullptr && !op_range->CanCover(pred_end)) {",
          "new_line_content": "  // Count the number of spilled operands.",
          "content_same": false
        },
        {
          "line": 2710,
          "old_api": "next",
          "new_api": null,
          "old_text": "op_range->next()",
          "new_text": null,
          "old_line_content": "      op_range = op_range->next();",
          "new_line_content": "  size_t spilled_count = 0;",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  if (spilled_count * 2 <= phi->operands().size()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(first_op != nullptr)",
          "new_text": null,
          "old_line_content": "  DCHECK(first_op != nullptr);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "first_op->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "  auto first_op_spill = first_op->TopLevel()->GetSpillRange();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 1; i < phi->operands().size(); i++) {",
          "new_line_content": "  // Only continue if more than half of the operands are spilled.",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(op)",
          "new_text": null,
          "old_line_content": "    auto op_range = data()->GetOrCreateLiveRangeFor(op);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "op_range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    if (!op_range->HasSpillRange()) continue;",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "GetSpillRange",
          "new_api": null,
          "old_text": "op_range->GetSpillRange()",
          "new_text": null,
          "old_line_content": "    auto op_spill = op_range->GetSpillRange();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "first_op_spill->TryMerge(op_spill)",
          "new_text": null,
          "old_line_content": "    if (op_spill == first_op_spill || first_op_spill->TryMerge(op_spill)) {",
          "new_line_content": "  // Try to merge the spilled operands and count the number of merged spilled",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": "Start",
          "new_api": null,
          "old_text": "range->Start()",
          "new_text": null,
          "old_line_content": "  auto next_pos = range->Start();",
          "new_line_content": "  // Only continue if enough operands could be merged to the",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "next_pos.NextStart()",
          "new_text": null,
          "old_line_content": "  if (next_pos.IsGapPosition()) next_pos = next_pos.NextStart();",
          "new_line_content": "  // same spill slot.",
          "content_same": false
        },
        {
          "line": 2755,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->GetSpillRange()",
          "new_text": null,
          "old_line_content": "            ? range->TopLevel()->GetSpillRange()",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2757,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()",
          "new_text": null,
          "old_line_content": "            : data()->AssignSpillRangeToLiveRange(range->TopLevel());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "first_op_spill->TryMerge(spill_range)",
          "new_text": null,
          "old_line_content": "    bool merged = first_op_spill->TryMerge(spill_range);",
          "new_line_content": "  // If the range does not need register soon, spill it to the merged",
          "content_same": false
        },
        {
          "line": 2759,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(merged)",
          "new_text": null,
          "old_line_content": "    CHECK(merged);",
          "new_line_content": "  // spill range.",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "        range->TopLevel()->HasSpillRange()",
          "new_line_content": "    auto spill_range =",
          "content_same": false
        },
        {
          "line": 2785,
          "old_api": "SpillBetweenUntil",
          "new_api": null,
          "old_text": "SpillBetweenUntil(range, start, start, end)",
          "new_text": null,
          "old_line_content": "  SpillBetweenUntil(range, start, start, end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2793,
          "old_api": "CHECK",
          "new_api": null,
          "old_text": "CHECK(start < end)",
          "new_text": null,
          "old_line_content": "  CHECK(start < end);",
          "new_line_content": "void LinearScanAllocator::SpillBetween(LiveRange* range, LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": "SplitRangeAt",
          "new_api": null,
          "old_text": "SplitRangeAt(range, start)",
          "new_text": null,
          "old_line_content": "  auto second_part = SplitRangeAt(range, start);",
          "new_line_content": "                                       LifetimePosition end) {",
          "content_same": false
        },
        {
          "line": 2796,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_part->Start()",
          "new_text": null,
          "old_line_content": "  if (second_part->Start() < end) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2800,
          "old_api": "PrevStart",
          "new_api": null,
          "old_text": "end.PrevStart().End()",
          "new_text": null,
          "old_line_content": "    auto third_part_end = end.PrevStart().End();",
          "new_line_content": "                                            LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 2801,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "    if (data()->IsBlockBoundary(end.Start())) {",
          "new_line_content": "                                            LifetimePosition until,",
          "content_same": false
        },
        {
          "line": 2802,
          "old_api": "Start",
          "new_api": null,
          "old_text": "end.Start()",
          "new_text": null,
          "old_line_content": "      third_part_end = end.Start();",
          "new_line_content": "                                            LifetimePosition end) {",
          "content_same": false
        },
        {
          "line": 2805,
          "old_api": "End",
          "new_api": null,
          "old_text": "second_part->Start().End()",
          "new_text": null,
          "old_line_content": "        second_part, Max(second_part->Start().End(), until), third_part_end);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(third_part != second_part)",
          "new_text": null,
          "old_line_content": "    DCHECK(third_part != second_part);",
          "new_line_content": "    // The split result intersects with [start, end[.",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": "Spill",
          "new_api": null,
          "old_text": "Spill(second_part)",
          "new_text": null,
          "old_line_content": "    Spill(second_part);",
          "new_line_content": "    // and put the rest to unhandled.",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range == nullptr || range->IsEmpty()) continue;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2828,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    if (!range->HasSpillRange()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": "spills_at_definition",
          "new_api": null,
          "old_text": "range->spills_at_definition()",
          "new_text": null,
          "old_line_content": "    auto spills = range->spills_at_definition();",
          "new_line_content": "SpillSlotLocator::SpillSlotLocator(RegisterAllocationData* data)",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": "DCHECK_NOT_NULL",
          "new_api": null,
          "old_text": "DCHECK_NOT_NULL(spills)",
          "new_text": null,
          "old_line_content": "    DCHECK_NOT_NULL(spills);",
          "new_line_content": "    : data_(data) {}",
          "content_same": false
        },
        {
          "line": 2832,
          "old_api": "GetInstructionBlock",
          "new_api": null,
          "old_text": "code->GetInstructionBlock(spills->gap_index)->mark_needs_frame()",
          "new_text": null,
          "old_line_content": "      code->GetInstructionBlock(spills->gap_index)->mark_needs_frame();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < spill_ranges.size(); ++i) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2847,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": "size",
          "new_api": null,
          "old_text": "spill_ranges.size()",
          "new_text": null,
          "old_line_content": "    for (size_t j = i + 1; j < spill_ranges.size(); ++j) {",
          "new_line_content": "OperandAssigner::OperandAssigner(RegisterAllocationData* data) : data_(data) {}",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "other->IsEmpty()",
          "new_text": null,
          "old_line_content": "      if (other != nullptr && !other->IsEmpty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": "TryMerge",
          "new_api": null,
          "old_text": "range->TryMerge(other)",
          "new_text": null,
          "old_line_content": "        range->TryMerge(other);",
          "new_line_content": "void OperandAssigner::AssignSpillSlots() {",
          "content_same": false
        },
        {
          "line": 2859,
          "old_api": "ByteWidth",
          "new_api": null,
          "old_text": "range->ByteWidth()",
          "new_text": null,
          "old_line_content": "    int byte_width = range->ByteWidth();",
          "new_line_content": "      SpillRange* other = spill_ranges[j];",
          "content_same": false
        },
        {
          "line": 2868,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "top_range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (top_range == nullptr || top_range->IsEmpty()) continue;",
          "new_line_content": "    // Allocate a new operand referring to the spill slot.",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->HasSpillRange()",
          "new_text": null,
          "old_line_content": "    } else if (top_range->TopLevel()->HasSpillRange()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2873,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "top_range->TopLevel()->GetSpillRangeOperand()",
          "new_text": null,
          "old_line_content": "      spill_operand = top_range->TopLevel()->GetSpillRangeOperand();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": "is_phi",
          "new_api": null,
          "old_text": "top_range->is_phi()",
          "new_text": null,
          "old_line_content": "    if (top_range->is_phi()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "End",
          "new_api": null,
          "old_text": "End()",
          "new_text": null,
          "old_line_content": "    DCHECK(end < End());",
          "new_line_content": "    // TODO(mtrofin): here, the TopLevel part is in the deferred range, so we",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "DetachAt",
          "new_api": null,
          "old_text": "DetachAt(end, result, zone)",
          "new_text": null,
          "old_line_content": "    DetachAt(end, result, zone);",
          "new_line_content": "    // may want to continue processing the splinter. However, if the value is",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "GetPhiMapValueFor",
          "new_api": null,
          "old_text": "data()->GetPhiMapValueFor(top_range)->CommitAssignment(\n          top_range->GetAssignedOperand())",
          "new_text": null,
          "old_line_content": "      data()->GetPhiMapValueFor(top_range)->CommitAssignment(",
          "new_line_content": "void OperandAssigner::CommitAssignment() {",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "End",
          "new_api": null,
          "old_text": "End()",
          "new_text": null,
          "old_line_content": "  } else if (end >= End()) {",
          "new_line_content": "    // it should terminate on the RHS of a phi, defined on the hot path. We",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "Start",
          "new_api": null,
          "old_text": "Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(start > Start());",
          "new_line_content": "    // should check this, however, this may not be the place, because we don't",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "DetachAt",
          "new_api": null,
          "old_text": "DetachAt(start, result, zone)",
          "new_text": null,
          "old_line_content": "    DetachAt(start, result, zone);",
          "new_line_content": "    // have access to the instruction sequence.",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "Start",
          "new_api": null,
          "old_text": "Start()",
          "new_text": null,
          "old_line_content": "    DCHECK(start < End() && Start() < end);",
          "new_line_content": "    next_ = nullptr;",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "DetachAt",
          "new_api": null,
          "old_text": "DetachAt(start, result, zone)",
          "new_text": null,
          "old_line_content": "    DetachAt(start, result, zone);",
          "new_line_content": "    next_ = nullptr;",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": "DetachAt",
          "new_api": null,
          "old_text": "result->DetachAt(end, &end_part, zone)",
          "new_text": null,
          "old_line_content": "    result->DetachAt(end, &end_part, zone);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "      if (!top_range->TryCommitSpillInDeferredBlock(data()->code(),",
          "new_line_content": "      // the range and control flow connection mechanism instead of spilling at",
          "content_same": false
        },
        {
          "line": 2901,
          "old_api": "CommitSpillsAtDefinition",
          "new_api": null,
          "old_text": "top_range->CommitSpillsAtDefinition(\n            data()->code(), spill_operand,\n            top_range->has_slot_use() || top_range->spilled())",
          "new_text": null,
          "old_line_content": "        top_range->CommitSpillsAtDefinition(",
          "new_line_content": "      // spilled range picks up its value from the slot which was assigned at",
          "content_same": false
        },
        {
          "line": 854,
          "old_api": "next",
          "new_api": null,
          "old_text": "pos->next()",
          "new_text": null,
          "old_line_content": "      for (; pos->next() != nullptr; pos = pos->next()) {",
          "new_line_content": "    // We can optimize DetachAt by setting current_interval_ accordingly,",
          "content_same": false
        },
        {
          "line": 2902,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()",
          "new_text": null,
          "old_line_content": "            data()->code(), spill_operand,",
          "new_line_content": "      // definition. For ranges that are determined to spill only in deferred",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "set_next",
          "new_api": null,
          "old_text": "pos->set_next(end_part.first_pos_)",
          "new_text": null,
          "old_line_content": "      pos->set_next(end_part.first_pos_);",
          "new_line_content": "    current_interval_ = last_interval_;",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "top_range->spilled()",
          "new_text": null,
          "old_line_content": "            top_range->has_slot_use() || top_range->spilled());",
          "new_line_content": "      // blocks, we let ConnectLiveRanges and ResolveControlFlow insert such",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": "SetSplinteredFrom",
          "new_api": null,
          "old_text": "result->SetSplinteredFrom(this)",
          "new_text": null,
          "old_line_content": "  result->SetSplinteredFrom(this);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": "Start",
          "new_api": null,
          "old_text": "Start()",
          "new_text": null,
          "old_line_content": "  DCHECK(splinter_parent->Start() < Start());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2916,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  for (auto map : *data()->code()->reference_maps()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "    if (safe_point > map->instruction_position()) return false;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "HasSpillOperand()",
          "new_text": null,
          "old_line_content": "  if (!HasSpillOperand()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2918,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "    safe_point = map->instruction_position();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2925,
          "old_api": "SafePointsAreInOrder",
          "new_api": null,
          "old_text": "SafePointsAreInOrder()",
          "new_text": null,
          "old_line_content": "  DCHECK(SafePointsAreInOrder());",
          "new_line_content": "  int safe_point = 0;",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "merged->HasSpillRange()",
          "new_text": null,
          "old_line_content": "  if (HasNoSpillType() && merged->HasSpillRange()) {",
          "new_line_content": "  splintered_from_ = splinter_parent;",
          "content_same": false
        },
        {
          "line": 2929,
          "old_api": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(*delayed_reference.operand)",
          "new_text": null,
          "old_line_content": "        AllocatedOperand::cast(*delayed_reference.operand));",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "SpillTypeField::update(merged->bits_, SpillType::kNoSpillType)",
          "new_api": null,
          "old_text": "SpillTypeField::update(merged->bits_, SpillType::kNoSpillType)",
          "new_text": null,
          "old_line_content": "        SpillTypeField::update(merged->bits_, SpillType::kNoSpillType);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": "code",
          "new_api": null,
          "old_text": "data()->code()->reference_maps()",
          "new_text": null,
          "old_line_content": "  auto reference_maps = data()->code()->reference_maps();",
          "new_line_content": "void ReferenceMapPopulator::PopulateReferenceMaps() {",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* range : data()->live_ranges()) {",
          "new_line_content": "  // Map all delayed references.",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "splintered_from",
          "new_api": null,
          "old_text": "other->splintered_from()",
          "new_text": null,
          "old_line_content": "  DCHECK(other->splintered_from() == this);",
          "new_line_content": "    merged->spill_range_ = nullptr;",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    if (range->IsEmpty()) continue;",
          "new_line_content": "  // Iterate over all safe point positions and record a pointer",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": "last_child",
          "new_api": null,
          "old_text": "other->last_child()",
          "new_text": null,
          "old_line_content": "  LiveRange* last_other = other->last_child();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "last_child",
          "new_api": null,
          "old_text": "last_child()",
          "new_text": null,
          "old_line_content": "  LiveRange* last_me = last_child();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2947,
          "old_api": "End",
          "new_api": null,
          "old_text": "cur->End()",
          "new_text": null,
          "old_line_content": "      auto this_end = cur->End();",
          "new_line_content": "    if (range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "this_end.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "      if (this_end.ToInstructionIndex() > end)",
          "new_line_content": "    // Skip non-reference values.",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "AppendAsChild",
          "new_api": null,
          "old_text": "last_me->AppendAsChild(other)",
          "new_text": null,
          "old_line_content": "  if (last_me->End() <= other->Start()) return last_me->AppendAsChild(other);",
          "new_line_content": "                              RegisterAllocationData* data) {",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "cur->Start().ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "      DCHECK(cur->Start().ToInstructionIndex() >= start);",
          "new_line_content": "    // Skip empty live ranges.",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": "begin",
          "new_api": null,
          "old_text": "reference_maps->begin()",
          "new_text": null,
          "old_line_content": "    if (start < last_range_start) first_it = reference_maps->begin();",
          "new_line_content": "    int end = 0;",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "Start",
          "new_api": null,
          "old_text": "other->Start()",
          "new_text": null,
          "old_line_content": "         last_insertion_point_->next()->Start() <= other->Start();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2962,
          "old_api": "instruction_position",
          "new_api": null,
          "old_text": "map->instruction_position()",
          "new_text": null,
          "old_line_content": "      if (map->instruction_position() >= start) break;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2966,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "    if (((range->HasSpillOperand() &&",
          "new_line_content": "    last_range_start = start;",
          "content_same": false
        },
        {
          "line": 2967,
          "old_api": "GetSpillOperand",
          "new_api": null,
          "old_text": "range->GetSpillOperand()->IsConstant()",
          "new_text": null,
          "old_line_content": "          !range->GetSpillOperand()->IsConstant()) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "next",
          "new_api": null,
          "old_text": "last_insertion_point_->next()",
          "new_text": null,
          "old_line_content": "  LiveRange* after = last_insertion_point_->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2968,
          "old_api": "HasSpillRange",
          "new_api": null,
          "old_text": "range->HasSpillRange()",
          "new_text": null,
          "old_line_content": "         range->HasSpillRange())) {",
          "new_line_content": "    // Step across all the safe points that are before the start of this range,",
          "content_same": false
        },
        {
          "line": 2969,
          "old_api": "HasSpillOperand",
          "new_api": null,
          "old_text": "range->HasSpillOperand()",
          "new_text": null,
          "old_line_content": "      if (range->HasSpillOperand()) {",
          "new_line_content": "    // recording how far we step in order to save doing this for the next range.",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "last_insertion_point_->spilled()",
          "new_text": null,
          "old_line_content": "    new_after->set_spilled(last_insertion_point_->spilled());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "new_after->spilled()",
          "new_text": null,
          "old_line_content": "    if (!new_after->spilled())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "set_assigned_register",
          "new_api": null,
          "old_text": "new_after->set_assigned_register(\n          last_insertion_point_->assigned_register())",
          "new_text": null,
          "old_line_content": "      new_after->set_assigned_register(",
          "new_line_content": "  // When we splintered the original range, we reconstituted the original range",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "assigned_register",
          "new_api": null,
          "old_text": "last_insertion_point_->assigned_register()",
          "new_text": null,
          "old_line_content": "          last_insertion_point_->assigned_register());",
          "new_line_content": "  // into one range without children, but with discontinuities. To merge the",
          "content_same": false
        },
        {
          "line": 2974,
          "old_api": "IsStackSlot",
          "new_api": null,
          "old_text": "spill_operand.IsStackSlot()",
          "new_text": null,
          "old_line_content": "      DCHECK(spill_operand.IsStackSlot());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2975,
          "old_api": "machine_type",
          "new_api": null,
          "old_text": "DCHECK_EQ(kRepTagged,\n                AllocatedOperand::cast(spill_operand).machine_type())",
          "new_text": null,
          "old_line_content": "      DCHECK_EQ(kRepTagged,",
          "new_line_content": "    InstructionOperand spill_operand;",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "value",
          "new_api": null,
          "old_text": "start.value()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Shorten live range %d to [%d\\n\", vreg(), start.value());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(first_interval_ != nullptr)",
          "new_text": null,
          "old_line_content": "  DCHECK(first_interval_ != nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "start",
          "new_api": null,
          "old_text": "first_interval_->start()",
          "new_text": null,
          "old_line_content": "  DCHECK(first_interval_->start() <= start);",
          "new_line_content": "  last_other->next_ = after;",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "end",
          "new_api": null,
          "old_text": "first_interval_->end()",
          "new_text": null,
          "old_line_content": "  DCHECK(start < first_interval_->end());",
          "new_line_content": "  last_insertion_point_->next_ = other;",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": "next",
          "new_api": null,
          "old_text": "cur->next()",
          "new_text": null,
          "old_line_content": "        cur = cur->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "      int spill_index = range->IsSpilledOnlyInDeferredBlocks()",
          "new_line_content": "      auto safe_point_pos =",
          "content_same": false
        },
        {
          "line": 3001,
          "old_api": "spill_start_index",
          "new_api": null,
          "old_text": "range->spill_start_index()",
          "new_text": null,
          "old_line_content": "                            : range->spill_start_index();",
          "new_line_content": "      LiveRange* cur = range;",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "end",
          "new_api": null,
          "old_text": "first_interval_->end()",
          "new_text": null,
          "old_line_content": "      new_end = first_interval_->end();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 956,
          "old_api": "next",
          "new_api": null,
          "old_text": "first_interval_->next()",
          "new_text": null,
          "old_line_content": "    first_interval_ = first_interval_->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3004,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",\n              range->vreg(), spill_index, safe_point)",
          "new_text": null,
          "old_line_content": "        TRACE(\"Pointer for range %d (spilled at %d) at safe point %d\\n\",",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "              range->vreg(), spill_index, safe_point);",
          "new_line_content": "      if (cur == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3006,
          "old_api": "AllocatedOperand::cast(spill_operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(spill_operand)",
          "new_text": null,
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(spill_operand));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3017,
          "old_api": "machine_type",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(operand).machine_type()",
          "new_text": null,
          "old_line_content": "        DCHECK_EQ(kRepTagged, AllocatedOperand::cast(operand).machine_type());",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3018,
          "old_api": "AllocatedOperand::cast(operand)",
          "new_api": null,
          "old_text": "AllocatedOperand::cast(operand)",
          "new_text": null,
          "old_line_content": "        map->RecordReference(AllocatedOperand::cast(operand));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "value",
          "new_api": null,
          "old_text": "end.value()",
          "new_text": null,
          "old_line_content": "        end.value());",
          "new_line_content": "  first_interval_ = new_interval;",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": "start",
          "new_api": null,
          "old_text": "first_interval_->start()",
          "new_text": null,
          "old_line_content": "    if (end == first_interval_->start()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "set_start",
          "new_api": null,
          "old_text": "first_interval_->set_start(start)",
          "new_text": null,
          "old_line_content": "      first_interval_->set_start(start);",
          "new_line_content": "void TopLevelLiveRange::AddUseInterval(LifetimePosition start,",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "start",
          "new_api": null,
          "old_text": "first_interval_->start()",
          "new_text": null,
          "old_line_content": "    } else if (end < first_interval_->start()) {",
          "new_line_content": "                                       LifetimePosition end, Zone* zone) {",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit LiveRangeBound(const LiveRange* range)",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": "End",
          "new_api": null,
          "old_text": "range->End()",
          "new_text": null,
          "old_line_content": "      : range_(range), start_(range->Start()), end_(range->End()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": "IsEmpty",
          "new_api": null,
          "old_text": "range->IsEmpty()",
          "new_text": null,
          "old_line_content": "    DCHECK(!range->IsEmpty());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "pos",
          "new_api": null,
          "old_text": "use_pos->pos()",
          "new_text": null,
          "old_line_content": "  auto pos = use_pos->pos();",
          "new_line_content": "      // last added interval.",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "pos",
          "new_api": null,
          "old_text": "current->pos()",
          "new_text": null,
          "old_line_content": "  while (current != nullptr && current->pos() < pos) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "HasHint",
          "new_api": null,
          "old_text": "current->HasHint()",
          "new_text": null,
          "old_line_content": "    prev_hint = current->HasHint() ? current : prev_hint;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "next",
          "new_api": null,
          "old_text": "current->next()",
          "new_text": null,
          "old_line_content": "    current = current->next();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "set_next",
          "new_api": null,
          "old_text": "use_pos->set_next(first_pos_)",
          "new_text": null,
          "old_line_content": "    use_pos->set_next(first_pos_);",
          "new_line_content": "  UsePosition* prev_hint = nullptr;",
          "content_same": false
        },
        {
          "line": 3061,
          "old_api": "next",
          "new_api": null,
          "old_text": "i->next()",
          "new_text": null,
          "old_line_content": "    for (auto i = range; i != nullptr; i = i->next()) length++;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": "zone->NewArray<LiveRangeBound>(length)",
          "new_api": null,
          "old_text": "zone->NewArray<LiveRangeBound>(length)",
          "new_text": null,
          "old_line_content": "    start_ = zone->NewArray<LiveRangeBound>(length);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "HasHint",
          "new_api": null,
          "old_text": "use_pos->HasHint()",
          "new_text": null,
          "old_line_content": "  if (prev_hint == nullptr && use_pos->HasHint()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 3065,
          "old_api": "next",
          "new_api": null,
          "old_text": "i->next()",
          "new_text": null,
          "old_line_content": "    for (auto i = range; i != nullptr; i = i->next(), ++curr) {",
          "new_line_content": "  LiveRangeBoundArray() : length_(0), start_(nullptr) {}",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "start",
          "new_api": null,
          "old_text": "interval2->start()",
          "new_text": null,
          "old_line_content": "    if (interval1->start() < interval2->start()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "next",
          "new_api": null,
          "old_text": "interval1->next()",
          "new_text": null,
          "old_line_content": "      interval1 = interval1->next();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": "start",
          "new_api": null,
          "old_text": "interval1->start()",
          "new_text": null,
          "old_line_content": "      if (interval2->end() > interval1->start()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(left_index < current_index)",
          "new_text": null,
          "old_line_content": "        DCHECK(left_index < current_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": "next",
          "new_api": null,
          "old_text": "interval2->next()",
          "new_text": null,
          "old_line_content": "      interval2 = interval2->next();",
          "new_line_content": "  while (interval1 != nullptr && interval2 != nullptr) {",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n        pred->last_instruction_index())",
          "new_text": null,
          "old_line_content": "    auto pred_end = LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "        if (position < bound->end_) return bound;",
          "content_same": false
        },
        {
          "line": 3090,
          "old_api": "Find",
          "new_api": null,
          "old_text": "Find(pred_end)",
          "new_text": null,
          "old_line_content": "    return Find(pred_end);",
          "new_line_content": "        left_index = current_index;",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->is_phi()",
          "new_text": null,
          "old_line_content": "  if (range->TopLevel()->is_phi()) os << \"phi \";",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": "TopLevel",
          "new_api": null,
          "old_text": "range->TopLevel()->is_non_loop_phi()",
          "new_text": null,
          "old_line_content": "  if (range->TopLevel()->is_non_loop_phi()) os << \"nlphi \";",
          "new_line_content": "  return false;",
          "content_same": false
        },
        {
          "line": 3094,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n        succ->first_instruction_index())",
          "new_text": null,
          "old_line_content": "    auto succ_start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 3095,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "succ->first_instruction_index()",
          "new_text": null,
          "old_line_content": "        succ->first_instruction_index());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "first_interval",
          "new_api": null,
          "old_text": "range->first_interval()",
          "new_text": null,
          "old_line_content": "  auto interval = range->first_interval();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1050,
          "old_api": "first_pos",
          "new_api": null,
          "old_text": "range->first_pos()",
          "new_text": null,
          "old_line_content": "  auto use_pos = range->first_pos();",
          "new_line_content": "std::ostream& operator<<(std::ostream& os,",
          "content_same": false
        },
        {
          "line": 3096,
          "old_api": "Find",
          "new_api": null,
          "old_text": "Find(succ_start)",
          "new_text": null,
          "old_line_content": "    return Find(succ_start);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3101,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n        pred->last_instruction_index())",
          "new_text": null,
          "old_line_content": "    auto pred_end = LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "operand",
          "new_api": null,
          "old_text": "use_pos->operand()",
          "new_text": null,
          "old_line_content": "    pio.op_ = *use_pos->operand();",
          "new_line_content": "     << \" \";",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "        pred->last_instruction_index());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3103,
          "old_api": "Find",
          "new_api": null,
          "old_text": "Find(pred_end)",
          "new_text": null,
          "old_line_content": "    auto bound = Find(pred_end);",
          "new_line_content": "  LiveRangeBound* FindSucc(const InstructionBlock* succ) {",
          "content_same": false
        },
        {
          "line": 3108,
          "old_api": "CanCover",
          "new_api": null,
          "old_text": "bound->CanCover(cur_start)",
          "new_text": null,
          "old_line_content": "    if (bound->CanCover(cur_start)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "end",
          "new_api": null,
          "old_text": "interval->end()",
          "new_text": null,
          "old_line_content": "    os << '[' << interval->start() << \", \" << interval->end() << ')'",
          "new_line_content": "  PrintableInstructionOperand pio;",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "next",
          "new_api": null,
          "old_text": "interval->next()",
          "new_text": null,
          "old_line_content": "    interval = interval->next();",
          "new_line_content": "  while (use_pos != nullptr) {",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": "kind",
          "new_api": null,
          "old_text": "parent->kind()",
          "new_text": null,
          "old_line_content": "      kind_(parent->kind()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "IsSplinter",
          "new_api": null,
          "old_text": "parent->IsSplinter()",
          "new_text": null,
          "old_line_content": "  DCHECK(!parent->IsSplinter());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3126,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "  explicit LiveRangeFinder(const RegisterAllocationData* data, Zone* zone)",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 3128,
          "old_api": "size",
          "new_api": null,
          "old_text": "data_->live_ranges().size()",
          "new_text": null,
          "old_line_content": "        bounds_length_(static_cast<int>(data_->live_ranges().size())),",
          "new_line_content": "  LiveRangeBound* start_;",
          "content_same": false
        },
        {
          "line": 3129,
          "old_api": "zone->NewArray<LiveRangeBoundArray>(bounds_length_)",
          "new_api": null,
          "old_text": "zone->NewArray<LiveRangeBoundArray>(bounds_length_)",
          "new_text": null,
          "old_line_content": "        bounds_(zone->NewArray<LiveRangeBoundArray>(bounds_length_)),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "next",
          "new_api": null,
          "old_text": "range->next()",
          "new_text": null,
          "old_line_content": "  for (LiveRange* range = parent; range != nullptr; range = range->next()) {",
          "new_line_content": "      assigned_slot_(kUnassignedSlot),",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "end",
          "new_api": null,
          "old_text": "src->end()",
          "new_text": null,
          "old_line_content": "      auto new_node = new (zone) UseInterval(src->start(), src->end());",
          "new_line_content": "  // Spill ranges are created for top level, non-splintered ranges. This is so",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "set_next",
          "new_api": null,
          "old_text": "node->set_next(new_node)",
          "new_text": null,
          "old_line_content": "        node->set_next(new_node);",
          "new_line_content": "  UseInterval* result = nullptr;",
          "content_same": false
        },
        {
          "line": 3137,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(operand_index < bounds_length_)",
          "new_text": null,
          "old_line_content": "    DCHECK(operand_index < bounds_length_);",
          "new_line_content": "      : data_(data),",
          "content_same": false
        },
        {
          "line": 3141,
          "old_api": "ShouldInitialize",
          "new_api": null,
          "old_text": "array->ShouldInitialize()",
          "new_text": null,
          "old_line_content": "    if (array->ShouldInitialize()) {",
          "new_line_content": "    for (int i = 0; i < bounds_length_; ++i) {",
          "content_same": false
        },
        {
          "line": 3142,
          "old_api": "Initialize",
          "new_api": null,
          "old_text": "array->Initialize(zone_, range)",
          "new_text": null,
          "old_line_content": "      array->Initialize(zone_, range);",
          "new_line_content": "      new (&bounds_[i]) LiveRangeBoundArray();",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "live_ranges().push_back(parent)",
          "new_text": null,
          "old_line_content": "  live_ranges().push_back(parent);",
          "new_line_content": "      if (result == nullptr) {",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "end",
          "new_api": null,
          "old_text": "node->end()",
          "new_text": null,
          "old_line_content": "  end_position_ = node->end();",
          "new_line_content": "        result = new_node;",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": "SetSpillRange",
          "new_api": null,
          "old_text": "parent->SetSpillRange(this)",
          "new_text": null,
          "old_line_content": "  parent->SetSpillRange(this);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "machine_type",
          "new_api": null,
          "old_text": "live_ranges_[0]->machine_type()",
          "new_text": null,
          "old_line_content": "  return GetByteWidth(live_ranges_[0]->machine_type());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "start",
          "new_api": null,
          "old_text": "other->use_interval_->start()",
          "new_text": null,
          "old_line_content": "      this->End() <= other->use_interval_->start() ||",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": "start",
          "new_api": null,
          "old_text": "this->use_interval_->start()",
          "new_text": null,
          "old_line_content": "      other->End() <= this->use_interval_->start()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3164,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "a.second.Compare(b.second)",
          "new_text": null,
          "old_line_content": "      return a.second.Compare(b.second);",
          "new_line_content": "};",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "LifetimePosition::MaxPosition()",
          "new_api": null,
          "old_text": "LifetimePosition::MaxPosition()",
          "new_text": null,
          "old_line_content": "  auto max = LifetimePosition::MaxPosition();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "End",
          "new_api": null,
          "old_text": "other->End()",
          "new_text": null,
          "old_line_content": "  if (End() < other->End() && other->End() != max) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "End",
          "new_api": null,
          "old_text": "other->End()",
          "new_text": null,
          "old_line_content": "    end_position_ = other->End();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "other->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (auto range : other->live_ranges()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3183,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "block->PredecessorCount()",
          "new_text": null,
          "old_line_content": "  if (block->PredecessorCount() != 1) return false;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "rpo_number",
          "new_api": null,
          "old_text": "block->rpo_number()",
          "new_text": null,
          "old_line_content": "  return block->predecessors()[0].IsNext(block->rpo_number());",
          "new_line_content": "}  // namespace",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": "begin",
          "new_api": null,
          "old_text": "other->live_ranges().begin()",
          "new_text": null,
          "old_line_content": "  live_ranges().insert(live_ranges().end(), other->live_ranges().begin(),",
          "new_line_content": "  other->end_position_ = max;",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "end",
          "new_api": null,
          "old_text": "other->live_ranges().end()",
          "new_text": null,
          "old_line_content": "                       other->live_ranges().end());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "live_in_sets",
          "new_api": null,
          "old_text": "data()->live_in_sets()",
          "new_text": null,
          "old_line_content": "  auto& live_in_sets = data()->live_in_sets();",
          "new_line_content": "bool LiveRangeConnector::CanEagerlyResolveControlFlow(",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "instruction_blocks",
          "new_api": null,
          "old_text": "code()->instruction_blocks()",
          "new_text": null,
          "old_line_content": "  for (auto block : code()->instruction_blocks()) {",
          "new_line_content": "    const InstructionBlock* block) const {",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "    while (!iterator.Done()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3197,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "      auto* array = finder.ArrayFor(iterator.Current());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "      for (auto pred : block->predecessors()) {",
          "new_line_content": "void LiveRangeConnector::ResolveControlFlow(Zone* local_zone) {",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "start",
          "new_api": null,
          "old_text": "other->start()",
          "new_text": null,
          "old_line_content": "    if (current == nullptr || current->start() > other->start()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1152,
          "old_api": "std::swap(current, other)",
          "new_api": null,
          "old_text": "std::swap(current, other)",
          "new_text": null,
          "old_line_content": "      std::swap(current, other);",
          "new_line_content": "  return true;",
          "content_same": false
        },
        {
          "line": 3200,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code()->InstructionBlockAt(pred)",
          "new_text": null,
          "old_line_content": "        const auto* pred_block = code()->InstructionBlockAt(pred);",
          "new_line_content": "  LiveRangeFinder finder(data(), local_zone);",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "start",
          "new_api": null,
          "old_text": "other->start()",
          "new_text": null,
          "old_line_content": "    DCHECK(other == nullptr || current->end() <= other->start());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "set_next",
          "new_api": null,
          "old_text": "tail->set_next(current)",
          "new_text": null,
          "old_line_content": "      tail->set_next(current);",
          "new_line_content": "    // Make sure the 'current' list starts first",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": "ResolveControlFlow",
          "new_api": null,
          "old_text": "ResolveControlFlow(block, cur_op, pred_block, pred_op)",
          "new_text": null,
          "old_line_content": "        ResolveControlFlow(block, cur_op, pred_block, pred_op);",
          "new_line_content": "        FindResult result;",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "next",
          "new_api": null,
          "old_text": "current->next()",
          "new_text": null,
          "old_line_content": "    current = current->next();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "  incoming_operands_.reserve(phi->operands().size());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3224,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "block->PredecessorCount()",
          "new_text": null,
          "old_line_content": "  if (block->PredecessorCount() == 1) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "    gap_index = block->first_instruction_index();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": "SuccessorCount",
          "new_api": null,
          "old_text": "pred->SuccessorCount()",
          "new_text": null,
          "old_line_content": "    DCHECK(pred->SuccessorCount() == 1);",
          "new_line_content": "                                            const InstructionOperand& cur_op,",
          "content_same": false
        },
        {
          "line": 3229,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()\n                ->InstructionAt(pred->last_instruction_index())\n                ->HasReferenceMap()",
          "new_text": null,
          "old_line_content": "    DCHECK(!code()",
          "new_line_content": "                                            const InstructionBlock* pred,",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "incoming_operands_.push_back(operand)",
          "new_text": null,
          "old_line_content": "  incoming_operands_.push_back(operand);",
          "new_line_content": "    : phi_(phi),",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "                ->InstructionAt(pred->last_instruction_index())",
          "new_line_content": "                                            const InstructionOperand& pred_op) {",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "pred->last_instruction_index()",
          "new_text": null,
          "old_line_content": "    gap_index = pred->last_instruction_index();",
          "new_line_content": "  int gap_index;",
          "content_same": false
        },
        {
          "line": 1189,
          "old_api": "InstructionOperand::ReplaceWith(operand, &assigned)",
          "new_api": null,
          "old_text": "InstructionOperand::ReplaceWith(operand, &assigned)",
          "new_text": null,
          "old_line_content": "    InstructionOperand::ReplaceWith(operand, &assigned);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "data()->live_ranges()",
          "new_text": null,
          "old_line_content": "  for (TopLevelLiveRange* top_range : data()->live_ranges()) {",
          "new_line_content": "                ->HasReferenceMap());",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "IsSpilledOnlyInDeferredBlocks",
          "new_api": null,
          "old_text": "top_range->IsSpilledOnlyInDeferredBlocks()",
          "new_text": null,
          "old_line_content": "    bool connect_spilled = top_range->IsSpilledOnlyInDeferredBlocks();",
          "new_line_content": "    position = Instruction::END;",
          "content_same": false
        },
        {
          "line": 3246,
          "old_api": "next",
          "new_api": null,
          "old_text": "second_range->next()",
          "new_text": null,
          "old_line_content": "         first_range = second_range, second_range = second_range->next()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3247,
          "old_api": "Start",
          "new_api": null,
          "old_text": "second_range->Start()",
          "new_text": null,
          "old_line_content": "      auto pos = second_range->Start();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "      phi_map_(allocation_zone()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "      live_in_sets_(code->InstructionBlockCount(), nullptr, allocation_zone()),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "      live_out_sets_(code->InstructionBlockCount(), nullptr, allocation_zone()),",
          "new_line_content": "RegisterAllocationData::RegisterAllocationData(",
          "content_same": false
        },
        {
          "line": 1205,
          "old_api": "VirtualRegisterCount",
          "new_api": null,
          "old_text": "code->VirtualRegisterCount()",
          "new_text": null,
          "old_line_content": "      live_ranges_(code->VirtualRegisterCount() * 2, nullptr,",
          "new_line_content": "    const RegisterConfiguration* config, Zone* zone, Frame* frame,",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "                   allocation_zone()),",
          "new_line_content": "    InstructionSequence* code, const char* debug_name)",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "config",
          "new_api": null,
          "old_text": "this->config()->num_general_registers()",
          "new_text": null,
          "old_line_content": "      fixed_live_ranges_(this->config()->num_general_registers(), nullptr,",
          "new_line_content": "    : allocation_zone_(zone),",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "                         allocation_zone()),",
          "new_line_content": "      frame_(frame),",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "config",
          "new_api": null,
          "old_text": "this->config()->num_double_registers()",
          "new_text": null,
          "old_line_content": "      fixed_double_live_ranges_(this->config()->num_double_registers(), nullptr,",
          "new_line_content": "      code_(code),",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "                                allocation_zone()),",
          "new_line_content": "      debug_name_(debug_name),",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "      spill_ranges_(code->VirtualRegisterCount(), nullptr, allocation_zone()),",
          "new_line_content": "      config_(config),",
          "content_same": false
        },
        {
          "line": 3252,
          "old_api": "IsBlockBoundary",
          "new_api": null,
          "old_text": "data()->IsBlockBoundary(pos)",
          "new_text": null,
          "old_line_content": "      if (data()->IsBlockBoundary(pos) &&",
          "new_line_content": "    if (top_range == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "Equals",
          "new_api": null,
          "old_text": "prev_operand.Equals(cur_operand)",
          "new_text": null,
          "old_line_content": "      if (prev_operand.Equals(cur_operand)) continue;",
          "new_line_content": "      // Add gap move if the two live ranges touch and there is no block",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": "IsStart",
          "new_api": null,
          "old_text": "pos.IsStart()",
          "new_text": null,
          "old_line_content": "        if (pos.IsStart()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "      BitVector(this->config()->num_aliased_double_registers(), code_zone());",
          "new_line_content": "      assigned_registers_(nullptr),",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "frame",
          "new_api": null,
          "old_text": "this->frame()->SetAllocatedRegisters(assigned_registers_)",
          "new_text": null,
          "old_line_content": "  this->frame()->SetAllocatedRegisters(assigned_registers_);",
          "new_line_content": "      assigned_double_registers_(nullptr),",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": "insert",
          "new_api": null,
          "old_text": "delayed_insertion_map.insert(\n            std::make_pair(std::make_pair(move, prev_operand), cur_operand))",
          "new_text": null,
          "old_line_content": "        delayed_insertion_map.insert(",
          "new_line_content": "        } else {",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": "std::make_pair(move, prev_operand)",
          "new_api": null,
          "old_text": "std::make_pair(move, prev_operand)",
          "new_text": null,
          "old_line_content": "            std::make_pair(std::make_pair(move, prev_operand), cur_operand));",
          "new_line_content": "          gap_index++;",
          "content_same": false
        },
        {
          "line": 3286,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "to_insert.reserve(4)",
          "new_text": null,
          "old_line_content": "  to_insert.reserve(4);",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": "VirtualRegisterCount",
          "new_api": null,
          "old_text": "code()->VirtualRegisterCount()",
          "new_text": null,
          "old_line_content": "  DCHECK_LT(virtual_register, code()->VirtualRegisterCount());",
          "new_line_content": "MoveOperands* RegisterAllocationData::AddGapMove(",
          "content_same": false
        },
        {
          "line": 1240,
          "old_api": "GetRepresentation",
          "new_api": null,
          "old_text": "code()->GetRepresentation(virtual_register)",
          "new_text": null,
          "old_line_content": "  return code()->GetRepresentation(virtual_register);",
          "new_line_content": "    int index, Instruction::GapPosition position,",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "begin",
          "new_api": null,
          "old_text": "delayed_insertion_map.begin()",
          "new_text": null,
          "old_line_content": "  for (auto it = delayed_insertion_map.begin();; ++it) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3290,
          "old_api": "end",
          "new_api": null,
          "old_text": "delayed_insertion_map.end()",
          "new_text": null,
          "old_line_content": "    bool done = it == delayed_insertion_map.end();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "size",
          "new_api": null,
          "old_text": "live_ranges().size()",
          "new_text": null,
          "old_line_content": "  if (index >= static_cast<int>(live_ranges().size())) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1246,
          "old_api": "resize",
          "new_api": null,
          "old_text": "live_ranges().resize(index + 1, nullptr)",
          "new_text": null,
          "old_line_content": "    live_ranges().resize(index + 1, nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "Eliminate",
          "new_api": null,
          "old_text": "move->Eliminate()",
          "new_text": null,
          "old_line_content": "        move->Eliminate();",
          "new_line_content": "  ZoneVector<MoveOperands*> to_insert(local_zone);",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "live_ranges()",
          "new_text": null,
          "old_line_content": "  auto result = live_ranges()[index];",
          "new_line_content": "MachineType RegisterAllocationData::MachineTypeFor(int virtual_register) {",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "live_ranges",
          "new_api": null,
          "old_text": "live_ranges()",
          "new_text": null,
          "old_line_content": "    live_ranges()[index] = result;",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": "clear",
          "new_api": null,
          "old_text": "to_eliminate.clear()",
          "new_text": null,
          "old_line_content": "      to_eliminate.clear();",
          "new_line_content": "    if (done || it->first.first != moves) {",
          "content_same": false
        },
        {
          "line": 3302,
          "old_api": "clear",
          "new_api": null,
          "old_text": "to_insert.clear()",
          "new_text": null,
          "old_line_content": "      to_insert.clear();",
          "new_line_content": "      // Commit the MoveOperands for current ParallelMove.",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": "code_zone",
          "new_api": null,
          "old_text": "code_zone()",
          "new_text": null,
          "old_line_content": "    auto move = new (code_zone()) MoveOperands(it->first.second, it->second);",
          "new_line_content": "      for (auto move : to_insert) {",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "  return new (allocation_zone()) TopLevelLiveRange(index, machine_type);",
          "new_line_content": "  if (result == nullptr) {",
          "content_same": false
        },
        {
          "line": 3308,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "to_insert.push_back(move)",
          "new_text": null,
          "old_line_content": "    to_insert.push_back(move);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 3309,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "to_eliminate.push_back(eliminate)",
          "new_text": null,
          "old_line_content": "    if (eliminate != nullptr) to_eliminate.push_back(eliminate);",
          "new_line_content": "      if (done) break;",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": "size",
          "new_api": null,
          "old_text": "live_ranges().size()",
          "new_text": null,
          "old_line_content": "  if (vreg >= static_cast<int>(live_ranges().size())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "resize",
          "new_api": null,
          "old_text": "live_ranges().resize(vreg + 1, nullptr)",
          "new_text": null,
          "old_line_content": "    live_ranges().resize(vreg + 1, nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "GetNextLiveRangeId",
          "new_api": null,
          "old_text": "GetNextLiveRangeId()",
          "new_text": null,
          "old_line_content": "  int vreg = GetNextLiveRangeId();",
          "new_line_content": "  int vreg = virtual_register_count_++;",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "  auto map_value = new (allocation_zone())",
          "new_line_content": "TopLevelLiveRange* RegisterAllocationData::NextLiveRange(",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "      RegisterAllocationData::PhiMapValue(phi, block, allocation_zone());",
          "new_line_content": "    MachineType machine_type) {",
          "content_same": false
        },
        {
          "line": 1286,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(res.second)",
          "new_text": null,
          "old_line_content": "  DCHECK(res.second);",
          "new_line_content": "  return ret;",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "USE",
          "new_api": null,
          "old_text": "USE(res)",
          "new_text": null,
          "old_line_content": "  USE(res);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": "find",
          "new_api": null,
          "old_text": "phi_map_.find(virtual_register)",
          "new_text": null,
          "old_line_content": "  auto it = phi_map_.find(virtual_register);",
          "new_line_content": "  auto res =",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "top_range->vreg()",
          "new_text": null,
          "old_line_content": "  return GetPhiMapValueFor(top_range->vreg());",
          "new_line_content": "RegisterAllocationData::PhiMapValue* RegisterAllocationData::GetPhiMapValueFor(",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "  while (!iterator.Done()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1311,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "    int operand_index = iterator.Current();",
          "new_line_content": "    TopLevelLiveRange* top_range) {",
          "content_same": false
        },
        {
          "line": 1314,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "GetOrCreateLiveRangeFor(operand_index)",
          "new_text": null,
          "old_line_content": "    LiveRange* range = GetOrCreateLiveRangeFor(operand_index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": "value",
          "new_api": null,
          "old_text": "range->first_pos()->pos().value()",
          "new_text": null,
          "old_line_content": "    PrintF(\"  (first use is at %d)\\n\", range->first_pos()->pos().value());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "debug_name",
          "new_api": null,
          "old_text": "debug_name()",
          "new_text": null,
          "old_line_content": "    if (debug_name() == nullptr) {",
          "new_line_content": "bool RegisterAllocationData::ExistsUseWithoutDefinition() {",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": "PrintF",
          "new_api": null,
          "old_text": "PrintF(\"\\n\")",
          "new_text": null,
          "old_line_content": "      PrintF(\"\\n\");",
          "new_line_content": "  bool found = false;",
          "content_same": false
        },
        {
          "line": 1333,
          "old_api": "IsSplinter",
          "new_api": null,
          "old_text": "range->IsSplinter()",
          "new_text": null,
          "old_line_content": "    DCHECK(!range->IsSplinter());",
          "new_line_content": "  return found;",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "    spill_range = new (allocation_zone()) SpillRange(range, allocation_zone());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": "set_spill_type",
          "new_api": null,
          "old_text": "range->set_spill_type(TopLevelLiveRange::SpillType::kSpillRange)",
          "new_text": null,
          "old_line_content": "  range->set_spill_type(TopLevelLiveRange::SpillType::kSpillRange);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": "IsSplinter",
          "new_api": null,
          "old_text": "range->IsSplinter()",
          "new_text": null,
          "old_line_content": "  DCHECK(!range->IsSplinter());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "      new (allocation_zone()) SpillRange(range, allocation_zone());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(kind == GENERAL_REGISTERS)",
          "new_text": null,
          "old_line_content": "    DCHECK(kind == GENERAL_REGISTERS);",
          "new_line_content": "  auto spill_range =",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": "IsFullStart",
          "new_api": null,
          "old_text": "pos.IsFullStart()",
          "new_text": null,
          "old_line_content": "  return pos.IsFullStart() &&",
          "new_line_content": "  if (kind == DOUBLE_REGISTERS) {",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": "ToInstructionIndex",
          "new_api": null,
          "old_text": "pos.ToInstructionIndex()",
          "new_text": null,
          "old_line_content": "             pos.ToInstructionIndex();",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": "config",
          "new_api": null,
          "old_text": "config()",
          "new_text": null,
          "old_line_content": "  wrapper.register_configuration_ = config();",
          "new_line_content": "  PrintableInstruction wrapper;",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "next",
          "new_api": null,
          "old_text": "i->next()",
          "new_text": null,
          "old_line_content": "  for (const LiveRange* i = range; i != nullptr; i = i->next()) {",
          "new_line_content": "  wrapper.instr_ = instruction;",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "config",
          "new_api": null,
          "old_text": "config()",
          "new_text": null,
          "old_line_content": "  wrapper.register_configuration_ = config();",
          "new_line_content": "    wrapper.range_ = i;",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": "config",
          "new_api": null,
          "old_text": "config()",
          "new_text": null,
          "old_line_content": "  wrapper.register_configuration_ = config();",
          "new_line_content": "  PrintableInstructionOperand wrapper;",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "source",
          "new_api": null,
          "old_text": "move->source()",
          "new_text": null,
          "old_line_content": "  wrapper.op_ = move->source();",
          "new_line_content": "  os << wrapper << std::endl;",
          "content_same": false
        },
        {
          "line": 1429,
          "old_api": "vreg",
          "new_api": null,
          "old_text": "range->vreg()",
          "new_text": null,
          "old_line_content": "    os << range->vreg() << \" \";",
          "new_line_content": "  os << wrapper << \" = \";",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": "interval",
          "new_api": null,
          "old_text": "spill_range->interval()",
          "new_text": null,
          "old_line_content": "  for (UseInterval* interval = spill_range->interval(); interval != nullptr;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "next",
          "new_api": null,
          "old_text": "interval->next()",
          "new_text": null,
          "old_line_content": "       interval = interval->next()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "end",
          "new_api": null,
          "old_text": "interval->end()",
          "new_text": null,
          "old_line_content": "    os << '[' << interval->start() << \", \" << interval->end() << ')'",
          "new_line_content": "void RegisterAllocationData::Print(const SpillRange* spill_range) {",
          "content_same": false
        },
        {
          "line": 1448,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "operand->virtual_register()",
          "new_text": null,
          "old_line_content": "  TRACE(\"Allocating fixed reg for op %d\\n\", operand->virtual_register());",
          "new_line_content": "  os << \"}\" << std::endl;",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "HasFixedPolicy",
          "new_api": null,
          "old_text": "operand->HasFixedPolicy()",
          "new_text": null,
          "old_line_content": "  DCHECK(operand->HasFixedPolicy());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": "InstructionSequence::DefaultRepresentation()",
          "new_api": null,
          "old_text": "InstructionSequence::DefaultRepresentation()",
          "new_text": null,
          "old_line_content": "  MachineType machine_type = InstructionSequence::DefaultRepresentation();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "operand->virtual_register()",
          "new_text": null,
          "old_line_content": "  int virtual_register = operand->virtual_register();",
          "new_line_content": "ConstraintBuilder::ConstraintBuilder(RegisterAllocationData* data)",
          "content_same": false
        },
        {
          "line": 1454,
          "old_api": "MachineTypeFor",
          "new_api": null,
          "old_text": "data()->MachineTypeFor(virtual_register)",
          "new_text": null,
          "old_line_content": "    machine_type = data()->MachineTypeFor(virtual_register);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1456,
          "old_api": "HasFixedSlotPolicy",
          "new_api": null,
          "old_text": "operand->HasFixedSlotPolicy()",
          "new_text": null,
          "old_line_content": "  if (operand->HasFixedSlotPolicy()) {",
          "new_line_content": "InstructionOperand* ConstraintBuilder::AllocateFixed(",
          "content_same": false
        },
        {
          "line": 1463,
          "old_api": "fixed_register_index",
          "new_api": null,
          "old_text": "AllocatedOperand(AllocatedOperand::REGISTER, machine_type,\n                                 operand->fixed_register_index())",
          "new_text": null,
          "old_line_content": "    allocated = AllocatedOperand(AllocatedOperand::REGISTER, machine_type,",
          "new_line_content": "  if (virtual_register != InstructionOperand::kInvalidVirtualRegister) {",
          "content_same": false
        },
        {
          "line": 1465,
          "old_api": "HasFixedDoubleRegisterPolicy",
          "new_api": null,
          "old_text": "operand->HasFixedDoubleRegisterPolicy()",
          "new_text": null,
          "old_line_content": "  } else if (operand->HasFixedDoubleRegisterPolicy()) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "fixed_register_index",
          "new_api": null,
          "old_text": "AllocatedOperand(AllocatedOperand::DOUBLE_REGISTER,\n                                 machine_type, operand->fixed_register_index())",
          "new_text": null,
          "old_line_content": "    allocated = AllocatedOperand(AllocatedOperand::DOUBLE_REGISTER,",
          "new_line_content": "    AllocatedOperand::AllocatedKind kind =",
          "content_same": false
        },
        {
          "line": 1470,
          "old_api": "UNREACHABLE",
          "new_api": null,
          "old_text": "UNREACHABLE()",
          "new_text": null,
          "old_line_content": "    UNREACHABLE();",
          "new_line_content": "    allocated =",
          "content_same": false
        },
        {
          "line": 1492,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "  int start = block->first_instruction_index();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "block->last_instruction_index()",
          "new_text": null,
          "old_line_content": "  int end = block->last_instruction_index();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "DCHECK_NE",
          "new_api": null,
          "old_text": "DCHECK_NE(-1, start)",
          "new_text": null,
          "old_line_content": "  DCHECK_NE(-1, start);",
          "new_line_content": "void ConstraintBuilder::MeetRegisterConstraints() {",
          "content_same": false
        },
        {
          "line": 1497,
          "old_api": "MeetConstraintsAfter",
          "new_api": null,
          "old_text": "MeetConstraintsAfter(i)",
          "new_text": null,
          "old_line_content": "    if (i != end) MeetConstraintsAfter(i);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "MeetRegisterConstraintsForLastInstructionInBlock",
          "new_api": null,
          "old_text": "MeetRegisterConstraintsForLastInstructionInBlock(block)",
          "new_text": null,
          "old_line_content": "  MeetRegisterConstraintsForLastInstructionInBlock(block);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "OutputCount",
          "new_api": null,
          "old_text": "last_instruction->OutputCount()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < last_instruction->OutputCount(); i++) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1509,
          "old_api": "OutputAt",
          "new_api": null,
          "old_text": "last_instruction->OutputAt(i)",
          "new_text": null,
          "old_line_content": "    auto output_operand = last_instruction->OutputAt(i);",
          "new_line_content": "  // Meet register constraints for the instruction in the end.",
          "content_same": false
        },
        {
          "line": 1511,
          "old_api": "UnallocatedOperand::cast(output_operand)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(output_operand)",
          "new_text": null,
          "old_line_content": "    auto output = UnallocatedOperand::cast(output_operand);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "output->virtual_register()",
          "new_text": null,
          "old_line_content": "    int output_vreg = output->virtual_register();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(output_vreg)",
          "new_text": null,
          "old_line_content": "    auto range = data()->GetOrCreateLiveRangeFor(output_vreg);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "HasFixedPolicy",
          "new_api": null,
          "old_text": "output->HasFixedPolicy()",
          "new_text": null,
          "old_line_content": "    if (output->HasFixedPolicy()) {",
          "new_line_content": "    const InstructionBlock* block) {",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code()->InstructionBlockAt(succ)",
          "new_text": null,
          "old_line_content": "        const InstructionBlock* successor = code()->InstructionBlockAt(succ);",
          "new_line_content": "      // This value is produced on the stack, we never need to spill it.",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": "AddGapMove",
          "new_api": null,
          "old_text": "data()->AddGapMove(gap_index, Instruction::START, *output, output_copy)",
          "new_text": null,
          "old_line_content": "        data()->AddGapMove(gap_index, Instruction::START, *output, output_copy);",
          "new_line_content": "        assigned = true;",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": "PredecessorCount",
          "new_api": null,
          "old_text": "successor->PredecessorCount()",
          "new_text": null,
          "old_line_content": "        DCHECK(successor->PredecessorCount() == 1);",
          "new_line_content": "        // Create an unconstrained operand for the same virtual register",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "successor->first_instruction_index()",
          "new_text": null,
          "old_line_content": "        int gap_index = successor->first_instruction_index();",
          "new_line_content": "        // and insert a gap move from the fixed output to the operand.",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "        range->SpillAtDefinition(allocation_zone(), gap_index, output);",
          "new_line_content": "        UnallocatedOperand output_copy(UnallocatedOperand::ANY, output_vreg);",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "TempAt",
          "new_api": null,
          "old_text": "first->TempAt(i)",
          "new_text": null,
          "old_line_content": "    auto temp = UnallocatedOperand::cast(first->TempAt(i));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": "AllocateFixed",
          "new_api": null,
          "old_text": "AllocateFixed(temp, instr_index, false)",
          "new_text": null,
          "old_line_content": "    if (temp->HasFixedPolicy()) AllocateFixed(temp, instr_index, false);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": "OutputCount",
          "new_api": null,
          "old_text": "first->OutputCount()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < first->OutputCount(); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": "OutputAt",
          "new_api": null,
          "old_text": "first->OutputAt(i)",
          "new_text": null,
          "old_line_content": "    InstructionOperand* output = first->OutputAt(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "IsConstant",
          "new_api": null,
          "old_text": "output->IsConstant()",
          "new_text": null,
          "old_line_content": "    if (output->IsConstant()) {",
          "new_line_content": "void ConstraintBuilder::MeetConstraintsAfter(int instr_index) {",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(output_vreg)",
          "new_text": null,
          "old_line_content": "      auto range = data()->GetOrCreateLiveRangeFor(output_vreg);",
          "new_line_content": "  // Handle fixed temporaries.",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "UnallocatedOperand::cast(output)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(output)",
          "new_text": null,
          "old_line_content": "    auto first_output = UnallocatedOperand::cast(output);",
          "new_line_content": "  // Handle constant/fixed output operands.",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": "AllocateFixed",
          "new_api": null,
          "old_text": "AllocateFixed(first_output, instr_index, is_tagged)",
          "new_text": null,
          "old_line_content": "      AllocateFixed(first_output, instr_index, is_tagged);",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "IsStackSlot",
          "new_api": null,
          "old_text": "first_output->IsStackSlot()",
          "new_text": null,
          "old_line_content": "      if (first_output->IsStackSlot()) {",
          "new_line_content": "    auto range =",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "frame",
          "new_api": null,
          "old_text": "data()->frame()->GetTotalFrameSlotCount()",
          "new_text": null,
          "old_line_content": "               data()->frame()->GetTotalFrameSlotCount());",
          "new_line_content": "    bool assigned = false;",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": "SetSpillStartIndex",
          "new_api": null,
          "old_text": "range->SetSpillStartIndex(instr_index + 1)",
          "new_text": null,
          "old_line_content": "      range->SetSpillStartIndex(instr_index + 1);",
          "new_line_content": "        assigned = true;",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()->InstructionAt(instr_index)",
          "new_text": null,
          "old_line_content": "  auto second = code()->InstructionAt(instr_index);",
          "new_line_content": "    if (!assigned) {",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "InputCount",
          "new_api": null,
          "old_text": "second->InputCount()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < second->InputCount(); i++) {",
          "new_line_content": "                               first_output);",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "IsImmediate",
          "new_api": null,
          "old_text": "input->IsImmediate()",
          "new_text": null,
          "old_line_content": "    if (input->IsImmediate()) continue;  // Ignore immediates.",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "UnallocatedOperand::cast(input)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(input)",
          "new_text": null,
          "old_line_content": "    auto cur_input = UnallocatedOperand::cast(input);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "HasFixedPolicy",
          "new_api": null,
          "old_text": "cur_input->HasFixedPolicy()",
          "new_text": null,
          "old_line_content": "    if (cur_input->HasFixedPolicy()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "cur_input->virtual_register()",
          "new_text": null,
          "old_line_content": "      int input_vreg = cur_input->virtual_register();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "IsReference",
          "new_api": null,
          "old_text": "code()->IsReference(input_vreg)",
          "new_text": null,
          "old_line_content": "      bool is_tagged = code()->IsReference(input_vreg);",
          "new_line_content": "void ConstraintBuilder::MeetConstraintsBefore(int instr_index) {",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": "AddGapMove",
          "new_api": null,
          "old_text": "data()->AddGapMove(instr_index, Instruction::END, input_copy, *cur_input)",
          "new_text": null,
          "old_line_content": "      data()->AddGapMove(instr_index, Instruction::END, input_copy, *cur_input);",
          "new_line_content": "  // Handle fixed input operands of second instruction.",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": "UnallocatedOperand::cast(output)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(output)",
          "new_text": null,
          "old_line_content": "    auto second_output = UnallocatedOperand::cast(output);",
          "new_line_content": "      UnallocatedOperand input_copy(UnallocatedOperand::ANY, input_vreg);",
          "content_same": false
        },
        {
          "line": 1622,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "second->InputAt(0)",
          "new_text": null,
          "old_line_content": "        UnallocatedOperand::cast(second->InputAt(0));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "second_output->virtual_register()",
          "new_text": null,
          "old_line_content": "    int output_vreg = second_output->virtual_register();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "cur_input->virtual_register()",
          "new_text": null,
          "old_line_content": "    int input_vreg = cur_input->virtual_register();",
          "new_line_content": "  // Handle \"output same as input\" for second instruction.",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": "IsReference",
          "new_api": null,
          "old_text": "code()->IsReference(input_vreg)",
          "new_text": null,
          "old_line_content": "    } else if (!code()->IsReference(input_vreg) &&",
          "new_line_content": "    UnallocatedOperand input_copy(UnallocatedOperand::ANY, input_vreg);",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "instruction_blocks",
          "new_api": null,
          "old_text": "code()->instruction_blocks()",
          "new_text": null,
          "old_line_content": "  for (InstructionBlock* block : base::Reversed(code()->instruction_blocks())) {",
          "new_line_content": "      // beginning of the instruction is equal to the input operand). If",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": "ResolvePhis",
          "new_api": null,
          "old_text": "ResolvePhis(block)",
          "new_text": null,
          "old_line_content": "    ResolvePhis(block);",
          "new_line_content": "      // this is not desired, then the pointer map at this instruction needs",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "phis",
          "new_api": null,
          "old_text": "block->phis()",
          "new_text": null,
          "old_line_content": "  for (auto phi : block->phis()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "phi->virtual_register()",
          "new_text": null,
          "old_line_content": "    int phi_vreg = phi->virtual_register();",
          "new_line_content": "void ConstraintBuilder::ResolvePhis() {",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": "InitializePhiMap",
          "new_api": null,
          "old_text": "data()->InitializePhiMap(block, phi)",
          "new_text": null,
          "old_line_content": "    auto map_value = data()->InitializePhiMap(block, phi);",
          "new_line_content": "  // Process the blocks in reverse order.",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "size",
          "new_api": null,
          "old_text": "phi->operands().size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < phi->operands().size(); ++i) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "          code()->InstructionBlockAt(block->predecessors()[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "operands",
          "new_api": null,
          "old_text": "phi->operands()",
          "new_text": null,
          "old_line_content": "      UnallocatedOperand input(UnallocatedOperand::ANY, phi->operands()[i]);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "cur_block->last_instruction_index()",
          "new_text": null,
          "old_line_content": "      auto move = data()->AddGapMove(cur_block->last_instruction_index(),",
          "new_line_content": "void ConstraintBuilder::ResolvePhis(const InstructionBlock* block) {",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(phi_vreg)",
          "new_text": null,
          "old_line_content": "    auto live_range = data()->GetOrCreateLiveRangeFor(phi_vreg);",
          "new_line_content": "      InstructionBlock* cur_block =",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": "ToSize",
          "new_api": null,
          "old_text": "block->rpo_number().ToSize()",
          "new_text": null,
          "old_line_content": "  size_t block_index = block->rpo_number().ToSize();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": "live_out_sets",
          "new_api": null,
          "old_text": "data->live_out_sets()",
          "new_text": null,
          "old_line_content": "  BitVector* live_out = data->live_out_sets()[block_index];",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "data->allocation_zone()",
          "new_text": null,
          "old_line_content": "    Zone* zone = data->allocation_zone();",
          "new_line_content": "    : data_(data), phi_hints_(local_zone) {}",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "code",
          "new_api": null,
          "old_text": "data->code()",
          "new_text": null,
          "old_line_content": "    const InstructionSequence* code = data->code();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "VirtualRegisterCount",
          "new_api": null,
          "old_text": "code->VirtualRegisterCount()",
          "new_text": null,
          "old_line_content": "    live_out = new (zone) BitVector(code->VirtualRegisterCount(), zone);",
          "new_line_content": "BitVector* LiveRangeBuilder::ComputeLiveOut(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": "rpo_number",
          "new_api": null,
          "old_text": "block->rpo_number()",
          "new_text": null,
          "old_line_content": "      if (succ <= block->rpo_number()) continue;",
          "new_line_content": "    // Compute live out for the given block, except not including backward",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "ToSize",
          "new_api": null,
          "old_text": "succ.ToSize()",
          "new_text": null,
          "old_line_content": "      BitVector* live_in = data->live_in_sets()[succ.ToSize()];",
          "new_line_content": "    // successor edges.",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "code->InstructionBlockAt(succ)",
          "new_text": null,
          "old_line_content": "      auto successor = code->InstructionBlockAt(succ);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "rpo_number",
          "new_api": null,
          "old_text": "block->rpo_number()",
          "new_text": null,
          "old_line_content": "      size_t index = successor->PredecessorIndexOf(block->rpo_number());",
          "new_line_content": "    // Process all successor blocks.",
          "content_same": false
        },
        {
          "line": 1713,
          "old_api": "phis",
          "new_api": null,
          "old_text": "successor->phis()",
          "new_text": null,
          "old_line_content": "      for (PhiInstruction* phi : successor->phis()) {",
          "new_line_content": "      // Add values live on entry to the successor.",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "live_out_sets",
          "new_api": null,
          "old_text": "data->live_out_sets()",
          "new_text": null,
          "old_line_content": "    data->live_out_sets()[block_index] = live_out;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "      block->first_instruction_index());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1729,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(\n                 block->last_instruction_index()).NextStart()",
          "new_text": null,
          "old_line_content": "  auto end = LifetimePosition::InstructionFromInstructionIndex(",
          "new_line_content": "  return live_out;",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "block->last_instruction_index()",
          "new_text": null,
          "old_line_content": "                 block->last_instruction_index()).NextStart();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "  while (!iterator.Done()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "    int operand_index = iterator.Current();",
          "new_line_content": "void LiveRangeBuilder::AddInitialIntervals(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(operand_index)",
          "new_text": null,
          "old_line_content": "    auto range = data()->GetOrCreateLiveRangeFor(operand_index);",
          "new_line_content": "                                           BitVector* live_out) {",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "    range->AddUseInterval(start, end, allocation_zone());",
          "new_line_content": "  // Add an interval that includes the entire block to the live range for",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": "Advance",
          "new_api": null,
          "old_text": "iterator.Advance()",
          "new_text": null,
          "old_line_content": "    iterator.Advance();",
          "new_line_content": "  // each live_out value.",
          "content_same": false
        },
        {
          "line": 1747,
          "old_api": "num_general_registers",
          "new_api": null,
          "old_text": "config()->num_general_registers()",
          "new_text": null,
          "old_line_content": "  DCHECK(index < config()->num_general_registers());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": "fixed_live_ranges",
          "new_api": null,
          "old_text": "data()->fixed_live_ranges()",
          "new_text": null,
          "old_line_content": "  auto result = data()->fixed_live_ranges()[index];",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1750,
          "old_api": "FixedLiveRangeID",
          "new_api": null,
          "old_text": "FixedLiveRangeID(index)",
          "new_text": null,
          "old_line_content": "    result = data()->NewLiveRange(FixedLiveRangeID(index),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "InstructionSequence::DefaultRepresentation()",
          "new_api": null,
          "old_text": "InstructionSequence::DefaultRepresentation()",
          "new_text": null,
          "old_line_content": "                                  InstructionSequence::DefaultRepresentation());",
          "new_line_content": "int LiveRangeBuilder::FixedDoubleLiveRangeID(int index) {",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": "set_assigned_register",
          "new_api": null,
          "old_text": "result->set_assigned_register(index)",
          "new_text": null,
          "old_line_content": "    result->set_assigned_register(index);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": "MarkAllocated",
          "new_api": null,
          "old_text": "data()->MarkAllocated(GENERAL_REGISTERS, index)",
          "new_text": null,
          "old_line_content": "    data()->MarkAllocated(GENERAL_REGISTERS, index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "fixed_live_ranges",
          "new_api": null,
          "old_text": "data()->fixed_live_ranges()",
          "new_text": null,
          "old_line_content": "    data()->fixed_live_ranges()[index] = result;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1766,
          "old_api": "IsFixed",
          "new_api": null,
          "old_text": "result->IsFixed()",
          "new_text": null,
          "old_line_content": "    DCHECK(result->IsFixed());",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "set_assigned_register",
          "new_api": null,
          "old_text": "result->set_assigned_register(index)",
          "new_text": null,
          "old_line_content": "    result->set_assigned_register(index);",
          "new_line_content": "  return result;",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "MarkAllocated",
          "new_api": null,
          "old_text": "data()->MarkAllocated(DOUBLE_REGISTERS, index)",
          "new_text": null,
          "old_line_content": "    data()->MarkAllocated(DOUBLE_REGISTERS, index);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": "fixed_double_live_ranges",
          "new_api": null,
          "old_text": "data()->fixed_double_live_ranges()",
          "new_text": null,
          "old_line_content": "    data()->fixed_double_live_ranges()[index] = result;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(\n        ConstantOperand::cast(operand)->virtual_register())",
          "new_text": null,
          "old_line_content": "    return data()->GetOrCreateLiveRangeFor(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "ConstantOperand::cast(operand)->virtual_register()",
          "new_text": null,
          "old_line_content": "        ConstantOperand::cast(operand)->virtual_register());",
          "new_line_content": "  return result;",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "IsRegister",
          "new_api": null,
          "old_text": "operand->IsRegister()",
          "new_text": null,
          "old_line_content": "  } else if (operand->IsRegister()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "index",
          "new_api": null,
          "old_text": "RegisterOperand::cast(operand)->index()",
          "new_text": null,
          "old_line_content": "    return FixedLiveRangeFor(RegisterOperand::cast(operand)->index());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "IsDoubleRegister",
          "new_api": null,
          "old_text": "operand->IsDoubleRegister()",
          "new_text": null,
          "old_line_content": "  } else if (operand->IsDoubleRegister()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1785,
          "old_api": "index",
          "new_api": null,
          "old_text": "FixedDoubleLiveRangeFor(\n        DoubleRegisterOperand::cast(operand)->index())",
          "new_text": null,
          "old_line_content": "    return FixedDoubleLiveRangeFor(",
          "new_line_content": "TopLevelLiveRange* LiveRangeBuilder::LiveRangeFor(InstructionOperand* operand) {",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "  return new (allocation_zone()) UsePosition(pos, operand, hint, hint_type);",
          "new_line_content": "  } else {",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": "LiveRangeFor",
          "new_api": null,
          "old_text": "LiveRangeFor(operand)",
          "new_text": null,
          "old_line_content": "  auto range = LiveRangeFor(operand);",
          "new_line_content": "                                              InstructionOperand* operand,",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "    range->AddUseInterval(position, position.NextStart(), allocation_zone());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": "NextStart",
          "new_api": null,
          "old_text": "position.NextStart()",
          "new_text": null,
          "old_line_content": "    range->AddUsePosition(NewUsePosition(position.NextStart()));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "ShortenTo",
          "new_api": null,
          "old_text": "range->ShortenTo(position)",
          "new_text": null,
          "old_line_content": "    range->ShortenTo(position);",
          "new_line_content": "                                      InstructionOperand* operand, void* hint,",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": "UnallocatedOperand::cast(operand)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(operand)",
          "new_text": null,
          "old_line_content": "  auto unalloc_operand = UnallocatedOperand::cast(operand);",
          "new_line_content": "  if (range == nullptr) return nullptr;",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "NewUsePosition",
          "new_api": null,
          "old_text": "NewUsePosition(position, unalloc_operand, hint, hint_type)",
          "new_text": null,
          "old_line_content": "  auto use_pos = NewUsePosition(position, unalloc_operand, hint, hint_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "IsUnallocated",
          "new_api": null,
          "old_text": "operand->IsUnallocated()",
          "new_text": null,
          "old_line_content": "  if (operand->IsUnallocated()) {",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "UnallocatedOperand::cast(operand)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(operand)",
          "new_text": null,
          "old_line_content": "    UnallocatedOperand* unalloc_operand = UnallocatedOperand::cast(operand);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": "NewUsePosition",
          "new_api": null,
          "old_text": "NewUsePosition(position, unalloc_operand, hint, hint_type)",
          "new_text": null,
          "old_line_content": "    use_pos = NewUsePosition(position, unalloc_operand, hint, hint_type);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "AddUsePosition",
          "new_api": null,
          "old_text": "range->AddUsePosition(use_pos)",
          "new_text": null,
          "old_line_content": "    range->AddUsePosition(use_pos);",
          "new_line_content": "UsePosition* LiveRangeBuilder::Use(LifetimePosition block_start,",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "  range->AddUseInterval(block_start, position, allocation_zone());",
          "new_line_content": "                                   InstructionOperand* operand, void* hint,",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": "LifetimePosition::GapFromInstructionIndex(block_start)",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(block_start)",
          "new_text": null,
          "old_line_content": "      LifetimePosition::GapFromInstructionIndex(block_start);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "last_instruction_index",
          "new_api": null,
          "old_text": "block->last_instruction_index()",
          "new_text": null,
          "old_line_content": "  for (int index = block->last_instruction_index(); index >= block_start;",
          "new_line_content": "  return use_pos;",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "LifetimePosition::InstructionFromInstructionIndex(index)",
          "new_api": null,
          "old_text": "LifetimePosition::InstructionFromInstructionIndex(index)",
          "new_text": null,
          "old_line_content": "        LifetimePosition::InstructionFromInstructionIndex(index);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "InstructionAt",
          "new_api": null,
          "old_text": "code()->InstructionAt(index)",
          "new_text": null,
          "old_line_content": "    auto instr = code()->InstructionAt(index);",
          "new_line_content": "void LiveRangeBuilder::ProcessInstructions(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": "DCHECK",
          "new_api": null,
          "old_text": "DCHECK(instr != nullptr)",
          "new_text": null,
          "old_line_content": "    DCHECK(instr != nullptr);",
          "new_line_content": "                                           BitVector* live) {",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "OutputAt",
          "new_api": null,
          "old_text": "instr->OutputAt(i)",
          "new_text": null,
          "old_line_content": "      auto output = instr->OutputAt(i);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": "HasSlotPolicy",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(output)->HasSlotPolicy()",
          "new_text": null,
          "old_line_content": "        DCHECK(!UnallocatedOperand::cast(output)->HasSlotPolicy());",
          "new_line_content": "    auto curr_position =",
          "content_same": false
        },
        {
          "line": 1862,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "live->Remove(out_vreg)",
          "new_text": null,
          "old_line_content": "        live->Remove(out_vreg);",
          "new_line_content": "    // Process output, inputs, and temps of this instruction.",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "ClobbersRegisters",
          "new_api": null,
          "old_text": "instr->ClobbersRegisters()",
          "new_text": null,
          "old_line_content": "    if (instr->ClobbersRegisters()) {",
          "new_line_content": "        // The register defined here is blocked from gap start - it is the",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "num_general_registers",
          "new_api": null,
          "old_text": "config()->num_general_registers()",
          "new_text": null,
          "old_line_content": "      for (int i = 0; i < config()->num_general_registers(); ++i) {",
          "new_line_content": "        // exception value.",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "IsOutputRegisterOf",
          "new_api": null,
          "old_text": "IsOutputRegisterOf(instr, i)",
          "new_text": null,
          "old_line_content": "        if (!IsOutputRegisterOf(instr, i)) {",
          "new_line_content": "        // TODO(mtrofin): should we explore an explicit opcode for",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": "FixedLiveRangeFor",
          "new_api": null,
          "old_text": "FixedLiveRangeFor(i)",
          "new_text": null,
          "old_line_content": "          auto range = FixedLiveRangeFor(i);",
          "new_line_content": "        // the first instruction in the handler?",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "                                allocation_zone());",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": "End",
          "new_api": null,
          "old_text": "curr_position.End()",
          "new_text": null,
          "old_line_content": "        use_pos = curr_position.End();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "unalloc->virtual_register()",
          "new_text": null,
          "old_line_content": "        int vreg = unalloc->virtual_register();",
          "new_line_content": "      LifetimePosition use_pos;",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(vreg)->set_has_slot_use(true)",
          "new_text": null,
          "old_line_content": "          data()->GetOrCreateLiveRangeFor(vreg)->set_has_slot_use(true);",
          "new_line_content": "        use_pos = curr_position;",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "Use",
          "new_api": null,
          "old_text": "Use(block_start_position, use_pos, input)",
          "new_text": null,
          "old_line_content": "      Use(block_start_position, use_pos, input);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "ClobbersTemps",
          "new_api": null,
          "old_text": "instr->ClobbersTemps()",
          "new_text": null,
          "old_line_content": "      if (instr->ClobbersTemps()) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": "IsRegister",
          "new_api": null,
          "old_text": "temp->IsRegister()",
          "new_text": null,
          "old_line_content": "        if (temp->IsRegister()) continue;",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": "UnallocatedOperand::cast(temp)",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(temp)",
          "new_text": null,
          "old_line_content": "          UnallocatedOperand* temp_unalloc = UnallocatedOperand::cast(temp);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": "HasFixedPolicy",
          "new_api": null,
          "old_text": "temp_unalloc->HasFixedPolicy()",
          "new_text": null,
          "old_line_content": "          if (temp_unalloc->HasFixedPolicy()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": "PrevStart",
          "new_api": null,
          "old_text": "curr_position.PrevStart()",
          "new_text": null,
          "old_line_content": "    curr_position = curr_position.PrevStart();",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": "IsGapPosition",
          "new_api": null,
          "old_text": "curr_position.IsGapPosition()",
          "new_text": null,
          "old_line_content": "    DCHECK(curr_position.IsGapPosition());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "End",
          "new_api": null,
          "old_text": "curr_position.End()",
          "new_text": null,
          "old_line_content": "        curr_position = curr_position.End();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "Start",
          "new_api": null,
          "old_text": "curr_position.Start()",
          "new_text": null,
          "old_line_content": "        curr_position = curr_position.Start();",
          "new_line_content": "    const Instruction::GapPosition kPositions[] = {Instruction::END,",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": "destination",
          "new_api": null,
          "old_text": "cur->destination()",
          "new_text": null,
          "old_line_content": "        auto& to = cur->destination();",
          "new_line_content": "    for (auto position : kPositions) {",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": "UsePosition::HintTypeForOperand(to)",
          "new_api": null,
          "old_text": "UsePosition::HintTypeForOperand(to)",
          "new_text": null,
          "old_line_content": "        UsePositionHintType hint_type = UsePosition::HintTypeForOperand(to);",
          "new_line_content": "      if (move == nullptr) continue;",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "IsUnallocated",
          "new_api": null,
          "old_text": "to.IsUnallocated()",
          "new_text": null,
          "old_line_content": "        if (to.IsUnallocated()) {",
          "new_line_content": "      } else {",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "GetOrCreateLiveRangeFor",
          "new_api": null,
          "old_text": "data()->GetOrCreateLiveRangeFor(to_vreg)",
          "new_text": null,
          "old_line_content": "          auto to_range = data()->GetOrCreateLiveRangeFor(to_vreg);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "is_phi",
          "new_api": null,
          "old_text": "to_range->is_phi()",
          "new_text": null,
          "old_line_content": "          if (to_range->is_phi()) {",
          "new_line_content": "      for (auto cur : *move) {",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "current_hint_position",
          "new_api": null,
          "old_text": "to_range->current_hint_position()",
          "new_text": null,
          "old_line_content": "              hint = to_range->current_hint_position();",
          "new_line_content": "        void* hint = &to;",
          "content_same": false
        },
        {
          "line": 1969,
          "old_api": "Contains",
          "new_api": null,
          "old_text": "live->Contains(to_vreg)",
          "new_text": null,
          "old_line_content": "            if (live->Contains(to_vreg)) {",
          "new_line_content": "            phi_vreg = to_vreg;",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "live->Remove(to_vreg)",
          "new_text": null,
          "old_line_content": "              live->Remove(to_vreg);",
          "new_line_content": "              hint_type = hint == nullptr ? UsePositionHintType::kNone",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "Eliminate",
          "new_api": null,
          "old_text": "cur->Eliminate()",
          "new_text": null,
          "old_line_content": "              cur->Eliminate();",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(from).virtual_register()",
          "new_text": null,
          "old_line_content": "          live->Add(UnallocatedOperand::cast(from).virtual_register());",
          "new_line_content": "              continue;",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "ResolveHint",
          "new_api": null,
          "old_text": "from_use->ResolveHint(to_use)",
          "new_text": null,
          "old_line_content": "          from_use->ResolveHint(to_use);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "IsResolved",
          "new_api": null,
          "old_text": "from_use->IsResolved()",
          "new_text": null,
          "old_line_content": "        DCHECK_IMPLIES(from_use != nullptr, from_use->IsResolved());",
          "new_line_content": "        // Mark range live.",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": "phis",
          "new_api": null,
          "old_text": "block->phis()",
          "new_text": null,
          "old_line_content": "  for (auto phi : block->phis()) {",
          "new_line_content": "        // Potentially resolve phi hint.",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "phi->virtual_register()",
          "new_text": null,
          "old_line_content": "    int phi_vreg = phi->virtual_register();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "Remove",
          "new_api": null,
          "old_text": "live->Remove(phi_vreg)",
          "new_text": null,
          "old_line_content": "    live->Remove(phi_vreg);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "InstructionBlockAt",
          "new_api": null,
          "old_text": "GetLastInstruction(\n        code(), code()->InstructionBlockAt(block->predecessors()[0]))",
          "new_text": null,
          "old_line_content": "    auto instr = GetLastInstruction(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "predecessors",
          "new_api": null,
          "old_text": "block->predecessors()",
          "new_text": null,
          "old_line_content": "        code(), code()->InstructionBlockAt(block->predecessors()[0]));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": "GetParallelMove",
          "new_api": null,
          "old_text": "instr->GetParallelMove(Instruction::END)",
          "new_text": null,
          "old_line_content": "    for (auto move : *instr->GetParallelMove(Instruction::END)) {",
          "new_line_content": "void LiveRangeBuilder::ProcessPhis(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "destination",
          "new_api": null,
          "old_text": "move->destination()",
          "new_text": null,
          "old_line_content": "      auto& to = move->destination();",
          "new_line_content": "                                   BitVector* live) {",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": "virtual_register",
          "new_api": null,
          "old_text": "UnallocatedOperand::cast(to).virtual_register()",
          "new_text": null,
          "old_line_content": "          UnallocatedOperand::cast(to).virtual_register() == phi_vreg) {",
          "new_line_content": "    // The live range interval already ends at the first instruction of the",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": "source",
          "new_api": null,
          "old_text": "move->source()",
          "new_text": null,
          "old_line_content": "        hint = &move->source();",
          "new_line_content": "    // block.",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": "spilled",
          "new_api": null,
          "old_text": "second_range->spilled()",
          "new_text": null,
          "old_line_content": "      if (!connect_spilled && second_range->spilled()) continue;",
          "new_line_content": "  DelayedInsertionMap delayed_insertion_map(local_zone);",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n      block->first_instruction_index())",
          "new_text": null,
          "old_line_content": "  auto start = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "first_instruction_index",
          "new_api": null,
          "old_text": "block->first_instruction_index()",
          "new_text": null,
          "old_line_content": "      block->first_instruction_index());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "NextFullStart",
          "new_api": null,
          "old_text": "LifetimePosition::GapFromInstructionIndex(\n                 code()->LastLoopInstructionIndex(block)).NextFullStart()",
          "new_text": null,
          "old_line_content": "  auto end = LifetimePosition::GapFromInstructionIndex(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": "LastLoopInstructionIndex",
          "new_api": null,
          "old_text": "code()->LastLoopInstructionIndex(block)",
          "new_text": null,
          "old_line_content": "                 code()->LastLoopInstructionIndex(block)).NextFullStart();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": "Done",
          "new_api": null,
          "old_text": "iterator.Done()",
          "new_text": null,
          "old_line_content": "  while (!iterator.Done()) {",
          "new_line_content": "void LiveRangeBuilder::ProcessLoopHeader(const InstructionBlock* block,",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": "Current",
          "new_api": null,
          "old_text": "iterator.Current()",
          "new_text": null,
          "old_line_content": "    int operand_index = iterator.Current();",
          "new_line_content": "                                         BitVector* live) {",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "allocation_zone",
          "new_api": null,
          "old_text": "allocation_zone()",
          "new_text": null,
          "old_line_content": "    range->EnsureInterval(start, end, allocation_zone());",
          "new_line_content": "  // Add a live range stretching from the first loop instruction to the last",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": "Advance",
          "new_api": null,
          "old_text": "iterator.Advance()",
          "new_text": null,
          "old_line_content": "    iterator.Advance();",
          "new_line_content": "  // for each value live on entry to the header.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 404,
      "total_additions": 590,
      "total_deletions": 590,
      "total_api_changes": 1584
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 1584,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          853,
          830,
          855
        ]
      }
    },
    "api_calls_before": 1919,
    "api_calls_after": 1919,
    "diff_info": {
      "added_lines": 10,
      "removed_lines": 0,
      "total_diff_lines": 29
    }
  }
}