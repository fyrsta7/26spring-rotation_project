diff --git a/src/compiler/register-allocator.cc b/src/compiler/register-allocator.cc
index f6c339234ab..563c9a276d8 100644
--- a/src/compiler/register-allocator.cc
+++ b/src/compiler/register-allocator.cc
@@ -825,6 +825,12 @@ void TopLevelLiveRange::Splinter(LifetimePosition start, LifetimePosition end,
   result->set_spill_type(spill_type());
 
   if (start <= Start()) {
+    // TODO(mtrofin): here, the TopLevel part is in the deferred range, so we
+    // may want to continue processing the splinter. However, if the value is
+    // defined in a cold block, and then used in a hot block, it follows that
+    // it should terminate on the RHS of a phi, defined on the hot path. We
+    // should check this, however, this may not be the place, because we don't
+    // have access to the instruction sequence.
     DCHECK(end < End());
     DetachAt(end, result, zone);
     next_ = nullptr;
@@ -844,6 +850,10 @@ void TopLevelLiveRange::Splinter(LifetimePosition start, LifetimePosition end,
 
     next_ = end_part.next_;
     last_interval_->set_next(end_part.first_interval_);
+    // The next splinter will happen either at or after the current interval.
+    // We can optimize DetachAt by setting current_interval_ accordingly,
+    // which will then be picked up by FirstSearchIntervalForPosition.
+    current_interval_ = last_interval_;
     last_interval_ = end_part.last_interval_;
 
 
