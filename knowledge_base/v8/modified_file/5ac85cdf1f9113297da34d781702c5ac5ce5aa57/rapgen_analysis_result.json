{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/5ac85cdf1f9113297da34d781702c5ac5ce5aa57",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/5ac85cdf1f9113297da34d781702c5ac5ce5aa57/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/5ac85cdf1f9113297da34d781702c5ac5ce5aa57/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/v8/modified_file/5ac85cdf1f9113297da34d781702c5ac5ce5aa57/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 574,
          "old_api": "opcode",
          "new_api": "empty",
          "old_text": "node->opcode()",
          "new_text": "queue.empty()",
          "old_line_content": "    if (node->opcode() == IrOpcode::kEnd) {",
          "new_line_content": "  while (!queue.empty()) {",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "size",
          "new_api": "erase",
          "old_text": "visited->size()",
          "new_text": "visited->erase(node)",
          "old_line_content": "    if (visited->size() > max_size) return nullptr;",
          "new_line_content": "      visited->erase(node);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "opcode",
          "new_api": "InputAt",
          "old_text": "use->opcode()",
          "new_text": "node->InputAt(1)",
          "old_line_content": "                           use->opcode() == IrOpcode::kLoopExitValue))",
          "new_line_content": "        if (node->InputAt(1) != loop_header) return nullptr;",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "InputAt",
          "new_api": "ENQUEUE_USES",
          "old_text": "node->InputAt(0)",
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "        Node* callee = node->InputAt(0);",
          "new_line_content": "          ENQUEUE_USES(use, true);",
          "content_same": false
        },
        {
          "line": 641,
          "old_api": "ENQUEUE_USES",
          "new_api": "std::end(unrollable_builtins)",
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": "std::end(unrollable_builtins)",
          "old_line_content": "        ENQUEUE_USES(use, true)",
          "new_line_content": "                       std::end(unrollable_builtins), info) == 0) {",
          "content_same": false
        },
        {
          "line": 654,
          "old_api": "ENQUEUE_USES",
          "new_api": "end",
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": "visited->end()",
          "old_line_content": "        ENQUEUE_USES(use, true);",
          "new_line_content": "            visited->find(object) != visited->end()) {",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "to",
          "new_api": "IsLive",
          "old_text": "edge.to()",
          "new_text": "all_nodes.IsLive(node)",
          "old_line_content": "      Node* input = edge.to();",
          "new_line_content": "    if (!all_nodes.IsLive(node)) continue;",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "opcode",
          "new_api": "input_edges",
          "old_text": "input->opcode()",
          "new_text": "node->input_edges()",
          "old_line_content": "          input->opcode() != IrOpcode::kStart) {",
          "new_line_content": "    for (Edge edge : node->input_edges()) {",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "id",
          "new_api": "to",
          "old_text": "FATAL(\n            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"\n            \"inside loop headed by #%d, but its control dependency #%d:%s is \"\n            \"outside\",\n            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),\n            input->op()->mnemonic())",
          "new_text": "edge.to()",
          "old_line_content": "        FATAL(",
          "new_line_content": "      Node* input = edge.to();",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "Contains",
          "new_api": "GetLoopControl",
          "old_text": "loop_tree->Contains(loop, use)",
          "new_text": "loop_tree->GetLoopControl(loop)",
          "old_line_content": "      if (!loop_tree->Contains(loop, use)) {",
          "new_line_content": "  Node* loop_node = loop_tree->GetLoopControl(loop);",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "opcode",
          "new_api": "uses",
          "old_text": "node->opcode()",
          "new_text": "node->uses()",
          "old_line_content": "        switch (node->opcode()) {",
          "new_line_content": "    for (Node* use : node->uses()) {",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": "opcode",
          "new_api": "InputAt",
          "old_text": "use->opcode()",
          "new_text": "node->InputAt(1)->InputAt(1)",
          "old_line_content": "            unmarked_exit = (use->opcode() != IrOpcode::kTerminate);",
          "new_line_content": "            unmarked_exit = (node->InputAt(1)->InputAt(1) != loop_node);",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "NodeProperties::GetControlInput(first)",
          "new_api": "begin",
          "old_text": "NodeProperties::GetControlInput(first)",
          "new_text": "HeaderNodes(loop).begin()",
          "old_line_content": "  Node* header = NodeProperties::GetControlInput(first);",
          "new_line_content": "  Node* first = *HeaderNodes(loop).begin();",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "end",
          "new_api": "size",
          "old_text": "new_copies.end()",
          "new_text": "new_copies.size()",
          "old_line_content": "  copies_->insert(copies_->end(), new_copies.begin(), new_copies.end());",
          "new_line_content": "  DCHECK_EQ(new_copies.size(), copy_count_);",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": "push_back",
          "new_api": "DCHECK_EQ",
          "old_text": "copies_->push_back(copy)",
          "new_text": "DCHECK_EQ(copy_count_, 1)",
          "old_line_content": "  copies_->push_back(copy);",
          "new_line_content": "  DCHECK_EQ(copy_count_, 1);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 640,
          "old_api": null,
          "new_api": "std::begin(unrollable_builtins)",
          "old_text": null,
          "new_text": "std::begin(unrollable_builtins)",
          "old_line_content": "        }",
          "new_line_content": "        if (std::count(std::begin(unrollable_builtins),",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "      case IrOpcode::kWasmStructGet: {",
          "new_line_content": "        ENQUEUE_USES(use, true)",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "node->InputAt(0)",
          "old_line_content": "          has_instruction_worth_peeling = true;",
          "new_line_content": "        Node* object = node->InputAt(0);",
          "content_same": false
        },
        {
          "line": 653,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "object->opcode()",
          "old_line_content": "        }",
          "new_line_content": "        if (object->opcode() == IrOpcode::kWasmStructGet &&",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "      case IrOpcode::kStringPrepareForGetCodeunit:",
          "new_line_content": "        ENQUEUE_USES(use, true);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "  }",
          "new_line_content": "        ENQUEUE_USES(use, true)",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "visited->count(input)",
          "old_line_content": "            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"",
          "new_line_content": "      if (NodeProperties::IsControlEdge(edge) && visited->count(input) == 0 &&",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "input->opcode()",
          "old_line_content": "            \"inside loop headed by #%d, but its control dependency #%d:%s is \"",
          "new_line_content": "          input->opcode() != IrOpcode::kStart) {",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "FATAL(\n            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"\n            \"inside loop headed by #%d, but its control dependency #%d:%s is \"\n            \"outside\",\n            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),\n            input->op()->mnemonic())",
          "old_line_content": "            \"outside\",",
          "new_line_content": "        FATAL(",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "input->id()",
          "old_line_content": "    }",
          "new_line_content": "            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "input->op()->mnemonic()",
          "old_line_content": "  }",
          "new_line_content": "            input->op()->mnemonic());",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "visited->insert(loop_header)",
          "old_line_content": "",
          "new_line_content": "  visited->insert(loop_header);",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "back",
          "old_text": null,
          "new_text": "queue.back()",
          "old_line_content": "      // We reached the end of the graph. The end node is not part of the loop.",
          "new_line_content": "    Node* node = queue.back();",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "pop_back",
          "old_text": null,
          "new_text": "queue.pop_back()",
          "old_line_content": "      continue;",
          "new_line_content": "    queue.pop_back();",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "node->opcode()",
          "old_line_content": "    }",
          "new_line_content": "    if (node->opcode() == IrOpcode::kEnd) {",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "visited->size()",
          "old_line_content": "        // Found nested loop.",
          "new_line_content": "    if (visited->size() > max_size) return nullptr;",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "node->opcode()",
          "old_line_content": "        if (node != loop_header) return nullptr;",
          "new_line_content": "    switch (node->opcode()) {",
          "content_same": false
        },
        {
          "line": 710,
          "old_api": null,
          "new_api": "LoopNodes",
          "old_text": null,
          "new_text": "loop_tree->LoopNodes(loop)",
          "old_line_content": "        bool unmarked_exit;",
          "new_line_content": "  for (Node* node : loop_tree->LoopNodes(loop)) {",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": null,
          "new_api": "Contains",
          "old_text": null,
          "new_text": "loop_tree->Contains(loop, use)",
          "old_line_content": "          case IrOpcode::kLoopExit:",
          "new_line_content": "      if (!loop_tree->Contains(loop, use)) {",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "node->opcode()",
          "old_line_content": "            break;",
          "new_line_content": "        switch (node->opcode()) {",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "        // Found nested loop.",
          "new_line_content": "        ENQUEUE_USES(use, true);",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "node->InputAt(1)",
          "old_line_content": "          case IrOpcode::kLoopExitEffect:",
          "new_line_content": "            unmarked_exit = (node->InputAt(1) != loop_node);",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use->opcode()",
          "old_line_content": "      case IrOpcode::kLoopExitEffect:",
          "new_line_content": "        ENQUEUE_USES(use, (use->opcode() == IrOpcode::kLoopExitEffect ||",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use->opcode()",
          "old_line_content": "      case IrOpcode::kLoopExitValue:",
          "new_line_content": "                           use->opcode() == IrOpcode::kLoopExitValue))",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "use->opcode()",
          "old_line_content": "          if (v8_flags.trace_turbo_loop) {",
          "new_line_content": "            unmarked_exit = (use->opcode() != IrOpcode::kTerminate);",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "NodeProperties::GetControlInput(node)->InputAt(1)",
          "old_line_content": "        }",
          "new_line_content": "        if (NodeProperties::GetControlInput(node)->InputAt(1) != loop_header) {",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "id",
          "old_text": null,
          "new_text": "use->id()",
          "old_line_content": "          return false;",
          "new_line_content": "                loop_node->id(), node->id(), node->op()->mnemonic(), use->id(),",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "use->op()->mnemonic()",
          "old_line_content": "        }",
          "new_line_content": "                use->op()->mnemonic());",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "ENQUEUE_USES",
          "old_text": null,
          "new_text": "ENQUEUE_USES(use, true)",
          "old_line_content": "        if (purpose == Purpose::kLoopPeeling) {",
          "new_line_content": "        ENQUEUE_USES(use, true)",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "first->opcode()",
          "old_line_content": "  return header;",
          "new_line_content": "  DCHECK(IrOpcode::IsPhiOpcode(first->opcode()));",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": null,
          "new_api": "InputAt",
          "old_text": null,
          "new_text": "node->InputAt(0)",
          "old_line_content": "          return nullptr;",
          "new_line_content": "        Node* callee = node->InputAt(0);",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "callee->opcode()",
          "old_line_content": "        }",
          "new_line_content": "        if (callee->opcode() != IrOpcode::kRelocatableInt32Constant &&",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "callee->opcode()",
          "old_line_content": "        intptr_t info =",
          "new_line_content": "            callee->opcode() != IrOpcode::kRelocatableInt64Constant) {",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": null,
          "new_api": "NodeProperties::GetControlInput(first)",
          "old_text": null,
          "new_text": "NodeProperties::GetControlInput(first)",
          "old_line_content": "}",
          "new_line_content": "  Node* header = NodeProperties::GetControlInput(first);",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "opcode",
          "old_text": null,
          "new_text": "header->opcode()",
          "old_line_content": "",
          "new_line_content": "  DCHECK_EQ(IrOpcode::kLoop, header->opcode());",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": null,
          "new_api": "op",
          "old_text": null,
          "new_text": "callee->op()",
          "old_line_content": "            // Exists in every stack check.",
          "new_line_content": "            OpParameter<RelocatablePtrConstantInfo>(callee->op()).value();",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "DCHECK_LT",
          "old_text": null,
          "new_text": "DCHECK_LT(copy_index, copy_count_)",
          "old_line_content": "}",
          "new_line_content": "  DCHECK_LT(copy_index, copy_count_);",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "            // Fast table operations.",
          "new_line_content": "        constexpr intptr_t unrollable_builtins[] = {",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_map_.Get(node)",
          "old_line_content": "",
          "new_line_content": "  if (node_map_.Get(node) == 0) return node;",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": null,
          "new_api": "Get",
          "old_text": null,
          "new_text": "node_map_.Get(node)",
          "old_line_content": "void NodeCopier::Insert(Node* original, const NodeVector& new_copies) {",
          "new_line_content": "  return copies_->at(node_map_.Get(node) + copy_index);",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "copies_->size()",
          "old_line_content": "}",
          "new_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copies_->push_back(original)",
          "old_line_content": "",
          "new_line_content": "  copies_->push_back(original);",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "new_copies.end()",
          "old_line_content": "void NodeCopier::Insert(Node* original, Node* copy) {",
          "new_line_content": "  copies_->insert(copies_->end(), new_copies.begin(), new_copies.end());",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "copies_->size()",
          "old_line_content": "}",
          "new_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copies_->push_back(original)",
          "old_line_content": "",
          "new_line_content": "  copies_->push_back(original);",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "copies_->push_back(copy)",
          "old_line_content": "}  // namespace compiler",
          "new_line_content": "  copies_->push_back(copy);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 649,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "node->InputAt(0)",
          "new_text": null,
          "old_line_content": "        Node* object = node->InputAt(0);",
          "new_line_content": "        // help.",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "object->opcode()",
          "new_text": null,
          "old_line_content": "        if (object->opcode() == IrOpcode::kWasmStructGet &&",
          "new_line_content": "        // Extending this idea to array.get/array.len has been found to hurt",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": "end",
          "new_api": null,
          "old_text": "visited->end()",
          "new_text": null,
          "old_line_content": "            visited->find(object) != visited->end()) {",
          "new_line_content": "        // more than it helps (tested on Sheets, Feb 2023).",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "ENQUEUE_USES",
          "new_api": null,
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": null,
          "old_line_content": "        ENQUEUE_USES(use, true)",
          "new_line_content": "        has_instruction_worth_peeling = true;",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "IsLive",
          "new_api": null,
          "old_text": "all_nodes.IsLive(node)",
          "new_text": null,
          "old_line_content": "    if (!all_nodes.IsLive(node)) continue;",
          "new_line_content": "    // The loop header is allowed to point outside the loop.",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "input_edges",
          "new_api": null,
          "old_text": "node->input_edges()",
          "new_text": null,
          "old_line_content": "    for (Edge edge : node->input_edges()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "count",
          "new_api": null,
          "old_text": "visited->count(input)",
          "new_text": null,
          "old_line_content": "      if (NodeProperties::IsControlEdge(edge) && visited->count(input) == 0 &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": "id",
          "new_api": null,
          "old_text": "input->id()",
          "new_text": null,
          "old_line_content": "            node->id(), node->op()->mnemonic(), loop_header->id(), input->id(),",
          "new_line_content": "            \"Floating control detected in wasm turbofan graph: Node #%d:%s is \"",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "op",
          "new_api": null,
          "old_text": "input->op()->mnemonic()",
          "new_text": null,
          "old_line_content": "            input->op()->mnemonic());",
          "new_line_content": "            \"inside loop headed by #%d, but its control dependency #%d:%s is \"",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "empty",
          "new_api": null,
          "old_text": "queue.empty()",
          "new_text": null,
          "old_line_content": "  while (!queue.empty()) {",
          "new_line_content": "    }                                                 \\",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "back",
          "new_api": null,
          "old_text": "queue.back()",
          "new_text": null,
          "old_line_content": "    Node* node = queue.back();",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "pop_back",
          "new_api": null,
          "old_text": "queue.pop_back()",
          "new_text": null,
          "old_line_content": "    queue.pop_back();",
          "new_line_content": "  bool has_instruction_worth_peeling = false;",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": "insert",
          "new_api": null,
          "old_text": "visited->insert(node)",
          "new_text": null,
          "old_line_content": "    visited->insert(node);",
          "new_line_content": "      // We reached the end of the graph. The end node is not part of the loop.",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": "GetLoopControl",
          "new_api": null,
          "old_text": "loop_tree->GetLoopControl(loop)",
          "new_text": null,
          "old_line_content": "  Node* loop_node = loop_tree->GetLoopControl(loop);",
          "new_line_content": "                                const LoopTree::Loop* loop) {",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "node->opcode()",
          "new_text": null,
          "old_line_content": "    switch (node->opcode()) {",
          "new_line_content": "      continue;",
          "content_same": false
        },
        {
          "line": 707,
          "old_api": "LoopNodes",
          "new_api": null,
          "old_text": "loop_tree->LoopNodes(loop)",
          "new_text": null,
          "old_line_content": "  for (Node* node : loop_tree->LoopNodes(loop)) {",
          "new_line_content": "  // Look for returns and if projections that are outside the loop but whose",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": "uses",
          "new_api": null,
          "old_text": "node->uses()",
          "new_text": null,
          "old_line_content": "    for (Node* use : node->uses()) {",
          "new_line_content": "  // control input is inside the loop.",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "ENQUEUE_USES",
          "new_api": null,
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": null,
          "old_line_content": "        ENQUEUE_USES(use, true);",
          "new_line_content": "      case IrOpcode::kLoop:",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "node->InputAt(1)",
          "new_text": null,
          "old_line_content": "            unmarked_exit = (node->InputAt(1) != loop_node);",
          "new_line_content": "        bool unmarked_exit;",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "node->InputAt(1)",
          "new_text": null,
          "old_line_content": "        if (node->InputAt(1) != loop_header) return nullptr;",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "node->InputAt(1)->InputAt(1)",
          "new_text": null,
          "old_line_content": "            unmarked_exit = (node->InputAt(1)->InputAt(1) != loop_node);",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "use->opcode()",
          "new_text": null,
          "old_line_content": "        ENQUEUE_USES(use, (use->opcode() == IrOpcode::kLoopExitEffect ||",
          "new_line_content": "        // Found nested loop.",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "InputAt",
          "new_api": null,
          "old_text": "NodeProperties::GetControlInput(node)->InputAt(1)",
          "new_text": null,
          "old_line_content": "        if (NodeProperties::GetControlInput(node)->InputAt(1) != loop_header) {",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "id",
          "new_api": null,
          "old_text": "PrintF(\n                \"Cannot peel loop %i. Loop exit without explicit mark: Node %i \"\n                \"(%s) is inside loop, but its use %i (%s) is outside.\\n\",\n                loop_node->id(), node->id(), node->op()->mnemonic(), use->id(),\n                use->op()->mnemonic())",
          "new_text": null,
          "old_line_content": "            PrintF(",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "op",
          "new_api": null,
          "old_text": "use->op()->mnemonic()",
          "new_text": null,
          "old_line_content": "                use->op()->mnemonic());",
          "new_line_content": "                \"Cannot peel loop %i. Loop exit without explicit mark: Node %i \"",
          "content_same": false
        },
        {
          "line": 607,
          "old_api": "ENQUEUE_USES",
          "new_api": null,
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": null,
          "old_line_content": "        ENQUEUE_USES(use, true)",
          "new_line_content": "      case IrOpcode::kJSWasmCall:",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "ENQUEUE_USES",
          "new_api": null,
          "old_text": "ENQUEUE_USES(use, true)",
          "new_text": null,
          "old_line_content": "          ENQUEUE_USES(use, true);",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "begin",
          "new_api": null,
          "old_text": "HeaderNodes(loop).begin()",
          "new_text": null,
          "old_line_content": "  Node* first = *HeaderNodes(loop).begin();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 740,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "first->opcode()",
          "new_text": null,
          "old_line_content": "  if (first->opcode() == IrOpcode::kLoop) return first;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "first->opcode()",
          "new_text": null,
          "old_line_content": "  DCHECK(IrOpcode::IsPhiOpcode(first->opcode()));",
          "new_line_content": "Node* LoopTree::HeaderNode(const Loop* loop) {",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "callee->opcode()",
          "new_text": null,
          "old_line_content": "        if (callee->opcode() != IrOpcode::kRelocatableInt32Constant &&",
          "new_line_content": "          break;",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "opcode",
          "new_api": null,
          "old_text": "callee->opcode()",
          "new_text": null,
          "old_line_content": "            callee->opcode() != IrOpcode::kRelocatableInt64Constant) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "op",
          "new_api": null,
          "old_text": "callee->op()",
          "new_text": null,
          "old_line_content": "            OpParameter<RelocatablePtrConstantInfo>(callee->op()).value();",
          "new_line_content": "          return nullptr;",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "DCHECK_LT",
          "new_api": null,
          "old_text": "DCHECK_LT(copy_index, copy_count_)",
          "new_text": null,
          "old_line_content": "  DCHECK_LT(copy_index, copy_count_);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "        constexpr intptr_t unrollable_builtins[] = {",
          "new_line_content": "        intptr_t info =",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_map_.Get(node)",
          "new_text": null,
          "old_line_content": "  if (node_map_.Get(node) == 0) return node;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 750,
          "old_api": "Get",
          "new_api": null,
          "old_text": "node_map_.Get(node)",
          "new_text": null,
          "old_line_content": "  return copies_->at(node_map_.Get(node) + copy_index);",
          "new_line_content": "Node* NodeCopier::map(Node* node, uint32_t copy_index) {",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": "size",
          "new_api": null,
          "old_text": "new_copies.size()",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(new_copies.size(), copy_count_);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": "size",
          "new_api": null,
          "old_text": "copies_->size()",
          "new_text": null,
          "old_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "copies_->push_back(original)",
          "new_text": null,
          "old_line_content": "  copies_->push_back(original);",
          "new_line_content": "void NodeCopier::Insert(Node* original, const NodeVector& new_copies) {",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": "DCHECK_EQ",
          "new_api": null,
          "old_text": "DCHECK_EQ(copy_count_, 1)",
          "new_text": null,
          "old_line_content": "  DCHECK_EQ(copy_count_, 1);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": "size",
          "new_api": null,
          "old_text": "copies_->size()",
          "new_text": null,
          "old_line_content": "  node_map_.Set(original, copies_->size() + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "copies_->push_back(original)",
          "new_text": null,
          "old_line_content": "  copies_->push_back(original);",
          "new_line_content": "void NodeCopier::Insert(Node* original, Node* copy) {",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "std::begin(unrollable_builtins)",
          "new_api": null,
          "old_text": "std::begin(unrollable_builtins)",
          "new_text": null,
          "old_line_content": "        if (std::count(std::begin(unrollable_builtins),",
          "new_line_content": "            WasmCode::kWasmRethrow, WasmCode::kWasmRethrowExplicitContext,",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "std::end(unrollable_builtins)",
          "new_api": null,
          "old_text": "std::end(unrollable_builtins)",
          "new_text": null,
          "old_line_content": "                       std::end(unrollable_builtins), info) == 0) {",
          "new_line_content": "            // Fast wasm-gc operations.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 15,
      "total_additions": 46,
      "total_deletions": 45,
      "total_api_changes": 106
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 106,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          565,
          566,
          567,
          568,
          569,
          570
        ]
      }
    },
    "api_calls_before": 288,
    "api_calls_after": 289,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 5,
      "total_diff_lines": 35
    }
  }
}