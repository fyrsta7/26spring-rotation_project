diff --git a/test/fuzzer/wasm-deopt.cc b/test/fuzzer/wasm-deopt.cc
index 383b18c5fc5..2628d47839e 100644
--- a/test/fuzzer/wasm-deopt.cc
+++ b/test/fuzzer/wasm-deopt.cc
@@ -166,7 +166,6 @@ std::vector<ExecutionResult> PerformReferenceRun(
 }
 
 int FuzzIt(base::Vector<const uint8_t> data) {
-  int deopt_count_before = GetWasmEngine()->GetDeoptsExecutedCount();
   v8_fuzzer::FuzzerSupport* support = v8_fuzzer::FuzzerSupport::Get();
   v8::Isolate* isolate = support->GetIsolate();
 
@@ -263,6 +262,8 @@ int FuzzIt(base::Vector<const uint8_t> data) {
     function_to_optimize--;
   }
 
+  int deopt_count_begin = GetWasmEngine()->GetDeoptsExecutedCount();
+  int deopt_count_previous_iteration = deopt_count_begin;
   size_t num_callees = reference_results.size();
   for (uint32_t i = 0; i < num_callees; ++i) {
     auto arguments = base::OwnedVector<Handle<Object>>::New(1);
@@ -284,15 +285,21 @@ int FuzzIt(base::Vector<const uint8_t> data) {
       UNREACHABLE();
     }
 
+    int deopt_count = GetWasmEngine()->GetDeoptsExecutedCount();
+    if (i != 0 && deopt_count == deopt_count_previous_iteration) {
+      // No deopt triggered. Skip the rest of the run as it won't provide
+      // meaningful coverage for the deoptimizer.
+      // Return -1 to prevent adding this case to the corpus if not a single
+      // deopt was executed.
+      return deopt_count == deopt_count_begin ? -1 : 0;
+    }
+    deopt_count_previous_iteration = deopt_count;
+
     TierUpNowForTesting(i_isolate, instance->trusted_data(i_isolate),
                         function_to_optimize);
   }
 
-  // If no deopt was triggered, return -1 to prevent adding this case to the
-  // corpus.
-  bool deopt_triggered =
-      GetWasmEngine()->GetDeoptsExecutedCount() != deopt_count_before;
-  return deopt_triggered ? 0 : -1;
+  return 0;
 }
 
 }  // anonymous namespace
