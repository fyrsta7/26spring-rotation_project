{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/476964303e6da6913caf1a498e228bf79a748aca",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/476964303e6da6913caf1a498e228bf79a748aca/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/476964303e6da6913caf1a498e228bf79a748aca/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/476964303e6da6913caf1a498e228bf79a748aca/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 905,
          "old_api": "clear",
          "new_api": "setSize",
          "old_text": "clear()",
          "new_text": "this->setSize(0)",
          "old_line_content": "    clear();",
          "new_line_content": "    this->setSize(0);",
          "content_same": false
        },
        {
          "line": 910,
          "old_api": "end",
          "new_api": "clear",
          "old_text": "il.end()",
          "new_text": "clear()",
          "old_line_content": "    assign(il.begin(), il.end());",
          "new_line_content": "    clear();",
          "content_same": false
        },
        {
          "line": 919,
          "old_api": "empty",
          "new_api": "clear",
          "old_text": "empty()",
          "new_text": "clear()",
          "old_line_content": "    assert(!empty());",
          "new_line_content": "    clear();",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "begin",
          "new_api": "end",
          "old_text": "begin()",
          "new_text": "end()",
          "old_line_content": "    return *begin();",
          "new_line_content": "    insert(end(), n, t);",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": "end",
          "new_api": "empty",
          "old_text": "end()",
          "new_text": "empty()",
          "old_line_content": "    return *(end() - 1);",
          "new_line_content": "    assert(!empty());",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "begin",
          "new_api": "empty",
          "old_text": "begin()",
          "new_text": "empty()",
          "old_line_content": "    return *begin();",
          "new_line_content": "    assert(!empty());",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": "end",
          "new_api": "empty",
          "old_text": "end()",
          "new_text": "empty()",
          "old_line_content": "    return *(end() - 1);",
          "new_line_content": "    assert(!empty());",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "size",
          "new_api": "empty",
          "old_text": "size()",
          "new_text": "empty()",
          "old_line_content": "    assert(i < size());",
          "new_line_content": "    assert(!empty());",
          "content_same": false
        },
        {
          "line": 937,
          "old_api": "begin",
          "new_api": "end",
          "old_text": "begin()",
          "new_text": "end()",
          "old_line_content": "    return *(begin() + i);",
          "new_line_content": "    return *(end() - 1);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": "throw_exception<std::out_of_range>(\"index out of range\")",
          "new_api": "begin",
          "old_text": "throw_exception<std::out_of_range>(\"index out of range\")",
          "new_text": "begin()",
          "old_line_content": "      throw_exception<std::out_of_range>(\"index out of range\");",
          "new_line_content": "    return *(begin() + i);",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "assert",
          "new_api": "begin",
          "old_text": "assert(distance >= 0)",
          "new_text": "begin()",
          "old_line_content": "    assert(distance >= 0);",
          "new_line_content": "      return begin() + offset;",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "detail::moveObjectsRightAndCreate(\n        data() + offset,\n        data() + size(),\n        data() + size() + distance,\n        [&](size_t i) -> it_ref {\n          assert(i < size_t(distance));\n          return *(first + i);\n        })",
          "new_api": "std::distance(first, last)",
          "old_text": "detail::moveObjectsRightAndCreate(\n        data() + offset,\n        data() + size(),\n        data() + size() + distance,\n        [&](size_t i) -> it_ref {\n          assert(i < size_t(distance));\n          return *(first + i);\n        })",
          "new_text": "std::distance(first, last)",
          "old_line_content": "    detail::moveObjectsRightAndCreate(",
          "new_line_content": "    auto const distance = std::distance(first, last);",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "data",
          "new_api": "begin",
          "old_text": "data()",
          "new_text": "begin()",
          "old_line_content": "        data() + offset,",
          "new_line_content": "    auto const offset = pos - begin();",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "size",
          "new_api": "assert",
          "old_text": "size()",
          "new_text": "assert(distance >= 0)",
          "old_line_content": "        data() + size(),",
          "new_line_content": "    assert(distance >= 0);",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "size",
          "new_api": "assert",
          "old_text": "size()",
          "new_text": "assert(offset >= 0)",
          "old_line_content": "        data() + size() + distance,",
          "new_line_content": "    assert(offset >= 0);",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "assert",
          "new_api": "detail::moveObjectsRightAndCreate(\n        data() + offset,\n        data() + size(),\n        data() + size() + distance,\n        [&](size_t i) -> it_ref {\n          assert(i < size_t(distance));\n          return *(first + i);\n        })",
          "old_text": "assert(i < size_t(distance))",
          "new_text": "detail::moveObjectsRightAndCreate(\n        data() + offset,\n        data() + size(),\n        data() + size() + distance,\n        [&](size_t i) -> it_ref {\n          assert(i < size_t(distance));\n          return *(first + i);\n        })",
          "old_line_content": "          assert(i < size_t(distance));",
          "new_line_content": "    detail::moveObjectsRightAndCreate(",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "std::distance(first, last)",
          "new_api": "emplace_back",
          "old_text": "std::distance(first, last)",
          "new_text": "emplace_back(*first++)",
          "old_line_content": "    auto distance = std::distance(first, last);",
          "new_line_content": "        emplace_back(*first++);",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "isExtern",
          "new_api": "std::distance(first, last)",
          "old_text": "this->isExtern()",
          "new_text": "std::distance(first, last)",
          "old_line_content": "        if (this->isExtern()) {",
          "new_line_content": "    auto distance = std::distance(first, last);",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "freeHeap",
          "new_api": "makeSize",
          "old_text": "u.freeHeap()",
          "new_text": "makeSize(distance)",
          "old_line_content": "          u.freeHeap();",
          "new_line_content": "    makeSize(distance);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "detail::populateMemForward(\n          data(), distance, [&](void* p) { new (p) value_type(*first++); })",
          "new_api": "freeHeap",
          "old_text": "detail::populateMemForward(\n          data(), distance, [&](void* p) { new (p) value_type(*first++); })",
          "new_text": "makeGuard([&] {\n        if (this->isExtern()) {\n          u.freeHeap();\n        }\n      })",
          "old_line_content": "      detail::populateMemForward(",
          "new_line_content": "      auto rollback = makeGuard([&] {",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "data",
          "new_api": "isExtern",
          "old_text": "data()",
          "new_text": "this->isExtern()",
          "old_line_content": "          data(), distance, [&](void* p) { new (p) value_type(*first++); });",
          "new_line_content": "        if (this->isExtern()) {",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "dismiss",
          "new_api": "freeHeap",
          "old_text": "rollback.dismiss()",
          "new_text": "u.freeHeap()",
          "old_line_content": "      rollback.dismiss();",
          "new_line_content": "          u.freeHeap();",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "freeHeap",
          "new_api": "makeSize",
          "old_text": "u.freeHeap()",
          "new_text": "makeSize(n)",
          "old_line_content": "          u.freeHeap();",
          "new_line_content": "    makeSize(n);",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": "std::forward<InitFunc>(func)",
          "new_api": "freeHeap",
          "old_text": "std::forward<InitFunc>(func)",
          "new_text": "makeGuard([&] {\n        if (this->isExtern()) {\n          u.freeHeap();\n        }\n      })",
          "old_line_content": "      detail::populateMemForward(data(), n, std::forward<InitFunc>(func));",
          "new_line_content": "      auto rollback = makeGuard([&] {",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": "dismiss",
          "new_api": "isExtern",
          "old_text": "rollback.dismiss()",
          "new_text": "this->isExtern()",
          "old_line_content": "      rollback.dismiss();",
          "new_line_content": "        if (this->isExtern()) {",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "capacity",
          "new_api": "assume_unreachable",
          "old_text": "capacity()",
          "new_text": "assume_unreachable()",
          "old_line_content": "    assert(size() == capacity());",
          "new_line_content": "    makeSizeInternal(newSize, false, [](void*) { assume_unreachable(); }, 0);",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "assert",
          "new_api": "capacity",
          "old_text": "assert(this->kShouldUseHeap)",
          "new_text": "capacity()",
          "old_line_content": "    assert(this->kShouldUseHeap);",
          "new_line_content": "    if (newSize <= capacity()) {",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": "static_cast<value_type*>(\n        heapifyCapacity ? detail::shiftPointer(newh, kHeapifyCapacitySize)\n                        : newh)",
          "new_api": "checkedMalloc",
          "old_text": "static_cast<value_type*>(\n        heapifyCapacity ? detail::shiftPointer(newh, kHeapifyCapacitySize)\n                        : newh)",
          "new_text": "checkedMalloc(sizeBytes)",
          "old_line_content": "    value_type* newp = static_cast<value_type*>(",
          "new_line_content": "    void* newh = checkedMalloc(sizeBytes);",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "makeGuard",
          "new_api": "static_cast<value_type*>(\n        heapifyCapacity ? detail::shiftPointer(newh, kHeapifyCapacitySize)\n                        : newh)",
          "old_text": "makeGuard([&] { //\n        sizedFree(newh, sizeBytes);\n      })",
          "new_text": "static_cast<value_type*>(\n        heapifyCapacity ? detail::shiftPointer(newh, kHeapifyCapacitySize)\n                        : newh)",
          "old_line_content": "      auto rollback = makeGuard([&] { //",
          "new_line_content": "    value_type* newp = static_cast<value_type*>(",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "sizedFree",
          "new_api": "detail::shiftPointer(newh, kHeapifyCapacitySize)",
          "old_text": "sizedFree(newh, sizeBytes)",
          "new_text": "detail::shiftPointer(newh, kHeapifyCapacitySize)",
          "old_line_content": "        sizedFree(newh, sizeBytes);",
          "new_line_content": "        heapifyCapacity ? detail::shiftPointer(newh, kHeapifyCapacitySize)",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "moveToUninitializedEmplace",
          "new_api": "makeGuard",
          "old_text": "this->moveToUninitializedEmplace(\n            begin(), end(), newp, pos, std::forward<EmplaceFunc>(emplaceFunc))",
          "new_text": "makeGuard([&] { //\n        sizedFree(newh, sizeBytes);\n      })",
          "old_line_content": "        this->moveToUninitializedEmplace(",
          "new_line_content": "      auto rollback = makeGuard([&] { //",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "std::forward<EmplaceFunc>(emplaceFunc)",
          "new_api": "sizedFree",
          "old_text": "std::forward<EmplaceFunc>(emplaceFunc)",
          "new_text": "sizedFree(newh, sizeBytes)",
          "old_line_content": "            begin(), end(), newp, pos, std::forward<EmplaceFunc>(emplaceFunc));",
          "new_line_content": "        sizedFree(newh, sizeBytes);",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "dismiss",
          "new_api": "std::forward<EmplaceFunc>(emplaceFunc)",
          "old_text": "rollback.dismiss()",
          "new_text": "std::forward<EmplaceFunc>(emplaceFunc)",
          "old_line_content": "      rollback.dismiss();",
          "new_line_content": "            begin(), end(), newp, pos, std::forward<EmplaceFunc>(emplaceFunc));",
          "content_same": false
        },
        {
          "line": 1148,
          "old_api": "val.~value_type()",
          "new_api": "end",
          "old_text": "val.~value_type()",
          "new_text": "end()",
          "old_line_content": "      val.~value_type();",
          "new_line_content": "        this->moveToUninitialized(begin(), end(), newp);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "setCapacity",
          "new_api": "detail::pointerFlagSet(newh)",
          "old_text": "this->setCapacity(newCapacity)",
          "new_text": "detail::pointerFlagSet(newh)",
          "old_line_content": "    this->setCapacity(newCapacity);",
          "new_line_content": "      u.pdata_.heap_ = detail::pointerFlagSet(newh);",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "heap",
          "new_api": "detail::shiftPointer(\n            detail::pointerFlagClear(pdata_.heap_), kHeapifyCapacitySize)",
          "old_text": "const_cast<Data*>(this)->heap()",
          "new_text": "detail::shiftPointer(\n            detail::pointerFlagClear(pdata_.heap_), kHeapifyCapacitySize)",
          "old_line_content": "      return const_cast<Data*>(this)->heap();",
          "new_line_content": "        return static_cast<value_type*>(detail::shiftPointer(",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "hasCapacity",
          "new_api": "setCapacity",
          "old_text": "hasCapacity()",
          "new_text": "pdata_.setCapacity(c)",
          "old_line_content": "      if (hasCapacity()) {",
          "new_line_content": "      pdata_.setCapacity(c);",
          "content_same": false
        },
        {
          "line": 1275,
          "old_api": "allocationExtraBytes",
          "new_api": "detail::pointerFlagClear(pdata_.heap_)",
          "old_text": "pdata_.allocationExtraBytes()",
          "new_text": "detail::pointerFlagClear(pdata_.heap_)",
          "old_line_content": "                pdata_.allocationExtraBytes());",
          "new_line_content": "      auto vp = detail::pointerFlagClear(pdata_.heap_);",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "free",
          "new_api": "getCapacity",
          "old_text": "free(vp)",
          "new_text": "sizedFree(\n            vp,\n            pdata_.getCapacity() * sizeof(value_type) +\n                pdata_.allocationExtraBytes())",
          "old_line_content": "        free(vp);",
          "new_line_content": "        sizedFree(",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": "end",
          "new_api": "swap",
          "old_text": "v.end()",
          "new_text": "a.swap(b)",
          "old_line_content": "  v.erase(std::remove(v.begin(), v.end(), value), v.end());",
          "new_line_content": "  a.swap(b);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1280,
          "old_api": null,
          "new_api": "allocationExtraBytes",
          "old_text": null,
          "new_text": "pdata_.allocationExtraBytes()",
          "old_line_content": "  } u;",
          "new_line_content": "                pdata_.allocationExtraBytes());",
          "content_same": false
        },
        {
          "line": 1025,
          "old_api": null,
          "new_api": "setSize",
          "old_text": null,
          "new_text": "this->setSize(distance)",
          "old_line_content": "        }",
          "new_line_content": "    this->setSize(distance);",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "val.~value_type()",
          "old_text": null,
          "new_text": "val.~value_type()",
          "old_line_content": "    }",
          "new_line_content": "      val.~value_type();",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "free",
          "old_text": null,
          "new_text": "free(vp)",
          "old_line_content": "FOLLY_SV_PACK_POP",
          "new_line_content": "        free(vp);",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": null,
          "new_api": "isExtern",
          "old_text": null,
          "new_text": "this->isExtern()",
          "old_line_content": "    } else {",
          "new_line_content": "    if (this->isExtern()) {",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": null,
          "new_api": "freeHeap",
          "old_text": null,
          "new_text": "u.freeHeap()",
          "old_line_content": "      u.pdata_.heap_ = newh;",
          "new_line_content": "      u.freeHeap();",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "end()",
          "old_line_content": "",
          "new_line_content": "    for (auto it = begin(); it != end(); ++it) {",
          "content_same": false
        },
        {
          "line": 903,
          "old_api": null,
          "new_api": "it->~value_type()",
          "old_text": null,
          "new_text": "it->~value_type()",
          "old_line_content": "  template <class Arg>",
          "new_line_content": "      it->~value_type();",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": null,
          "new_api": "detail::populateMemForward(\n          data(), distance, [&](void* p) { new (p) value_type(*first++); })",
          "old_text": null,
          "new_text": "detail::populateMemForward(\n          data(), distance, [&](void* p) { new (p) value_type(*first++); })",
          "old_line_content": "",
          "new_line_content": "      detail::populateMemForward(",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "data()",
          "old_line_content": "  template <typename InitFunc>",
          "new_line_content": "          data(), distance, [&](void* p) { new (p) value_type(*first++); });",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "dismiss",
          "old_text": null,
          "new_text": "rollback.dismiss()",
          "old_line_content": "  void doConstruct(size_type n, InitFunc&& func) {",
          "new_line_content": "      rollback.dismiss();",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": null,
          "new_api": "setExtern",
          "old_text": null,
          "new_text": "this->setExtern(true)",
          "old_line_content": "   * This will set the capacity field, stored inline in the storage_ field",
          "new_line_content": "    this->setExtern(true);",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": null,
          "new_api": "setCapacity",
          "old_text": null,
          "new_text": "this->setCapacity(newCapacity)",
          "old_line_content": "   * if there is sufficient room to store it.",
          "new_line_content": "    this->setCapacity(newCapacity);",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "end()",
          "old_line_content": "  }",
          "new_line_content": "    insert(end(), first, last);",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "setSize",
          "old_text": null,
          "new_text": "this->setSize(n)",
          "old_line_content": "        }",
          "new_line_content": "    this->setSize(n);",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "freeHeap",
          "old_text": null,
          "new_text": "u.freeHeap()",
          "old_line_content": "    }",
          "new_line_content": "          u.freeHeap();",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": null,
          "new_api": "isExtern",
          "old_text": null,
          "new_text": "this->isExtern()",
          "old_line_content": "  }",
          "new_line_content": "    assert(this->isExtern());",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "hasCapacity",
          "old_text": null,
          "new_text": "u.hasCapacity()",
          "old_line_content": "",
          "new_line_content": "    if (u.hasCapacity()) {",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "std::forward<InitFunc>(func)",
          "old_text": null,
          "new_text": "std::forward<InitFunc>(func)",
          "old_line_content": "  // The true_type means we should forward to the size_t,value_type",
          "new_line_content": "      detail::populateMemForward(data(), n, std::forward<InitFunc>(func));",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "dismiss",
          "old_text": null,
          "new_text": "rollback.dismiss()",
          "old_line_content": "  // overload.",
          "new_line_content": "      rollback.dismiss();",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "newCapacity < std::numeric_limits<InternalSizeType>::max()",
          "old_text": null,
          "new_text": "newCapacity < std::numeric_limits<InternalSizeType>::max()",
          "old_line_content": " private:",
          "new_line_content": "      assert(newCapacity < std::numeric_limits<InternalSizeType>::max());",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "setCapacity",
          "old_text": null,
          "new_text": "u.setCapacity(newCapacity)",
          "old_line_content": "  struct HeapPtrWithCapacity {",
          "new_line_content": "      u.setCapacity(newCapacity);",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "v.end()",
          "old_line_content": "    std::size_t MaxInline,",
          "new_line_content": "  v.erase(std::remove(v.begin(), v.end(), value), v.end());",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "begin()",
          "old_line_content": "  }",
          "new_line_content": "    return *begin();",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "doConstruct",
          "old_text": null,
          "new_text": "doConstruct(n, [&](void* p) { new (p) value_type(val); })",
          "old_line_content": "   */",
          "new_line_content": "    doConstruct(n, [&](void* p) { new (p) value_type(val); });",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "end()",
          "old_line_content": "  }",
          "new_line_content": "    return *(end() - 1);",
          "content_same": false
        },
        {
          "line": 1313,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "v.end()",
          "old_line_content": "namespace detail {",
          "new_line_content": "  v.erase(std::remove_if(v.begin(), v.end(), predicate), v.end());",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "begin()",
          "old_line_content": "  }",
          "new_line_content": "    return *begin();",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": null,
          "new_api": "max_size",
          "old_text": null,
          "new_text": "max_size()",
          "old_line_content": "  }",
          "new_line_content": "    return std::min((3 * capacity()) / 2 + 1, max_size());",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": null,
          "new_api": "capacity",
          "old_text": null,
          "new_text": "capacity()",
          "old_line_content": "  /*",
          "new_line_content": "    assert(size() == capacity());",
          "content_same": false
        },
        {
          "line": 1073,
          "old_api": null,
          "new_api": "makeSizeInternal",
          "old_text": null,
          "new_text": "makeSizeInternal(\n        newSize, true, std::forward<EmplaceFunc>(emplaceFunc), pos)",
          "old_line_content": "   * Ensure we have a large enough memory region to be size `newSize'.",
          "new_line_content": "    makeSizeInternal(",
          "content_same": false
        },
        {
          "line": 1074,
          "old_api": null,
          "new_api": "std::forward<EmplaceFunc>(emplaceFunc)",
          "old_text": null,
          "new_text": "std::forward<EmplaceFunc>(emplaceFunc)",
          "old_line_content": "   * Will move/copy elements if we are spilling to heap_ or needed to",
          "new_line_content": "        newSize, true, std::forward<EmplaceFunc>(emplaceFunc), pos);",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": null,
          "new_api": "detail::pointerFlagGet(heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagGet(heap_)",
          "old_line_content": "    }",
          "new_line_content": "      assert(detail::pointerFlagGet(heap_));",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": null,
          "new_api": "detail::pointerFlagClear(heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagClear(heap_)",
          "old_line_content": "    size_t allocationExtraBytes() const {",
          "new_line_content": "      return *static_cast<InternalSizeType*>(detail::pointerFlagClear(heap_));",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": null,
          "new_api": "detail::pointerFlagClear(heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagClear(heap_)",
          "old_line_content": "    }",
          "new_line_content": "      *static_cast<InternalSizeType*>(detail::pointerFlagClear(heap_)) = c;",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "",
          "new_line_content": "    if (i >= size()) {",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "throw_exception<std::out_of_range>(\"index out of range\")",
          "old_text": null,
          "new_text": "throw_exception<std::out_of_range>(\"index out of range\")",
          "old_line_content": "  const_reference at(size_type i) const {",
          "new_line_content": "      throw_exception<std::out_of_range>(\"index out of range\");",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": null,
          "new_api": "detail::pointerFlagGet(heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagGet(heap_)",
          "old_line_content": "  typedef aligned_storage_for_t<value_type[MaxInline]> InlineStorageDataType;",
          "new_line_content": "      assert(detail::pointerFlagGet(heap_));",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "",
          "new_line_content": "    if (i >= size()) {",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": null,
          "new_api": "throw_exception<std::out_of_range>(\"index out of range\")",
          "old_text": null,
          "new_text": "throw_exception<std::out_of_range>(\"index out of range\")",
          "old_line_content": " private:",
          "new_line_content": "      throw_exception<std::out_of_range>(\"index out of range\");",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": null,
          "new_api": "max_size",
          "old_text": null,
          "new_text": "max_size()",
          "old_line_content": "      return;",
          "new_line_content": "    if (newSize > max_size()) {",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": null,
          "new_api": "const_cast<iterator>(it)",
          "old_text": null,
          "new_text": "const_cast<iterator>(it)",
          "old_line_content": "  template <class It>",
          "new_line_content": "    return const_cast<iterator>(it);",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": null,
          "new_api": "throw_exception<std::length_error>(\"max_size exceeded in small_vector\")",
          "old_text": null,
          "new_text": "throw_exception<std::length_error>(\"max_size exceeded in small_vector\")",
          "old_line_content": "    }",
          "new_line_content": "      throw_exception<std::length_error>(\"max_size exceeded in small_vector\");",
          "content_same": false
        },
        {
          "line": 1221,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "      typename std::",
          "new_line_content": "  static bool constexpr kHasInlineCapacity =",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!insert)",
          "old_line_content": "    // This branch isn't needed for correctness, but allows the optimizer to",
          "new_line_content": "      assert(!insert);",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": null,
          "new_api": "alignof",
          "old_text": null,
          "new_text": "alignof(value_type)",
          "old_line_content": "",
          "new_line_content": "          aligned_storage<sizeof(InternalSizeType), alignof(value_type)>::type);",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(this->kShouldUseHeap)",
          "old_line_content": "      return;",
          "new_line_content": "    assert(this->kShouldUseHeap);",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": null,
          "new_api": "constexpr",
          "old_text": null,
          "new_text": "constexpr",
          "old_line_content": "          PointerType;",
          "new_line_content": "  static size_t constexpr kHeapifyCapacityThreshold =",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "insert(pos, *first++)",
          "old_line_content": "",
          "new_line_content": "        pos = insert(pos, *first++);",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "computeNewSize",
          "old_text": null,
          "new_text": "computeNewSize()",
          "old_line_content": "    // a capacity at the front of the heap allocation.",
          "new_line_content": "    newSize = std::max(newSize, computeNewSize());",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": null,
          "new_api": "explicit",
          "old_text": null,
          "new_text": "explicit",
          "old_line_content": "    InlineStorageType storage_;",
          "new_line_content": "    explicit Data() {",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "        [&](size_t i) -> it_ref {",
          "new_line_content": "    makeSize(size() + distance);",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "data",
          "old_text": null,
          "new_text": "data()",
          "old_line_content": "          return *(first + i);",
          "new_line_content": "        data() + offset,",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "        });",
          "new_line_content": "        data() + size(),",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "goodMallocSize",
          "old_text": null,
          "new_text": "goodMallocSize(needBytes + allocationExtraBytes)",
          "old_line_content": "    // sized deallocation. If goodMallocSize() gives us extra bytes that are not",
          "new_line_content": "        goodMallocSize(needBytes + allocationExtraBytes);",
          "content_same": false
        },
        {
          "line": 1247,
          "old_api": null,
          "new_api": "static_cast<value_type*>(vp)",
          "old_text": null,
          "new_text": "static_cast<value_type*>(vp)",
          "old_line_content": "    value_type* heap() noexcept {",
          "new_line_content": "      return static_cast<value_type*>(vp);",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(i < size_t(distance))",
          "old_line_content": "  }",
          "new_line_content": "          assert(i < size_t(distance));",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "buffer",
          "old_text": null,
          "new_text": "const_cast<Data*>(this)->buffer()",
          "old_line_content": "      } else {",
          "new_line_content": "      return const_cast<Data*>(this)->buffer();",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "  insertImpl(iterator pos, size_type n, const value_type& val, std::true_type) {",
          "new_line_content": "    this->setSize(size() + distance);",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "begin()",
          "old_line_content": "    // The true_type means this should call the size_t,value_type",
          "new_line_content": "    return begin() + offset;",
          "content_same": false
        },
        {
          "line": 1253,
          "old_api": null,
          "new_api": "detail::pointerFlagGet(pdata_.heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagGet(pdata_.heap_)",
          "old_line_content": "      }",
          "new_line_content": "      if (kHasInlineCapacity || !detail::pointerFlagGet(pdata_.heap_)) {",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "static_cast<value_type*>(pdata_.heap_)",
          "old_text": null,
          "new_text": "static_cast<value_type*>(pdata_.heap_)",
          "old_line_content": "    }",
          "new_line_content": "        return static_cast<value_type*>(pdata_.heap_);",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": null,
          "new_api": "detail::pointerFlagClear(pdata_.heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagClear(pdata_.heap_)",
          "old_line_content": "    }",
          "new_line_content": "            detail::pointerFlagClear(pdata_.heap_), kHeapifyCapacitySize));",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "detail::pointerFlagGet(newh)",
          "old_text": null,
          "new_text": "detail::pointerFlagGet(newh)",
          "old_line_content": "",
          "new_line_content": "    assert(!detail::pointerFlagGet(newh));",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "insert(pos, n, val)",
          "old_line_content": "  // constructor).",
          "new_line_content": "    return insert(pos, n, val);",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "heap",
          "old_text": null,
          "new_text": "const_cast<Data*>(this)->heap()",
          "old_line_content": "    }",
          "new_line_content": "      return const_cast<Data*>(this)->heap();",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "detail::pointerFlagGet(pdata_.heap_)",
          "old_text": null,
          "new_text": "detail::pointerFlagGet(pdata_.heap_)",
          "old_line_content": "    void setCapacity(InternalSizeType c) {",
          "new_line_content": "      return kHasInlineCapacity || detail::pointerFlagGet(pdata_.heap_);",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "getCapacity",
          "old_text": null,
          "new_text": "pdata_.getCapacity()",
          "old_line_content": "",
          "new_line_content": "      return pdata_.getCapacity();",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": null,
          "new_api": "moveToUninitializedEmplace",
          "old_text": null,
          "new_text": "this->moveToUninitializedEmplace(\n            begin(), end(), newp, pos, std::forward<EmplaceFunc>(emplaceFunc))",
          "old_line_content": "      }",
          "new_line_content": "        this->moveToUninitializedEmplace(",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": null,
          "new_api": "hasCapacity",
          "old_text": null,
          "new_text": "hasCapacity()",
          "old_line_content": "      } else {",
          "new_line_content": "      if (hasCapacity()) {",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "dismiss",
          "old_text": null,
          "new_text": "rollback.dismiss()",
          "old_line_content": "",
          "new_line_content": "      rollback.dismiss();",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "getCapacity",
          "old_text": null,
          "new_text": "pdata_.getCapacity()",
          "old_line_content": "    }",
          "new_line_content": "            pdata_.getCapacity() * sizeof(value_type) +",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1152,
          "old_api": "freeHeap",
          "new_api": null,
          "old_text": "u.freeHeap()",
          "new_text": null,
          "old_line_content": "      u.freeHeap();",
          "new_line_content": "    for (auto& val : *this) {",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "detail::pointerFlagSet(newh)",
          "new_api": null,
          "old_text": "detail::pointerFlagSet(newh)",
          "new_text": null,
          "old_line_content": "      u.pdata_.heap_ = detail::pointerFlagSet(newh);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "end",
          "new_api": null,
          "old_text": "end()",
          "new_text": null,
          "old_line_content": "    erase(begin(), end());",
          "new_line_content": "    // Equivalent to erase(begin(), end()), but neither Clang or GCC are able to",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": "setExtern",
          "new_api": null,
          "old_text": "this->setExtern(true)",
          "new_text": null,
          "old_line_content": "    this->setExtern(true);",
          "new_line_content": "    if (heapifyCapacity) {",
          "content_same": false
        },
        {
          "line": 906,
          "old_api": "end",
          "new_api": null,
          "old_text": "end()",
          "new_text": null,
          "old_line_content": "    insert(end(), first, last);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "makeSize",
          "new_api": null,
          "old_text": "makeSize(n)",
          "new_text": null,
          "old_line_content": "    makeSize(n);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": "setSize",
          "new_api": null,
          "old_text": "this->setSize(n)",
          "new_text": null,
          "old_line_content": "    this->setSize(n);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": "swap",
          "new_api": null,
          "old_text": "a.swap(b)",
          "new_text": null,
          "old_line_content": "  a.swap(b);",
          "new_line_content": "// nothrow move or copy constructor.",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "freeHeap",
          "new_api": null,
          "old_text": "makeGuard([&] {\n        if (this->isExtern()) {\n          u.freeHeap();\n        }\n      })",
          "new_text": null,
          "old_line_content": "      auto rollback = makeGuard([&] {",
          "new_line_content": "  template <typename InitFunc>",
          "content_same": false
        },
        {
          "line": 1039,
          "old_api": "isExtern",
          "new_api": null,
          "old_text": "this->isExtern()",
          "new_text": null,
          "old_line_content": "        if (this->isExtern()) {",
          "new_line_content": "  void doConstruct(size_type n, InitFunc&& func) {",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "isExtern",
          "new_api": null,
          "old_text": "this->isExtern()",
          "new_text": null,
          "old_line_content": "    assert(this->isExtern());",
          "new_line_content": "  /*",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "hasCapacity",
          "new_api": null,
          "old_text": "u.hasCapacity()",
          "new_text": null,
          "old_line_content": "    if (u.hasCapacity()) {",
          "new_line_content": "   * This will set the capacity field, stored inline in the storage_ field",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "clear",
          "new_api": null,
          "old_text": "clear()",
          "new_text": null,
          "old_line_content": "    clear();",
          "new_line_content": "  void assign(std::initializer_list<value_type> il) {",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": "newCapacity < std::numeric_limits<InternalSizeType>::max()",
          "new_api": null,
          "old_text": "newCapacity < std::numeric_limits<InternalSizeType>::max()",
          "new_text": null,
          "old_line_content": "      assert(newCapacity < std::numeric_limits<InternalSizeType>::max());",
          "new_line_content": "   * if there is sufficient room to store it.",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": "setCapacity",
          "new_api": null,
          "old_text": "u.setCapacity(newCapacity)",
          "new_text": null,
          "old_line_content": "      u.setCapacity(newCapacity);",
          "new_line_content": "   */",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": "empty",
          "new_api": null,
          "old_text": "empty()",
          "new_text": null,
          "old_line_content": "    assert(!empty());",
          "new_line_content": "  reference front() {",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "doConstruct",
          "new_api": null,
          "old_text": "doConstruct(n, [&](void* p) { new (p) value_type(val); })",
          "new_text": null,
          "old_line_content": "    doConstruct(n, [&](void* p) { new (p) value_type(val); });",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "end",
          "new_api": null,
          "old_text": "v.end()",
          "new_text": null,
          "old_line_content": "  v.erase(std::remove_if(v.begin(), v.end(), predicate), v.end());",
          "new_line_content": "    class A,",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "empty",
          "new_api": null,
          "old_text": "empty()",
          "new_text": null,
          "old_line_content": "    assert(!empty());",
          "new_line_content": "  reference back() {",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "max_size",
          "new_api": null,
          "old_text": "max_size()",
          "new_text": null,
          "old_line_content": "    return std::min((3 * capacity()) / 2 + 1, max_size());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 931,
          "old_api": "empty",
          "new_api": null,
          "old_text": "empty()",
          "new_text": null,
          "old_line_content": "    assert(!empty());",
          "new_line_content": "  const_reference front() const {",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "assume_unreachable",
          "new_api": null,
          "old_text": "assume_unreachable()",
          "new_text": null,
          "old_line_content": "    makeSizeInternal(newSize, false, [](void*) { assume_unreachable(); }, 0);",
          "new_line_content": "  size_type computeNewSize() const {",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "makeSizeInternal",
          "new_api": null,
          "old_text": "makeSizeInternal(\n        newSize, true, std::forward<EmplaceFunc>(emplaceFunc), pos)",
          "new_text": null,
          "old_line_content": "    makeSizeInternal(",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1069,
          "old_api": "std::forward<EmplaceFunc>(emplaceFunc)",
          "new_api": null,
          "old_text": "std::forward<EmplaceFunc>(emplaceFunc)",
          "new_text": null,
          "old_line_content": "        newSize, true, std::forward<EmplaceFunc>(emplaceFunc), pos);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "detail::pointerFlagGet(heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagGet(heap_)",
          "new_text": null,
          "old_line_content": "      assert(detail::pointerFlagGet(heap_));",
          "new_line_content": "    // Lower order bit of heap_ is used as flag to indicate whether capacity is",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "detail::pointerFlagClear(heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagClear(heap_)",
          "new_text": null,
          "old_line_content": "      return *static_cast<InternalSizeType*>(detail::pointerFlagClear(heap_));",
          "new_line_content": "    // stored at the front of the heap allocation.",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": "detail::pointerFlagClear(heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagClear(heap_)",
          "new_text": null,
          "old_line_content": "      *static_cast<InternalSizeType*>(detail::pointerFlagClear(heap_)) = c;",
          "new_line_content": "    InternalSizeType getCapacity() const {",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "detail::pointerFlagGet(heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagGet(heap_)",
          "new_text": null,
          "old_line_content": "      assert(detail::pointerFlagGet(heap_));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    if (i >= size()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "throw_exception<std::out_of_range>(\"index out of range\")",
          "new_api": null,
          "old_text": "throw_exception<std::out_of_range>(\"index out of range\")",
          "new_text": null,
          "old_line_content": "      throw_exception<std::out_of_range>(\"index out of range\");",
          "new_line_content": "    return (*this)[i];",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": "max_size",
          "new_api": null,
          "old_text": "max_size()",
          "new_text": null,
          "old_line_content": "    if (newSize > max_size()) {",
          "new_line_content": "  void makeSizeInternal(",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": "const_cast<iterator>(it)",
          "new_api": null,
          "old_text": "const_cast<iterator>(it)",
          "new_text": null,
          "old_line_content": "    return const_cast<iterator>(it);",
          "new_line_content": "    return (*this)[i];",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": "throw_exception<std::length_error>(\"max_size exceeded in small_vector\")",
          "new_api": null,
          "old_text": "throw_exception<std::length_error>(\"max_size exceeded in small_vector\")",
          "new_text": null,
          "old_line_content": "      throw_exception<std::length_error>(\"max_size exceeded in small_vector\");",
          "new_line_content": "      size_type newSize,",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "capacity",
          "new_api": null,
          "old_text": "capacity()",
          "new_text": null,
          "old_line_content": "    if (newSize <= capacity()) {",
          "new_line_content": "      EmplaceFunc&& emplaceFunc,",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!insert)",
          "new_text": null,
          "old_line_content": "      assert(!insert);",
          "new_line_content": "      size_type pos) {",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  static bool constexpr kHasInlineCapacity =",
          "new_line_content": "  typedef typename std::conditional<",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "  static size_t constexpr kHeapifyCapacitySize = sizeof(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "alignof",
          "new_api": null,
          "old_text": "alignof(value_type)",
          "new_text": null,
          "old_line_content": "          aligned_storage<sizeof(InternalSizeType), alignof(value_type)>::type);",
          "new_line_content": "      sizeof(HeapPtrWithCapacity) < sizeof(InlineStorageType);",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": "begin",
          "new_api": null,
          "old_text": "begin()",
          "new_text": null,
          "old_line_content": "      auto offset = pos - begin();",
          "new_line_content": "  template <class It>",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "insert",
          "new_api": null,
          "old_text": "insert(pos, *first++)",
          "new_text": null,
          "old_line_content": "        pos = insert(pos, *first++);",
          "new_line_content": "    using categ = typename std::iterator_traits<It>::iterator_category;",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": "computeNewSize",
          "new_api": null,
          "old_text": "computeNewSize()",
          "new_text": null,
          "old_line_content": "    newSize = std::max(newSize, computeNewSize());",
          "new_line_content": "    // small_vectors.",
          "content_same": false
        },
        {
          "line": 1233,
          "old_api": "explicit",
          "new_api": null,
          "old_text": "explicit",
          "new_text": null,
          "old_line_content": "    explicit Data() {",
          "new_line_content": "  typedef typename std::",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "std::distance(first, last)",
          "new_api": null,
          "old_text": "std::distance(first, last)",
          "new_text": null,
          "old_line_content": "    auto const distance = std::distance(first, last);",
          "new_line_content": "        ++pos;",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": "begin",
          "new_api": null,
          "old_text": "begin()",
          "new_text": null,
          "old_line_content": "    auto const offset = pos - begin();",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(offset >= 0)",
          "new_text": null,
          "old_line_content": "    assert(offset >= 0);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    makeSize(size() + distance);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": "static_cast<value_type*>(vp)",
          "new_api": null,
          "old_text": "static_cast<value_type*>(vp)",
          "new_text": null,
          "old_line_content": "      return static_cast<value_type*>(vp);",
          "new_line_content": "    PointerType pdata_;",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "goodMallocSize",
          "new_api": null,
          "old_text": "goodMallocSize(needBytes + allocationExtraBytes)",
          "new_text": null,
          "old_line_content": "        goodMallocSize(needBytes + allocationExtraBytes);",
          "new_line_content": "    const bool heapifyCapacity =",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": "buffer",
          "new_api": null,
          "old_text": "const_cast<Data*>(this)->buffer()",
          "new_text": null,
          "old_line_content": "      return const_cast<Data*>(this)->buffer();",
          "new_line_content": "    value_type* buffer() noexcept {",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "detail::pointerFlagGet(pdata_.heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagGet(pdata_.heap_)",
          "new_text": null,
          "old_line_content": "      if (kHasInlineCapacity || !detail::pointerFlagGet(pdata_.heap_)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "begin",
          "new_api": null,
          "old_text": "begin()",
          "new_text": null,
          "old_line_content": "    return begin() + offset;",
          "new_line_content": "        [&](size_t i) -> it_ref {",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": "static_cast<value_type*>(pdata_.heap_)",
          "new_api": null,
          "old_text": "static_cast<value_type*>(pdata_.heap_)",
          "new_text": null,
          "old_line_content": "        return static_cast<value_type*>(pdata_.heap_);",
          "new_line_content": "    value_type const* buffer() const noexcept {",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "detail::shiftPointer(\n            detail::pointerFlagClear(pdata_.heap_), kHeapifyCapacitySize)",
          "new_api": null,
          "old_text": "detail::shiftPointer(\n            detail::pointerFlagClear(pdata_.heap_), kHeapifyCapacitySize)",
          "new_text": null,
          "old_line_content": "        return static_cast<value_type*>(detail::shiftPointer(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "checkedMalloc",
          "new_api": null,
          "old_text": "checkedMalloc(sizeBytes)",
          "new_text": null,
          "old_line_content": "    void* newh = checkedMalloc(sizeBytes);",
          "new_line_content": "    // capacity, instead of using goodAllocationSizeBytes, so that we can do",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "detail::pointerFlagClear(pdata_.heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagClear(pdata_.heap_)",
          "new_text": null,
          "old_line_content": "            detail::pointerFlagClear(pdata_.heap_), kHeapifyCapacitySize));",
          "new_line_content": "    value_type* heap() noexcept {",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "detail::pointerFlagGet(newh)",
          "new_api": null,
          "old_text": "detail::pointerFlagGet(newh)",
          "new_text": null,
          "old_line_content": "    assert(!detail::pointerFlagGet(newh));",
          "new_line_content": "    const size_t sizeBytes =",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "insert",
          "new_api": null,
          "old_text": "insert(pos, n, val)",
          "new_text": null,
          "old_line_content": "    return insert(pos, n, val);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "detail::shiftPointer(newh, kHeapifyCapacitySize)",
          "new_api": null,
          "old_text": "detail::shiftPointer(newh, kHeapifyCapacitySize)",
          "new_text": null,
          "old_line_content": "        heapifyCapacity ? detail::shiftPointer(newh, kHeapifyCapacitySize)",
          "new_line_content": "    // We expect newh to be at least 2-aligned, because we want to",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "detail::pointerFlagGet(pdata_.heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagGet(pdata_.heap_)",
          "new_text": null,
          "old_line_content": "      return kHasInlineCapacity || detail::pointerFlagGet(pdata_.heap_);",
          "new_line_content": "    value_type const* heap() const noexcept {",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "getCapacity",
          "new_api": null,
          "old_text": "pdata_.getCapacity()",
          "new_text": null,
          "old_line_content": "      return pdata_.getCapacity();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "setCapacity",
          "new_api": null,
          "old_text": "pdata_.setCapacity(c)",
          "new_text": null,
          "old_line_content": "      pdata_.setCapacity(c);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "emplace_back(*first++)",
          "new_text": null,
          "old_line_content": "        emplace_back(*first++);",
          "new_line_content": "    typedef typename std::iterator_traits<It>::iterator_category categ;",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": "detail::pointerFlagClear(pdata_.heap_)",
          "new_api": null,
          "old_text": "detail::pointerFlagClear(pdata_.heap_)",
          "new_text": null,
          "old_line_content": "      auto vp = detail::pointerFlagClear(pdata_.heap_);",
          "new_line_content": "    void setCapacity(InternalSizeType c) {",
          "content_same": false
        },
        {
          "line": 1143,
          "old_api": "end",
          "new_api": null,
          "old_text": "end()",
          "new_text": null,
          "old_line_content": "        this->moveToUninitialized(begin(), end(), newp);",
          "new_line_content": "        // move and insert the new element",
          "content_same": false
        },
        {
          "line": 1272,
          "old_api": "getCapacity",
          "new_api": null,
          "old_text": "sizedFree(\n            vp,\n            pdata_.getCapacity() * sizeof(value_type) +\n                pdata_.allocationExtraBytes())",
          "new_text": null,
          "old_line_content": "        sizedFree(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "getCapacity",
          "new_api": null,
          "old_text": "pdata_.getCapacity()",
          "new_text": null,
          "old_line_content": "            pdata_.getCapacity() * sizeof(value_type) +",
          "new_line_content": "    void freeHeap() {",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "makeSize",
          "new_api": null,
          "old_text": "makeSize(distance)",
          "new_text": null,
          "old_line_content": "    makeSize(distance);",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "setSize",
          "new_api": null,
          "old_text": "this->setSize(distance)",
          "new_text": null,
          "old_line_content": "    this->setSize(distance);",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "freeHeap",
          "new_api": null,
          "old_text": "makeGuard([&] {\n        if (this->isExtern()) {\n          u.freeHeap();\n        }\n      })",
          "new_text": null,
          "old_line_content": "      auto rollback = makeGuard([&] {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "isExtern",
          "new_api": null,
          "old_text": "this->isExtern()",
          "new_text": null,
          "old_line_content": "    if (this->isExtern()) {",
          "new_line_content": "    }",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 40,
      "total_additions": 72,
      "total_deletions": 70,
      "total_api_changes": 182
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 182,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          904,
          901
        ]
      }
    },
    "api_calls_before": 453,
    "api_calls_after": 454,
    "diff_info": {
      "added_lines": 6,
      "removed_lines": 1,
      "total_diff_lines": 19
    }
  }
}