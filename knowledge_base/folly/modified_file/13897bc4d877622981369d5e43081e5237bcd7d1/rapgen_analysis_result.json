{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/13897bc4d877622981369d5e43081e5237bcd7d1",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/13897bc4d877622981369d5e43081e5237bcd7d1/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/13897bc4d877622981369d5e43081e5237bcd7d1/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/13897bc4d877622981369d5e43081e5237bcd7d1/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 49,
          "old_api": "post",
          "new_api": "exchange",
          "old_text": "baton.post()",
          "new_text": "posted->exchange(true, std::memory_order_acq_rel)",
          "old_line_content": "          executor->add([&baton] { baton.post(); });",
          "new_line_content": "        if (!posted->exchange(true, std::memory_order_acq_rel)) {",
          "content_same": false
        },
        {
          "line": 65,
          "old_api": "std::move(r)",
          "new_api": "cancel",
          "old_text": "std::move(r)",
          "new_text": "sleepFuture.cancel()",
          "old_line_content": "            result = std::move(r);",
          "new_line_content": "          sleepFuture.cancel();",
          "content_same": false
        },
        {
          "line": 66,
          "old_api": "post",
          "new_api": "exchange",
          "old_text": "baton.post()",
          "new_text": "posted->exchange(true, std::memory_order_acq_rel)",
          "old_line_content": "            baton.post();",
          "new_line_content": "          if (!posted->exchange(true, std::memory_order_acq_rel)) {",
          "content_same": false
        },
        {
          "line": 75,
          "old_api": "hasException",
          "new_api": "get_awaiter",
          "old_text": "result.hasException()",
          "new_text": "get_awaiter(baton)",
          "old_line_content": "  if (!result.hasValue() && !result.hasException()) {",
          "new_line_content": "  co_await detail::UnsafeResumeInlineSemiAwaitable{get_awaiter(baton)};",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 67,
          "old_api": null,
          "new_api": "std::move(r)",
          "old_text": null,
          "new_text": "std::move(r)",
          "old_line_content": "          } else {",
          "new_line_content": "            result = std::move(r);",
          "content_same": false
        },
        {
          "line": 68,
          "old_api": null,
          "new_api": "post",
          "old_text": null,
          "new_text": "baton.post()",
          "old_line_content": "            delete posted;",
          "new_line_content": "            baton.post();",
          "content_same": false
        },
        {
          "line": 44,
          "old_api": null,
          "new_api": "toUnsafeFuture",
          "old_text": null,
          "new_text": "futures::sleep(duration).toUnsafeFuture()",
          "old_line_content": "  auto posted = new std::atomic<bool>(false);",
          "new_line_content": "  auto sleepFuture = futures::sleep(duration).toUnsafeFuture();",
          "content_same": false
        },
        {
          "line": 77,
          "old_api": null,
          "new_api": "hasException",
          "old_text": null,
          "new_text": "result.hasException()",
          "old_line_content": "  }",
          "new_line_content": "  if (!result.hasValue() && !result.hasException()) {",
          "content_same": false
        },
        {
          "line": 46,
          "old_api": null,
          "new_api": "setCallback_",
          "old_text": null,
          "new_text": "sleepFuture.setCallback_(\n      [posted, &baton, executor = Executor::KeepAlive<>{executor}](\n          auto&&, auto&&) {\n        if (!posted->exchange(true, std::memory_order_acq_rel)) {\n          executor->add([&baton] { baton.post(); });\n        } else {\n          delete posted;\n        }\n      })",
          "old_line_content": "      .setCallback_([posted, &baton, executor = co_await co_current_executor](",
          "new_line_content": "  sleepFuture.setCallback_(",
          "content_same": false
        },
        {
          "line": 80,
          "old_api": null,
          "new_api": "std::move(*result)",
          "old_text": null,
          "new_text": "std::move(*result)",
          "old_line_content": "",
          "new_line_content": "  co_return std::move(*result);",
          "content_same": false
        },
        {
          "line": 50,
          "old_api": null,
          "new_api": "post",
          "old_text": null,
          "new_text": "baton.post()",
          "old_line_content": "        } else {",
          "new_line_content": "          executor->add([&baton] { baton.post(); });",
          "content_same": false
        },
        {
          "line": 57,
          "old_api": null,
          "new_api": "co_invoke",
          "old_text": null,
          "new_text": "co_invoke(\n        [awaitable = std::move(\n             awaitable)]() mutable -> Task<semi_await_result_t<Awaitable>> {\n          co_return co_await std::move(awaitable);\n        })",
          "old_line_content": "        [awaitable = std::move(",
          "new_line_content": "    auto t = co_invoke(",
          "content_same": false
        },
        {
          "line": 60,
          "old_api": null,
          "new_api": "std::move(awaitable)",
          "old_text": null,
          "new_text": "std::move(awaitable)",
          "old_line_content": "        });",
          "new_line_content": "          co_return co_await std::move(awaitable);",
          "content_same": false
        },
        {
          "line": 62,
          "old_api": null,
          "new_api": "scheduleOn",
          "old_text": null,
          "new_text": "std::move(t).scheduleOn(executor).start(\n        [posted, &baton, &result, sleepFuture = std::move(sleepFuture)](\n            auto&& r) mutable {\n          sleepFuture.cancel();\n          if (!posted->exchange(true, std::memory_order_acq_rel)) {\n            result = std::move(r);\n            baton.post();\n          } else {\n            delete posted;\n          }\n        })",
          "old_line_content": "        .scheduleOn(co_await co_current_executor)",
          "new_line_content": "    std::move(t).scheduleOn(executor).start(",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 64,
          "old_api": "exchange",
          "new_api": null,
          "old_text": "posted->exchange(true, std::memory_order_acq_rel)",
          "new_text": null,
          "old_line_content": "          if (!posted->exchange(true, std::memory_order_acq_rel)) {",
          "new_line_content": "            auto&& r) mutable {",
          "content_same": false
        },
        {
          "line": 73,
          "old_api": "get_awaiter",
          "new_api": null,
          "old_text": "get_awaiter(baton)",
          "new_text": null,
          "old_line_content": "  co_await detail::UnsafeResumeInlineSemiAwaitable{get_awaiter(baton)};",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 43,
          "old_api": "toUnsafeFuture",
          "new_api": null,
          "old_text": "futures::sleep(duration).toUnsafeFuture()",
          "new_text": null,
          "old_line_content": "  auto sleepFuture = futures::sleep(duration).toUnsafeFuture();",
          "new_line_content": "  Executor* executor = co_await co_current_executor;",
          "content_same": false
        },
        {
          "line": 45,
          "old_api": "setCallback_",
          "new_api": null,
          "old_text": "std::move(sleepFuture)\n      .setCallback_([posted, &baton, executor = co_await co_current_executor](\n                        auto&&, auto&&) {\n        if (!posted->exchange(true, std::memory_order_acq_rel)) {\n          executor->add([&baton] { baton.post(); });\n        } else {\n          delete posted;\n        }\n      })",
          "new_text": null,
          "old_line_content": "  std::move(sleepFuture)",
          "new_line_content": "  auto posted = new std::atomic<bool>(false);",
          "content_same": false
        },
        {
          "line": 78,
          "old_api": "std::move(*result)",
          "new_api": null,
          "old_text": "std::move(*result)",
          "new_text": null,
          "old_line_content": "  co_return std::move(*result);",
          "new_line_content": "    co_return folly::none;",
          "content_same": false
        },
        {
          "line": 48,
          "old_api": "exchange",
          "new_api": null,
          "old_text": "posted->exchange(true, std::memory_order_acq_rel)",
          "new_text": null,
          "old_line_content": "        if (!posted->exchange(true, std::memory_order_acq_rel)) {",
          "new_line_content": "          auto&&, auto&&) {",
          "content_same": false
        },
        {
          "line": 56,
          "old_api": "co_invoke",
          "new_api": null,
          "old_text": "co_invoke(\n        [awaitable = std::move(\n             awaitable)]() mutable -> Task<semi_await_result_t<Awaitable>> {\n          co_return co_await std::move(awaitable);\n        })",
          "new_text": null,
          "old_line_content": "    auto t = co_invoke(",
          "new_line_content": "  {",
          "content_same": false
        },
        {
          "line": 59,
          "old_api": "std::move(awaitable)",
          "new_api": null,
          "old_text": "std::move(awaitable)",
          "new_text": null,
          "old_line_content": "          co_return co_await std::move(awaitable);",
          "new_line_content": "             awaitable)]() mutable -> Task<semi_await_result_t<Awaitable>> {",
          "content_same": false
        },
        {
          "line": 61,
          "old_api": "scheduleOn",
          "new_api": null,
          "old_text": "std::move(t)\n        .scheduleOn(co_await co_current_executor)\n        .start([posted, &baton, &result](auto&& r) {\n          if (!posted->exchange(true, std::memory_order_acq_rel)) {\n            result = std::move(r);\n            baton.post();\n          } else {\n            delete posted;\n          }\n        })",
          "new_text": null,
          "old_line_content": "    std::move(t)",
          "new_line_content": "        });",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 4,
      "total_additions": 10,
      "total_deletions": 9,
      "total_api_changes": 23
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 10,
        "api_related_lines": 23,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          63,
          47
        ]
      }
    },
    "api_calls_before": 19,
    "api_calls_after": 19,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 6,
      "total_diff_lines": 35
    }
  }
}