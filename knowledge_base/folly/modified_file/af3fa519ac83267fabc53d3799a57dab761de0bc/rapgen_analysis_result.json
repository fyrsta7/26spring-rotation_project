{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/af3fa519ac83267fabc53d3799a57dab761de0bc",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/af3fa519ac83267fabc53d3799a57dab761de0bc/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/af3fa519ac83267fabc53d3799a57dab761de0bc/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/af3fa519ac83267fabc53d3799a57dab761de0bc/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 505,
          "old_api": "RequestContext::saveContext()",
          "new_api": "isInEventBaseThread",
          "old_text": "RequestContext::saveContext()",
          "new_text": "isInEventBaseThread()",
          "old_line_content": "  callback->context_ = RequestContext::saveContext();",
          "new_line_content": "  DCHECK(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "push_back",
          "new_api": "RequestContext::saveContext()",
          "old_text": "runOnceCallbacks_->push_back(*callback)",
          "new_text": "RequestContext::saveContext()",
          "old_line_content": "    runOnceCallbacks_->push_back(*callback);",
          "new_line_content": "  callback->context_ = RequestContext::saveContext();",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "RequestContext::saveContext()",
          "new_api": "isInEventBaseThread",
          "old_text": "RequestContext::saveContext()",
          "new_text": "isInEventBaseThread()",
          "old_line_content": "  wrapper->context_ = RequestContext::saveContext();",
          "new_line_content": "  DCHECK(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "push_back",
          "new_api": "RequestContext::saveContext()",
          "old_text": "runOnceCallbacks_->push_back(*wrapper)",
          "new_text": "RequestContext::saveContext()",
          "old_line_content": "    runOnceCallbacks_->push_back(*wrapper);",
          "new_line_content": "  wrapper->context_ = RequestContext::saveContext();",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "RequestContext::saveContext()",
          "new_api": "isInEventBaseThread",
          "old_text": "RequestContext::saveContext()",
          "new_text": "isInEventBaseThread()",
          "old_line_content": "  wrapper->context_ = RequestContext::saveContext();",
          "new_line_content": "  DCHECK(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": "push_back",
          "new_api": "RequestContext::saveContext()",
          "old_text": "runOnceCallbacks_->push_back(*wrapper)",
          "new_text": "RequestContext::saveContext()",
          "old_line_content": "    runOnceCallbacks_->push_back(*wrapper);",
          "new_line_content": "  wrapper->context_ = RequestContext::saveContext();",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "cancelLoopCallback",
          "new_api": "std::move(cob)",
          "old_text": "callback->cancelLoopCallback()",
          "new_text": "std::move(cob)",
          "old_line_content": "  callback->cancelLoopCallback();",
          "new_line_content": "  auto callback = new FunctionLoopCallback<Cob>(std::move(cob));",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": "push_back",
          "new_api": "isInEventBaseThread",
          "old_text": "runBeforeLoopCallbacks_.push_back(*callback)",
          "new_text": "isInEventBaseThread()",
          "old_line_content": "  runBeforeLoopCallbacks_.push_back(*callback);",
          "new_line_content": "  DCHECK(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "LOG",
          "new_api": "std::make_pair(fn, arg)",
          "old_text": "LOG(ERROR)",
          "new_text": "std::make_pair(fn, arg)",
          "old_line_content": "    LOG(ERROR) << \"EventBase \" << this << \": failed to schedule function \"",
          "new_line_content": "    queue_->putMessage(std::make_pair(fn, arg));",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": "l",
          "new_api": "notify_one",
          "old_text": "l(m)",
          "new_text": "runInEventBaseThread([&] {\n      SCOPE_EXIT {\n        std::unique_lock<std::mutex> l(m);\n        ready = true;\n        cv.notify_one();\n        // We cannot release the lock before notify_one, because a spurious\n        // wakeup in the waiting thread may lead to cv and m going out of scope\n        // prematurely.\n      }",
          "old_line_content": "        std::unique_lock<std::mutex> l(m);",
          "new_line_content": "  runInEventBaseThread([&] {",
          "content_same": false
        },
        {
          "line": 623,
          "old_api": "notify_one",
          "new_api": "l",
          "old_text": "cv.notify_one()",
          "new_text": "l(m)",
          "old_line_content": "        cv.notify_one();",
          "new_line_content": "        std::unique_lock<std::mutex> l(m);",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "pop_front",
          "new_api": "empty",
          "old_text": "currentCallbacks.pop_front()",
          "new_text": "currentCallbacks.empty()",
          "old_line_content": "      currentCallbacks.pop_front();",
          "new_line_content": "    while (!currentCallbacks.empty()) {",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": "RequestContext::setContext(callback->context_)",
          "new_api": "pop_front",
          "old_text": "RequestContext::setContext(callback->context_)",
          "new_text": "currentCallbacks.pop_front()",
          "old_line_content": "        RequestContext::setContext(callback->context_);",
          "new_line_content": "      currentCallbacks.pop_front();",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "runLoopCallback",
          "new_api": "RequestContext::setContext(callback->context_)",
          "old_text": "callback->runLoopCallback()",
          "new_text": "RequestContext::setContext(callback->context_)",
          "old_line_content": "      callback->runLoopCallback();",
          "new_line_content": "        RequestContext::setContext(callback->context_);",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "LOG",
          "new_api": "*fn)()",
          "old_text": "LOG(ERROR)",
          "new_text": "*fn)()",
          "old_line_content": "    LOG(ERROR) << \"runInEventBaseThread() std::function threw a \"",
          "new_line_content": "    (*fn)();",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "abort",
          "new_api": "LOG",
          "old_text": "abort()",
          "new_text": "LOG(ERROR)",
          "old_line_content": "    abort();",
          "new_line_content": "    LOG(ERROR) << \"runInEventBaseThread() std::function threw a \"",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "LOG",
          "new_api": "abort",
          "old_text": "LOG(ERROR)",
          "new_text": "abort()",
          "old_line_content": "    LOG(ERROR) << \"runInEventBaseThread() std::function threw an exception\";",
          "new_line_content": "    abort();",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": "getLibeventBase",
          "new_api": "assert",
          "old_text": "getLibeventBase()",
          "new_text": "assert(ev->ev_base == nullptr)",
          "old_line_content": "  event_base_set(getLibeventBase(), ev);",
          "new_line_content": "  assert(ev->ev_base == nullptr);",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "getEvent",
          "new_api": "count",
          "old_text": "obj->getEvent()",
          "new_text": "timeout.count()",
          "old_line_content": "  struct event* ev = obj->getEvent();",
          "new_line_content": "  tv.tv_usec = (timeout.count() % 1000LL) * 1000LL;",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "strerror",
          "new_api": "getEvent",
          "old_text": "strerror(errno)",
          "new_text": "obj->getEvent()",
          "old_line_content": "    LOG(ERROR) << \"EventBase: failed to schedule timeout: \" << strerror(errno);",
          "new_line_content": "  struct event* ev = obj->getEvent();",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "EventUtil::isEventRegistered(ev)",
          "new_api": "isInEventBaseThread",
          "old_text": "EventUtil::isEventRegistered(ev)",
          "new_text": "isInEventBaseThread()",
          "old_line_content": "  if (EventUtil::isEventRegistered(ev)) {",
          "new_line_content": "  assert(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": "event_del",
          "new_api": "getEvent",
          "old_text": "event_del(ev)",
          "new_text": "obj->getEvent()",
          "old_line_content": "    event_del(ev);",
          "new_line_content": "  struct event* ev = obj->getEvent();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 640,
          "old_api": null,
          "new_api": "fn",
          "old_text": null,
          "new_text": "fn()",
          "old_line_content": "  } else {",
          "new_line_content": "    fn();",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "ex.what()",
          "old_line_content": "  } catch (...) {",
          "new_line_content": "               << typeid(ex).name() << \" exception: \" << ex.what();",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "runInEventBaseThreadAndWait",
          "old_text": null,
          "new_text": "runInEventBaseThreadAndWait(fn)",
          "old_line_content": "}",
          "new_line_content": "    return runInEventBaseThreadAndWait(fn);",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(ERROR)",
          "old_line_content": "  }",
          "new_line_content": "    LOG(ERROR) << \"runInEventBaseThread() std::function threw an exception\";",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "abort",
          "old_text": null,
          "new_text": "abort()",
          "old_line_content": "",
          "new_line_content": "    abort();",
          "content_same": false
        },
        {
          "line": 522,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "loopCallbacks_.push_back(*wrapper)",
          "old_line_content": "}",
          "new_line_content": "    loopCallbacks_.push_back(*wrapper);",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "tryRunAfterDelay",
          "old_text": null,
          "new_text": "tryRunAfterDelay(cob, milliseconds, in)",
          "old_line_content": "      \"error in EventBase::runAfterDelay(), failed to schedule timeout\");",
          "new_line_content": "  if (!tryRunAfterDelay(cob, milliseconds, in)) {",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "folly::throwSystemError(\n      \"error in EventBase::runAfterDelay(), failed to schedule timeout\")",
          "old_text": null,
          "new_text": "folly::throwSystemError(\n      \"error in EventBase::runAfterDelay(), failed to schedule timeout\")",
          "old_line_content": "  }",
          "new_line_content": "    folly::throwSystemError(",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "loopCallbacks_.push_back(*callback)",
          "old_line_content": "}",
          "new_line_content": "    loopCallbacks_.push_back(*callback);",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": null,
          "new_api": "std::move(cob)",
          "old_text": null,
          "new_text": "std::move(cob)",
          "old_line_content": "  if (runOnceCallbacks_ != nullptr && thisIteration) {",
          "new_line_content": "  auto wrapper = new FunctionLoopCallback<Cob>(std::move(cob));",
          "content_same": false
        },
        {
          "line": 785,
          "old_api": null,
          "new_api": "fn_",
          "old_text": null,
          "new_text": "fn_(arg_)",
          "old_line_content": "}",
          "new_line_content": "  fn_(arg_);",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "scheduleTimeout",
          "old_text": null,
          "new_text": "timeout->scheduleTimeout(milliseconds)",
          "old_line_content": "    return false;",
          "new_line_content": "  if (!timeout->scheduleTimeout(milliseconds)) {",
          "content_same": false
        },
        {
          "line": 533,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "loopCallbacks_.push_back(*wrapper)",
          "old_line_content": "}",
          "new_line_content": "    loopCallbacks_.push_back(*wrapper);",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "pendingCobTimeouts_.push_back(*timeout)",
          "old_line_content": "}",
          "new_line_content": "  pendingCobTimeouts_.push_back(*timeout);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "getEvent",
          "old_text": null,
          "new_text": "obj->getEvent()",
          "old_line_content": "",
          "new_line_content": "  struct event* ev = obj->getEvent();",
          "content_same": false
        },
        {
          "line": 795,
          "old_api": null,
          "new_api": "getLibeventBase",
          "old_text": null,
          "new_text": "getLibeventBase()",
          "old_line_content": "    // Set the EVLIST_INTERNAL flag",
          "new_line_content": "  event_base_set(getLibeventBase(), ev);",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "cancelLoopCallback",
          "old_text": null,
          "new_text": "callback->cancelLoopCallback()",
          "old_line_content": "}",
          "new_line_content": "  callback->cancelLoopCallback();",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "runAfterDrainCallbacks_.push_back(*callback)",
          "old_line_content": "",
          "new_line_content": "  runAfterDrainCallbacks_.push_back(*callback);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "loopCallbacks_.empty()",
          "old_line_content": "    // Swap the loopCallbacks_ list with a temporary list on our stack.",
          "new_line_content": "  if (!loopCallbacks_.empty()) {",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "bumpHandlingTime",
          "old_text": null,
          "new_text": "bumpHandlingTime()",
          "old_line_content": "    // This way we will only run callbacks scheduled at the time",
          "new_line_content": "    bumpHandlingTime();",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": null,
          "new_api": "event_ref_flags",
          "old_text": null,
          "new_text": "event_ref_flags(ev)",
          "old_line_content": "}",
          "new_line_content": "    event_ref_flags(ev) |= EVLIST_INTERNAL;",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": null,
          "new_api": "cancelLoopCallback",
          "old_text": null,
          "new_text": "callback->cancelLoopCallback()",
          "old_line_content": "}",
          "new_line_content": "  callback->cancelLoopCallback();",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "onDestructionCallbacks_.push_back(*callback)",
          "old_line_content": "",
          "new_line_content": "  onDestructionCallbacks_.push_back(*callback);",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": null,
          "new_api": "cancelTimeout",
          "old_text": null,
          "new_text": "cancelTimeout(obj)",
          "old_line_content": "  ev->ev_base = nullptr;",
          "new_line_content": "  cancelTimeout(obj);",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": null,
          "new_api": "getEvent",
          "old_text": null,
          "new_text": "obj->getEvent()",
          "old_line_content": "}",
          "new_line_content": "  struct event* ev = obj->getEvent();",
          "content_same": false
        },
        {
          "line": 552,
          "old_api": null,
          "new_api": "cancelLoopCallback",
          "old_text": null,
          "new_text": "callback->cancelLoopCallback()",
          "old_line_content": "}",
          "new_line_content": "  callback->cancelLoopCallback();",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "runBeforeLoopCallbacks_.push_back(*callback)",
          "old_line_content": "",
          "new_line_content": "  runBeforeLoopCallbacks_.push_back(*callback);",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "swap",
          "old_text": null,
          "new_text": "currentCallbacks.swap(loopCallbacks_)",
          "old_line_content": "",
          "new_line_content": "    currentCallbacks.swap(loopCallbacks_);",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "isInEventBaseThread",
          "old_text": null,
          "new_text": "isInEventBaseThread()",
          "old_line_content": "  struct timeval tv;",
          "new_line_content": "  assert(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "front",
          "old_text": null,
          "new_text": "currentCallbacks.front()",
          "old_line_content": "      if (setContext) {",
          "new_line_content": "      LoopCallback* callback = &currentCallbacks.front();",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "count",
          "old_text": null,
          "new_text": "timeout.count()",
          "old_line_content": "",
          "new_line_content": "  tv.tv_sec = timeout.count() / 1000LL;",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": null,
          "new_api": "runLoopCallback",
          "old_text": null,
          "new_text": "callback->runLoopCallback()",
          "old_line_content": "",
          "new_line_content": "      callback->runLoopCallback();",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(ERROR)",
          "old_line_content": "    return false;",
          "new_line_content": "    LOG(ERROR) << \"EventBase \" << this",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": null,
          "new_api": "event_add",
          "old_text": null,
          "new_text": "event_add(ev, &tv)",
          "old_line_content": "    return false;",
          "new_line_content": "  if (event_add(ev, &tv) < 0) {",
          "content_same": false
        },
        {
          "line": 818,
          "old_api": null,
          "new_api": "strerror",
          "old_text": null,
          "new_text": "strerror(errno)",
          "old_line_content": "  }",
          "new_line_content": "    LOG(ERROR) << \"EventBase: failed to schedule timeout: \" << strerror(errno);",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "inRunningEventBaseThread",
          "old_text": null,
          "new_text": "inRunningEventBaseThread()",
          "old_line_content": "    return true;",
          "new_line_content": "  if (inRunningEventBaseThread()) {",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "runInLoop",
          "old_text": null,
          "new_text": "runInLoop(new RunInLoopCallback(fn, arg))",
          "old_line_content": "",
          "new_line_content": "    runInLoop(new RunInLoopCallback(fn, arg));",
          "content_same": false
        },
        {
          "line": 700,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "queue_.reset(new NotificationQueue<std::pair<void (*)(void*), void*>>())",
          "old_line_content": "  // We allocate fnRunner_ separately, rather than declaring it directly",
          "new_line_content": "  queue_.reset(new NotificationQueue<std::pair<void (*)(void*), void*>>());",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": null,
          "new_api": "EventUtil::isEventRegistered(ev)",
          "old_text": null,
          "new_text": "EventUtil::isEventRegistered(ev)",
          "old_line_content": "  }",
          "new_line_content": "  if (EventUtil::isEventRegistered(ev)) {",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "event_del",
          "old_text": null,
          "new_text": "event_del(ev)",
          "old_line_content": "}",
          "new_line_content": "    event_del(ev);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(ERROR)",
          "old_line_content": "    return false;",
          "new_line_content": "    LOG(ERROR) << \"EventBase \" << this << \": failed to schedule function \"",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "ex.what()",
          "old_line_content": "  }",
          "new_line_content": "               << fn << \"for EventBase thread: \" << ex.what();",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "fnRunner_.reset(new FunctionRunner())",
          "old_line_content": "  // Mark this as an internal event, so event_base_loop() will return if",
          "new_line_content": "  fnRunner_.reset(new FunctionRunner());",
          "content_same": false
        },
        {
          "line": 834,
          "old_api": null,
          "new_api": "isInEventBaseThread",
          "old_text": null,
          "new_text": "isInEventBaseThread()",
          "old_line_content": "",
          "new_line_content": "  assert(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "isRunning",
          "old_text": null,
          "new_text": "isRunning()",
          "old_line_content": "                  name_);",
          "new_line_content": "  if (isRunning()) {",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "loopThread_.load(std::memory_order_relaxed)",
          "old_line_content": "  }",
          "new_line_content": "    setThreadName(loopThread_.load(std::memory_order_relaxed),",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "inRunningEventBaseThread",
          "old_text": null,
          "new_text": "inRunningEventBaseThread()",
          "old_line_content": "    return true;",
          "new_line_content": "  if (inRunningEventBaseThread()) {",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "runInLoop",
          "old_text": null,
          "new_text": "runInLoop(fn)",
          "old_line_content": "  }",
          "new_line_content": "    runInLoop(fn);",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "queue_.get()",
          "old_line_content": "",
          "new_line_content": "  fnRunner_->startConsumingInternal(this, queue_.get());",
          "content_same": false
        },
        {
          "line": 844,
          "old_api": null,
          "new_api": "isInEventBaseThread",
          "old_text": null,
          "new_text": "isInEventBaseThread()",
          "old_line_content": "}",
          "new_line_content": "  assert(isInEventBaseThread());",
          "content_same": false
        },
        {
          "line": 848,
          "old_api": null,
          "new_api": "event_get_version",
          "old_text": null,
          "new_text": "event_get_version()",
          "old_line_content": "",
          "new_line_content": "const char* EventBase::getLibeventVersion() { return event_get_version(); }",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(11)",
          "old_line_content": "",
          "new_line_content": "  VLOG(11) << \"expCoeff_ \" << expCoeff_ << \" \" << __PRETTY_FUNCTION__;",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": null,
          "new_api": "event_get_method",
          "old_text": null,
          "new_text": "event_get_method()",
          "old_line_content": "} // folly",
          "new_line_content": "const char* EventBase::getLibeventMethod() { return event_get_method(); }",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "time_since_epoch",
          "old_text": null,
          "new_text": "std::chrono::steady_clock::now().time_since_epoch()",
          "old_line_content": "",
          "new_line_content": "        std::chrono::steady_clock::now().time_since_epoch()).count();",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(11)",
          "old_line_content": "      \" (loop) startWork_ \" << startWork_;",
          "new_line_content": "      VLOG(11) << \"EventBase \" << this << \" \" << __PRETTY_FUNCTION__ <<",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(ERROR)",
          "old_line_content": "    return false;",
          "new_line_content": "    LOG(ERROR) << \"failed to allocate tr::function copy \"",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": null,
          "new_api": "runInEventBaseThread",
          "old_text": null,
          "new_text": "runInEventBaseThread(&EventBase::runFunctionPtr, fnCopy)",
          "old_line_content": "    return false;",
          "new_line_content": "  if (!runInEventBaseThread(&EventBase::runFunctionPtr, fnCopy)) {",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(5)",
          "old_line_content": "  // Set stop to true, so the event loop will know to exit.",
          "new_line_content": "  VLOG(5) << \"EventBase(): Received terminateLoopSoon() command.\";",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": null,
          "new_api": "inRunningEventBaseThread",
          "old_text": null,
          "new_text": "inRunningEventBaseThread()",
          "old_line_content": "               << \"allowed\";",
          "new_line_content": "  if (inRunningEventBaseThread()) {",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": null,
          "new_api": "LOG",
          "old_text": null,
          "new_text": "LOG(ERROR)",
          "old_line_content": "    return false;",
          "new_line_content": "    LOG(ERROR) << \"EventBase \" << this << \": Waiting in the event loop is not \"",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(11)",
          "old_line_content": "              \" busy \" << busy << \" \" << __PRETTY_FUNCTION__;",
          "new_line_content": "  VLOG(11) << \"idle \" << idle << \" oldBusyLeftover_ \" << oldBusyLeftover_ <<",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "event_base_loopbreak",
          "old_text": null,
          "new_text": "event_base_loopbreak(evb_)",
          "old_line_content": "  // If terminateLoopSoon() is called from another thread,",
          "new_line_content": "  event_base_loopbreak(evb_);",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": null,
          "new_api": "exp",
          "old_text": null,
          "new_text": "exp(idle * expCoeff_)",
          "old_line_content": "  value_ += (1.0 - coeff) * busy;",
          "new_line_content": "  double coeff = exp(idle * expCoeff_);",
          "content_same": false
        },
        {
          "line": 625,
          "old_api": null,
          "new_api": "notify_one",
          "old_text": null,
          "new_text": "cv.notify_one()",
          "old_line_content": "        // wakeup in the waiting thread may lead to cv and m going out of scope",
          "new_line_content": "        cv.notify_one();",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "VLOG",
          "old_text": null,
          "new_text": "VLOG(11)",
          "old_line_content": "}",
          "new_line_content": "  VLOG(11) << \"latest \" << latestLoopCnt_ << \" next \" << nextLoopCnt_;",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "std::make_pair(nullptr, nullptr)",
          "old_text": null,
          "new_text": "std::make_pair(nullptr, nullptr)",
          "old_line_content": "    // We don't care if putMessage() fails.  This likely means",
          "new_line_content": "    queue_->putMessage(std::make_pair(nullptr, nullptr));",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "fn",
          "old_text": null,
          "new_text": "fn()",
          "old_line_content": "  std::unique_lock<std::mutex> l(m);",
          "new_line_content": "      fn();",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "wait",
          "old_text": null,
          "new_text": "cv.wait(l, [&] { return ready; })",
          "old_line_content": "  return true;",
          "new_line_content": "  cv.wait(l, [&] { return ready; });",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "cancelLoopCallback",
          "old_text": null,
          "new_text": "callback->cancelLoopCallback()",
          "old_line_content": "  if (runOnceCallbacks_ != nullptr && thisIteration) {",
          "new_line_content": "  callback->cancelLoopCallback();",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": null,
          "new_api": "isInEventBaseThread",
          "old_text": null,
          "new_text": "isInEventBaseThread()",
          "old_line_content": "    return true;",
          "new_line_content": "  if (isInEventBaseThread()) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 641,
          "old_api": "runInEventBaseThreadAndWait",
          "new_api": null,
          "old_text": "runInEventBaseThreadAndWait(fn)",
          "new_text": null,
          "old_line_content": "    return runInEventBaseThreadAndWait(fn);",
          "new_line_content": "    return true;",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  DCHECK(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "abort",
          "new_api": null,
          "old_text": "abort()",
          "new_text": null,
          "old_line_content": "    abort();",
          "new_line_content": "  } catch (...) {",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": "tryRunAfterDelay",
          "new_api": null,
          "old_text": "tryRunAfterDelay(cob, milliseconds, in)",
          "new_text": null,
          "old_line_content": "  if (!tryRunAfterDelay(cob, milliseconds, in)) {",
          "new_line_content": "                              int milliseconds,",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "folly::throwSystemError(\n      \"error in EventBase::runAfterDelay(), failed to schedule timeout\")",
          "new_api": null,
          "old_text": "folly::throwSystemError(\n      \"error in EventBase::runAfterDelay(), failed to schedule timeout\")",
          "new_text": null,
          "old_line_content": "    folly::throwSystemError(",
          "new_line_content": "                              TimeoutManager::InternalEnum in) {",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  DCHECK(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 526,
          "old_api": "std::move(cob)",
          "new_api": null,
          "old_text": "std::move(cob)",
          "new_text": null,
          "old_line_content": "  auto wrapper = new FunctionLoopCallback<Cob>(std::move(cob));",
          "new_line_content": "void EventBase::runInLoop(Cob&& cob, bool thisIteration) {",
          "content_same": false
        },
        {
          "line": 766,
          "old_api": "what",
          "new_api": null,
          "old_text": "ex.what()",
          "new_text": null,
          "old_line_content": "               << typeid(ex).name() << \" exception: \" << ex.what();",
          "new_line_content": "  } catch (const std::exception &ex) {",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": "fn_",
          "new_api": null,
          "old_text": "fn_(arg_)",
          "new_text": null,
          "old_line_content": "  fn_(arg_);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "scheduleTimeout",
          "new_api": null,
          "old_text": "timeout->scheduleTimeout(milliseconds)",
          "new_text": null,
          "old_line_content": "  if (!timeout->scheduleTimeout(milliseconds)) {",
          "new_line_content": "                                 TimeoutManager::InternalEnum in) {",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "pendingCobTimeouts_.push_back(*timeout)",
          "new_text": null,
          "old_line_content": "  pendingCobTimeouts_.push_back(*timeout);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "getEvent",
          "new_api": null,
          "old_text": "obj->getEvent()",
          "new_text": null,
          "old_line_content": "  struct event* ev = obj->getEvent();",
          "new_line_content": "                                      InternalEnum internal) {",
          "content_same": false
        },
        {
          "line": 536,
          "old_api": "std::move(cob)",
          "new_api": null,
          "old_text": "std::move(cob)",
          "new_text": null,
          "old_line_content": "  auto callback = new FunctionLoopCallback<Cob>(std::move(cob));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(ev->ev_base == nullptr)",
          "new_text": null,
          "old_line_content": "  assert(ev->ev_base == nullptr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "runAfterDrainCallbacks_.push_back(*callback)",
          "new_text": null,
          "old_line_content": "  runAfterDrainCallbacks_.push_back(*callback);",
          "new_line_content": "  std::lock_guard<std::mutex> lg(runAfterDrainCallbacksMutex_);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "empty",
          "new_api": null,
          "old_text": "loopCallbacks_.empty()",
          "new_text": null,
          "old_line_content": "  if (!loopCallbacks_.empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": "bumpHandlingTime",
          "new_api": null,
          "old_text": "bumpHandlingTime()",
          "new_text": null,
          "old_line_content": "    bumpHandlingTime();",
          "new_line_content": "bool EventBase::runLoopCallbacks(bool setContext) {",
          "content_same": false
        },
        {
          "line": 796,
          "old_api": "event_ref_flags",
          "new_api": null,
          "old_text": "event_ref_flags(ev)",
          "new_text": null,
          "old_line_content": "    event_ref_flags(ev) |= EVLIST_INTERNAL;",
          "new_line_content": "  if (internal == AsyncTimeout::InternalEnum::INTERNAL) {",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": "cancelLoopCallback",
          "new_api": null,
          "old_text": "callback->cancelLoopCallback()",
          "new_text": null,
          "old_line_content": "  callback->cancelLoopCallback();",
          "new_line_content": "void EventBase::runOnDestruction(LoopCallback* callback) {",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "onDestructionCallbacks_.push_back(*callback)",
          "new_text": null,
          "old_line_content": "  onDestructionCallbacks_.push_back(*callback);",
          "new_line_content": "  std::lock_guard<std::mutex> lg(onDestructionCallbacksMutex_);",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "cancelTimeout",
          "new_api": null,
          "old_text": "cancelTimeout(obj)",
          "new_text": null,
          "old_line_content": "  cancelTimeout(obj);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": "getEvent",
          "new_api": null,
          "old_text": "obj->getEvent()",
          "new_text": null,
          "old_line_content": "  struct event* ev = obj->getEvent();",
          "new_line_content": "void EventBase::detachTimeoutManager(AsyncTimeout* obj) {",
          "content_same": false
        },
        {
          "line": 549,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  DCHECK(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 550,
          "old_api": "cancelLoopCallback",
          "new_api": null,
          "old_text": "callback->cancelLoopCallback()",
          "new_text": null,
          "old_line_content": "  callback->cancelLoopCallback();",
          "new_line_content": "void EventBase::runBeforeLoop(LoopCallback* callback) {",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "swap",
          "new_api": null,
          "old_text": "currentCallbacks.swap(loopCallbacks_)",
          "new_text": null,
          "old_line_content": "    currentCallbacks.swap(loopCallbacks_);",
          "new_line_content": "    // able to start file descriptor and timeout based events.",
          "content_same": false
        },
        {
          "line": 808,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  assert(isInEventBaseThread());",
          "new_line_content": "bool EventBase::scheduleTimeout(AsyncTimeout* obj,",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": "empty",
          "new_api": null,
          "old_text": "currentCallbacks.empty()",
          "new_text": null,
          "old_line_content": "    while (!currentCallbacks.empty()) {",
          "new_line_content": "    runOnceCallbacks_ = &currentCallbacks;",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": "front",
          "new_api": null,
          "old_text": "currentCallbacks.front()",
          "new_text": null,
          "old_line_content": "      LoopCallback* callback = &currentCallbacks.front();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "count",
          "new_api": null,
          "old_text": "timeout.count()",
          "new_text": null,
          "old_line_content": "  tv.tv_sec = timeout.count() / 1000LL;",
          "new_line_content": "  // Set up the timeval and add the event",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": "count",
          "new_api": null,
          "old_text": "timeout.count()",
          "new_text": null,
          "old_line_content": "  tv.tv_usec = (timeout.count() % 1000LL) * 1000LL;",
          "new_line_content": "  struct timeval tv;",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "event_add",
          "new_api": null,
          "old_text": "event_add(ev, &tv)",
          "new_text": null,
          "old_line_content": "  if (event_add(ev, &tv) < 0) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "LOG",
          "new_api": null,
          "old_text": "LOG(ERROR)",
          "new_text": null,
          "old_line_content": "    LOG(ERROR) << \"EventBase \" << this",
          "new_line_content": "  // We try not to schedule nullptr callbacks",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "inRunningEventBaseThread",
          "new_api": null,
          "old_text": "inRunningEventBaseThread()",
          "new_text": null,
          "old_line_content": "  if (inRunningEventBaseThread()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "runInLoop",
          "new_api": null,
          "old_text": "runInLoop(new RunInLoopCallback(fn, arg))",
          "new_text": null,
          "old_line_content": "    runInLoop(new RunInLoopCallback(fn, arg));",
          "new_line_content": "  // Short-circuit if we are already in our event base",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  assert(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "getEvent",
          "new_api": null,
          "old_text": "obj->getEvent()",
          "new_text": null,
          "old_line_content": "  struct event* ev = obj->getEvent();",
          "new_line_content": "void EventBase::cancelTimeout(AsyncTimeout* obj) {",
          "content_same": false
        },
        {
          "line": 698,
          "old_api": "reset",
          "new_api": null,
          "old_text": "queue_.reset(new NotificationQueue<std::pair<void (*)(void*), void*>>())",
          "new_text": null,
          "old_line_content": "  queue_.reset(new NotificationQueue<std::pair<void (*)(void*), void*>>());",
          "new_line_content": "void EventBase::initNotificationQueue() {",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "std::make_pair(fn, arg)",
          "new_api": null,
          "old_text": "std::make_pair(fn, arg)",
          "new_text": null,
          "old_line_content": "    queue_->putMessage(std::make_pair(fn, arg));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 703,
          "old_api": "reset",
          "new_api": null,
          "old_text": "fnRunner_.reset(new FunctionRunner())",
          "new_text": null,
          "old_line_content": "  fnRunner_.reset(new FunctionRunner());",
          "new_line_content": "  // as a member of EventBase solely so that we don't need to include",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "what",
          "new_api": null,
          "old_text": "ex.what()",
          "new_text": null,
          "old_line_content": "               << fn << \"for EventBase thread: \" << ex.what();",
          "new_line_content": "  } catch (const std::exception& ex) {",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  assert(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "isRunning",
          "new_api": null,
          "old_text": "isRunning()",
          "new_text": null,
          "old_line_content": "  if (isRunning()) {",
          "new_line_content": "  name_ = name;",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": "load",
          "new_api": null,
          "old_text": "loopThread_.load(std::memory_order_relaxed)",
          "new_text": null,
          "old_line_content": "    setThreadName(loopThread_.load(std::memory_order_relaxed),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "inRunningEventBaseThread",
          "new_api": null,
          "old_text": "inRunningEventBaseThread()",
          "new_text": null,
          "old_line_content": "  if (inRunningEventBaseThread()) {",
          "new_line_content": "bool EventBase::runInEventBaseThread(const Cob& fn) {",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "runInLoop",
          "new_api": null,
          "old_text": "runInLoop(fn)",
          "new_text": null,
          "old_line_content": "    runInLoop(fn);",
          "new_line_content": "  // Short-circuit if we are already in our event base",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": "get",
          "new_api": null,
          "old_text": "queue_.get()",
          "new_text": null,
          "old_line_content": "  fnRunner_->startConsumingInternal(this, queue_.get());",
          "new_line_content": "  // (This is useful for EventBase threads that do nothing but process",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  assert(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 846,
          "old_api": "event_get_version",
          "new_api": null,
          "old_text": "event_get_version()",
          "new_text": null,
          "old_line_content": "const char* EventBase::getLibeventVersion() { return event_get_version(); }",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(11)",
          "new_text": null,
          "old_line_content": "  VLOG(11) << \"expCoeff_ \" << expCoeff_ << \" \" << __PRETTY_FUNCTION__;",
          "new_line_content": "void EventBase::SmoothLoopTime::setTimeInterval(uint64_t timeInterval) {",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": "event_get_method",
          "new_api": null,
          "old_text": "event_get_method()",
          "new_text": null,
          "old_line_content": "const char* EventBase::getLibeventMethod() { return event_get_method(); }",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "time_since_epoch",
          "new_api": null,
          "old_text": "std::chrono::duration_cast<std::chrono::microseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count()",
          "new_text": null,
          "old_line_content": "    startWork_ = std::chrono::duration_cast<std::chrono::microseconds>(",
          "new_line_content": "      // set the time",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(11)",
          "new_text": null,
          "old_line_content": "    VLOG(11) << \"EventBase \" << this << \" \" << __PRETTY_FUNCTION__ <<",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": "LOG",
          "new_api": null,
          "old_text": "LOG(ERROR)",
          "new_text": null,
          "old_line_content": "    LOG(ERROR) << \"failed to allocate tr::function copy \"",
          "new_line_content": "    fnCopy = new Cob(fn);",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "runInEventBaseThread",
          "new_api": null,
          "old_text": "runInEventBaseThread(&EventBase::runFunctionPtr, fnCopy)",
          "new_text": null,
          "old_line_content": "  if (!runInEventBaseThread(&EventBase::runFunctionPtr, fnCopy)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(5)",
          "new_text": null,
          "old_line_content": "  VLOG(5) << \"EventBase(): Received terminateLoopSoon() command.\";",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "inRunningEventBaseThread",
          "new_api": null,
          "old_text": "inRunningEventBaseThread()",
          "new_text": null,
          "old_line_content": "  if (inRunningEventBaseThread()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "LOG",
          "new_api": null,
          "old_text": "LOG(ERROR)",
          "new_text": null,
          "old_line_content": "    LOG(ERROR) << \"EventBase \" << this << \": Waiting in the event loop is not \"",
          "new_line_content": "bool EventBase::runInEventBaseThreadAndWait(const Cob& fn) {",
          "content_same": false
        },
        {
          "line": 739,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(11)",
          "new_text": null,
          "old_line_content": "  VLOG(11) << \"idle \" << idle << \" oldBusyLeftover_ \" << oldBusyLeftover_ <<",
          "new_line_content": "  // See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": "event_base_loopbreak",
          "new_api": null,
          "old_text": "event_base_loopbreak(evb_)",
          "new_text": null,
          "old_line_content": "  event_base_loopbreak(evb_);",
          "new_line_content": "  // Call event_base_loopbreak() so that libevent will exit the next time",
          "content_same": false
        },
        {
          "line": 503,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  DCHECK(isInEventBaseThread());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "exp",
          "new_api": null,
          "old_text": "exp(idle * expCoeff_)",
          "new_text": null,
          "old_line_content": "  double coeff = exp(idle * expCoeff_);",
          "new_line_content": "  idle -= oldBusyLeftover_;",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": "notify_one",
          "new_api": null,
          "old_text": "runInEventBaseThread([&] {\n      SCOPE_EXIT {\n        std::unique_lock<std::mutex> l(m);\n        ready = true;\n        cv.notify_one();\n        // We cannot release the lock before notify_one, because a spurious\n        // wakeup in the waiting thread may lead to cv and m going out of scope\n        // prematurely.\n      }",
          "new_text": null,
          "old_line_content": "  runInEventBaseThread([&] {",
          "new_line_content": "  std::mutex m;",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "std::make_pair(nullptr, nullptr)",
          "new_api": null,
          "old_text": "std::make_pair(nullptr, nullptr)",
          "new_text": null,
          "old_line_content": "    queue_->putMessage(std::make_pair(nullptr, nullptr));",
          "new_line_content": "  // anyway.",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": "VLOG",
          "new_api": null,
          "old_text": "VLOG(11)",
          "new_text": null,
          "old_line_content": "  VLOG(11) << \"latest \" << latestLoopCnt_ << \" next \" << nextLoopCnt_;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "fn",
          "new_api": null,
          "old_text": "fn()",
          "new_text": null,
          "old_line_content": "      fn();",
          "new_line_content": "        // prematurely.",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "wait",
          "new_api": null,
          "old_text": "cv.wait(l, [&] { return ready; })",
          "new_text": null,
          "old_line_content": "  cv.wait(l, [&] { return ready; });",
          "new_line_content": "  });",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "cancelLoopCallback",
          "new_api": null,
          "old_text": "callback->cancelLoopCallback()",
          "new_text": null,
          "old_line_content": "  callback->cancelLoopCallback();",
          "new_line_content": "void EventBase::runInLoop(LoopCallback* callback, bool thisIteration) {",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": "*fn)()",
          "new_api": null,
          "old_text": "*fn)()",
          "new_text": null,
          "old_line_content": "    (*fn)();",
          "new_line_content": "  // If it does throw, log a message and abort the program.",
          "content_same": false
        },
        {
          "line": 637,
          "old_api": "isInEventBaseThread",
          "new_api": null,
          "old_text": "isInEventBaseThread()",
          "new_text": null,
          "old_line_content": "  if (isInEventBaseThread()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "fn",
          "new_api": null,
          "old_text": "fn()",
          "new_text": null,
          "old_line_content": "    fn();",
          "new_line_content": "bool EventBase::runImmediatelyOrRunInEventBaseThreadAndWait(const Cob& fn) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 22,
      "total_additions": 70,
      "total_deletions": 70,
      "total_api_changes": 162
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 162,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          464,
          468,
          469,
          462
        ]
      }
    },
    "api_calls_before": 245,
    "api_calls_after": 245,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 5,
      "total_diff_lines": 25
    }
  }
}