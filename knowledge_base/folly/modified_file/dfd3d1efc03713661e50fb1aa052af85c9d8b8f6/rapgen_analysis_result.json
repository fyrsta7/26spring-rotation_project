{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/dfd3d1efc03713661e50fb1aa052af85c9d8b8f6",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/dfd3d1efc03713661e50fb1aa052af85c9d8b8f6/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/dfd3d1efc03713661e50fb1aa052af85c9d8b8f6/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/dfd3d1efc03713661e50fb1aa052af85c9d8b8f6/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 112,
          "old_api": "compare_exchange_strong",
          "new_api": "load",
          "old_text": "work_.compare_exchange_strong(tmp, target)",
          "new_text": "work_.load(std::memory_order_acquire)",
          "old_line_content": "    if (work < target && work_.compare_exchange_strong(tmp, target)) {",
          "new_line_content": "    auto work = work_.load(std::memory_order_acquire);",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": "readFull",
          "new_api": "waitForZero",
          "old_text": "counters_.readFull(next & 1)",
          "new_text": "counters_.waitForZero(next & 1)",
          "old_line_content": "    if (counters_.readFull(next & 1) != 0) {",
          "new_line_content": "    counters_.waitForZero(next & 1);",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "store",
          "new_api": "splice",
          "old_text": "version_.store(next, std::memory_order_release)",
          "new_text": "queues_[1].splice(queues_[0])",
          "old_line_content": "  version_.store(next, std::memory_order_release);",
          "new_line_content": "  queues_[1].splice(queues_[0]);",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": "completeTurn",
          "new_api": "store",
          "old_text": "turn_.completeTurn(curr)",
          "new_text": "version_.store(next, std::memory_order_release)",
          "old_line_content": "  turn_.completeTurn(curr);",
          "new_line_content": "  version_.store(next, std::memory_order_release);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 162,
          "old_api": null,
          "new_api": "readFull",
          "old_text": null,
          "new_text": "counters_.readFull(next & 1)",
          "old_line_content": "    }",
          "new_line_content": "    if (counters_.readFull(next & 1) != 0) {",
          "content_same": false
        },
        {
          "line": 98,
          "old_api": null,
          "new_api": "forEach",
          "old_text": null,
          "new_text": "finished.forEach(\n        [&](list_node* item) { executor_->add(std::move(item->cb_)); })",
          "old_line_content": "  }",
          "new_line_content": "    finished.forEach(",
          "content_same": false
        },
        {
          "line": 132,
          "old_api": null,
          "new_api": "tryWaitForTurn",
          "old_text": null,
          "new_text": "turn_.tryWaitForTurn(work, cutoff, false)",
          "old_line_content": "  }",
          "new_line_content": "      turn_.tryWaitForTurn(work, cutoff, false);",
          "content_same": false
        },
        {
          "line": 99,
          "old_api": null,
          "new_api": "std::move(item->cb_)",
          "old_text": null,
          "new_text": "std::move(item->cb_)",
          "old_line_content": "}",
          "new_line_content": "        [&](list_node* item) { executor_->add(std::move(item->cb_)); });",
          "content_same": false
        },
        {
          "line": 169,
          "old_api": null,
          "new_api": "splice",
          "old_text": null,
          "new_text": "finished.splice(queues_[1])",
          "old_line_content": "",
          "new_line_content": "  finished.splice(queues_[1]);",
          "content_same": false
        },
        {
          "line": 105,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "version_.load(std::memory_order_acquire)",
          "old_line_content": "  auto target = curr + 2;",
          "new_line_content": "  auto curr = version_.load(std::memory_order_acquire);",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "version_.load(std::memory_order_acquire)",
          "old_line_content": "      }",
          "new_line_content": "      if (version_.load(std::memory_order_acquire) >= target) {",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "completeTurn",
          "old_text": null,
          "new_text": "turn_.completeTurn(curr)",
          "old_line_content": "",
          "new_line_content": "  turn_.completeTurn(curr);",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": null,
          "new_api": "compare_exchange_strong",
          "old_text": null,
          "new_text": "work_.compare_exchange_strong(tmp, target)",
          "old_line_content": "      {",
          "new_line_content": "    if (work < target && work_.compare_exchange_strong(tmp, target)) {",
          "content_same": false
        },
        {
          "line": 147,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "version_.load(std::memory_order_acquire)",
          "old_line_content": "",
          "new_line_content": "  uint64_t curr = version_.load(std::memory_order_acquire);",
          "content_same": false
        },
        {
          "line": 118,
          "old_api": null,
          "new_api": "load",
          "old_text": null,
          "new_text": "version_.load(std::memory_order_acquire)",
          "old_line_content": "        }",
          "new_line_content": "        while (version_.load(std::memory_order_acquire) < target) {",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "half_sync",
          "old_text": null,
          "new_text": "half_sync(true, finished)",
          "old_line_content": "      }",
          "new_line_content": "          half_sync(true, finished);",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": null,
          "new_api": "compare_exchange_strong",
          "old_text": null,
          "new_text": "syncTime_.compare_exchange_strong(\n          syncTime, time, std::memory_order_relaxed)",
          "old_line_content": "    {",
          "new_line_content": "      syncTime_.compare_exchange_strong(",
          "content_same": false
        },
        {
          "line": 123,
          "old_api": null,
          "new_api": "forEach",
          "old_text": null,
          "new_text": "finished.forEach(\n          [&](list_node* node) { executor_->add(std::move(node->cb_)); })",
          "old_line_content": "      return;",
          "new_line_content": "      finished.forEach(",
          "content_same": false
        },
        {
          "line": 124,
          "old_api": null,
          "new_api": "std::move(node->cb_)",
          "old_text": null,
          "new_text": "std::move(node->cb_)",
          "old_line_content": "    } else {",
          "new_line_content": "          [&](list_node* node) { executor_->add(std::move(node->cb_)); });",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": null,
          "new_api": "collect",
          "old_text": null,
          "new_text": "q_.collect(queues_[0])",
          "old_line_content": "  if (blocking) {",
          "new_line_content": "  q_.collect(queues_[0]);",
          "content_same": false
        },
        {
          "line": 95,
          "old_api": null,
          "new_api": "half_sync",
          "old_text": null,
          "new_text": "half_sync(false, finished)",
          "old_line_content": "    // callbacks are called outside of syncMutex_",
          "new_line_content": "      half_sync(false, finished);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 96,
          "old_api": "forEach",
          "new_api": null,
          "old_text": "finished.forEach(\n        [&](list_node* item) { executor_->add(std::move(item->cb_)); })",
          "new_text": null,
          "old_line_content": "    finished.forEach(",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 97,
          "old_api": "std::move(item->cb_)",
          "new_api": null,
          "old_text": "std::move(item->cb_)",
          "new_text": null,
          "old_line_content": "        [&](list_node* item) { executor_->add(std::move(item->cb_)); });",
          "new_line_content": "    // callbacks are called outside of syncMutex_",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "tryWaitForTurn",
          "new_api": null,
          "old_text": "turn_.tryWaitForTurn(work, cutoff, false)",
          "new_text": null,
          "old_line_content": "      turn_.tryWaitForTurn(work, cutoff, false);",
          "new_line_content": "      std::atomic<uint32_t> cutoff{100};",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": "splice",
          "new_api": null,
          "old_text": "finished.splice(queues_[1])",
          "new_text": null,
          "old_line_content": "  finished.splice(queues_[1]);",
          "new_line_content": "  // Run callbacks that have been through two epochs, and swap queues",
          "content_same": false
        },
        {
          "line": 168,
          "old_api": "splice",
          "new_api": null,
          "old_text": "queues_[1].splice(queues_[0])",
          "new_text": null,
          "old_line_content": "  queues_[1].splice(queues_[0]);",
          "new_line_content": "  // for those only through a single epoch.",
          "content_same": false
        },
        {
          "line": 103,
          "old_api": "load",
          "new_api": null,
          "old_text": "version_.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "  auto curr = version_.load(std::memory_order_acquire);",
          "new_line_content": "template <typename Tag>",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": "load",
          "new_api": null,
          "old_text": "work_.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "    auto work = work_.load(std::memory_order_acquire);",
          "new_line_content": "    // If someone else is already assigned, we can wait for",
          "content_same": false
        },
        {
          "line": 145,
          "old_api": "load",
          "new_api": null,
          "old_text": "version_.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "  uint64_t curr = version_.load(std::memory_order_acquire);",
          "new_line_content": "template <typename Tag>",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": "load",
          "new_api": null,
          "old_text": "version_.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "        while (version_.load(std::memory_order_acquire) < target) {",
          "new_line_content": "      {",
          "content_same": false
        },
        {
          "line": 117,
          "old_api": "half_sync",
          "new_api": null,
          "old_text": "half_sync(true, finished)",
          "new_text": null,
          "old_line_content": "          half_sync(true, finished);",
          "new_line_content": "        std::lock_guard<std::mutex> g(syncMutex_);",
          "content_same": false
        },
        {
          "line": 125,
          "old_api": "load",
          "new_api": null,
          "old_text": "version_.load(std::memory_order_acquire)",
          "new_text": null,
          "old_line_content": "      if (version_.load(std::memory_order_acquire) >= target) {",
          "new_line_content": "      return;",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": "forEach",
          "new_api": null,
          "old_text": "finished.forEach(\n          [&](list_node* node) { executor_->add(std::move(node->cb_)); })",
          "new_text": null,
          "old_line_content": "      finished.forEach(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": "std::move(node->cb_)",
          "new_api": null,
          "old_text": "std::move(node->cb_)",
          "new_text": null,
          "old_line_content": "          [&](list_node* node) { executor_->add(std::move(node->cb_)); });",
          "new_line_content": "      // callbacks are called outside of syncMutex_",
          "content_same": false
        },
        {
          "line": 155,
          "old_api": "collect",
          "new_api": null,
          "old_text": "q_.collect(queues_[0])",
          "new_text": null,
          "old_line_content": "  q_.collect(queues_[0]);",
          "new_line_content": "  // and instead drain it, so concurrent calls to call() are safe,",
          "content_same": false
        },
        {
          "line": 92,
          "old_api": "store",
          "new_api": null,
          "old_text": "syncTime_.store(time, std::memory_order_relaxed)",
          "new_text": null,
          "old_line_content": "      syncTime_.store(time, std::memory_order_relaxed);",
          "new_line_content": "    list_head finished;",
          "content_same": false
        },
        {
          "line": 93,
          "old_api": "half_sync",
          "new_api": null,
          "old_text": "half_sync(false, finished)",
          "new_text": null,
          "old_line_content": "      half_sync(false, finished);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "waitForZero",
          "new_api": null,
          "old_text": "counters_.waitForZero(next & 1)",
          "new_text": null,
          "old_line_content": "    counters_.waitForZero(next & 1);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 4,
      "total_additions": 17,
      "total_deletions": 17,
      "total_api_changes": 38
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 38,
        "non_api_lines": 3,
        "non_api_line_numbers": [
          88,
          89,
          91
        ]
      }
    },
    "api_calls_before": 43,
    "api_calls_after": 43,
    "diff_info": {
      "added_lines": 4,
      "removed_lines": 2,
      "total_diff_lines": 21
    }
  }
}