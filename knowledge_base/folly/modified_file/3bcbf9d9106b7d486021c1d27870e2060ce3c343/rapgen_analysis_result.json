{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/3bcbf9d9106b7d486021c1d27870e2060ce3c343",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/3bcbf9d9106b7d486021c1d27870e2060ce3c343/before.h",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/3bcbf9d9106b7d486021c1d27870e2060ce3c343/after.h",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/folly/modified_file/3bcbf9d9106b7d486021c1d27870e2060ce3c343/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": true,
    "api_changes": {
      "replacements": [
        {
          "line": 849,
          "old_api": "hasIndex",
          "new_api": "prefetchAddr",
          "old_text": "last.hasIndex()",
          "new_text": "prefetchAddr(&*c - 1)",
          "old_line_content": "      if (LIKELY(last.hasIndex())) {",
          "new_line_content": "      prefetchAddr(&*c - 1);",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "index",
          "new_api": "hasIndex",
          "old_text": "last.index()",
          "new_text": "last.hasIndex()",
          "old_line_content": "        index_ = last.index();",
          "new_line_content": "      if (LIKELY(last.hasIndex())) {",
          "content_same": false
        },
        {
          "line": 851,
          "old_api": "item",
          "new_api": "index",
          "old_text": "c->item(index_)",
          "new_text": "last.index()",
          "old_line_content": "        itemPtr_ = std::pointer_traits<ItemPtr>::pointer_to(c->item(index_));",
          "new_line_content": "        index_ = last.index();",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "hasIndex",
          "new_api": "lastOccupied",
          "old_text": "last.hasIndex()",
          "new_text": "c->lastOccupied()",
          "old_line_content": "      if (LIKELY(last.hasIndex())) {",
          "new_line_content": "      auto last = c->lastOccupied();",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": "index",
          "new_api": "hasIndex",
          "old_text": "last.index()",
          "new_text": "last.hasIndex()",
          "old_line_content": "        index_ = last.index();",
          "new_line_content": "      if (LIKELY(last.hasIndex())) {",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": "item",
          "new_api": "index",
          "old_text": "c->item(index_)",
          "new_text": "last.index()",
          "old_line_content": "        itemPtr_ = std::pointer_traits<ItemPtr>::pointer_to(c->item(index_));",
          "new_line_content": "        index_ = last.index();",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "Chunk::owner(*itemPtr_, index_)",
          "new_api": "std::pointer_traits<ChunkPtr>::pointer_to(\n        Chunk::owner(*itemPtr_, index_))",
          "old_text": "Chunk::owner(*itemPtr_, index_)",
          "new_text": "std::pointer_traits<ChunkPtr>::pointer_to(\n        Chunk::owner(*itemPtr_, index_))",
          "old_line_content": "        Chunk::owner(*itemPtr_, index_));",
          "new_line_content": "    return std::pointer_traits<ChunkPtr>::pointer_to(",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "folly::assume_unreachable()",
          "new_api": "noreturn",
          "old_text": "folly::assume_unreachable()",
          "new_text": "noreturn",
          "old_line_content": "    folly::assume_unreachable();",
          "new_line_content": "  [[noreturn]] typename ItemIter::Packed& packedBegin() {",
          "content_same": false
        },
        {
          "line": 954,
          "old_api": "folly::assume_unreachable()",
          "new_api": "noreturn",
          "old_text": "folly::assume_unreachable()",
          "new_text": "noreturn",
          "old_line_content": "    folly::assume_unreachable();",
          "new_line_content": "  [[noreturn]] typename ItemIter::Packed const& packedBegin() const {",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": "std::numeric_limits<std::size_t>::max)()",
          "new_api": "constexpr",
          "old_text": "std::numeric_limits<std::size_t>::max)()",
          "new_text": "constexpr",
          "old_line_content": "          (std::numeric_limits<std::size_t>::max)() / Chunk::kDesiredCapacity;",
          "new_line_content": "      constexpr std::size_t kMaxChunksWithoutCapacityOverflow =",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": "throw_exception<std::bad_alloc>()",
          "new_api": "max_size",
          "old_text": "throw_exception<std::bad_alloc>()",
          "new_text": "max_size()",
          "old_line_content": "        throw_exception<std::bad_alloc>();",
          "new_line_content": "              maxSizeWithoutRehash > max_size())) {",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": "rehashImpl",
          "new_api": "bucket_count",
          "old_text": "rehashImpl(chunkCount, maxSizeWithoutRehash)",
          "new_text": "bucket_count()",
          "old_line_content": "      rehashImpl(chunkCount, maxSizeWithoutRehash);",
          "new_line_content": "    if (bucket_count() != maxSizeWithoutRehash) {",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": "reserveForInsertImpl",
          "new_api": "bucket_count",
          "old_text": "reserveForInsertImpl(incoming)",
          "new_text": "bucket_count()",
          "old_line_content": "      reserveForInsertImpl(incoming);",
          "new_line_content": "    if (size() + incoming - 1 >= bucket_count()) {",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": "atEnd",
          "new_api": "findImpl",
          "old_text": "existing.atEnd()",
          "new_text": "findImpl(hp, key)",
          "old_line_content": "    if (!existing.atEnd()) {",
          "new_line_content": "    auto existing = findImpl(hp, key);",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "std::make_pair(existing, false)",
          "new_api": "atEnd",
          "old_text": "std::make_pair(existing, false)",
          "new_text": "existing.atEnd()",
          "old_line_content": "      return std::make_pair(existing, false);",
          "new_line_content": "    if (!existing.atEnd()) {",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": "probeDelta",
          "new_api": "hasIndex",
          "old_text": "probeDelta(hp)",
          "new_text": "firstEmpty.hasIndex()",
          "old_line_content": "      std::size_t delta = probeDelta(hp);",
          "new_line_content": "    if (!firstEmpty.hasIndex()) {",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "hasIndex",
          "new_api": "firstEmpty",
          "old_text": "firstEmpty.hasIndex()",
          "new_text": "chunk->firstEmpty()",
          "old_line_content": "      } while (!firstEmpty.hasIndex());",
          "new_line_content": "        firstEmpty = chunk->firstEmpty();",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "adjustHostedOverflowCount",
          "new_api": "hasIndex",
          "old_text": "chunk->adjustHostedOverflowCount(Chunk::kIncrHostedOverflowCount)",
          "new_text": "firstEmpty.hasIndex()",
          "old_line_content": "      chunk->adjustHostedOverflowCount(Chunk::kIncrHostedOverflowCount);",
          "new_line_content": "      } while (!firstEmpty.hasIndex());",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "occupied",
          "new_api": "index",
          "old_text": "chunk->occupied(itemIndex)",
          "new_text": "firstEmpty.index()",
          "old_line_content": "    FOLLY_SAFE_DCHECK(!chunk->occupied(itemIndex), \"\");",
          "new_line_content": "    std::size_t itemIndex = firstEmpty.index();",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": "std::make_pair(iter, true)",
          "new_api": "std::forward<Args>(args)",
          "old_text": "std::make_pair(iter, true)",
          "new_text": "std::forward<Args>(args)",
          "old_line_content": "    return std::make_pair(iter, true);",
          "new_line_content": "    insertAtBlank(iter, hp, std::forward<Args>(args)...);",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": "bucket_count",
          "new_api": "Chunk::emptyInstance()",
          "old_text": "bucket_count()",
          "new_text": "Chunk::emptyInstance()",
          "old_line_content": "      FOLLY_SAFE_DCHECK(empty() && bucket_count() == 0, \"\");",
          "new_line_content": "    if (chunks_ == Chunk::emptyInstance()) {",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": "bucket_count",
          "new_api": "size",
          "old_text": "bucket_count()",
          "new_text": "size()",
          "old_line_content": "    auto origCapacity = bucket_count();",
          "new_line_content": "    auto origSize = size();",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": "Policy::destroyItemOnClear()",
          "new_api": "empty",
          "old_text": "Policy::destroyItemOnClear()",
          "new_text": "empty()",
          "old_line_content": "      if (Policy::destroyItemOnClear()) {",
          "new_line_content": "    if (!empty()) {",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "Policy::prefetchBeforeDestroy()",
          "new_api": "occupiedIter",
          "old_text": "Policy::prefetchBeforeDestroy()",
          "new_text": "chunk->occupiedIter()",
          "old_line_content": "          if (Policy::prefetchBeforeDestroy()) {",
          "new_line_content": "          auto iter = chunk->occupiedIter();",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "hasNext",
          "new_api": "Policy::prefetchBeforeDestroy()",
          "old_text": "piter.hasNext()",
          "new_text": "Policy::prefetchBeforeDestroy()",
          "old_line_content": "            for (auto piter = iter; piter.hasNext();) {",
          "new_line_content": "          if (Policy::prefetchBeforeDestroy()) {",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": "next",
          "new_api": "hasNext",
          "old_text": "piter.next()",
          "new_text": "piter.hasNext()",
          "old_line_content": "              this->prefetchValue(chunk->item(piter.next()));",
          "new_line_content": "            for (auto piter = iter; piter.hasNext();) {",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "next",
          "new_api": "hasNext",
          "old_text": "iter.next()",
          "new_text": "iter.hasNext()",
          "old_line_content": "            this->destroyItem(chunk->item(iter.next()));",
          "new_line_content": "          while (iter.hasNext()) {",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "static_cast<void*>(&*chunks_)",
          "new_api": "std::pointer_traits<BytePtr>::pointer_to(\n          *static_cast<uint8_t*>(static_cast<void*>(&*chunks_)))",
          "old_text": "static_cast<void*>(&*chunks_)",
          "new_text": "std::pointer_traits<BytePtr>::pointer_to(\n          *static_cast<uint8_t*>(static_cast<void*>(&*chunks_)))",
          "old_line_content": "          *static_cast<uint8_t*>(static_cast<void*>(&*chunks_)));",
          "new_line_content": "      BytePtr rawAllocation = std::pointer_traits<BytePtr>::pointer_to(",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "bucket_count",
          "new_api": "static_cast<void*>(&*chunks_)",
          "old_text": "bucket_count()",
          "new_text": "static_cast<void*>(&*chunks_)",
          "old_line_content": "      std::size_t rawSize = chunkAllocSize(chunkMask_ + 1, bucket_count());",
          "new_line_content": "          *static_cast<uint8_t*>(static_cast<void*>(&*chunks_)));",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": "adjustSizeAndBeginBeforeErase",
          "new_api": "item",
          "old_text": "adjustSizeAndBeginBeforeErase(pos)",
          "new_text": "pos.item()",
          "old_line_content": "    adjustSizeAndBeginBeforeErase(pos);",
          "new_line_content": "    this->destroyItem(pos.item());",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "eraseBlank",
          "new_api": "adjustSizeAndBeginBeforeErase",
          "old_text": "eraseBlank(pos, hp)",
          "new_text": "adjustSizeAndBeginBeforeErase(pos)",
          "old_line_content": "    eraseBlank(pos, hp);",
          "new_line_content": "    adjustSizeAndBeginBeforeErase(pos);",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "citem",
          "new_api": "chunk",
          "old_text": "pos.citem()",
          "new_text": "pos.chunk()->hostedOverflowCount()",
          "old_line_content": "      hp = splitHash(this->computeItemHash(pos.citem()));",
          "new_line_content": "    if (pos.chunk()->hostedOverflowCount() != 0) {",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "eraseImpl",
          "new_api": "item",
          "old_text": "eraseImpl(pos, hp)",
          "new_text": "pos.item()",
          "old_line_content": "    eraseImpl(pos, hp);",
          "new_line_content": "    beforeDestroy(this->valueAtItemForExtract(pos.item()));",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "findImpl",
          "new_api": "computeKeyHash",
          "old_text": "findImpl(hp, key)",
          "new_text": "this->computeKeyHash(key)",
          "old_line_content": "    auto iter = findImpl(hp, key);",
          "new_line_content": "    auto hp = splitHash(this->computeKeyHash(key));",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "atEnd",
          "new_api": "findImpl",
          "old_text": "iter.atEnd()",
          "new_text": "findImpl(hp, key)",
          "old_line_content": "    if (!iter.atEnd()) {",
          "new_line_content": "    auto iter = findImpl(hp, key);",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": "item",
          "new_api": "atEnd",
          "old_text": "iter.item()",
          "new_text": "iter.atEnd()",
          "old_line_content": "      beforeDestroy(this->valueAtItemForExtract(iter.item()));",
          "new_line_content": "    if (!iter.atEnd()) {",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": "eraseImpl",
          "new_api": "item",
          "old_text": "eraseImpl(iter, hp)",
          "new_text": "iter.item()",
          "old_line_content": "      eraseImpl(iter, hp);",
          "new_line_content": "      beforeDestroy(this->valueAtItemForExtract(iter.item()));",
          "content_same": false
        },
        {
          "line": 2033,
          "old_api": "visitPolicyAllocationClasses",
          "new_api": "bucket_count",
          "old_text": "this->visitPolicyAllocationClasses(\n        (bc == 0 ? 0 : chunkAllocSize(chunkMask_ + 1, bc)),\n        size(),\n        bc,\n        visitor)",
          "new_text": "bucket_count()",
          "old_line_content": "    this->visitPolicyAllocationClasses(",
          "new_line_content": "    auto bc = bucket_count();",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": "chunkAllocSize",
          "new_api": "visitPolicyAllocationClasses",
          "old_text": "chunkAllocSize(chunkMask_ + 1, bc)",
          "new_text": "this->visitPolicyAllocationClasses(\n        (bc == 0 ? 0 : chunkAllocSize(chunkMask_ + 1, bc)),\n        size(),\n        bc,\n        visitor)",
          "old_line_content": "        (bc == 0 ? 0 : chunkAllocSize(chunkMask_ + 1, bc)),",
          "new_line_content": "    this->visitPolicyAllocationClasses(",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "size",
          "new_api": "chunkAllocSize",
          "old_text": "size()",
          "new_text": "chunkAllocSize(chunkMask_ + 1, bc)",
          "old_line_content": "        size(),",
          "new_line_content": "        (bc == 0 ? 0 : chunkAllocSize(chunkMask_ + 1, bc)),",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "Policy::prefetchBeforeCopy()",
          "new_api": "occupiedIter",
          "old_text": "Policy::prefetchBeforeCopy()",
          "new_text": "chunk->occupiedIter()",
          "old_line_content": "      if (Policy::prefetchBeforeCopy()) {",
          "new_line_content": "      auto iter = chunk->occupiedIter();",
          "content_same": false
        },
        {
          "line": 2048,
          "old_api": "hasNext",
          "new_api": "Policy::prefetchBeforeCopy()",
          "old_text": "piter.hasNext()",
          "new_text": "Policy::prefetchBeforeCopy()",
          "old_line_content": "        for (auto piter = iter; piter.hasNext();) {",
          "new_line_content": "      if (Policy::prefetchBeforeCopy()) {",
          "content_same": false
        },
        {
          "line": 2049,
          "old_api": "next",
          "new_api": "hasNext",
          "old_text": "piter.next()",
          "new_text": "piter.hasNext()",
          "old_line_content": "          this->prefetchValue(chunk->citem(piter.next()));",
          "new_line_content": "        for (auto piter = iter; piter.hasNext();) {",
          "content_same": false
        },
        {
          "line": 2053,
          "old_api": "next",
          "new_api": "hasNext",
          "old_text": "iter.next()",
          "new_text": "iter.hasNext()",
          "old_line_content": "        visitor(chunk->citem(iter.next()));",
          "new_line_content": "      while (iter.hasNext()) {",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "next",
          "new_api": "hasNext",
          "old_text": "iter.next()",
          "new_text": "iter.hasNext()",
          "old_line_content": "        auto be = iter.next();",
          "new_line_content": "      for (auto iter = chunk->occupiedRangeIter(); iter.hasNext();) {",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "occupied",
          "new_api": "next",
          "old_text": "FOLLY_SAFE_DCHECK(\n            chunk->occupied(be.first) && chunk->occupied(be.second - 1), \"\")",
          "new_text": "iter.next()",
          "old_line_content": "        FOLLY_SAFE_DCHECK(",
          "new_line_content": "        auto be = iter.next();",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": "itemAddr",
          "new_api": "occupied",
          "old_text": "chunk->itemAddr(be.first)",
          "new_text": "chunk->occupied(be.second - 1)",
          "old_line_content": "        Item const* b = chunk->itemAddr(be.first);",
          "new_line_content": "            chunk->occupied(be.first) && chunk->occupied(be.second - 1), \"\");",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "visitor",
          "new_api": "itemAddr",
          "old_text": "visitor(b, b + (be.second - be.first))",
          "new_text": "chunk->itemAddr(be.first)",
          "old_line_content": "        visitor(b, b + (be.second - be.first));",
          "new_line_content": "        Item const* b = chunk->itemAddr(be.first);",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "resize",
          "new_api": "size",
          "old_text": "histo.resize(index + 1)",
          "new_text": "histo.size()",
          "old_line_content": "      histo.resize(index + 1);",
          "new_line_content": "    if (histo.size() <= index) {",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "pack",
          "new_api": "advance",
          "old_text": "prev.pack()",
          "new_text": "iter.advance()",
          "old_line_content": "        FOLLY_SAFE_DCHECK(n == 0 || iter.pack() < prev.pack(), \"\");",
          "new_line_content": "      for (auto iter = begin(); iter != end(); iter.advance()) {",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "bucket_count",
          "new_api": "FOLLY_SAFE_DCHECK",
          "old_text": "bucket_count()",
          "new_text": "FOLLY_SAFE_DCHECK(\n        (chunks_ == Chunk::emptyInstance()) == (bucket_count() == 0), \"\")",
          "old_line_content": "        (chunks_ == Chunk::emptyInstance()) == (bucket_count() == 0), \"\");",
          "new_line_content": "    FOLLY_SAFE_DCHECK(",
          "content_same": false
        },
        {
          "line": 2120,
          "old_api": "outboundOverflowCount",
          "new_api": "histoAt",
          "old_text": "histoAt(\n          stats.chunkOutboundOverflowHisto, chunk->outboundOverflowCount())",
          "new_text": "histoAt(stats.chunkOccupancyHisto, chunkOccupied)",
          "old_line_content": "      histoAt(",
          "new_line_content": "      histoAt(stats.chunkOccupancyHisto, chunkOccupied)++;",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "hostedOverflowCount",
          "new_api": "outboundOverflowCount",
          "old_text": "chunk->hostedOverflowCount()",
          "new_text": "chunk->outboundOverflowCount()",
          "old_line_content": "      histoAt(stats.chunkHostedOverflowHisto, chunk->hostedOverflowCount())++;",
          "new_line_content": "          stats.chunkOutboundOverflowHisto, chunk->outboundOverflowCount())++;",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "next",
          "new_api": "hasNext",
          "old_text": "iter.next()",
          "new_text": "iter.hasNext()",
          "old_line_content": "        auto ii = iter.next();",
          "new_line_content": "      while (iter.hasNext()) {",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": "computeItemHash",
          "new_api": "citem",
          "old_text": "this->computeItemHash(item)",
          "new_text": "chunk->citem(ii)",
          "old_line_content": "          auto hp = splitHash(this->computeItemHash(item));",
          "new_line_content": "          auto& item = chunk->citem(ii);",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "tag",
          "new_api": "computeItemHash",
          "old_text": "chunk->tag(ii)",
          "new_text": "this->computeItemHash(item)",
          "old_line_content": "          FOLLY_SAFE_DCHECK(chunk->tag(ii) == hp.second, \"\");",
          "new_line_content": "          auto hp = splitHash(this->computeItemHash(item));",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "size",
          "new_api": "getAllocatedMemorySize",
          "old_text": "size()",
          "new_text": "getAllocatedMemorySize()",
          "old_line_content": "    stats.overheadBytes = stats.totalBytes - size() * sizeof(value_type);",
          "new_line_content": "    stats.totalBytes = sizeof(*this) + getAllocatedMemorySize();",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2050,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "piter.next()",
          "old_line_content": "        }",
          "new_line_content": "          this->prefetchValue(chunk->citem(piter.next()));",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "iter.next()",
          "old_line_content": "      }",
          "new_line_content": "        visitor(chunk->citem(iter.next()));",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "lastOccupiedChunk",
          "old_text": null,
          "new_text": "lastOccupiedChunk()",
          "old_line_content": "    auto chunk = &chunks_[0];",
          "new_line_content": "    std::size_t maxChunkIndex = lastOccupiedChunk() - chunks_;",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": null,
          "new_api": "visitor",
          "old_text": null,
          "new_text": "visitor(b, b + (be.second - be.first))",
          "old_line_content": "      }",
          "new_line_content": "        visitor(b, b + (be.second - be.first));",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "histoAt",
          "old_text": null,
          "new_text": "histoAt(\n      std::vector<std::size_t>& histo,\n      std::size_t index)",
          "old_line_content": "      std::vector<std::size_t>& histo,",
          "new_line_content": "  static std::size_t& histoAt(",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "histo.resize(index + 1)",
          "old_line_content": "    }",
          "new_line_content": "      histo.resize(index + 1);",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "at",
          "old_text": null,
          "new_text": "histo.at(index)",
          "old_line_content": "  }",
          "new_line_content": "    return histo.at(index);",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": null,
          "new_api": "pack",
          "old_text": null,
          "new_text": "prev.pack()",
          "old_line_content": "        ++n;",
          "new_line_content": "        FOLLY_SAFE_DCHECK(n == 0 || iter.pack() < prev.pack(), \"\");",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "    }",
          "new_line_content": "      FOLLY_SAFE_DCHECK(n == size(), \"\");",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": null,
          "new_api": "bucket_count",
          "old_text": null,
          "new_text": "bucket_count()",
          "old_line_content": "",
          "new_line_content": "        (chunks_ == Chunk::emptyInstance()) == (bucket_count() == 0), \"\");",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": "bucket_count",
          "old_text": null,
          "new_text": "bucket_count()",
          "old_line_content": "    for (std::size_t ci = 0; ci < cc; ++ci) {",
          "new_line_content": "    auto cc = bucket_count() == 0 ? 0 : chunkMask_ + 1;",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": null,
          "new_api": "eof",
          "old_text": null,
          "new_text": "chunk->eof()",
          "old_line_content": "",
          "new_line_content": "      FOLLY_SAFE_DCHECK(chunk->eof() == (ci == 0), \"\");",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": null,
          "new_api": "occupiedIter",
          "old_text": null,
          "new_text": "chunk->occupiedIter()",
          "old_line_content": "",
          "new_line_content": "      auto iter = chunk->occupiedIter();",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "piter.next()",
          "old_line_content": "        ++chunkOccupied;",
          "new_line_content": "      for (auto piter = iter; piter.hasNext(); piter.next()) {",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": null,
          "new_api": "hostedOverflowCount",
          "old_text": null,
          "new_text": "chunk->hostedOverflowCount()",
          "old_line_content": "",
          "new_line_content": "      histoAt(stats.chunkHostedOverflowHisto, chunk->hostedOverflowCount())++;",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "iter.next()",
          "old_line_content": "        ++n2;",
          "new_line_content": "        auto ii = iter.next();",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": null,
          "new_api": "tag",
          "old_text": null,
          "new_text": "chunk->tag(ii)",
          "old_line_content": "",
          "new_line_content": "          FOLLY_SAFE_DCHECK(chunk->tag(ii) == hp.second, \"\");",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": null,
          "new_api": "probeDelta",
          "old_text": null,
          "new_text": "probeDelta(hp)",
          "old_line_content": "          while ((index & chunkMask_) != ci) {",
          "new_line_content": "          std::size_t delta = probeDelta(hp);",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "histoAt",
          "old_text": null,
          "new_text": "histoAt(stats.keyProbeLengthHisto, dist)",
          "old_line_content": "        }",
          "new_line_content": "          histoAt(stats.keyProbeLengthHisto, dist)++;",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "static_cast<uint8_t>(ti == 0 ? 1 : 0)",
          "old_text": null,
          "new_text": "static_cast<uint8_t>(ti == 0 ? 1 : 0)",
          "old_line_content": "          HashPair hp{ci, tag};",
          "new_line_content": "          uint8_t tag = static_cast<uint8_t>(ti == 0 ? 1 : 0);",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": null,
          "new_api": "probeDelta",
          "old_text": null,
          "new_text": "probeDelta(hp)",
          "old_line_content": "          for (std::size_t tries = 0; tries <= chunkMask_ &&",
          "new_line_content": "          std::size_t delta = probeDelta(hp);",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": null,
          "new_api": "outboundOverflowCount",
          "old_text": null,
          "new_text": "chunks_[index & chunkMask_].outboundOverflowCount()",
          "old_line_content": "               ++tries) {",
          "new_line_content": "               chunks_[index & chunkMask_].outboundOverflowCount() != 0;",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": null,
          "new_api": "histoAt",
          "old_text": null,
          "new_text": "histoAt(stats.missProbeLengthHisto, dist)",
          "old_line_content": "        }",
          "new_line_content": "          histoAt(stats.missProbeLengthHisto, dist)++;",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "",
          "new_line_content": "    FOLLY_SAFE_DCHECK(n2 == size(), \"\");",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "name",
          "old_text": null,
          "new_text": "typeid(Policy).name()",
          "old_line_content": "#endif",
          "new_line_content": "    stats.policy = typeid(Policy).name();",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "    stats.valueSize = sizeof(value_type);",
          "new_line_content": "    stats.size = size();",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": null,
          "new_api": "bucket_count",
          "old_text": null,
          "new_text": "bucket_count()",
          "old_line_content": "    stats.chunkCount = cc;",
          "new_line_content": "    stats.bucketCount = bucket_count();",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "",
          "new_line_content": "    stats.overheadBytes = stats.totalBytes - size() * sizeof(value_type);",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "    }",
          "new_line_content": "      capacity = size();",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": null,
          "new_api": "folly::nextPowTwo(\n          (capacity + Chunk::kDesiredCapacity - 1) / Chunk::kDesiredCapacity)",
          "old_text": null,
          "new_text": "folly::nextPowTwo(\n          (capacity + Chunk::kDesiredCapacity - 1) / Chunk::kDesiredCapacity)",
          "old_line_content": "          (capacity + Chunk::kDesiredCapacity - 1) / Chunk::kDesiredCapacity);",
          "new_line_content": "      chunkCount = folly::nextPowTwo(",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": null,
          "new_api": "std::numeric_limits<std::size_t>::max)()",
          "old_text": null,
          "new_text": "std::numeric_limits<std::size_t>::max)()",
          "old_line_content": "",
          "new_line_content": "          (std::numeric_limits<std::size_t>::max)() / Chunk::kDesiredCapacity;",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": null,
          "new_api": "UNLIKELY",
          "old_text": null,
          "new_text": "UNLIKELY(\n              chunkCount > kMaxChunksWithoutCapacityOverflow ||\n              maxSizeWithoutRehash > max_size())",
          "old_line_content": "              chunkCount > kMaxChunksWithoutCapacityOverflow ||",
          "new_line_content": "      if (UNLIKELY(",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": null,
          "new_api": "throw_exception<std::bad_alloc>()",
          "old_text": null,
          "new_text": "throw_exception<std::bad_alloc>()",
          "old_line_content": "      }",
          "new_line_content": "        throw_exception<std::bad_alloc>();",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "rehashImpl",
          "old_text": null,
          "new_text": "rehashImpl(chunkCount, maxSizeWithoutRehash)",
          "old_line_content": "    }",
          "new_line_content": "      rehashImpl(chunkCount, maxSizeWithoutRehash);",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": null,
          "new_api": "rehash",
          "old_text": null,
          "new_text": "rehash(capacity)",
          "old_line_content": "  }",
          "new_line_content": "    rehash(capacity);",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": null,
          "new_api": "reserveForInsertImpl",
          "old_text": null,
          "new_text": "reserveForInsertImpl(incoming)",
          "old_line_content": "    }",
          "new_line_content": "      reserveForInsertImpl(incoming);",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "  }",
          "new_line_content": "    rehash(size() + incoming);",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": null,
          "new_api": "computeKeyHash",
          "old_text": null,
          "new_text": "this->computeKeyHash(key)",
          "old_line_content": "",
          "new_line_content": "    const auto hp = splitHash(this->computeKeyHash(key));",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": null,
          "new_api": "std::make_pair(existing, false)",
          "old_text": null,
          "new_text": "std::make_pair(existing, false)",
          "old_line_content": "    }",
          "new_line_content": "      return std::make_pair(existing, false);",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": null,
          "new_api": "reserveForInsert",
          "old_text": null,
          "new_text": "reserveForInsert()",
          "old_line_content": "",
          "new_line_content": "    reserveForInsert();",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": null,
          "new_api": "firstEmpty",
          "old_text": null,
          "new_text": "chunk->firstEmpty()",
          "old_line_content": "",
          "new_line_content": "    auto firstEmpty = chunk->firstEmpty();",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "probeDelta",
          "old_text": null,
          "new_text": "probeDelta(hp)",
          "old_line_content": "      do {",
          "new_line_content": "      std::size_t delta = probeDelta(hp);",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": null,
          "new_api": "incrOutboundOverflowCount",
          "old_text": null,
          "new_text": "chunk->incrOutboundOverflowCount()",
          "old_line_content": "        index += delta;",
          "new_line_content": "        chunk->incrOutboundOverflowCount();",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "item",
          "old_text": null,
          "new_text": "c->item(index_)",
          "old_line_content": "        return;",
          "new_line_content": "        itemPtr_ = std::pointer_traits<ItemPtr>::pointer_to(c->item(index_));",
          "content_same": false
        },
        {
          "line": 1878,
          "old_api": null,
          "new_api": "adjustHostedOverflowCount",
          "old_text": null,
          "new_text": "chunk->adjustHostedOverflowCount(Chunk::kIncrHostedOverflowCount)",
          "old_line_content": "    }",
          "new_line_content": "      chunk->adjustHostedOverflowCount(Chunk::kIncrHostedOverflowCount);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": null,
          "new_api": "occupied",
          "old_text": null,
          "new_text": "chunk->occupied(itemIndex)",
          "old_line_content": "",
          "new_line_content": "    FOLLY_SAFE_DCHECK(!chunk->occupied(itemIndex), \"\");",
          "content_same": false
        },
        {
          "line": 1883,
          "old_api": null,
          "new_api": "setTag",
          "old_text": null,
          "new_text": "chunk->setTag(itemIndex, hp.second)",
          "old_line_content": "    ItemIter iter{chunk, itemIndex};",
          "new_line_content": "    chunk->setTag(itemIndex, hp.second);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "chunk",
          "old_text": null,
          "new_text": "chunk()",
          "old_line_content": "",
          "new_line_content": "    auto c = chunk();",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": null,
          "new_api": "std::make_pair(iter, true)",
          "old_text": null,
          "new_text": "std::make_pair(iter, true)",
          "old_line_content": "  }",
          "new_line_content": "    return std::make_pair(iter, true);",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": null,
          "new_api": "occupied",
          "old_text": null,
          "new_text": "c->occupied(index_)",
          "old_line_content": "        return;",
          "new_line_content": "      if (LIKELY(c->occupied(index_))) {",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "bucket_count",
          "old_text": null,
          "new_text": "bucket_count()",
          "old_line_content": "      return;",
          "new_line_content": "      FOLLY_SAFE_DCHECK(empty() && bucket_count() == 0, \"\");",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "eof",
          "old_text": null,
          "new_text": "c->eof()",
          "old_line_content": "      --c;",
          "new_line_content": "      FOLLY_SAFE_DCHECK(!c->eof(), \"\");",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "item",
          "old_text": null,
          "new_text": "c->item(index_)",
          "old_line_content": "        return;",
          "new_line_content": "        itemPtr_ = std::pointer_traits<ItemPtr>::pointer_to(c->item(index_));",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": null,
          "new_api": "bucket_count",
          "old_text": null,
          "new_text": "bucket_count()",
          "old_line_content": "    if (willReset) {",
          "new_line_content": "    auto origCapacity = bucket_count();",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "beforeReset",
          "old_text": null,
          "new_text": "this->beforeReset(origSize, origCapacity)",
          "old_line_content": "    } else {",
          "new_line_content": "      this->beforeReset(origSize, origCapacity);",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": null,
          "new_api": "beforeClear",
          "old_text": null,
          "new_text": "this->beforeClear(origSize, origCapacity)",
          "old_line_content": "    }",
          "new_line_content": "      this->beforeClear(origSize, origCapacity);",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": null,
          "new_api": "Chunk::owner(*itemPtr_, index_)",
          "old_text": null,
          "new_text": "Chunk::owner(*itemPtr_, index_)",
          "old_line_content": "  }",
          "new_line_content": "        Chunk::owner(*itemPtr_, index_));",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": null,
          "new_api": "Policy::destroyItemOnClear()",
          "old_text": null,
          "new_text": "Policy::destroyItemOnClear()",
          "old_line_content": "        for (std::size_t ci = 0; ci <= chunkMask_; ++ci) {",
          "new_line_content": "      if (Policy::destroyItemOnClear()) {",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "piter.next()",
          "old_line_content": "            }",
          "new_line_content": "              this->prefetchValue(chunk->item(piter.next()));",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "std::addressof(*itemPtr_)",
          "old_text": null,
          "new_text": "std::addressof(*itemPtr_)",
          "old_line_content": "  }",
          "new_line_content": "    return std::addressof(*itemPtr_);",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": null,
          "new_api": "next",
          "old_text": null,
          "new_text": "iter.next()",
          "old_line_content": "          }",
          "new_line_content": "            this->destroyItem(chunk->item(iter.next()));",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": null,
          "new_api": "chunk0Capacity",
          "old_text": null,
          "new_text": "chunks_[0].chunk0Capacity()",
          "old_line_content": "        for (std::size_t ci = 0; ci <= chunkMask_; ++ci) {",
          "new_line_content": "        auto c0c = chunks_[0].chunk0Capacity();",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "chunks_[ci].clear()",
          "old_line_content": "        }",
          "new_line_content": "          chunks_[ci].clear();",
          "content_same": false
        },
        {
          "line": 909,
          "old_api": null,
          "new_api": "static_cast<uint8_t>(index_)",
          "old_text": null,
          "new_text": "static_cast<uint8_t>(index_)",
          "old_line_content": "  }",
          "new_line_content": "    return Packed{itemPtr_, static_cast<uint8_t>(index_)};",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": null,
          "new_api": "markEof",
          "old_text": null,
          "new_text": "chunks_[0].markEof(c0c)",
          "old_line_content": "      }",
          "new_line_content": "        chunks_[0].markEof(c0c);",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": null,
          "new_api": "pack",
          "old_text": null,
          "new_text": "ItemIter{}.pack()",
          "old_line_content": "      }",
          "new_line_content": "        sizeAndPackedBegin_.packedBegin() = ItemIter{}.pack();",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": null,
          "new_api": "bucket_count",
          "old_text": null,
          "new_text": "bucket_count()",
          "old_line_content": "",
          "new_line_content": "      std::size_t rawSize = chunkAllocSize(chunkMask_ + 1, bucket_count());",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "Chunk::emptyInstance()",
          "old_text": null,
          "new_text": "Chunk::emptyInstance()",
          "old_line_content": "      chunkMask_ = 0;",
          "new_line_content": "      chunks_ = Chunk::emptyInstance();",
          "content_same": false
        },
        {
          "line": 1950,
          "old_api": null,
          "new_api": "afterReset",
          "old_text": null,
          "new_text": "this->afterReset(origSize, origCapacity, rawAllocation, rawSize)",
          "old_line_content": "    } else {",
          "new_line_content": "      this->afterReset(origSize, origCapacity, rawAllocation, rawSize);",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": null,
          "new_api": "afterClear",
          "old_text": null,
          "new_text": "this->afterClear(origSize, origCapacity)",
          "old_line_content": "    }",
          "new_line_content": "      this->afterClear(origSize, origCapacity);",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": null,
          "new_api": "pack",
          "old_text": null,
          "new_text": "ItemIter{}.pack()",
          "old_line_content": "",
          "new_line_content": "  typename ItemIter::Packed packedBegin_{ItemIter{}.pack()};",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "eraseBlank",
          "old_text": null,
          "new_text": "eraseBlank(pos, hp)",
          "old_line_content": "  }",
          "new_line_content": "    eraseBlank(pos, hp);",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": null,
          "new_api": "eraseIterInto",
          "old_text": null,
          "new_text": "eraseIterInto(pos, [](value_type&&) {})",
          "old_line_content": "  }",
          "new_line_content": "    eraseIterInto(pos, [](value_type&&) {});",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "folly::assume_unreachable()",
          "old_text": null,
          "new_text": "folly::assume_unreachable()",
          "old_line_content": "  }",
          "new_line_content": "    folly::assume_unreachable();",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "citem",
          "old_text": null,
          "new_text": "pos.citem()",
          "old_line_content": "    }",
          "new_line_content": "      hp = splitHash(this->computeItemHash(pos.citem()));",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "folly::assume_unreachable()",
          "old_text": null,
          "new_text": "folly::assume_unreachable()",
          "old_line_content": "  }",
          "new_line_content": "    folly::assume_unreachable();",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": null,
          "new_api": "eraseImpl",
          "old_text": null,
          "new_text": "eraseImpl(pos, hp)",
          "old_line_content": "  }",
          "new_line_content": "    eraseImpl(pos, hp);",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": null,
          "new_api": "eraseKeyInto",
          "old_text": null,
          "new_text": "eraseKeyInto(key, [](value_type&&) {})",
          "old_line_content": "  }",
          "new_line_content": "    return eraseKeyInto(key, [](value_type&&) {});",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "      return 0;",
          "new_line_content": "    if (UNLIKELY(size() == 0)) {",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": null,
          "new_api": "eraseImpl",
          "old_text": null,
          "new_text": "eraseImpl(iter, hp)",
          "old_line_content": "      return 1;",
          "new_line_content": "      eraseImpl(iter, hp);",
          "content_same": false
        },
        {
          "line": 2005,
          "old_api": null,
          "new_api": "clearImpl<false>()",
          "old_text": null,
          "new_text": "clearImpl<false>()",
          "old_line_content": "  }",
          "new_line_content": "    clearImpl<false>();",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": null,
          "new_api": "clearImpl<true>()",
          "old_text": null,
          "new_text": "clearImpl<true>()",
          "old_line_content": "  }",
          "new_line_content": "    clearImpl<true>();",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": null,
          "new_api": "visitAllocationClasses",
          "old_text": null,
          "new_text": "visitAllocationClasses(\n        [&sum](std::size_t bytes, std::size_t n) { sum += bytes * n; })",
          "old_line_content": "        [&sum](std::size_t bytes, std::size_t n) { sum += bytes * n; });",
          "new_line_content": "    visitAllocationClasses(",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "size()",
          "old_line_content": "        bc,",
          "new_line_content": "        size(),",
          "content_same": false
        },
        {
          "line": 2044,
          "old_api": null,
          "new_api": "lastOccupiedChunk",
          "old_text": null,
          "new_text": "lastOccupiedChunk()",
          "old_line_content": "    auto chunk = &chunks_[0];",
          "new_line_content": "    std::size_t maxChunkIndex = lastOccupiedChunk() - chunks_;",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2052,
          "old_api": "hasNext",
          "new_api": null,
          "old_text": "iter.hasNext()",
          "new_text": null,
          "old_line_content": "      while (iter.hasNext()) {",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": "lastOccupiedChunk",
          "new_api": null,
          "old_text": "lastOccupiedChunk()",
          "new_text": null,
          "old_line_content": "    std::size_t maxChunkIndex = lastOccupiedChunk() - chunks_;",
          "new_line_content": "  void visitContiguousItemRanges(V&& visitor) const {",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "hasNext",
          "new_api": null,
          "old_text": "iter.hasNext()",
          "new_text": null,
          "old_line_content": "      for (auto iter = chunk->occupiedRangeIter(); iter.hasNext();) {",
          "new_line_content": "    for (std::size_t i = 0; i < maxChunkIndex; ++i, ++chunk) {",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": "histoAt",
          "new_api": null,
          "old_text": "histoAt(\n      std::vector<std::size_t>& histo,\n      std::size_t index)",
          "new_text": null,
          "old_line_content": "  static std::size_t& histoAt(",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "size",
          "new_api": null,
          "old_text": "histo.size()",
          "new_text": null,
          "old_line_content": "    if (histo.size() <= index) {",
          "new_line_content": "      std::size_t index) {",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": "at",
          "new_api": null,
          "old_text": "histo.at(index)",
          "new_text": null,
          "old_line_content": "    return histo.at(index);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "advance",
          "new_api": null,
          "old_text": "iter.advance()",
          "new_text": null,
          "old_line_content": "      for (auto iter = begin(); iter != end(); iter.advance()) {",
          "new_line_content": "      ItemIter prev;",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "      FOLLY_SAFE_DCHECK(n == size(), \"\");",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "FOLLY_SAFE_DCHECK",
          "new_api": null,
          "old_text": "FOLLY_SAFE_DCHECK(\n        (chunks_ == Chunk::emptyInstance()) == (bucket_count() == 0), \"\")",
          "new_text": null,
          "old_line_content": "    FOLLY_SAFE_DCHECK(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "bucket_count",
          "new_api": null,
          "old_text": "bucket_count()",
          "new_text": null,
          "old_line_content": "    auto cc = bucket_count() == 0 ? 0 : chunkMask_ + 1;",
          "new_line_content": "    std::size_t n2 = 0;",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "eof",
          "new_api": null,
          "old_text": "chunk->eof()",
          "new_text": null,
          "old_line_content": "      FOLLY_SAFE_DCHECK(chunk->eof() == (ci == 0), \"\");",
          "new_line_content": "      ChunkPtr chunk = chunks_ + ci;",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": "occupiedIter",
          "new_api": null,
          "old_text": "chunk->occupiedIter()",
          "new_text": null,
          "old_line_content": "      auto iter = chunk->occupiedIter();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "next",
          "new_api": null,
          "old_text": "piter.next()",
          "new_text": null,
          "old_line_content": "      for (auto piter = iter; piter.hasNext(); piter.next()) {",
          "new_line_content": "      std::size_t chunkOccupied = 0;",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "histoAt",
          "new_api": null,
          "old_text": "histoAt(stats.chunkOccupancyHisto, chunkOccupied)",
          "new_text": null,
          "old_line_content": "      histoAt(stats.chunkOccupancyHisto, chunkOccupied)++;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": "hasNext",
          "new_api": null,
          "old_text": "iter.hasNext()",
          "new_text": null,
          "old_line_content": "      while (iter.hasNext()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": "citem",
          "new_api": null,
          "old_text": "chunk->citem(ii)",
          "new_text": null,
          "old_line_content": "          auto& item = chunk->citem(ii);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "probeDelta",
          "new_api": null,
          "old_text": "probeDelta(hp)",
          "new_text": null,
          "old_line_content": "          std::size_t delta = probeDelta(hp);",
          "new_line_content": "          std::size_t index = hp.first;",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": "histoAt",
          "new_api": null,
          "old_text": "histoAt(stats.keyProbeLengthHisto, dist)",
          "new_text": null,
          "old_line_content": "          histoAt(stats.keyProbeLengthHisto, dist)++;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "static_cast<uint8_t>(ti == 0 ? 1 : 0)",
          "new_api": null,
          "old_text": "static_cast<uint8_t>(ti == 0 ? 1 : 0)",
          "new_text": null,
          "old_line_content": "          uint8_t tag = static_cast<uint8_t>(ti == 0 ? 1 : 0);",
          "new_line_content": "        for (std::size_t ti = 0; ti < 256; ++ti) {",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "probeDelta",
          "new_api": null,
          "old_text": "probeDelta(hp)",
          "new_text": null,
          "old_line_content": "          std::size_t delta = probeDelta(hp);",
          "new_line_content": "          std::size_t index = hp.first;",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "outboundOverflowCount",
          "new_api": null,
          "old_text": "chunks_[index & chunkMask_].outboundOverflowCount()",
          "new_text": null,
          "old_line_content": "               chunks_[index & chunkMask_].outboundOverflowCount() != 0;",
          "new_line_content": "          for (std::size_t tries = 0; tries <= chunkMask_ &&",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "histoAt",
          "new_api": null,
          "old_text": "histoAt(stats.missProbeLengthHisto, dist)",
          "new_text": null,
          "old_line_content": "          histoAt(stats.missProbeLengthHisto, dist)++;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    FOLLY_SAFE_DCHECK(n1 == size(), \"\");",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": "name",
          "new_api": null,
          "old_text": "typeid(Policy).name()",
          "new_text": null,
          "old_line_content": "    stats.policy = typeid(Policy).name();",
          "new_line_content": "#if FOLLY_HAS_RTTI",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    stats.size = size();",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "bucket_count",
          "new_api": null,
          "old_text": "bucket_count()",
          "new_text": null,
          "old_line_content": "    stats.bucketCount = bucket_count();",
          "new_line_content": "    stats.valueSize = sizeof(value_type);",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "getAllocatedMemorySize",
          "new_api": null,
          "old_text": "getAllocatedMemorySize()",
          "new_text": null,
          "old_line_content": "    stats.totalBytes = sizeof(*this) + getAllocatedMemorySize();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    if (capacity < size()) {",
          "new_line_content": "  void rehash(std::size_t capacity) {",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": "folly::nextPowTwo(\n          (capacity + Chunk::kDesiredCapacity - 1) / Chunk::kDesiredCapacity)",
          "new_api": null,
          "old_text": "folly::nextPowTwo(\n          (capacity + Chunk::kDesiredCapacity - 1) / Chunk::kDesiredCapacity)",
          "new_text": null,
          "old_line_content": "      chunkCount = folly::nextPowTwo(",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": "constexpr",
          "new_api": null,
          "old_text": "constexpr",
          "new_text": null,
          "old_line_content": "      constexpr std::size_t kMaxChunksWithoutCapacityOverflow =",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "UNLIKELY",
          "new_api": null,
          "old_text": "UNLIKELY(\n              chunkCount > kMaxChunksWithoutCapacityOverflow ||\n              maxSizeWithoutRehash > max_size())",
          "new_text": null,
          "old_line_content": "      if (UNLIKELY(",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "max_size",
          "new_api": null,
          "old_text": "max_size()",
          "new_text": null,
          "old_line_content": "              maxSizeWithoutRehash > max_size())) {",
          "new_line_content": "              chunkCount > kMaxChunksWithoutCapacityOverflow ||",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": "bucket_count",
          "new_api": null,
          "old_text": "bucket_count()",
          "new_text": null,
          "old_line_content": "    if (bucket_count() != maxSizeWithoutRehash) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1837,
          "old_api": "rehash",
          "new_api": null,
          "old_text": "rehash(capacity)",
          "new_text": null,
          "old_line_content": "    rehash(capacity);",
          "new_line_content": "  void reserve(std::size_t capacity) {",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": "bucket_count",
          "new_api": null,
          "old_text": "bucket_count()",
          "new_text": null,
          "old_line_content": "    if (size() + incoming - 1 >= bucket_count()) {",
          "new_line_content": "  void reserveForInsert(size_t incoming = 1) {",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    rehash(size() + incoming);",
          "new_line_content": "  FOLLY_NOINLINE void reserveForInsertImpl(size_t incoming) {",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "computeKeyHash",
          "new_api": null,
          "old_text": "this->computeKeyHash(key)",
          "new_text": null,
          "old_line_content": "    const auto hp = splitHash(this->computeKeyHash(key));",
          "new_line_content": "  std::pair<ItemIter, bool> tryEmplaceValue(K const& key, Args&&... args) {",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "findImpl",
          "new_api": null,
          "old_text": "findImpl(hp, key)",
          "new_text": null,
          "old_line_content": "    auto existing = findImpl(hp, key);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": "reserveForInsert",
          "new_api": null,
          "old_text": "reserveForInsert()",
          "new_text": null,
          "old_line_content": "    reserveForInsert();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": "firstEmpty",
          "new_api": null,
          "old_text": "chunk->firstEmpty()",
          "new_text": null,
          "old_line_content": "    auto firstEmpty = chunk->firstEmpty();",
          "new_line_content": "    ChunkPtr chunk = chunks_ + (index & chunkMask_);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "hasIndex",
          "new_api": null,
          "old_text": "firstEmpty.hasIndex()",
          "new_text": null,
          "old_line_content": "    if (!firstEmpty.hasIndex()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": "incrOutboundOverflowCount",
          "new_api": null,
          "old_text": "chunk->incrOutboundOverflowCount()",
          "new_text": null,
          "old_line_content": "        chunk->incrOutboundOverflowCount();",
          "new_line_content": "      do {",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "firstEmpty",
          "new_api": null,
          "old_text": "chunk->firstEmpty()",
          "new_text": null,
          "old_line_content": "        firstEmpty = chunk->firstEmpty();",
          "new_line_content": "        chunk = chunks_ + (index & chunkMask_);",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "index",
          "new_api": null,
          "old_text": "firstEmpty.index()",
          "new_text": null,
          "old_line_content": "    std::size_t itemIndex = firstEmpty.index();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": "setTag",
          "new_api": null,
          "old_text": "chunk->setTag(itemIndex, hp.second)",
          "new_text": null,
          "old_line_content": "    chunk->setTag(itemIndex, hp.second);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "chunk()",
          "new_text": null,
          "old_line_content": "    auto c = chunk();",
          "new_line_content": "  void precheckedAdvance() {",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": "std::forward<Args>(args)",
          "new_api": null,
          "old_text": "std::forward<Args>(args)",
          "new_text": null,
          "old_line_content": "    insertAtBlank(iter, hp, std::forward<Args>(args)...);",
          "new_line_content": "    // insertAtBlank will clear the tag if the constructor throws",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": "occupied",
          "new_api": null,
          "old_text": "c->occupied(index_)",
          "new_text": null,
          "old_line_content": "      if (LIKELY(c->occupied(index_))) {",
          "new_line_content": "      --itemPtr_;",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "Chunk::emptyInstance()",
          "new_api": null,
          "old_text": "Chunk::emptyInstance()",
          "new_text": null,
          "old_line_content": "    if (chunks_ == Chunk::emptyInstance()) {",
          "new_line_content": "  void clearImpl() noexcept {",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": "eof",
          "new_api": null,
          "old_text": "c->eof()",
          "new_text": null,
          "old_line_content": "      FOLLY_SAFE_DCHECK(!c->eof(), \"\");",
          "new_line_content": "      // exhausted the current chunk",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "lastOccupied",
          "new_api": null,
          "old_text": "c->lastOccupied()",
          "new_text": null,
          "old_line_content": "      auto last = c->lastOccupied();",
          "new_line_content": "      --c;",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    auto origSize = size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": "beforeReset",
          "new_api": null,
          "old_text": "this->beforeReset(origSize, origCapacity)",
          "new_text": null,
          "old_line_content": "      this->beforeReset(origSize, origCapacity);",
          "new_line_content": "    if (willReset) {",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": "beforeClear",
          "new_api": null,
          "old_text": "this->beforeClear(origSize, origCapacity)",
          "new_text": null,
          "old_line_content": "      this->beforeClear(origSize, origCapacity);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": "std::pointer_traits<ChunkPtr>::pointer_to(\n        Chunk::owner(*itemPtr_, index_))",
          "new_api": null,
          "old_text": "std::pointer_traits<ChunkPtr>::pointer_to(\n        Chunk::owner(*itemPtr_, index_))",
          "new_text": null,
          "old_line_content": "    return std::pointer_traits<ChunkPtr>::pointer_to(",
          "new_line_content": "  ChunkPtr chunk() const {",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": "empty",
          "new_api": null,
          "old_text": "empty()",
          "new_text": null,
          "old_line_content": "    if (!empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "occupiedIter",
          "new_api": null,
          "old_text": "chunk->occupiedIter()",
          "new_text": null,
          "old_line_content": "          auto iter = chunk->occupiedIter();",
          "new_line_content": "          ChunkPtr chunk = chunks_ + ci;",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "std::addressof(*itemPtr_)",
          "new_api": null,
          "old_text": "std::addressof(*itemPtr_)",
          "new_text": null,
          "old_line_content": "    return std::addressof(*itemPtr_);",
          "new_line_content": "  Item* itemAddr() const {",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": "hasNext",
          "new_api": null,
          "old_text": "iter.hasNext()",
          "new_text": null,
          "old_line_content": "          while (iter.hasNext()) {",
          "new_line_content": "          }",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": "chunk0Capacity",
          "new_api": null,
          "old_text": "chunks_[0].chunk0Capacity()",
          "new_text": null,
          "old_line_content": "        auto c0c = chunks_[0].chunk0Capacity();",
          "new_line_content": "        // are promoting a clear to a reset for a large table.",
          "content_same": false
        },
        {
          "line": 1931,
          "old_api": "clear",
          "new_api": null,
          "old_text": "chunks_[ci].clear()",
          "new_text": null,
          "old_line_content": "          chunks_[ci].clear();",
          "new_line_content": "        for (std::size_t ci = 0; ci <= chunkMask_; ++ci) {",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": "static_cast<uint8_t>(index_)",
          "new_api": null,
          "old_text": "static_cast<uint8_t>(index_)",
          "new_text": null,
          "old_line_content": "    return Packed{itemPtr_, static_cast<uint8_t>(index_)};",
          "new_line_content": "  Packed pack() const {",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "markEof",
          "new_api": null,
          "old_text": "chunks_[0].markEof(c0c)",
          "new_text": null,
          "old_line_content": "        chunks_[0].markEof(c0c);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "pack",
          "new_api": null,
          "old_text": "ItemIter{}.pack()",
          "new_text": null,
          "old_line_content": "        sizeAndPackedBegin_.packedBegin() = ItemIter{}.pack();",
          "new_line_content": "      if (Policy::kEnableItemIteration) {",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "std::pointer_traits<BytePtr>::pointer_to(\n          *static_cast<uint8_t*>(static_cast<void*>(&*chunks_)))",
          "new_api": null,
          "old_text": "std::pointer_traits<BytePtr>::pointer_to(\n          *static_cast<uint8_t*>(static_cast<void*>(&*chunks_)))",
          "new_text": null,
          "old_line_content": "      BytePtr rawAllocation = std::pointer_traits<BytePtr>::pointer_to(",
          "new_line_content": "    if (willReset) {",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "Chunk::emptyInstance()",
          "new_api": null,
          "old_text": "Chunk::emptyInstance()",
          "new_text": null,
          "old_line_content": "      chunks_ = Chunk::emptyInstance();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "afterReset",
          "new_api": null,
          "old_text": "this->afterReset(origSize, origCapacity, rawAllocation, rawSize)",
          "new_text": null,
          "old_line_content": "      this->afterReset(origSize, origCapacity, rawAllocation, rawSize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1951,
          "old_api": "afterClear",
          "new_api": null,
          "old_text": "this->afterClear(origSize, origCapacity)",
          "new_text": null,
          "old_line_content": "      this->afterClear(origSize, origCapacity);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1956,
          "old_api": "item",
          "new_api": null,
          "old_text": "pos.item()",
          "new_text": null,
          "old_line_content": "    this->destroyItem(pos.item());",
          "new_line_content": "  void eraseImpl(ItemIter pos, HashPair hp) {",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "pack",
          "new_api": null,
          "old_text": "ItemIter{}.pack()",
          "new_text": null,
          "old_line_content": "  typename ItemIter::Packed packedBegin_{ItemIter{}.pack()};",
          "new_line_content": " private:",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "eraseIterInto",
          "new_api": null,
          "old_text": "eraseIterInto(pos, [](value_type&&) {})",
          "new_text": null,
          "old_line_content": "    eraseIterInto(pos, [](value_type&&) {});",
          "new_line_content": "  void eraseIter(ItemIter pos) {",
          "content_same": false
        },
        {
          "line": 949,
          "old_api": "noreturn",
          "new_api": null,
          "old_text": "noreturn",
          "new_text": null,
          "old_line_content": "  [[noreturn]] typename ItemIter::Packed& packedBegin() {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": "chunk",
          "new_api": null,
          "old_text": "pos.chunk()->hostedOverflowCount()",
          "new_text": null,
          "old_line_content": "    if (pos.chunk()->hostedOverflowCount() != 0) {",
          "new_line_content": "    HashPair hp{};",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "noreturn",
          "new_api": null,
          "old_text": "noreturn",
          "new_text": null,
          "old_line_content": "  [[noreturn]] typename ItemIter::Packed const& packedBegin() const {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "item",
          "new_api": null,
          "old_text": "pos.item()",
          "new_text": null,
          "old_line_content": "    beforeDestroy(this->valueAtItemForExtract(pos.item()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": "eraseKeyInto",
          "new_api": null,
          "old_text": "eraseKeyInto(key, [](value_type&&) {})",
          "new_text": null,
          "old_line_content": "    return eraseKeyInto(key, [](value_type&&) {});",
          "new_line_content": "  std::size_t eraseKey(K const& key) {",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "size",
          "new_api": null,
          "old_text": "size()",
          "new_text": null,
          "old_line_content": "    if (UNLIKELY(size() == 0)) {",
          "new_line_content": "  std::size_t eraseKeyInto(K const& key, BeforeDestroy&& beforeDestroy) {",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": "computeKeyHash",
          "new_api": null,
          "old_text": "this->computeKeyHash(key)",
          "new_text": null,
          "old_line_content": "    auto hp = splitHash(this->computeKeyHash(key));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": "clearImpl<false>()",
          "new_api": null,
          "old_text": "clearImpl<false>()",
          "new_text": null,
          "old_line_content": "    clearImpl<false>();",
          "new_line_content": "  void clear() noexcept {",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "clearImpl<true>()",
          "new_api": null,
          "old_text": "clearImpl<true>()",
          "new_text": null,
          "old_line_content": "    clearImpl<true>();",
          "new_line_content": "  void reset() noexcept {",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": "visitAllocationClasses",
          "new_api": null,
          "old_text": "visitAllocationClasses(\n        [&sum](std::size_t bytes, std::size_t n) { sum += bytes * n; })",
          "new_text": null,
          "old_line_content": "    visitAllocationClasses(",
          "new_line_content": "    std::size_t sum = 0;",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "bucket_count",
          "new_api": null,
          "old_text": "bucket_count()",
          "new_text": null,
          "old_line_content": "    auto bc = bucket_count();",
          "new_line_content": "  void visitAllocationClasses(V&& visitor) const {",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": "lastOccupiedChunk",
          "new_api": null,
          "old_text": "lastOccupiedChunk()",
          "new_text": null,
          "old_line_content": "    std::size_t maxChunkIndex = lastOccupiedChunk() - chunks_;",
          "new_line_content": "  void visitItems(V&& visitor) const {",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "occupiedIter",
          "new_api": null,
          "old_text": "chunk->occupiedIter()",
          "new_text": null,
          "old_line_content": "      auto iter = chunk->occupiedIter();",
          "new_line_content": "    for (std::size_t i = 0; i < maxChunkIndex; ++i, ++chunk) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 57,
      "total_additions": 85,
      "total_deletions": 84,
      "total_api_changes": 226
    },
    "non_api_changes": {
      "has_non_api_changes": false,
      "evidence": {
        "total_diff_lines": 1,
        "api_related_lines": 226,
        "non_api_lines": 0,
        "non_api_line_numbers": []
      }
    },
    "api_calls_before": 351,
    "api_calls_after": 352,
    "diff_info": {
      "added_lines": 1,
      "removed_lines": 0,
      "total_diff_lines": 13
    }
  }
}