{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/c346ee1c29afc423a9b89bdf8c0a6b858f742789",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/c346ee1c29afc423a9b89bdf8c0a6b858f742789/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/c346ee1c29afc423a9b89bdf8c0a6b858f742789/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/c346ee1c29afc423a9b89bdf8c0a6b858f742789/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1820,
          "old_api": "cv::isContourConvex(approx_contour)",
          "new_api": "cv::arcLength(approx_contour, true)",
          "old_text": "cv::isContourConvex(approx_contour)",
          "new_text": "cv::arcLength(approx_contour, true)",
          "old_line_content": "        if (!cv::isContourConvex(approx_contour))",
          "new_line_content": "            double p = cv::arcLength(approx_contour, true);",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "normL2Sqr<double>(pt[1] - pt[2])",
          "new_api": "emplace_back",
          "old_text": "normL2Sqr<double>(pt[1] - pt[2])",
          "new_text": "contour_quads.emplace_back(pt, parentIdx)",
          "old_line_content": "            double d4 = sqrt(normL2Sqr<double>(pt[1] - pt[2]));",
          "new_line_content": "        contour_quads.emplace_back(pt, parentIdx);",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "normL2Sqr<float>(q.corners[i]->pt - q.corners[(i+1)&3]->pt)",
          "new_api": "CV_LOG_VERBOSE",
          "old_text": "normL2Sqr<float>(q.corners[i]->pt - q.corners[(i+1)&3]->pt)",
          "new_text": "CV_LOG_VERBOSE(NULL, 3, \"Total quad contours: \" << total)",
          "old_line_content": "            float d = normL2Sqr<float>(q.corners[i]->pt - q.corners[(i+1)&3]->pt);",
          "new_line_content": "    CV_LOG_VERBOSE(NULL, 3, \"Total quad contours: \" << total);",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "std::min(q.edge_len, d)",
          "new_api": "CV_LOG_VERBOSE",
          "old_text": "std::min(q.edge_len, d)",
          "new_text": "CV_LOG_VERBOSE(NULL, 3, \"max_quad_buf_size=\" << max_quad_buf_size)",
          "old_line_content": "            q.edge_len = std::min(q.edge_len, d);",
          "new_line_content": "    CV_LOG_VERBOSE(NULL, 3, \"max_quad_buf_size=\" << max_quad_buf_size);",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": "CV_LOG_VERBOSE",
          "new_api": "size",
          "old_text": "CV_LOG_VERBOSE(NULL, 3, \"max_quad_buf_size=\" << max_quad_buf_size)",
          "new_text": "all_quads.size()",
          "old_line_content": "    CV_LOG_VERBOSE(NULL, 3, \"max_quad_buf_size=\" << max_quad_buf_size);",
          "new_line_content": "    size_t max_quad_buf_size = all_quads.size();",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": "findConnectedQuads",
          "new_api": "DPRINTF",
          "old_text": "findConnectedQuads(quad_group, group_idx)",
          "new_text": "DPRINTF(\"Finished ordering of inner quads (%d)\", count)",
          "old_line_content": "        findConnectedQuads(quad_group, group_idx);",
          "new_line_content": "        DPRINTF(\"Finished ordering of inner quads (%d)\", count);",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "DPRINTF",
          "new_api": "checkQuadGroup",
          "old_text": "DPRINTF(\"Finished ordering of inner quads (%d)\", count)",
          "new_text": "checkQuadGroup(quad_group, corner_group)",
          "old_line_content": "        DPRINTF(\"Finished ordering of inner quads (%d)\", count);",
          "new_line_content": "        count = checkQuadGroup(quad_group, corner_group);",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": "DPRINTF",
          "new_api": "sumDist",
          "old_text": "DPRINTF(\"Connected group: %d, count: %d\", group_idx, count)",
          "new_text": "corner_group[i]->sumDist(ni)",
          "old_line_content": "        DPRINTF(\"Connected group: %d, count: %d\", group_idx, count);",
          "new_line_content": "            float sum = corner_group[i]->sumDist(ni);",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": "sumDist",
          "new_api": "reserve",
          "old_text": "corner_group[i]->sumDist(ni)",
          "new_text": "out_corners.reserve(n)",
          "old_line_content": "            float sum = corner_group[i]->sumDist(ni);",
          "new_line_content": "            out_corners.reserve(n);",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": "CV_MAT_CN",
          "new_api": "getMat",
          "old_text": "CV_MAT_CN(type)",
          "new_text": "_corners.getMat()",
          "old_line_content": "    int cn = CV_MAT_CN(type);",
          "new_line_content": "    Mat corners = _corners.getMat();",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "CV_CheckType",
          "new_api": "corners.ptr<Point2f>(0)",
          "old_text": "CV_CheckType(type, cn == 1 || cn == 3 || cn == 4,\n            \"Number of channels must be 1, 3 or 4\" )",
          "new_text": "corners.ptr<Point2f>(0)",
          "old_line_content": "    CV_CheckType(type, cn == 1 || cn == 3 || cn == 4,",
          "new_line_content": "    const Point2f* corners_data = corners.ptr<Point2f>(0);",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "CV_MAT_DEPTH",
          "new_api": "CV_Assert",
          "old_text": "CV_MAT_DEPTH(type)",
          "new_text": "CV_Assert(nelems >= 0)",
          "old_line_content": "    int depth = CV_MAT_DEPTH(type);",
          "new_line_content": "    CV_Assert(nelems >= 0);",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "Scalar::all(200)",
          "new_api": "Point",
          "old_text": "Scalar::all(200)",
          "new_text": "Point( pt.x + r, pt.y - r)",
          "old_line_content": "            color = Scalar::all(200);",
          "new_line_content": "            line(image, Point(pt.x - r, pt.y + r), Point( pt.x + r, pt.y - r), color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "copyTo",
          "new_api": "clear",
          "old_text": "Mat(centers).copyTo(_centers)",
          "new_text": "centers.clear()",
          "old_line_content": "      Mat(centers).copyTo(_centers);",
          "new_line_content": "        centers.clear();",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "clear",
          "new_api": "getHoles",
          "old_text": "centers.clear()",
          "new_text": "boxFinder.getHoles(centers)",
          "old_line_content": "        centers.clear();",
          "new_line_content": "                    boxFinder.getHoles(centers);",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": "CV_Error",
          "new_api": "what",
          "old_text": "CV_Error(Error::StsBadArg, \"Unknown pattern type\")",
          "new_text": "e.what()",
          "old_line_content": "                    CV_Error(Error::StsBadArg, \"Unknown pattern type\");",
          "new_line_content": "            CV_LOG_DEBUG(NULL, \"findCirclesGrid2: attempt=\" << i << \": \" << e.what());",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "CV_UNUSED",
          "new_api": "getDetectedGridSize",
          "old_text": "CV_UNUSED(e)",
          "new_text": "boxFinder.getDetectedGridSize()",
          "old_line_content": "            CV_UNUSED(e);",
          "new_line_content": "            H = CirclesGridFinder::rectifyGrid(boxFinder.getDetectedGridSize(), centers, points, points);",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "size",
          "new_api": "convertPointsFromHomogeneous",
          "old_text": "centers.size()",
          "new_text": "convertPointsFromHomogeneous(orgPointsMat, centers)",
          "old_line_content": "            if (centers.size() < minHomographyPoints)",
          "new_line_content": "        convertPointsFromHomogeneous(orgPointsMat, centers);",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": "getDetectedGridSize",
          "new_api": "copyTo",
          "old_text": "boxFinder.getDetectedGridSize()",
          "new_text": "Mat(centers).copyTo(_centers)",
          "old_line_content": "            H = CirclesGridFinder::rectifyGrid(boxFinder.getDetectedGridSize(), centers, points, points);",
          "new_line_content": "    Mat(centers).copyTo(_centers);",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": "inv",
          "new_api": "CirclesGridFinderParameters",
          "old_text": "H.inv()",
          "new_text": "CirclesGridFinderParameters()",
          "old_line_content": "        transform(centers, orgPointsMat, H.inv());",
          "new_line_content": "    return cv::findCirclesGrid(_image, patternSize, _centers, flags, blobDetector, CirclesGridFinderParameters());",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "cvRound",
          "old_text": null,
          "new_text": "cvRound(corners_data[i].y*(1 << shift))",
          "old_line_content": "            const int* line_color = &line_colors[y % line_max][0];",
          "new_line_content": "                        cvRound(corners_data[i].y*(1 << shift))",
          "content_same": false
        },
        {
          "line": 1923,
          "old_api": null,
          "new_api": "DPRINTF",
          "old_text": null,
          "new_text": "DPRINTF(\"Connected group: %d, count: %d\", group_idx, count)",
          "old_line_content": "",
          "new_line_content": "        DPRINTF(\"Connected group: %d, count: %d\", group_idx, count);",
          "content_same": false
        },
        {
          "line": 2052,
          "old_api": null,
          "new_api": "line",
          "old_text": null,
          "new_text": "line(image, prev_pt, pt, color, 1, line_type, shift)",
          "old_line_content": "            color *= scale;",
          "new_line_content": "                    line(image, prev_pt, pt, color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 2054,
          "old_api": null,
          "new_api": "Point",
          "old_text": null,
          "new_text": "Point( pt.x + r, pt.y + r)",
          "old_line_content": "            for (int x = 0; x < patternSize.width; x++, i++)",
          "new_line_content": "                line(image, Point(pt.x - r, pt.y - r), Point( pt.x + r, pt.y + r), color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 2055,
          "old_api": null,
          "new_api": "Point",
          "old_text": null,
          "new_text": "Point( pt.x + r, pt.y - r)",
          "old_line_content": "            {",
          "new_line_content": "                line(image, Point(pt.x - r, pt.y + r), Point( pt.x + r, pt.y - r), color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": null,
          "new_api": "circle",
          "old_text": null,
          "new_text": "circle(image, pt, r+(1<<shift), color, 1, line_type, shift)",
          "old_line_content": "                cv::Point2i pt(",
          "new_line_content": "                circle(image, pt, r+(1<<shift), color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 1926,
          "old_api": null,
          "new_api": "std::min(n, pattern_size.width * pattern_size.height)",
          "old_text": null,
          "new_text": "std::min(n, pattern_size.width * pattern_size.height)",
          "old_line_content": "",
          "new_line_content": "        n = std::min(n, pattern_size.width * pattern_size.height);",
          "content_same": false
        },
        {
          "line": 1802,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "approx_contour.size()",
          "old_line_content": "        for (int approx_level = min_approx_level; approx_level <= max_approx_level; approx_level++ )",
          "new_line_content": "        for (int approx_level = min_approx_level; approx_contour.size() > 4 && approx_level <= max_approx_level; approx_level++ )",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "approx_contour.size()",
          "old_line_content": "            // we call this again on its own output, because sometimes",
          "new_line_content": "        if (approx_contour.size() != 4)",
          "content_same": false
        },
        {
          "line": 1937,
          "old_api": null,
          "new_api": "std::max(total, 1)",
          "old_text": null,
          "new_text": "std::max(total, 1)",
          "old_line_content": "        float sum_dist = 0;",
          "new_line_content": "        prev_sqr_size = cvRound(sum_dist/std::max(total, 1));",
          "content_same": false
        },
        {
          "line": 1810,
          "old_api": null,
          "new_api": "cv::isContourConvex(approx_contour)",
          "old_text": null,
          "new_text": "cv::isContourConvex(approx_contour)",
          "old_line_content": "            std::vector<Point> approx_contour_tmp;",
          "new_line_content": "        if (!cv::isContourConvex(approx_contour))",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "CV_INSTRUMENT_REGION",
          "old_text": null,
          "new_text": "CV_INSTRUMENT_REGION()",
          "old_line_content": "                prev_pt = pt;",
          "new_line_content": "    CV_INSTRUMENT_REGION();",
          "content_same": false
        },
        {
          "line": 1939,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "out_corners.size()",
          "old_line_content": "",
          "new_line_content": "        if (count > 0 || (-count > (int)out_corners.size()))",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "out_corners.clear()",
          "old_line_content": "            int ni = 0;",
          "new_line_content": "            out_corners.clear();",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "contour_quads.size()",
          "old_line_content": "",
          "new_line_content": "        CV_LOG_VERBOSE(NULL, 9, \"... contours(\" << contour_quads.size() << \" added):\" << pt[0] << \" \" << pt[1] << \" \" << pt[2] << \" \" << pt[3]);",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": null,
          "new_api": "CV_Assert",
          "old_text": null,
          "new_text": "CV_Assert(isAsymmetricGrid ^ isSymmetricGrid)",
          "old_line_content": "bool findCirclesGrid( InputArray _image, Size patternSize,",
          "new_line_content": "    CV_Assert(isAsymmetricGrid ^ isSymmetricGrid);",
          "content_same": false
        },
        {
          "line": 1945,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "out_corners.push_back(corner_group[i]->pt)",
          "old_line_content": "            total += ni;",
          "new_line_content": "                out_corners.push_back(corner_group[i]->pt);",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": null,
          "new_api": "checkBoardMonotony",
          "old_text": null,
          "new_text": "checkBoardMonotony(out_corners)",
          "old_line_content": "",
          "new_line_content": "                    && checkBoardMonotony(out_corners))",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "cv::contourArea(approx_contour, false)",
          "old_text": null,
          "new_text": "cv::contourArea(approx_contour, false)",
          "old_line_content": "            continue;",
          "new_line_content": "            double area = cv::contourArea(approx_contour, false);",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "normL2Sqr<double>(pt[0] - pt[2])",
          "old_text": null,
          "new_text": "normL2Sqr<double>(pt[0] - pt[2])",
          "old_line_content": "        cv::Point pt[4];",
          "new_line_content": "            double d1 = sqrt(normL2Sqr<double>(pt[0] - pt[2]));",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": null,
          "new_api": "normL2Sqr<double>(pt[1] - pt[3])",
          "old_text": null,
          "new_text": "normL2Sqr<double>(pt[1] - pt[3])",
          "old_line_content": "        for (int i = 0; i < 4; ++i)",
          "new_line_content": "            double d2 = sqrt(normL2Sqr<double>(pt[1] - pt[3]));",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": null,
          "new_api": "detect",
          "old_text": null,
          "new_text": "blobDetector->detect(_image, keypoints)",
          "old_line_content": "    bool isAsymmetricGrid = (flags & CALIB_CB_ASYMMETRIC_GRID) ? true : false;",
          "new_line_content": "        blobDetector->detect(_image, keypoints);",
          "content_same": false
        },
        {
          "line": 2082,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "keypoints.size()",
          "old_line_content": "    bool isSymmetricGrid  = (flags & CALIB_CB_SYMMETRIC_GRID ) ? true : false;",
          "new_line_content": "        for (size_t i = 0; i < keypoints.size(); i++)",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "points.push_back(keypoints[i].pt)",
          "old_line_content": "",
          "new_line_content": "            points.push_back(keypoints[i].pt);",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": null,
          "new_api": "normL2Sqr<double>(pt[0] - pt[1])",
          "old_text": null,
          "new_text": "normL2Sqr<double>(pt[0] - pt[1])",
          "old_line_content": "        if (filterQuads)",
          "new_line_content": "            double d3 = sqrt(normL2Sqr<double>(pt[0] - pt[1]));",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": null,
          "new_api": "normL2Sqr<double>(pt[1] - pt[2])",
          "old_text": null,
          "new_text": "normL2Sqr<double>(pt[1] - pt[2])",
          "old_line_content": "        {",
          "new_line_content": "            double d4 = sqrt(normL2Sqr<double>(pt[1] - pt[2]));",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "_image.type()",
          "old_line_content": "    {",
          "new_line_content": "        CV_CheckTypeEQ(_image.type(), CV_32FC2, \"blobDetector must be provided or image must contains Point2f array (std::vector<Point2f>) with candidates\");",
          "content_same": false
        },
        {
          "line": 2090,
          "old_api": null,
          "new_api": "copyTo",
          "old_text": null,
          "new_text": "_image.copyTo(points)",
          "old_line_content": "        std::vector<KeyPoint> keypoints;",
          "new_line_content": "        _image.copyTo(points);",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": null,
          "new_api": "CV_INSTRUMENT_REGION",
          "old_text": null,
          "new_text": "CV_INSTRUMENT_REGION()",
          "old_line_content": "",
          "new_line_content": "    CV_INSTRUMENT_REGION();",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": null,
          "new_api": "type",
          "old_text": null,
          "new_text": "image.type()",
          "old_line_content": "}",
          "new_line_content": "    int type = image.type();",
          "content_same": false
        },
        {
          "line": 1967,
          "old_api": null,
          "new_api": "CV_MAT_CN",
          "old_text": null,
          "new_text": "CV_MAT_CN(type)",
          "old_line_content": "",
          "new_line_content": "    int cn = CV_MAT_CN(type);",
          "content_same": false
        },
        {
          "line": 1968,
          "old_api": null,
          "new_api": "CV_CheckType",
          "old_text": null,
          "new_text": "CV_CheckType(type, cn == 1 || cn == 3 || cn == 4,\n            \"Number of channels must be 1, 3 or 4\" )",
          "old_line_content": "",
          "new_line_content": "    CV_CheckType(type, cn == 1 || cn == 3 || cn == 4,",
          "content_same": false
        },
        {
          "line": 1842,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "contour_quads.size()",
          "old_line_content": "                continue;",
          "new_line_content": "    size_t total = contour_quads.size();",
          "content_same": false
        },
        {
          "line": 1843,
          "old_api": null,
          "new_api": "std::max((size_t)2, total * 3)",
          "old_text": null,
          "new_text": "std::max((size_t)2, total * 3)",
          "old_line_content": "        }",
          "new_line_content": "    size_t max_quad_buf_size = std::max((size_t)2, total * 3);",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": null,
          "new_api": "allocate",
          "old_text": null,
          "new_text": "all_quads.allocate(max_quad_buf_size)",
          "old_line_content": "",
          "new_line_content": "    all_quads.allocate(max_quad_buf_size);",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": null,
          "new_api": "findGrid",
          "old_text": null,
          "new_text": "circlesGridClusterFinder.findGrid(points, patternSize, centers)",
          "old_line_content": "    }",
          "new_line_content": "      circlesGridClusterFinder.findGrid(points, patternSize, centers);",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": null,
          "new_api": "copyTo",
          "old_text": null,
          "new_text": "Mat(centers).copyTo(_centers)",
          "old_line_content": "",
          "new_line_content": "      Mat(centers).copyTo(_centers);",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "centers.empty()",
          "old_line_content": "    if(flags & CALIB_CB_ASYMMETRIC_GRID)",
          "new_line_content": "      return !centers.empty();",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": null,
          "new_api": "allocate",
          "old_text": null,
          "new_text": "all_corners.allocate(max_quad_buf_size * 4)",
          "old_line_content": "        contour_child_counter[parentIdx]++;",
          "new_line_content": "    all_corners.allocate(max_quad_buf_size * 4);",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": null,
          "new_api": "CV_MAT_DEPTH",
          "old_text": null,
          "new_text": "CV_MAT_DEPTH(type)",
          "old_line_content": "                                InputArray _corners,",
          "new_line_content": "    int depth = CV_MAT_DEPTH(type);",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "CV_CheckType",
          "old_text": null,
          "new_text": "CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F,\n            \"Only 8-bit, 16-bit or floating-point 32-bit images are supported\")",
          "old_line_content": "                                bool patternWasFound )",
          "new_line_content": "    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F,",
          "content_same": false
        },
        {
          "line": 1975,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "_corners.empty()",
          "old_line_content": "",
          "new_line_content": "    if (_corners.empty())",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": null,
          "new_api": "CV_DbgAssert",
          "old_text": null,
          "new_text": "CV_DbgAssert(corners_data)",
          "old_line_content": "            \"Number of channels must be 1, 3 or 4\" );",
          "new_line_content": "    CV_DbgAssert(corners_data);",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": null,
          "new_api": "checkVector",
          "old_text": null,
          "new_text": "corners.checkVector(2, CV_32F, true)",
          "old_line_content": "",
          "new_line_content": "    int nelems = corners.checkVector(2, CV_32F, true);",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": null,
          "new_api": "cvRound",
          "old_text": null,
          "new_text": "cvRound(corners_data[i].x*(1 << shift))",
          "old_line_content": "        {",
          "new_line_content": "                        cvRound(corners_data[i].x*(1 << shift)),",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": null,
          "new_api": "ChessBoardQuad",
          "old_text": null,
          "new_text": "ChessBoardQuad()",
          "old_line_content": "    for (size_t idx = 0; idx < total; ++idx)",
          "new_line_content": "        q = ChessBoardQuad();",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "findHoles",
          "old_text": null,
          "new_text": "boxFinder.findHoles()",
          "old_line_content": "    bool isValid = false;",
          "new_line_content": "            bool isFound = boxFinder.findHoles();",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": null,
          "new_api": "ChessBoardCorner",
          "old_text": null,
          "new_text": "ChessBoardCorner(pt)",
          "old_line_content": "        int quad_idx = quad_count++;",
          "new_line_content": "            corner = ChessBoardCorner(pt);",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": null,
          "new_api": "getAsymmetricHoles",
          "old_text": null,
          "new_text": "boxFinder.getAsymmetricHoles(centers)",
          "old_line_content": "        {",
          "new_line_content": "                    boxFinder.getAsymmetricHoles(centers);",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "normL2Sqr<float>(q.corners[i]->pt - q.corners[(i+1)&3]->pt)",
          "old_text": null,
          "new_text": "normL2Sqr<float>(q.corners[i]->pt - q.corners[(i+1)&3]->pt)",
          "old_line_content": "        {",
          "new_line_content": "            float d = normL2Sqr<float>(q.corners[i]->pt - q.corners[(i+1)&3]->pt);",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": null,
          "new_api": "std::min(q.edge_len, d)",
          "old_text": null,
          "new_text": "std::min(q.edge_len, d)",
          "old_line_content": "            Point2f pt(qc.pt[i]);",
          "new_line_content": "            q.edge_len = std::min(q.edge_len, d);",
          "content_same": false
        },
        {
          "line": 2128,
          "old_api": null,
          "new_api": "CV_Error",
          "old_text": null,
          "new_text": "CV_Error(Error::StsBadArg, \"Unknown pattern type\")",
          "old_line_content": "            {",
          "new_line_content": "                    CV_Error(Error::StsBadArg, \"Unknown pattern type\");",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "sqrt",
          "old_text": null,
          "new_text": "sqrt(q.edge_len)",
          "old_line_content": "            q.corners[i] = &corner;",
          "new_line_content": "        q.edge_len += 2 * sqrt(q.edge_len) * edge_len_compensation + edge_len_compensation * edge_len_compensation;",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": null,
          "new_api": "Scalar::all(200)",
          "old_text": null,
          "new_text": "Scalar::all(200)",
          "old_line_content": "        scale = 1./255;",
          "new_line_content": "            color = Scalar::all(200);",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": null,
          "new_api": "CV_UNUSED",
          "old_text": null,
          "new_text": "CV_UNUSED(e)",
          "old_line_content": "                default:",
          "new_line_content": "            CV_UNUSED(e);",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "CV_LOG_VERBOSE",
          "old_text": null,
          "new_text": "CV_LOG_VERBOSE(NULL, 3, \"filtered quad_count=\" << quad_count)",
          "old_line_content": "        }",
          "new_line_content": "    CV_LOG_VERBOSE(NULL, 3, \"filtered quad_count=\" << quad_count);",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": null,
          "new_api": "cvRound",
          "old_text": null,
          "new_text": "cvRound(corners_data[i].x*(1 << shift))",
          "old_line_content": "    if (!patternWasFound)",
          "new_line_content": "                    cvRound(corners_data[i].x*(1 << shift)),",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "getHoles",
          "old_text": null,
          "new_text": "boxFinder.getHoles(centers)",
          "old_line_content": "                break;  // done, return result",
          "new_line_content": "        boxFinder.getHoles(centers);",
          "content_same": false
        },
        {
          "line": 1887,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "out_corners.resize(0)",
          "old_line_content": "",
          "new_line_content": "    out_corners.resize(0);",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "cvRound",
          "old_text": null,
          "new_text": "cvRound(corners_data[i].y*(1 << shift))",
          "old_line_content": "    {",
          "new_line_content": "                    cvRound(corners_data[i].y*(1 << shift))",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "centers.size()",
          "old_line_content": "        catch (const cv::Exception& e)",
          "new_line_content": "            if (centers.size() < minHomographyPoints)",
          "content_same": false
        },
        {
          "line": 2016,
          "old_api": null,
          "new_api": "Point",
          "old_text": null,
          "new_text": "Point( pt.x + r, pt.y + r)",
          "old_line_content": "        if (cn == 1)",
          "new_line_content": "            line(image, Point(pt.x - r, pt.y - r), Point( pt.x + r, pt.y + r), color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": null,
          "new_api": "circle",
          "old_text": null,
          "new_text": "circle(image, pt, r+(1<<shift), color, 1, line_type, shift)",
          "old_line_content": "        color *= scale;",
          "new_line_content": "            circle(image, pt, r+(1<<shift), color, 1, line_type, shift);",
          "content_same": false
        },
        {
          "line": 1894,
          "old_api": null,
          "new_api": "findQuadNeighbors",
          "old_text": null,
          "new_text": "findQuadNeighbors()",
          "old_line_content": "",
          "new_line_content": "    findQuadNeighbors();",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "H.empty()",
          "old_line_content": "",
          "new_line_content": "    if (!centers.empty() && !H.empty())  // undone rectification",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": null,
          "new_api": "inv",
          "old_text": null,
          "new_text": "H.inv()",
          "old_line_content": "        {",
          "new_line_content": "        transform(centers, orgPointsMat, H.inv());",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": null,
          "new_api": "reserve",
          "old_text": null,
          "new_text": "corner_group.reserve(max_quad_buf_size * 4)",
          "old_line_content": "    if (all_quads_count <= 0)",
          "new_line_content": "    std::vector<ChessBoardCorner*> corner_group; corner_group.reserve(max_quad_buf_size * 4);",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": null,
          "new_api": "findConnectedQuads",
          "old_text": null,
          "new_text": "findConnectedQuads(quad_group, group_idx)",
          "old_line_content": "",
          "new_line_content": "        findConnectedQuads(quad_group, group_idx);",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "quad_group.empty()",
          "old_line_content": "    // Find quad's neighbors",
          "new_line_content": "        if (quad_group.empty())",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "quad_group.size()",
          "old_line_content": "    // allocate extra for adding in orderFoundQuads",
          "new_line_content": "        int count = (int)quad_group.size();",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "DPRINTF",
          "old_text": null,
          "new_text": "DPRINTF(\"Starting ordering of inner quads (%d)\", count)",
          "old_line_content": "    for (int group_idx = 0; ; group_idx++)",
          "new_line_content": "        DPRINTF(\"Starting ordering of inner quads (%d)\", count);",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": null,
          "new_api": "orderFoundConnectedQuads",
          "old_text": null,
          "new_text": "orderFoundConnectedQuads(quad_group)",
          "old_line_content": "    {",
          "new_line_content": "        count = orderFoundConnectedQuads(quad_group);",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": null,
          "new_api": "Scalar::all(200)",
          "old_text": null,
          "new_text": "Scalar::all(200)",
          "old_line_content": "            {255,0,0,0},",
          "new_line_content": "                color = Scalar::all(200);",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": null,
          "new_api": "cleanFoundConnectedQuads",
          "old_text": null,
          "new_text": "cleanFoundConnectedQuads(quad_group)",
          "old_line_content": "        // maybe delete or add some",
          "new_line_content": "        count = cleanFoundConnectedQuads(quad_group);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2051,
          "old_api": "Scalar::all(200)",
          "new_api": null,
          "old_text": "Scalar::all(200)",
          "new_text": null,
          "old_line_content": "                color = Scalar::all(200);",
          "new_line_content": "                if (i != 0)",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "cvRound",
          "new_api": null,
          "old_text": "cvRound(corners_data[i].x*(1 << shift))",
          "new_text": null,
          "old_line_content": "                        cvRound(corners_data[i].x*(1 << shift)),",
          "new_line_content": "                prev_pt = pt;",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "cvRound",
          "new_api": null,
          "old_text": "cvRound(corners_data[i].y*(1 << shift))",
          "new_text": null,
          "old_line_content": "                        cvRound(corners_data[i].y*(1 << shift))",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": "line",
          "new_api": null,
          "old_text": "line(image, prev_pt, pt, color, 1, line_type, shift)",
          "new_text": null,
          "old_line_content": "                    line(image, prev_pt, pt, color, 1, line_type, shift);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "Point",
          "new_api": null,
          "old_text": "Point( pt.x + r, pt.y + r)",
          "new_text": null,
          "old_line_content": "                line(image, Point(pt.x - r, pt.y - r), Point( pt.x + r, pt.y + r), color, 1, line_type, shift);",
          "new_line_content": "                          OutputArray _centers, int flags, const Ptr<FeatureDetector> &blobDetector,",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "Point",
          "new_api": null,
          "old_text": "Point( pt.x + r, pt.y - r)",
          "new_text": null,
          "old_line_content": "                line(image, Point(pt.x - r, pt.y + r), Point( pt.x + r, pt.y - r), color, 1, line_type, shift);",
          "new_line_content": "                          const CirclesGridFinderParameters& parameters_)",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": "circle",
          "new_api": null,
          "old_text": "circle(image, pt, r+(1<<shift), color, 1, line_type, shift)",
          "new_text": null,
          "old_line_content": "                circle(image, pt, r+(1<<shift), color, 1, line_type, shift);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "CV_INSTRUMENT_REGION",
          "new_api": null,
          "old_text": "CV_INSTRUMENT_REGION()",
          "new_text": null,
          "old_line_content": "    CV_INSTRUMENT_REGION();",
          "new_line_content": "    std::vector<Point2f> points;",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "CV_Assert",
          "new_api": null,
          "old_text": "CV_Assert(isAsymmetricGrid ^ isSymmetricGrid)",
          "new_text": null,
          "old_line_content": "    CV_Assert(isAsymmetricGrid ^ isSymmetricGrid);",
          "new_line_content": "        {",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "detect",
          "new_api": null,
          "old_text": "blobDetector->detect(_image, keypoints)",
          "new_text": null,
          "old_line_content": "        blobDetector->detect(_image, keypoints);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2092,
          "old_api": "size",
          "new_api": null,
          "old_text": "keypoints.size()",
          "new_text": null,
          "old_line_content": "        for (size_t i = 0; i < keypoints.size(); i++)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "points.push_back(keypoints[i].pt)",
          "new_text": null,
          "old_line_content": "            points.push_back(keypoints[i].pt);",
          "new_line_content": "      parameters.gridType = CirclesGridFinderParameters::ASYMMETRIC_GRID;",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "type",
          "new_api": null,
          "old_text": "_image.type()",
          "new_text": null,
          "old_line_content": "        CV_CheckTypeEQ(_image.type(), CV_32FC2, \"blobDetector must be provided or image must contains Point2f array (std::vector<Point2f>) with candidates\");",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": "copyTo",
          "new_api": null,
          "old_text": "_image.copyTo(points)",
          "new_text": null,
          "old_line_content": "        _image.copyTo(points);",
          "new_line_content": "      CirclesGridClusterFinder circlesGridClusterFinder(parameters);",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": "findGrid",
          "new_api": null,
          "old_text": "circlesGridClusterFinder.findGrid(points, patternSize, centers)",
          "new_text": null,
          "old_line_content": "      circlesGridClusterFinder.findGrid(points, patternSize, centers);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": "empty",
          "new_api": null,
          "old_text": "centers.empty()",
          "new_text": null,
          "old_line_content": "      return !centers.empty();",
          "new_line_content": "        CirclesGridFinder boxFinder(patternSize, points, parameters);",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": "findHoles",
          "new_api": null,
          "old_text": "boxFinder.findHoles()",
          "new_text": null,
          "old_line_content": "            bool isFound = boxFinder.findHoles();",
          "new_line_content": "                    break;",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "getHoles",
          "new_api": null,
          "old_text": "boxFinder.getHoles(centers)",
          "new_text": null,
          "old_line_content": "                    boxFinder.getHoles(centers);",
          "new_line_content": "                break;  // done, return result",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "getAsymmetricHoles",
          "new_api": null,
          "old_text": "boxFinder.getAsymmetricHoles(centers)",
          "new_text": null,
          "old_line_content": "                    boxFinder.getAsymmetricHoles(centers);",
          "new_line_content": "        catch (const cv::Exception& e)",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "            CV_LOG_DEBUG(NULL, \"findCirclesGrid2: attempt=\" << i << \": \" << e.what());",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "getHoles",
          "new_api": null,
          "old_text": "boxFinder.getHoles(centers)",
          "new_text": null,
          "old_line_content": "        boxFinder.getHoles(centers);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": "empty",
          "new_api": null,
          "old_text": "H.empty()",
          "new_text": null,
          "old_line_content": "    if (!centers.empty() && !H.empty())  // undone rectification",
          "new_line_content": "bool findCirclesGrid(InputArray _image, Size patternSize,",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "convertPointsFromHomogeneous",
          "new_api": null,
          "old_text": "convertPointsFromHomogeneous(orgPointsMat, centers)",
          "new_text": null,
          "old_line_content": "        convertPointsFromHomogeneous(orgPointsMat, centers);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": "copyTo",
          "new_api": null,
          "old_text": "Mat(centers).copyTo(_centers)",
          "new_text": null,
          "old_line_content": "    Mat(centers).copyTo(_centers);",
          "new_line_content": "} // namespace",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": "CirclesGridFinderParameters",
          "new_api": null,
          "old_text": "CirclesGridFinderParameters()",
          "new_text": null,
          "old_line_content": "    return cv::findCirclesGrid(_image, patternSize, _centers, flags, blobDetector, CirclesGridFinderParameters());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "size",
          "new_api": null,
          "old_text": "approx_contour.size()",
          "new_text": null,
          "old_line_content": "            if (approx_contour.size() == 4)",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1811,
          "old_api": "std::swap(approx_contour, approx_contour_tmp)",
          "new_api": null,
          "old_text": "std::swap(approx_contour, approx_contour_tmp)",
          "new_text": null,
          "old_line_content": "            std::swap(approx_contour, approx_contour_tmp);",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1812,
          "old_api": "approxPolyDP",
          "new_api": null,
          "old_text": "approxPolyDP(approx_contour_tmp, approx_contour, (float)approx_level, true)",
          "new_text": null,
          "old_line_content": "            approxPolyDP(approx_contour_tmp, approx_contour, (float)approx_level, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": "size",
          "new_api": null,
          "old_text": "approx_contour.size()",
          "new_text": null,
          "old_line_content": "            if (approx_contour.size() == 4)",
          "new_line_content": "        cv::Point pt[4];",
          "content_same": false
        },
        {
          "line": 1818,
          "old_api": "size",
          "new_api": null,
          "old_text": "approx_contour.size()",
          "new_text": null,
          "old_line_content": "        if (approx_contour.size() != 4)",
          "new_line_content": "        if (filterQuads)",
          "content_same": false
        },
        {
          "line": 1826,
          "old_api": "size",
          "new_api": null,
          "old_text": "contour_quads.size()",
          "new_text": null,
          "old_line_content": "        CV_LOG_VERBOSE(NULL, 9, \"... contours(\" << contour_quads.size() << \" added):\" << pt[0] << \" \" << pt[1] << \" \" << pt[2] << \" \" << pt[3]);",
          "new_line_content": "            // philipg.  Only accept those quadrangles which are more square",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": "cv::arcLength(approx_contour, true)",
          "new_api": null,
          "old_text": "cv::arcLength(approx_contour, true)",
          "new_text": null,
          "old_line_content": "            double p = cv::arcLength(approx_contour, true);",
          "new_line_content": "            if (!(d3*4 > d4 && d4*4 > d3 && d3*d4 < area*1.5 && area > min_area &&",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": "cv::contourArea(approx_contour, false)",
          "new_api": null,
          "old_text": "cv::contourArea(approx_contour, false)",
          "new_text": null,
          "old_line_content": "            double area = cv::contourArea(approx_contour, false);",
          "new_line_content": "                d1 >= 0.15 * p && d2 >= 0.15 * p))",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": "normL2Sqr<double>(pt[0] - pt[2])",
          "new_api": null,
          "old_text": "normL2Sqr<double>(pt[0] - pt[2])",
          "new_text": null,
          "old_line_content": "            double d1 = sqrt(normL2Sqr<double>(pt[0] - pt[2]));",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": "normL2Sqr<double>(pt[1] - pt[3])",
          "new_api": null,
          "old_text": "normL2Sqr<double>(pt[1] - pt[3])",
          "new_text": null,
          "old_line_content": "            double d2 = sqrt(normL2Sqr<double>(pt[1] - pt[3]));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "normL2Sqr<double>(pt[0] - pt[1])",
          "new_api": null,
          "old_text": "normL2Sqr<double>(pt[0] - pt[1])",
          "new_text": null,
          "old_line_content": "            double d3 = sqrt(normL2Sqr<double>(pt[0] - pt[1]));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1849,
          "old_api": "emplace_back",
          "new_api": null,
          "old_text": "contour_quads.emplace_back(pt, parentIdx)",
          "new_text": null,
          "old_line_content": "        contour_quads.emplace_back(pt, parentIdx);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": "size",
          "new_api": null,
          "old_text": "contour_quads.size()",
          "new_text": null,
          "old_line_content": "    size_t total = contour_quads.size();",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": "std::max((size_t)2, total * 3)",
          "new_api": null,
          "old_text": "std::max((size_t)2, total * 3)",
          "new_text": null,
          "old_line_content": "    size_t max_quad_buf_size = std::max((size_t)2, total * 3);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "allocate",
          "new_api": null,
          "old_text": "all_quads.allocate(max_quad_buf_size)",
          "new_text": null,
          "old_line_content": "    all_quads.allocate(max_quad_buf_size);",
          "new_line_content": "        int quad_idx = quad_count++;",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": "allocate",
          "new_api": null,
          "old_text": "all_corners.allocate(max_quad_buf_size * 4)",
          "new_text": null,
          "old_line_content": "    all_corners.allocate(max_quad_buf_size * 4);",
          "new_line_content": "        ChessBoardQuad& q = all_quads[quad_idx];",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "ChessBoardQuad",
          "new_api": null,
          "old_text": "ChessBoardQuad()",
          "new_text": null,
          "old_line_content": "        q = ChessBoardQuad();",
          "new_line_content": "        for (int i = 0; i < 4; ++i)",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": "ChessBoardCorner",
          "new_api": null,
          "old_text": "ChessBoardCorner(pt)",
          "new_text": null,
          "old_line_content": "            corner = ChessBoardCorner(pt);",
          "new_line_content": "        const int edge_len_compensation = 2 * dilations;",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": "sqrt",
          "new_api": null,
          "old_text": "sqrt(q.edge_len)",
          "new_text": null,
          "old_line_content": "        q.edge_len += 2 * sqrt(q.edge_len) * edge_len_compensation + edge_len_compensation * edge_len_compensation;",
          "new_line_content": "bool ChessBoardDetector::processQuads(std::vector<cv::Point2f>& out_corners, int &prev_sqr_size)",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "CV_LOG_VERBOSE",
          "new_api": null,
          "old_text": "CV_LOG_VERBOSE(NULL, 3, \"Total quad contours: \" << total)",
          "new_text": null,
          "old_line_content": "    CV_LOG_VERBOSE(NULL, 3, \"Total quad contours: \" << total);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "CV_LOG_VERBOSE",
          "new_api": null,
          "old_text": "CV_LOG_VERBOSE(NULL, 3, \"filtered quad_count=\" << quad_count)",
          "new_text": null,
          "old_line_content": "    CV_LOG_VERBOSE(NULL, 3, \"filtered quad_count=\" << quad_count);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": "resize",
          "new_api": null,
          "old_text": "out_corners.resize(0)",
          "new_text": null,
          "old_line_content": "    out_corners.resize(0);",
          "new_line_content": "    std::vector<ChessBoardQuad*> quad_group;",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "size",
          "new_api": null,
          "old_text": "all_quads.size()",
          "new_text": null,
          "old_line_content": "    size_t max_quad_buf_size = all_quads.size();",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "findQuadNeighbors",
          "new_api": null,
          "old_text": "findQuadNeighbors()",
          "new_text": null,
          "old_line_content": "    findQuadNeighbors();",
          "new_line_content": "            break;",
          "content_same": false
        },
        {
          "line": 1908,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "corner_group.reserve(max_quad_buf_size * 4)",
          "new_text": null,
          "old_line_content": "    std::vector<ChessBoardCorner*> corner_group; corner_group.reserve(max_quad_buf_size * 4);",
          "new_line_content": "        // order the quad corners globally",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": "empty",
          "new_api": null,
          "old_text": "quad_group.empty()",
          "new_text": null,
          "old_line_content": "        if (quad_group.empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": "size",
          "new_api": null,
          "old_text": "quad_group.size()",
          "new_text": null,
          "old_line_content": "        int count = (int)quad_group.size();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "orderFoundConnectedQuads",
          "new_api": null,
          "old_text": "orderFoundConnectedQuads(quad_group)",
          "new_text": null,
          "old_line_content": "        count = orderFoundConnectedQuads(quad_group);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": "cleanFoundConnectedQuads",
          "new_api": null,
          "old_text": "cleanFoundConnectedQuads(quad_group)",
          "new_text": null,
          "old_line_content": "        count = cleanFoundConnectedQuads(quad_group);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1930,
          "old_api": "DPRINTF",
          "new_api": null,
          "old_text": "DPRINTF(\"Connected group: %d, count: %d\", group_idx, count)",
          "new_text": null,
          "old_line_content": "        DPRINTF(\"Connected group: %d, count: %d\", group_idx, count);",
          "new_line_content": "        for(int i = 0; i < n; i++ )",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "checkQuadGroup",
          "new_api": null,
          "old_text": "checkQuadGroup(quad_group, corner_group)",
          "new_text": null,
          "old_line_content": "        count = checkQuadGroup(quad_group, corner_group);",
          "new_line_content": "            int ni = 0;",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "std::min(n, pattern_size.width * pattern_size.height)",
          "new_api": null,
          "old_text": "std::min(n, pattern_size.width * pattern_size.height)",
          "new_text": null,
          "old_line_content": "        n = std::min(n, pattern_size.width * pattern_size.height);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": "std::max(total, 1)",
          "new_api": null,
          "old_text": "std::max(total, 1)",
          "new_text": null,
          "old_line_content": "        prev_sqr_size = cvRound(sum_dist/std::max(total, 1));",
          "new_line_content": "            if (count == pattern_size.width*pattern_size.height",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "size",
          "new_api": null,
          "old_text": "out_corners.size()",
          "new_text": null,
          "old_line_content": "        if (count > 0 || (-count > (int)out_corners.size()))",
          "new_line_content": "            {",
          "content_same": false
        },
        {
          "line": 1952,
          "old_api": "clear",
          "new_api": null,
          "old_text": "out_corners.clear()",
          "new_text": null,
          "old_line_content": "            out_corners.clear();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1953,
          "old_api": "reserve",
          "new_api": null,
          "old_text": "out_corners.reserve(n)",
          "new_text": null,
          "old_line_content": "            out_corners.reserve(n);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "out_corners.push_back(corner_group[i]->pt)",
          "new_text": null,
          "old_line_content": "                out_corners.push_back(corner_group[i]->pt);",
          "new_line_content": "    return false;",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": "checkBoardMonotony",
          "new_api": null,
          "old_text": "checkBoardMonotony(out_corners)",
          "new_text": null,
          "old_line_content": "                    && checkBoardMonotony(out_corners))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "CV_INSTRUMENT_REGION",
          "new_api": null,
          "old_text": "CV_INSTRUMENT_REGION()",
          "new_text": null,
          "old_line_content": "    CV_INSTRUMENT_REGION();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": "type",
          "new_api": null,
          "old_text": "image.type()",
          "new_text": null,
          "old_line_content": "    int type = image.type();",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "CV_CheckType",
          "new_api": null,
          "old_text": "CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F,\n            \"Only 8-bit, 16-bit or floating-point 32-bit images are supported\")",
          "new_text": null,
          "old_line_content": "    CV_CheckType(type, depth == CV_8U || depth == CV_16U || depth == CV_32F,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": "empty",
          "new_api": null,
          "old_text": "_corners.empty()",
          "new_text": null,
          "old_line_content": "    if (_corners.empty())",
          "new_line_content": "    const int r = radius*(1 << shift);",
          "content_same": false
        },
        {
          "line": 1987,
          "old_api": "getMat",
          "new_api": null,
          "old_text": "_corners.getMat()",
          "new_text": null,
          "old_line_content": "    Mat corners = _corners.getMat();",
          "new_line_content": "    double scale = 1;",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": "corners.ptr<Point2f>(0)",
          "new_api": null,
          "old_text": "corners.ptr<Point2f>(0)",
          "new_text": null,
          "old_line_content": "    const Point2f* corners_data = corners.ptr<Point2f>(0);",
          "new_line_content": "    switch (depth)",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "CV_DbgAssert",
          "new_api": null,
          "old_text": "CV_DbgAssert(corners_data)",
          "new_text": null,
          "old_line_content": "    CV_DbgAssert(corners_data);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "checkVector",
          "new_api": null,
          "old_text": "corners.checkVector(2, CV_32F, true)",
          "new_text": null,
          "old_line_content": "    int nelems = corners.checkVector(2, CV_32F, true);",
          "new_line_content": "    case CV_8U:",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": "CV_Assert",
          "new_api": null,
          "old_text": "CV_Assert(nelems >= 0)",
          "new_text": null,
          "old_line_content": "    CV_Assert(nelems >= 0);",
          "new_line_content": "        scale = 1;",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": "cvRound",
          "new_api": null,
          "old_text": "cvRound(corners_data[i].x*(1 << shift))",
          "new_text": null,
          "old_line_content": "                    cvRound(corners_data[i].x*(1 << shift)),",
          "new_line_content": "        const int line_max = 7;",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": "cvRound",
          "new_api": null,
          "old_text": "cvRound(corners_data[i].y*(1 << shift))",
          "new_text": null,
          "old_line_content": "                    cvRound(corners_data[i].y*(1 << shift))",
          "new_line_content": "        static const int line_colors[line_max][4] =",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": "Point",
          "new_api": null,
          "old_text": "Point( pt.x + r, pt.y + r)",
          "new_text": null,
          "old_line_content": "            line(image, Point(pt.x - r, pt.y - r), Point( pt.x + r, pt.y + r), color, 1, line_type, shift);",
          "new_line_content": "            {0,0,255,0},",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "Point",
          "new_api": null,
          "old_text": "Point( pt.x + r, pt.y - r)",
          "new_text": null,
          "old_line_content": "            line(image, Point(pt.x - r, pt.y + r), Point( pt.x + r, pt.y - r), color, 1, line_type, shift);",
          "new_line_content": "            {0,128,255,0},",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": "circle",
          "new_api": null,
          "old_text": "circle(image, pt, r+(1<<shift), color, 1, line_type, shift)",
          "new_text": null,
          "old_line_content": "            circle(image, pt, r+(1<<shift), color, 1, line_type, shift);",
          "new_line_content": "            {0,200,200,0},",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 20,
      "total_additions": 74,
      "total_deletions": 77,
      "total_api_changes": 171
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 171,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          1799,
          1804,
          1806,
          1807,
          1809,
          1814
        ]
      }
    },
    "api_calls_before": 349,
    "api_calls_after": 346,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 13,
      "total_diff_lines": 31
    }
  }
}