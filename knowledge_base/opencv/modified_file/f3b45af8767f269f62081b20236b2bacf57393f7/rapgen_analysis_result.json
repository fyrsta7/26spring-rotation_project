{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/f3b45af8767f269f62081b20236b2bacf57393f7",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/f3b45af8767f269f62081b20236b2bacf57393f7/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/f3b45af8767f269f62081b20236b2bacf57393f7/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/opencv/modified_file/f3b45af8767f269f62081b20236b2bacf57393f7/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 426,
          "old_api": "at& src, const",
          "new_api": "s[2] == 0.0 &",
          "old_text": "at& src, const",
          "new_text": " s[2] == 0.0 &",
          "old_line_content": null,
          "new_line_content": "        matrix_operations::set_to_gpu(src, sf.val, mask, src.channels(), 0);",
          "content_same": true
        },
        {
          "line": 432,
          "old_api": "<CV_8U, 1,",
          "new_api": ", rows) );",
          "old_text": "<CV_8U, 1, ",
          "new_text": ", rows) );\n",
          "old_line_content": null,
          "new_line_content": "    CV_Assert(mask.type() == CV_8UC1);",
          "content_same": true
        },
        {
          "line": 434,
          "old_api": "char>,k",
          "new_api": "}",
          "old_text": "char>,k",
          "new_text": "  }\n   ",
          "old_line_content": null,
          "new_line_content": "    CV_Assert((depth() != CV_64F) || ",
          "content_same": true
        },
        {
          "line": 435,
          "old_api": "{kernelSet<schar>,kernelSet<schar>,",
          "new_api": ");\n\n            if (cn == 1 || (cn =",
          "old_text": " {kernelSet<schar>,kernelSet<schar>,",
          "new_text": ");\n\n            if (cn == 1 || (cn =",
          "old_line_content": null,
          "new_line_content": "        (TargetArchs::builtWith(NATIVE_DOUBLE) && DeviceInfo().supports(NATIVE_DOUBLE)));",
          "content_same": true
        },
        {
          "line": 437,
          "old_api": "t<schar>},",
          "new_api": "cn == 3 && s[",
          "old_text": "t<schar>},\n  ",
          "new_text": "cn == 3 && s[",
          "old_line_content": null,
          "new_line_content": "    CV_DbgAssert(!this->empty());",
          "content_same": true
        },
        {
          "line": 443,
          "old_api": "short>,NppSe",
          "new_api": "== s[3]))",
          "old_text": "short>,NppSe",
          "new_text": "== s[3]))\n  ",
          "old_line_content": null,
          "new_line_content": "    if (mask.empty())",
          "content_same": true
        },
        {
          "line": 457,
          "old_api": "SetMask<CV",
          "new_api": "et<CV_16U, 1, nppiSet_16u_C1R>::set,kerne",
          "old_text": "SetMask<CV",
          "new_text": "et<CV_16U, 1, nppiSet_16u_C1R>::set,kerne",
          "old_line_content": "        set_callers[depth()][channels()-1](*this, s);",
          "new_line_content": "                cudaSafeCall( cudaMemset2D(data, step, val, cols, rows) );",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "ows;",
          "new_api": "1, nppiSet",
          "old_text": "ows;\n     ",
          "new_text": "1, nppiSet",
          "old_line_content": "        set_callers[depth()][channels()-1](*this, s, mask);",
          "new_line_content": "        set_callers[depth()][channels()-1](*this, s);",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "s not divisible by the new number of channels\" );",
          "new_api": "total_size",
          "old_text": "s not divisible by the new number of channels\" );\n\n   ",
          "new_text": "total_size",
          "old_line_content": "            CV_Error( CV_StsOutOfRange, \"Bad new number of rows\" );",
          "new_line_content": "    int cn = channels();",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "gs |=",
          "new_api": "rele",
          "old_text": "gs |= ",
          "new_text": "       rele",
          "old_line_content": "    if( rows == _rows && cols == _cols && type() == _type && data )",
          "new_line_content": "        hdr.step = total_width * elemSize1();",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": "ombined) ); break;\n            default: cv::gpu::err",
          "new_api": "fer is allocated\");\n        size_t datas",
          "old_text": "ombined) ); break;\n            default: cv::gpu::err",
          "new_text": "fer is allocated\");\n        size_t datas",
          "old_line_content": "            CV_Error(CV_StsNoMem, \"Too big buffer is allocated\");",
          "new_line_content": "    CV_DbgAssert( _rows >= 0 && _cols >= 0 );",
          "content_same": false
        },
        {
          "line": 644,
          "old_api": ") );\n        res = GpuMat(rows, cols, type(), pdev,",
          "new_api": "break;",
          "old_text": ") );\n        res = GpuMat(rows, cols, type(), pdev,",
          "new_text": "break;\n    ",
          "old_line_content": "            case ALLOC_ZEROCOPY:       cudaSafeCall( cudaHostAlloc( &ptr, datasize, cudaHostAllocMapped) );  break;",
          "new_line_content": "            cudaSafeCall( cudaGetDeviceProperties(&prop, getDevice()) );",
          "content_same": false
        },
        {
          "line": 645,
          "old_api": "pported or memory was allocated without zero-copy flag\", _",
          "new_api": "PY:       cudaSafeCall( cudaHostAlloc( &",
          "old_text": "pported or memory was allocated without zero-copy flag\", _",
          "new_text": "PY:       cudaSafeCall( cudaHostAlloc( &",
          "old_line_content": "            case ALLOC_WRITE_COMBINED: cudaSafeCall( cudaHostAlloc( &ptr, datasize, cudaHostAllocWriteCombined) ); break;",
          "new_line_content": "            step = alignUpStep(step, prop.textureAlignment);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "dr.step = tota",
          "old_text": null,
          "new_text": "dr.step = tota",
          "old_line_content": "",
          "new_line_content": "        if( !isContinuous() )",
          "content_same": false
        },
        {
          "line": 513,
          "old_api": null,
          "new_api": "ze1",
          "old_text": null,
          "new_text": "ze1();\n    }\n\n    int new_width = total_width / new_cn;\n\n    if( new_width * new_cn != total_width",
          "old_line_content": "    if( new_width * new_cn != total_width )",
          "new_line_content": "            CV_Error( CV_BadStep, \"The matrix is not continuous, thus its number of rows can not be changed\" );",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "void",
          "old_text": null,
          "new_text": "     void ",
          "old_line_content": "",
          "new_line_content": "        step = elemSize()*cols;",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": null,
          "new_api": "by the new number of channels\" );\n\n    hdr.cols = new_",
          "old_text": null,
          "new_text": "by the new number of channels\" );\n\n    hdr.cols = new_",
          "old_line_content": "    hdr.cols = new_width;",
          "new_line_content": "            CV_Error( CV_StsOutOfRange, \"Bad new number of rows\" );",
          "content_same": false
        },
        {
          "line": 521,
          "old_api": null,
          "new_api": "GpuMat::create(int _rows, int _cols, int _type)\n{\n    _type &= TYPE_MASK;\n    if( rows == _rows && cols ==",
          "old_text": null,
          "new_text": "GpuMat::create(int _rows, int _cols, int _type)\n{\n    _type &= TYPE_MASK;\n    if( rows == _rows && cols ==",
          "old_line_content": "void cv::gpu::GpuMat::create(int _rows, int _cols, int _type)",
          "new_line_content": "            CV_Error( CV_StsBadArg, \"The total number of matrix elements is not divisible by the new number of rows\" );",
          "content_same": false
        },
        {
          "line": 650,
          "old_api": null,
          "new_api": "k;\n            default: cv::gpu::error(\"Invalid allo",
          "old_text": null,
          "new_text": "k;\n            default: cv::gpu::error(\"Invalid allo",
          "old_line_content": "        dataend = data + nettosize;",
          "new_line_content": "            CV_Error(CV_StsNoMem, \"Too big buffer is allocated\");",
          "content_same": false
        },
        {
          "line": 651,
          "old_api": null,
          "new_api": "}\n\n        datastart = data =  (uch",
          "old_text": null,
          "new_text": "\n        }\n\n        datastart = data =  (uch",
          "old_line_content": "",
          "new_line_content": "        size_t datasize = alignSize(nettosize, (int)sizeof(*refcount));",
          "content_same": false
        },
        {
          "line": 530,
          "old_api": null,
          "new_api": "t::MAGIC_VAL + _type;\n        rows = _rows;\n        cols = _cols;\n\n        size_t esz = elemSiz",
          "old_text": null,
          "new_text": "t::MAGIC_VAL + _type;\n        rows = _rows;\n        cols = _cols;\n\n        size_t esz = elemSiz",
          "old_line_content": "    {",
          "new_line_content": "        CV_Error( CV_BadNumChannels, \"The total width is not divisible by the new number of channels\" );",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "C_ZEROCOPY)\n    {\n        void *pdev;\n        cudaSa",
          "old_text": null,
          "new_text": "C_ZEROCOPY)\n    {\n        void *pdev;\n        cudaSa",
          "old_line_content": "    GpuMat res;",
          "new_line_content": "            case ALLOC_PAGE_LOCKED:    cudaSafeCall( cudaHostAlloc( &ptr, datasize, cudaHostAllocDefault) ); break;",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "= GpuMat(rows, cols, type(), pdev, step);\n    }",
          "old_text": null,
          "new_text": " = GpuMat(rows, cols, type(), pdev, step);\n    }\n  ",
          "old_line_content": "    if (alloc_type == ALLOC_ZEROCOPY)",
          "new_line_content": "            case ALLOC_ZEROCOPY:       cudaSafeCall( cudaHostAlloc( &ptr, datasize, cudaHostAllocMapped) );  break;",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": null,
          "new_api": "y was allocated without zero-copy flag\", __FILE__, __LINE_",
          "old_text": null,
          "new_text": "y was allocated without zero-copy flag\", __FILE__, __LINE_",
          "old_line_content": "    {",
          "new_line_content": "            case ALLOC_WRITE_COMBINED: cudaSafeCall( cudaHostAlloc( &ptr, datasize, cudaHostAllocWriteCombined) ); break;",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "gpu::CudaMem::release()\n{\n    if( refcount && CV_XADD(re",
          "old_text": null,
          "new_text": "gpu::CudaMem::release()\n{\n    if( refcount && CV_XADD(re",
          "old_line_content": "        void *pdev;",
          "new_line_content": "            default: cv::gpu::error(\"Invalid alloc type\", __FILE__, __LINE__);",
          "content_same": false
        },
        {
          "line": 540,
          "old_api": null,
          "new_api": "NUOUS_",
          "old_text": null,
          "new_text": "NUOUS_",
          "old_line_content": "        // Single row must be continuous",
          "new_line_content": "    if( rows == _rows && cols == _cols && type() == _type && data )",
          "content_same": false
        },
        {
          "line": 668,
          "old_api": null,
          "new_api": "tastart = dataend = 0;\n    step =",
          "old_text": null,
          "new_text": "tastart = dataend = 0;\n    step =",
          "old_line_content": "",
          "new_line_content": "        refcount = (int*)cv::fastMalloc(sizeof(*refcount));",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "ze_t nett",
          "old_text": null,
          "new_text": "ze_t nett",
          "old_line_content": "",
          "new_line_content": "        release();",
          "content_same": false
        },
        {
          "line": 544,
          "old_api": null,
          "new_api": "(size_t)_nettosize;\n\n        datastart",
          "old_text": null,
          "new_text": " (size_t)_nettosize;\n\n        datastart ",
          "old_line_content": "        if (esz * cols == step)",
          "new_line_content": "    CV_DbgAssert( _rows >= 0 && _cols >= 0 );",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "d cv::gpu:",
          "old_text": null,
          "new_text": "d cv::gpu:",
          "old_line_content": "        dataend = data + nettosize;",
          "new_line_content": "        size_t esz = elemSize();",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "    data = datastart = dataend = 0;",
          "new_line_content": "        cudaSafeCall( cudaHostGetDevicePointer( &pdev, data, 0 ) );",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "    step = rows = cols = 0;",
          "new_line_content": "        res = GpuMat(rows, cols, type(), pdev, step);",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "fcount, -1) == 1 )\n    {\n        fastFree(refcount",
          "old_text": null,
          "new_text": "fcount, -1) == 1 )\n    {\n        fastFree(refcount",
          "old_line_content": "        *refcount = 1;",
          "new_line_content": "        cudaSafeCall( cudaMallocPitch(&dev_ptr, &step, esz * cols, rows) );",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "        cv::gpu::error(\"Zero-copy is not supported or memory was allocated without zero-copy flag\", __FILE__, __LINE__);",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "    if( refcount && CV_XADD(refcount, -1) == 1 )",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "        cudaSafeCall( cudaFreeHost(datastart ) );",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "        fastFree(refcount);",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": null,
          "new_api": "::ensureSizeIsEnough(int rows",
          "old_text": null,
          "new_text": "::ensureSizeIsEnough(int rows",
          "old_line_content": "",
          "new_line_content": "        refcount = (int*)fastMalloc(sizeof(*refcount));",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": null,
          "new_api": "return",
          "old_text": null,
          "new_text": "    return",
          "old_line_content": "        {",
          "new_line_content": "            cudaSafeCall( cudaMemset2D(data, step, 0, cols * elemSize(), rows) );",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": ")\n        return;",
          "old_text": null,
          "new_text": ")\n        return;\n   ",
          "old_line_content": "}",
          "new_line_content": "    if( refcount && CV_XADD(refcount, -1) == 1 )",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "pe);\n}\n\n\n/////////",
          "old_text": null,
          "new_text": "pe);\n}\n\n\n/////////",
          "old_line_content": "void cv::gpu::ensureSizeIsEnough(int rows, int cols, int type, GpuMat& m)",
          "new_line_content": "        fastFree(refcount);",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": null,
          "new_api": "///////////////////",
          "old_text": null,
          "new_text": "///////////////////",
          "old_line_content": "{",
          "new_line_content": "        cudaSafeCall( cudaFree(datastart) );",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "ler_t)(",
          "old_text": null,
          "new_text": "ler_t)(",
          "old_line_content": "            {NppSet<CV_16U, 1, nppiSet_16u_C1R>::set,kernelSet<ushort>,kernelSet<ushort>,NppSet<CV_16U, 4, nppiSet_16u_C4R>::set},",
          "new_line_content": "        if (depth() == CV_8U)",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "c const se",
          "old_text": null,
          "new_text": "c const se",
          "old_line_content": "            {NppSet<CV_32S, 1, nppiSet_32s_C1R>::set,kernelSet<int>,kernelSet<int>,NppSet<CV_32S, 4, nppiSet_32s_C4R>::set},",
          "new_line_content": "            int cn = channels();",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "char>,kernelSet<schar>,ker",
          "old_text": null,
          "new_text": "char>,kernelSet<schar>,ker",
          "old_line_content": "        };",
          "new_line_content": "                int val = saturate_cast<uchar>(s[0]);",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": null,
          "new_api": "etDevicePropert",
          "old_text": null,
          "new_text": "etDevicePropert",
          "old_line_content": "",
          "new_line_content": "    if (!m.isContinuous() || m.type() != type || m.size().area() != area)",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e()) );\n    return (pro",
          "old_line_content": "bool cv::gpu::CudaMem::canMapHostMemory()",
          "new_line_content": "        m.create(1, area, type);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "tMemory != 0) ? tr",
          "old_text": null,
          "new_text": "tMemory != 0) ? tr",
          "old_line_content": "{",
          "new_line_content": "    m = m.reshape(0, rows);",
          "content_same": false
        },
        {
          "line": 596,
          "old_api": null,
          "new_api": "size_t",
          "old_text": null,
          "new_text": " size_t ",
          "old_line_content": "",
          "new_line_content": "    if (m.type() == type && m.rows >= rows && m.cols >= cols)",
          "content_same": false
        },
        {
          "line": 598,
          "old_api": null,
          "new_api": "k;\n        size_t res = (w",
          "old_text": null,
          "new_text": "k;\n        size_t res = (w",
          "old_line_content": "{",
          "new_line_content": "    m.create(rows, cols, type);",
          "content_same": false
        },
        {
          "line": 609,
          "old_api": null,
          "new_api": "&& cols ==",
          "old_text": null,
          "new_text": "&& cols == ",
          "old_line_content": "{",
          "new_line_content": "    cudaSafeCall( cudaGetDeviceProperties(&prop, getDevice()) );",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": null,
          "new_api": "!isContin",
          "old_text": null,
          "new_text": " !isContin",
          "old_line_content": "",
          "new_line_content": "        set_callers[depth()][channels()-1](*this, s, mask);",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "getDevice",
          "old_text": null,
          "new_text": "getDevice()) );\n  ",
          "old_line_content": "        {",
          "new_line_content": "    if (_alloc_type == ALLOC_ZEROCOPY && !canMapHostMemory())",
          "content_same": false
        },
        {
          "line": 627,
          "old_api": null,
          "new_api": "= alignUpStep(step, prop.textureAlignment);\n        }\n        int64 _nettosize =",
          "old_text": null,
          "new_text": "= alignUpStep(step, prop.textureAlignment);\n        }\n        int64 _nettosize = ",
          "old_line_content": "            cudaDeviceProp prop;",
          "new_line_content": "            cv::gpu::error(\"ZeroCopy is not supported by current device\", __FILE__, __LINE__);",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": null,
          "new_api": "if( _",
          "old_text": null,
          "new_text": " if( _",
          "old_line_content": "        }",
          "new_line_content": "    if( rows == _rows && cols == _cols && type() == _type && data )",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "em, \"Too",
          "old_text": null,
          "new_text": "em, \"Too ",
          "old_line_content": "        if( _nettosize != (int64)nettosize )",
          "new_line_content": "        release();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 514,
          "old_api": "flags = Mat::MAGIC_VAL + _type;\n        rows = _rows;\n        cols = _cols;\n\n        size",
          "new_api": null,
          "old_text": "      flags = Mat::MAGIC_VAL + _type;\n        rows = _rows;\n        cols = _cols;\n\n        size",
          "new_text": null,
          "old_line_content": "        CV_Error( CV_BadNumChannels, \"The total width is not divisible by the new number of channels\" );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "loc_type == ALLOC_ZEROCOPY)\n    {\n        void *pdev",
          "new_api": null,
          "old_text": "loc_type == ALLOC_ZEROCOPY)\n    {\n        void *pdev",
          "new_text": null,
          "old_line_content": "            case ALLOC_PAGE_LOCKED:    cudaSafeCall( cudaHostAlloc( &ptr, datasize, cudaHostAllocDefault) ); break;",
          "new_line_content": "            cudaDeviceProp prop;",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "es;\n}\n\nvoid cv::gpu::CudaMem::release()\n{\n    if( refcou",
          "new_api": null,
          "old_text": "es;\n}\n\nvoid cv::gpu::CudaMem::release()\n{\n    if( refcou",
          "new_text": null,
          "old_line_content": "            default: cv::gpu::error(\"Invalid alloc type\", __FILE__, __LINE__);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": "}\n    data = datastart = dataend",
          "new_api": null,
          "old_text": " }\n    data = datastart = dataend",
          "new_text": null,
          "old_line_content": "        refcount = (int*)cv::fastMalloc(sizeof(*refcount));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "rows;",
          "new_api": null,
          "old_text": "rows;\n   ",
          "new_text": null,
          "old_line_content": "        release();",
          "new_line_content": "    int new_width = total_width / new_cn;",
          "content_same": false
        },
        {
          "line": 528,
          "old_api": "ze_t nettosize = (size_t)_nettosize;",
          "new_api": null,
          "old_text": "ze_t nettosize = (size_t)_nettosize;\n\n  ",
          "new_text": null,
          "old_line_content": "    CV_DbgAssert( _rows >= 0 && _cols >= 0 );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "1;\n    }",
          "new_api": null,
          "old_text": " 1;\n    }\n",
          "new_text": null,
          "old_line_content": "        size_t esz = elemSize();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        cudaSafeCall( cudaHostGetDevicePointer( &pdev, data, 0 ) );",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        res = GpuMat(rows, cols, type(), pdev, step);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "nt && CV_XADD(refcount, -1) == 1 )\n    {\n        f",
          "new_api": null,
          "old_text": "nt && CV_XADD(refcount, -1) == 1 )\n    {\n        f",
          "new_text": null,
          "old_line_content": "        cudaSafeCall( cudaMallocPitch(&dev_ptr, &step, esz * cols, rows) );",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        cv::gpu::error(\"Zero-copy is not supported or memory was allocated without zero-copy flag\", __FILE__, __LINE__);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 674,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    if( refcount && CV_XADD(refcount, -1) == 1 )",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        cudaSafeCall( cudaFreeHost(datastart ) );",
          "new_line_content": "    if (alloc_type == ALLOC_ZEROCOPY)",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "        fastFree(refcount);",
          "new_line_content": "    {",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": "}\n\nvoid cv::gpu::ensureSizeI",
          "new_api": null,
          "old_text": "\n}\n\nvoid cv::gpu::ensureSizeI",
          "new_text": null,
          "old_line_content": "        refcount = (int*)fastMalloc(sizeof(*refcount));",
          "new_line_content": "        void *dev_ptr;",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "& m.cols >= cols)",
          "new_api": null,
          "old_text": "& m.cols >= cols)\n   ",
          "new_text": null,
          "old_line_content": "    if( refcount && CV_XADD(refcount, -1) == 1 )",
          "new_line_content": "        if (esz * cols == step)",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "e",
          "new_api": null,
          "old_text": "e(rows, cols, type",
          "new_text": null,
          "old_line_content": "        fastFree(refcount);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "///////////////////",
          "new_api": null,
          "old_text": "///////////////////",
          "new_text": null,
          "old_line_content": "        cudaSafeCall( cudaFree(datastart) );",
          "new_line_content": "        int64 _nettosize = (int64)step*rows;",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "aSafeCall",
          "new_api": null,
          "old_text": "aSafeCall( cuda",
          "new_text": null,
          "old_line_content": "    if (!m.isContinuous() || m.type() != type || m.size().area() != area)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "(&prop, getDevice()) );",
          "new_api": null,
          "old_text": "(&prop, getDevice()) );",
          "new_text": null,
          "old_line_content": "        m.create(1, area, type);",
          "new_line_content": "void cv::gpu::GpuMat::release()",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "(prop.canMapHostM",
          "new_api": null,
          "old_text": " (prop.canMapHostM",
          "new_text": null,
          "old_line_content": "    m = m.reshape(0, rows);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "t)\n    {",
          "new_api": null,
          "old_text": "t)\n    {",
          "new_text": null,
          "old_line_content": "    if (m.type() == type && m.rows >= rows && m.cols >= cols)",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "Mask = ~alignMask;",
          "new_api": null,
          "old_text": "Mask = ~alignMask;\n       ",
          "new_text": null,
          "old_line_content": "    m.create(rows, cols, type);",
          "new_line_content": "    step = rows = cols = 0;",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "( rows == _",
          "new_api": null,
          "old_text": "( rows == _",
          "new_text": null,
          "old_line_content": "    cudaSafeCall( cudaGetDeviceProperties(&prop, getDevice()) );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": "operties",
          "new_api": null,
          "old_text": "operties(&prop, ge",
          "new_text": null,
          "old_line_content": "    if (_alloc_type == ALLOC_ZEROCOPY && !canMapHostMemory())",
          "new_line_content": "    return (prop.canMapHostMemory != 0) ? true : false;",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "step = alignUpStep(step, prop.textureAlignment);\n        }\n        int",
          "new_api": null,
          "old_text": "           step = alignUpStep(step, prop.textureAlignment);\n        }\n        int",
          "new_text": null,
          "old_line_content": "            cv::gpu::error(\"ZeroCopy is not supported by current device\", __FILE__, __LINE__);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "ows > (uns",
          "new_api": null,
          "old_text": "ows > (uns",
          "new_text": null,
          "old_line_content": "    int cn = channels();",
          "new_line_content": "            {NppSetMask<CV_32S, 1, nppiSet_32s_C1MR>::set,kernelSetMask<int>,kernelSetMask<int>,NppSetMask<CV_32S, 4, nppiSet_32s_C4MR>::set},",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "ttosiz",
          "new_api": null,
          "old_text": "ttosiz",
          "new_text": null,
          "old_line_content": "    if( rows == _rows && cols == _cols && type() == _type && data )",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "_Error",
          "new_api": null,
          "old_text": "_Error(CV",
          "new_text": null,
          "old_line_content": "        release();",
          "new_line_content": "        size_t alignMask = alignment-1;",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "em, \"Too big buffer is allocated\");",
          "new_api": null,
          "old_text": "em, \"Too big buffer is allocated\");\n    ",
          "new_text": null,
          "old_line_content": "    CV_DbgAssert( _rows >= 0 && _cols >= 0 );",
          "new_line_content": "        size_t inverseAlignMask = ~alignMask;",
          "content_same": false
        },
        {
          "line": 624,
          "old_api": "_alloc_typ",
          "new_api": null,
          "old_text": "_alloc_typ",
          "new_text": null,
          "old_line_content": "        step = elemSize()*cols;",
          "new_line_content": "void cv::gpu::CudaMem::create(int _rows, int _cols, int _type, int _alloc_type)",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "_rows;",
          "new_api": null,
          "old_text": "_rows;\n       ",
          "new_text": null,
          "old_line_content": "        if( !isContinuous() )",
          "new_line_content": "GpuMat cv::gpu::GpuMat::reshape(int new_cn, int new_rows) const",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": "l_width * elemSize1();\n    }\n\n    int new_width = total_width / new_cn;\n\n    if( new_width * new_c",
          "new_api": null,
          "old_text": "l_width * elemSize1();\n    }\n\n    int new_width = total_width / new_cn;\n\n    if( new_width * new_c",
          "new_text": null,
          "old_line_content": "            CV_Error( CV_BadStep, \"The matrix is not continuous, thus its number of rows can not be changed\" );",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": "llocDefault",
          "new_api": null,
          "old_text": "llocDefault",
          "new_text": null,
          "old_line_content": "            cudaSafeCall( cudaGetDeviceProperties(&prop, getDevice()) );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 629,
          "old_api": "ase ALLOC_ZEROCOPY:       cudaSafeCall(",
          "new_api": null,
          "old_text": "ase ALLOC_ZEROCOPY:       cudaSafeCall( ",
          "new_text": null,
          "old_line_content": "            step = alignUpStep(step, prop.textureAlignment);",
          "new_line_content": "    _type &= TYPE_MASK;",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": "void cv::gpu::GpuMat::create(int _rows, int _cols, int _type)\n{\n    _type &= TYPE_MASK;\n    if( rows ==",
          "new_api": null,
          "old_text": "\n\nvoid cv::gpu::GpuMat::create(int _rows, int _cols, int _type)\n{\n    _type &= TYPE_MASK;\n    if( rows == ",
          "new_text": null,
          "old_line_content": "            CV_Error( CV_StsBadArg, \"The total number of matrix elements is not divisible by the new number of rows\" );",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": "LE__, __LINE__);\n        }\n\n        datastar",
          "new_api": null,
          "old_text": "LE__, __LINE__);\n        }\n\n        datastar",
          "new_text": null,
          "old_line_content": "        size_t datasize = alignSize(nettosize, (int)sizeof(*refcount));",
          "new_line_content": "    if( _rows > 0 && _cols > 0 )",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "if( dat",
          "new_api": null,
          "old_text": "    if( dat",
          "new_text": null,
          "old_line_content": "        hdr.step = total_width * elemSize1();",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 13,
      "total_additions": 43,
      "total_deletions": 38,
      "total_api_changes": 94
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 16,
        "api_related_lines": 94,
        "non_api_lines": 11,
        "non_api_line_numbers": [
          448,
          449,
          451,
          453,
          454,
          455,
          458,
          459,
          460,
          445,
          446
        ]
      }
    },
    "api_calls_before": 198,
    "api_calls_after": 206,
    "diff_info": {
      "added_lines": 16,
      "removed_lines": 0,
      "total_diff_lines": 28
    }
  }
}