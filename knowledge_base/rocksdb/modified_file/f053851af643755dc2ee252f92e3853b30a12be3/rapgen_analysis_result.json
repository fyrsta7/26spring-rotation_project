{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/rocksdb/modified_file/f053851af643755dc2ee252f92e3853b30a12be3",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/rocksdb/modified_file/f053851af643755dc2ee252f92e3853b30a12be3/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/rocksdb/modified_file/f053851af643755dc2ee252f92e3853b30a12be3/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/rocksdb/modified_file/f053851af643755dc2ee252f92e3853b30a12be3/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 559,
          "old_api": "GetOverlappingInputs",
          "new_api": "NumberLevels",
          "old_text": "vstorage->GetOverlappingInputs(output_level_inputs.level + 1, &start,\n                                   &limit, grandparents)",
          "new_text": "NumberLevels()",
          "old_line_content": "    vstorage->GetOverlappingInputs(output_level_inputs.level + 1, &start,",
          "new_line_content": "  for (int level = output_level_inputs.level + 1; level < NumberLevels();",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": "num_levels",
          "new_api": "assert",
          "old_text": "vstorage->num_levels()",
          "new_text": "assert(ioptions_.compaction_style == kCompactionStyleUniversal)",
          "old_line_content": "    assert(vstorage->num_levels() > 1);",
          "new_line_content": "    assert(ioptions_.compaction_style == kCompactionStyleUniversal);",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": "assert",
          "new_api": "num_levels",
          "old_text": "assert(end == nullptr)",
          "new_text": "vstorage->num_levels()",
          "old_line_content": "    assert(end == nullptr);",
          "new_line_content": "      assert(output_level == vstorage->num_levels() - 1);",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "num_levels",
          "new_api": "assert",
          "old_text": "vstorage->num_levels()",
          "new_text": "assert(end == nullptr)",
          "old_line_content": "    for (; start_level < vstorage->num_levels() &&",
          "new_line_content": "    assert(end == nullptr);",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "empty",
          "new_api": "num_levels",
          "old_text": "level0_compactions_in_progress_.empty()",
          "new_text": "vstorage->num_levels()",
          "old_line_content": "    if ((start_level == 0) && (!level0_compactions_in_progress_.empty())) {",
          "new_line_content": "    if (start_level == vstorage->num_levels()) {",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": "push_back",
          "new_api": "num_levels",
          "old_text": "files.push_back(f)",
          "new_text": "vstorage->num_levels()",
          "old_line_content": "        files.push_back(f);",
          "new_line_content": "    for (int level = start_level; level < vstorage->num_levels(); level++) {",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "GetCompressionType",
          "new_api": "MaxFileSizeForLevel",
          "old_text": "GetCompressionType(ioptions_, vstorage, mutable_cf_options,\n                           output_level, 1)",
          "new_text": "MaxFileSizeForLevel(mutable_cf_options, output_level,\n                            ioptions_.compaction_style)",
          "old_line_content": "        GetCompressionType(ioptions_, vstorage, mutable_cf_options,",
          "new_line_content": "        MaxFileSizeForLevel(mutable_cf_options, output_level,",
          "content_same": false
        },
        {
          "line": 642,
          "old_api": "RegisterCompaction",
          "new_api": "GetCompressionOptions",
          "old_text": "RegisterCompaction(c)",
          "new_text": "GetCompressionOptions(mutable_cf_options, vstorage, output_level)",
          "old_line_content": "    RegisterCompaction(c);",
          "new_line_content": "        GetCompressionOptions(mutable_cf_options, vstorage, output_level),",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": "size",
          "new_api": "assert",
          "old_text": "inputs.size()",
          "new_text": "assert(input_level == output_level)",
          "old_line_content": "    size_t skip_input_index = inputs.size();",
          "new_line_content": "    assert(input_level == output_level);",
          "content_same": false
        },
        {
          "line": 727,
          "old_api": "empty",
          "new_api": "size",
          "old_text": "inputs_shrunk.empty()",
          "new_text": "inputs.size()",
          "old_line_content": "      } else if (!inputs_shrunk.empty()) {",
          "new_line_content": "    size_t skip_input_index = inputs.size();",
          "content_same": false
        },
        {
          "line": 738,
          "old_api": "swap",
          "new_api": "empty",
          "old_text": "inputs.files.swap(inputs_shrunk)",
          "new_text": "inputs_shrunk.empty()",
          "old_line_content": "      inputs.files.swap(inputs_shrunk);",
          "new_line_content": "    if (inputs_shrunk.empty()) {",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "size",
          "new_api": "swap",
          "old_text": "inputs.size()",
          "new_text": "inputs.files.swap(inputs_shrunk)",
          "old_line_content": "    for (size_t i = skip_input_index + 1; i < inputs.size(); ++i) {",
          "new_line_content": "      inputs.files.swap(inputs_shrunk);",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "AreFilesInCompaction",
          "new_api": "empty",
          "old_text": "AreFilesInCompaction(compaction_inputs[i].files)",
          "new_text": "output_level_inputs.empty()",
          "old_line_content": "    if (AreFilesInCompaction(compaction_inputs[i].files)) {",
          "new_line_content": "  if (!output_level_inputs.empty()) {",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "base_level",
          "new_api": "GetGrandparents",
          "old_text": "MaxFileSizeForLevel(mutable_cf_options, output_level,\n                          ioptions_.compaction_style, vstorage->base_level(),\n                          ioptions_.level_compaction_dynamic_level_bytes)",
          "new_text": "GetGrandparents(vstorage, inputs, output_level_inputs, &grandparents)",
          "old_line_content": "      MaxFileSizeForLevel(mutable_cf_options, output_level,",
          "new_line_content": "  GetGrandparents(vstorage, inputs, output_level_inputs, &grandparents);",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "std::move(grandparents)",
          "new_api": "base_level",
          "old_text": "std::move(grandparents)",
          "new_text": "GetCompressionType(ioptions_, vstorage, mutable_cf_options, output_level,\n                         vstorage->base_level())",
          "old_line_content": "      std::move(grandparents),",
          "new_line_content": "      GetCompressionType(ioptions_, vstorage, mutable_cf_options, output_level,",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "RegisterCompaction",
          "new_api": "std::move(grandparents)",
          "old_text": "RegisterCompaction(compaction)",
          "new_text": "std::move(grandparents)",
          "old_line_content": "  RegisterCompaction(compaction);",
          "new_line_content": "      std::move(grandparents),",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "static_cast<int>(f)",
          "new_api": "size",
          "old_text": "static_cast<int>(f)",
          "new_text": "current_files.size()",
          "old_line_content": "        last_included = std::max(last_included, static_cast<int>(f));",
          "new_line_content": "    for (size_t f = 0; f < current_files.size(); ++f) {",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "TableFileNameToNumber",
          "new_api": "Status::Aborted(\"Necessary compaction input file \" +\n                               current_files[f].name +\n                               \" is currently being compacted.\")",
          "old_text": "TableFileNameToNumber(current_files[f].name)",
          "new_text": "Status::Aborted(\"Necessary compaction input file \" +\n                               current_files[f].name +\n                               \" is currently being compacted.\")",
          "old_line_content": "      input_files->insert(TableFileNameToNumber(current_files[f].name));",
          "new_line_content": "        return Status::Aborted(\"Necessary compaction input file \" +",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": "Status::OK()",
          "new_api": "Status::Aborted(\n        \"A running compaction is writing to the same output level in an \"\n        \"overlapping key range\")",
          "old_text": "Status::OK()",
          "new_text": "Status::Aborted(\n        \"A running compaction is writing to the same output level in an \"\n        \"overlapping key range\")",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "    return Status::Aborted(",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "Status::InvalidArgument(\n        \"Exceed the maximum output level defined by \"\n        \"the current compaction algorithm --- \" +\n        ToString(MaxOutputLevel()))",
          "new_api": "size",
          "old_text": "Status::InvalidArgument(\n        \"Exceed the maximum output level defined by \"\n        \"the current compaction algorithm --- \" +\n        ToString(MaxOutputLevel()))",
          "new_text": "cf_meta.levels.size()",
          "old_line_content": "    return Status::InvalidArgument(",
          "new_line_content": "        ToString(cf_meta.levels[cf_meta.levels.size() - 1].level) + \"].\");",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": "Status::InvalidArgument(\"Output level cannot be negative.\")",
          "new_api": "MaxOutputLevel",
          "old_text": "Status::InvalidArgument(\"Output level cannot be negative.\")",
          "new_text": "MaxOutputLevel()",
          "old_line_content": "    return Status::InvalidArgument(\"Output level cannot be negative.\");",
          "new_line_content": "        ToString(MaxOutputLevel()));",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "Status::InvalidArgument(\n        \"A compaction must contain at least one file.\")",
          "new_api": "Status::InvalidArgument(\"Output level cannot be negative.\")",
          "old_text": "Status::InvalidArgument(\n        \"A compaction must contain at least one file.\")",
          "new_text": "Status::InvalidArgument(\"Output level cannot be negative.\")",
          "old_line_content": "    return Status::InvalidArgument(",
          "new_line_content": "    return Status::InvalidArgument(\"Output level cannot be negative.\");",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "SanitizeCompactionInputFilesForAllLevels",
          "new_api": "Status::InvalidArgument(\n        \"A compaction must contain at least one file.\")",
          "old_text": "SanitizeCompactionInputFilesForAllLevels(input_files, cf_meta,\n                                                      output_level)",
          "new_text": "Status::InvalidArgument(\n        \"A compaction must contain at least one file.\")",
          "old_line_content": "  Status s = SanitizeCompactionInputFilesForAllLevels(input_files, cf_meta,",
          "new_line_content": "    return Status::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "Status::InvalidArgument(\n          \"Cannot compact file to up level, input file: \" +\n          MakeTableFileName(\"\", file_num) + \" level \" +\n          ToString(input_file_level) + \" > output level \" +\n          ToString(output_level))",
          "new_api": "MakeTableFileName",
          "old_text": "Status::InvalidArgument(\n          \"Cannot compact file to up level, input file: \" +\n          MakeTableFileName(\"\", file_num) + \" level \" +\n          ToString(input_file_level) + \" > output level \" +\n          ToString(output_level))",
          "new_text": "MakeTableFileName(\"\", file_num)",
          "old_line_content": "      return Status::InvalidArgument(",
          "new_line_content": "          \"Specified compaction input file \" + MakeTableFileName(\"\", file_num) +",
          "content_same": false
        },
        {
          "line": 1063,
          "old_api": "ToString",
          "new_api": "Status::InvalidArgument(\n          \"Cannot compact file to up level, input file: \" +\n          MakeTableFileName(\"\", file_num) + \" level \" +\n          ToString(input_file_level) + \" > output level \" +\n          ToString(output_level))",
          "old_text": "ToString(output_level)",
          "new_text": "Status::InvalidArgument(\n          \"Cannot compact file to up level, input file: \" +\n          MakeTableFileName(\"\", file_num) + \" level \" +\n          ToString(input_file_level) + \" > output level \" +\n          ToString(output_level))",
          "old_line_content": "          ToString(output_level));",
          "new_line_content": "      return Status::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "Status::OK()",
          "new_api": "ToString",
          "old_text": "Status::OK()",
          "new_text": "ToString(output_level)",
          "old_line_content": "  return Status::OK();",
          "new_line_content": "          ToString(output_level));",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "insert",
          "new_api": "output_level",
          "old_text": "level0_compactions_in_progress_.insert(c)",
          "new_text": "c->output_level()",
          "old_line_content": "    level0_compactions_in_progress_.insert(c);",
          "new_line_content": "         c->output_level() == 0 ||",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "insert",
          "new_api": "start_level",
          "old_text": "compactions_in_progress_.insert(c)",
          "new_text": "c->start_level()",
          "old_line_content": "  compactions_in_progress_.insert(c);",
          "new_line_content": "  if (c->start_level() == 0 ||",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "erase",
          "new_api": "start_level",
          "old_text": "compactions_in_progress_.erase(c)",
          "new_text": "c->start_level()",
          "old_line_content": "  compactions_in_progress_.erase(c);",
          "new_line_content": "  if (c->start_level() == 0 ||",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "FilesMarkedForCompaction",
          "new_api": "size",
          "old_text": "vstorage->FilesMarkedForCompaction()",
          "new_text": "vstorage->FilesMarkedForCompaction().size()",
          "old_line_content": "  if (continuation(vstorage->FilesMarkedForCompaction()[random_file_index])) {",
          "new_line_content": "      static_cast<uint64_t>(vstorage->FilesMarkedForCompaction().size())));",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "clear",
          "new_api": "GetRange",
          "old_text": "start_level_inputs->files.clear()",
          "new_text": "GetRange(*start_level_inputs, &smallest, &largest)",
          "old_line_content": "  start_level_inputs->files.clear();",
          "new_line_content": "  GetRange(*start_level_inputs, &smallest, &largest);",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "empty",
          "new_api": "IsRangeInCompaction",
          "old_text": "start_level_inputs->files.empty()",
          "new_text": "IsRangeInCompaction(vstorage, &smallest, &largest, output_level,\n                          parent_index)",
          "old_line_content": "  assert(!start_level_inputs->files.empty());",
          "new_line_content": "  if (IsRangeInCompaction(vstorage, &smallest, &largest, output_level,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1028,
          "old_api": null,
          "new_api": "SanitizeCompactionInputFilesForAllLevels",
          "old_text": null,
          "new_text": "SanitizeCompactionInputFilesForAllLevels(input_files, cf_meta,\n                                                      output_level)",
          "old_line_content": "    return s;",
          "new_line_content": "  Status s = SanitizeCompactionInputFilesForAllLevels(input_files, cf_meta,",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "ok",
          "old_text": null,
          "new_text": "s.ok()",
          "old_line_content": "  // for all input files, check whether the file number matches",
          "new_line_content": "  if (!s.ok()) {",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "TableFileNameToNumber",
          "old_text": null,
          "new_text": "TableFileNameToNumber(file_meta.name)",
          "old_line_content": "                                   \" is already being compacted.\");",
          "new_line_content": "        if (file_num == TableFileNameToNumber(file_meta.name)) {",
          "content_same": false
        },
        {
          "line": 1044,
          "old_api": null,
          "new_api": "Status::Aborted(\"Specified compaction input file \" +\n                                   MakeTableFileName(\"\", file_num) +\n                                   \" is already being compacted.\")",
          "old_text": null,
          "new_text": "Status::Aborted(\"Specified compaction input file \" +\n                                   MakeTableFileName(\"\", file_num) +\n                                   \" is already being compacted.\")",
          "old_line_content": "          found = true;",
          "new_line_content": "            return Status::Aborted(\"Specified compaction input file \" +",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "MakeTableFileName",
          "old_text": null,
          "new_text": "MakeTableFileName(\"\", file_num)",
          "old_line_content": "          input_file_level = level_meta.level;",
          "new_line_content": "                                   MakeTableFileName(\"\", file_num) +",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": null,
          "new_api": "Status::InvalidArgument(\n          \"Specified compaction input file \" + MakeTableFileName(\"\", file_num) +\n          \" does not exist in column family \" + cf_meta.name + \".\")",
          "old_text": null,
          "new_text": "Status::InvalidArgument(\n          \"Specified compaction input file \" + MakeTableFileName(\"\", file_num) +\n          \" does not exist in column family \" + cf_meta.name + \".\")",
          "old_line_content": "    if (input_file_level > output_level) {",
          "new_line_content": "      return Status::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "MakeTableFileName",
          "old_text": null,
          "new_text": "MakeTableFileName(\"\", file_num)",
          "old_line_content": "  }",
          "new_line_content": "          MakeTableFileName(\"\", file_num) + \" level \" +",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": null,
          "new_api": "ToString",
          "old_text": null,
          "new_text": "ToString(input_file_level)",
          "old_line_content": "",
          "new_line_content": "          ToString(input_file_level) + \" > output level \" +",
          "content_same": false
        },
        {
          "line": 1071,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "void CompactionPicker::RegisterCompaction(Compaction* c) {",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 561,
          "old_api": null,
          "new_api": "GetOverlappingInputs",
          "old_text": null,
          "new_text": "vstorage->GetOverlappingInputs(level, &start, &limit, grandparents)",
          "old_line_content": "  }",
          "new_line_content": "    vstorage->GetOverlappingInputs(level, &start, &limit, grandparents);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "grandparents->empty()",
          "old_line_content": "}",
          "new_line_content": "    if (!grandparents->empty()) {",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "output_level",
          "old_text": null,
          "new_text": "assert(ioptions_.compaction_style != kCompactionStyleLevel ||\n         c->output_level() == 0 ||\n         !FilesRangeOverlapWithCompaction(*c->inputs(), c->output_level()))",
          "old_line_content": "      ioptions_.compaction_style == kCompactionStyleUniversal) {",
          "new_line_content": "  assert(ioptions_.compaction_style != kCompactionStyleLevel ||",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": null,
          "new_api": "output_level",
          "old_text": null,
          "new_text": "c->output_level()",
          "old_line_content": "  }",
          "new_line_content": "         !FilesRangeOverlapWithCompaction(*c->inputs(), c->output_level()));",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "level0_compactions_in_progress_.insert(c)",
          "old_line_content": "                           c);",
          "new_line_content": "    level0_compactions_in_progress_.insert(c);",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "insert",
          "old_text": null,
          "new_text": "compactions_in_progress_.insert(c)",
          "old_line_content": "",
          "new_line_content": "  compactions_in_progress_.insert(c);",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "TEST_SYNC_POINT_CALLBACK",
          "old_text": null,
          "new_text": "TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::RegisterCompaction:Registered\",\n                           c)",
          "old_line_content": "void CompactionPicker::UnregisterCompaction(Compaction* c) {",
          "new_line_content": "  TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::RegisterCompaction:Registered\",",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ioptions_.compaction_style != kCompactionStyleFIFO)",
          "old_line_content": "",
          "new_line_content": "  assert(ioptions_.compaction_style != kCompactionStyleFIFO);",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": null,
          "new_api": "num_levels",
          "old_text": null,
          "new_text": "vstorage->num_levels()",
          "old_line_content": "    } else {",
          "new_line_content": "    assert(vstorage->num_levels() > 1);",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "level0_compactions_in_progress_.erase(c)",
          "old_line_content": "",
          "new_line_content": "    level0_compactions_in_progress_.erase(c);",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "num_levels",
          "old_text": null,
          "new_text": "vstorage->num_levels()",
          "old_line_content": "    // DBImpl::RunManualCompaction will make full range for universal compaction",
          "new_line_content": "      assert(output_level == vstorage->num_levels() - 2);",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "erase",
          "old_text": null,
          "new_text": "compactions_in_progress_.erase(c)",
          "old_line_content": "    const std::string& cf_name, VersionStorageInfo* vstorage, int* start_level,",
          "new_line_content": "  compactions_in_progress_.erase(c);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(begin == nullptr)",
          "old_line_content": "    int start_level = 0;",
          "new_line_content": "    assert(begin == nullptr);",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "vstorage->FilesMarkedForCompaction().empty()",
          "old_line_content": "  auto continuation = [&, cf_name](std::pair<int, FileMetaData*> level_file) {",
          "new_line_content": "  if (vstorage->FilesMarkedForCompaction().empty()) {",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "NumLevelFiles",
          "old_text": null,
          "new_text": "vstorage->NumLevelFiles(start_level)",
          "old_line_content": "      return nullptr;",
          "new_line_content": "           vstorage->NumLevelFiles(start_level) == 0;",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!level_file.second->being_compacted)",
          "old_line_content": "",
          "new_line_content": "    assert(!level_file.second->being_compacted);",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "level0_compactions_in_progress_.empty()",
          "old_line_content": "    }",
          "new_line_content": "    if ((start_level == 0) && (!level0_compactions_in_progress_.empty())) {",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": null,
          "new_api": "base_level",
          "old_text": null,
          "new_text": "vstorage->base_level()",
          "old_line_content": "    }",
          "new_line_content": "        (*start_level == 0) ? vstorage->base_level() : *start_level + 1;",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "level0_compactions_in_progress()->empty()",
          "old_line_content": "    start_level_inputs->files = {level_file.second};",
          "new_line_content": "    if (*start_level == 0 && !level0_compactions_in_progress()->empty()) {",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "num_levels",
          "old_text": null,
          "new_text": "vstorage->num_levels()",
          "old_line_content": "      auto& files = inputs[level - start_level].files;",
          "new_line_content": "    std::vector<CompactionInputFiles> inputs(vstorage->num_levels() -",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": null,
          "new_api": "ExpandInputsToCleanCut",
          "old_text": null,
          "new_text": "ExpandInputsToCleanCut(cf_name, vstorage, start_level_inputs)",
          "old_line_content": "  Random64 rnd(/* seed */ reinterpret_cast<uint64_t>(vstorage));",
          "new_line_content": "    return ExpandInputsToCleanCut(cf_name, vstorage, start_level_inputs);",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": null,
          "new_api": "LevelFiles",
          "old_text": null,
          "new_text": "vstorage->LevelFiles(level)",
          "old_line_content": "        *manual_conflict = true;",
          "new_line_content": "      for (FileMetaData* f : vstorage->LevelFiles(level)) {",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "files.push_back(f)",
          "old_line_content": "        return nullptr;",
          "new_line_content": "        files.push_back(f);",
          "content_same": false
        },
        {
          "line": 1129,
          "old_api": null,
          "new_api": "Uniform",
          "old_text": null,
          "new_text": "rnd.Uniform(\n      static_cast<uint64_t>(vstorage->FilesMarkedForCompaction().size()))",
          "old_line_content": "",
          "new_line_content": "  size_t random_file_index = static_cast<size_t>(rnd.Uniform(",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": null,
          "new_api": "AreFilesInCompaction",
          "old_text": null,
          "new_text": "AreFilesInCompaction(files)",
          "old_line_content": "    }",
          "new_line_content": "      if (AreFilesInCompaction(files)) {",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "TEST_SYNC_POINT_CALLBACK",
          "old_text": null,
          "new_text": "TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::PickFilesMarkedForCompaction\",\n                           &random_file_index)",
          "old_line_content": "    // found the compaction!",
          "new_line_content": "  TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::PickFilesMarkedForCompaction\",",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "FilesMarkedForCompaction",
          "old_text": null,
          "new_text": "vstorage->FilesMarkedForCompaction()",
          "old_line_content": "",
          "new_line_content": "  if (continuation(vstorage->FilesMarkedForCompaction()[random_file_index])) {",
          "content_same": false
        },
        {
          "line": 626,
          "old_api": null,
          "new_api": "FilesRangeOverlapWithCompaction",
          "old_text": null,
          "new_text": "FilesRangeOverlapWithCompaction(inputs, output_level)",
          "old_line_content": "      return nullptr;",
          "new_line_content": "    if (FilesRangeOverlapWithCompaction(inputs, output_level)) {",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "FilesMarkedForCompaction",
          "old_text": null,
          "new_text": "vstorage->FilesMarkedForCompaction()",
          "old_line_content": "    }",
          "new_line_content": "  for (auto& level_file : vstorage->FilesMarkedForCompaction()) {",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": null,
          "new_api": "continuation",
          "old_text": null,
          "new_text": "continuation(level_file)",
          "old_line_content": "  }",
          "new_line_content": "    if (continuation(level_file)) {",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "start_level_inputs->files.clear()",
          "old_line_content": "    VersionStorageInfo* vstorage, CompactionInputFiles* start_level_inputs,",
          "new_line_content": "  start_level_inputs->files.clear();",
          "content_same": false
        },
        {
          "line": 635,
          "old_api": null,
          "new_api": "std::move(inputs)",
          "old_text": null,
          "new_text": "std::move(inputs)",
          "old_line_content": "        compact_range_options.target_path_id,",
          "new_line_content": "        std::move(inputs), output_level,",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": null,
          "new_api": "GetCompressionType",
          "old_text": null,
          "new_text": "GetCompressionType(ioptions_, vstorage, mutable_cf_options,\n                           output_level, 1)",
          "old_line_content": "        /* grandparents */ {},",
          "new_line_content": "        GetCompressionType(ioptions_, vstorage, mutable_cf_options,",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "level0_compactions_in_progress()->empty()",
          "old_line_content": "  // c->inputs_[0] earlier and replace it with an overlapping set",
          "new_line_content": "  assert(level0_compactions_in_progress()->empty());",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": null,
          "new_api": "RegisterCompaction",
          "old_text": null,
          "new_text": "RegisterCompaction(c)",
          "old_line_content": "",
          "new_line_content": "    RegisterCompaction(c);",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": null,
          "new_api": "ComputeCompactionScore",
          "old_text": null,
          "new_text": "vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options)",
          "old_line_content": "  CompactionInputFiles inputs;",
          "new_line_content": "    vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options);",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "start_level_inputs->files.clear()",
          "old_line_content": "  // If we include more L0 files in the same compaction run it can",
          "new_line_content": "  start_level_inputs->files.clear();",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "GetOverlappingInputs",
          "old_text": null,
          "new_text": "vstorage->GetOverlappingInputs(0, &smallest, &largest,\n                                 &(start_level_inputs->files))",
          "old_line_content": "  // cause the 'smallest' and 'largest' key to get extended to a",
          "new_line_content": "  vstorage->GetOverlappingInputs(0, &smallest, &largest,",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": null,
          "new_api": "GetRange",
          "old_text": null,
          "new_text": "GetRange(*start_level_inputs, &smallest, &largest)",
          "old_line_content": "  }",
          "new_line_content": "  GetRange(*start_level_inputs, &smallest, &largest);",
          "content_same": false
        },
        {
          "line": 1171,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "start_level_inputs->files.empty()",
          "old_line_content": "",
          "new_line_content": "  assert(!start_level_inputs->files.empty());",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": null,
          "new_api": "GetOverlappingInputs",
          "old_text": null,
          "new_text": "vstorage->GetOverlappingInputs(input_level, begin, end, &inputs.files)",
          "old_line_content": "",
          "new_line_content": "  vstorage->GetOverlappingInputs(input_level, begin, end, &inputs.files);",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "level0_compactions_in_progress_.empty()",
          "old_line_content": "    return nullptr;",
          "new_line_content": "  if ((input_level == 0) && (!level0_compactions_in_progress_.empty())) {",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "TEST_SYNC_POINT",
          "old_text": null,
          "new_text": "TEST_SYNC_POINT(\"CompactionPicker::CompactRange:Conflict\")",
          "old_line_content": "",
          "new_line_content": "    TEST_SYNC_POINT(\"CompactionPicker::CompactRange:Conflict\");",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs.size()",
          "old_line_content": "      largest = &inputs[i]->largest;",
          "new_line_content": "    for (size_t i = 0; i + 1 < inputs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "num_non_empty_levels",
          "old_text": null,
          "new_text": "vstorage->num_non_empty_levels()",
          "old_line_content": "        for (const auto& file : files) {",
          "new_line_content": "      if (output_level < vstorage->num_non_empty_levels()) {",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "GetOverlappingInputsRangeBinarySearch",
          "old_text": null,
          "new_text": "vstorage->GetOverlappingInputsRangeBinarySearch(\n            output_level, smallest, largest, &files, hint_index, &hint_index)",
          "old_line_content": "        }",
          "new_line_content": "        vstorage->GetOverlappingInputsRangeBinarySearch(",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": null,
          "new_api": "resize",
          "old_text": null,
          "new_text": "inputs.files.resize(i + 1)",
          "old_line_content": "  }",
          "new_line_content": "        inputs.files.resize(i + 1);",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "assert(compact_range_options.target_path_id <\n         static_cast<uint32_t>(ioptions_.cf_paths.size()))",
          "old_line_content": "  // files that are created during the current compaction.",
          "new_line_content": "  assert(compact_range_options.target_path_id <",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "ioptions_.cf_paths.size()",
          "old_line_content": "  if (compact_range_options.bottommost_level_compaction ==",
          "new_line_content": "         static_cast<uint32_t>(ioptions_.cf_paths.size()));",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs.size()",
          "old_line_content": "        // inputs[i] was created during the current manual compaction and",
          "new_line_content": "    for (size_t i = 0; i < inputs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "GetNumber",
          "old_text": null,
          "new_text": "inputs[i]->fd.GetNumber()",
          "old_line_content": "        // need to be skipped",
          "new_line_content": "      if (inputs[i]->fd.GetNumber() < max_file_num_to_ignore) {",
          "content_same": false
        },
        {
          "line": 730,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "inputs_shrunk.push_back(inputs[i])",
          "old_line_content": "        skip_input_index = i;",
          "new_line_content": "        inputs_shrunk.push_back(inputs[i]);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "empty",
          "old_text": null,
          "new_text": "inputs_shrunk.empty()",
          "old_line_content": "        break;",
          "new_line_content": "      } else if (!inputs_shrunk.empty()) {",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs_shrunk.size()",
          "old_line_content": "    // be compacted in the range of inputs[skip_input_index+1, inputs.size())",
          "new_line_content": "    if (inputs.size() != inputs_shrunk.size()) {",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "inputs.size()",
          "old_line_content": "    }",
          "new_line_content": "    for (size_t i = skip_input_index + 1; i < inputs.size(); ++i) {",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": null,
          "new_api": "GetNumber",
          "old_text": null,
          "new_text": "inputs[i]->fd.GetNumber()",
          "old_line_content": "  }",
          "new_line_content": "      if (inputs[i]->fd.GetNumber() < max_file_num_to_ignore) {",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "ExpandInputsToCleanCut",
          "old_text": null,
          "new_text": "ExpandInputsToCleanCut(cf_name, vstorage, &inputs, &next_smallest)",
          "old_line_content": "    // we handle it higher in RunManualCompaction",
          "new_line_content": "  if (ExpandInputsToCleanCut(cf_name, vstorage, &inputs, &next_smallest) ==",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(input_level == 0)",
          "old_line_content": "  output_level_inputs.level = output_level;",
          "new_line_content": "    assert(input_level == 0);",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": null,
          "new_api": "base_level",
          "old_text": null,
          "new_text": "vstorage->base_level()",
          "old_line_content": "  if (input_level != output_level) {",
          "new_line_content": "    output_level = vstorage->base_level();",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(output_level > 0)",
          "old_line_content": "    int parent_index = -1;",
          "new_line_content": "    assert(output_level > 0);",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "SetupOtherInputs",
          "old_text": null,
          "new_text": "SetupOtherInputs(cf_name, mutable_cf_options, vstorage, &inputs,\n                          &output_level_inputs, &parent_index, -1)",
          "old_line_content": "      // we handle it higher in RunManualCompaction",
          "new_line_content": "    if (!SetupOtherInputs(cf_name, mutable_cf_options, vstorage, &inputs,",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "push_back",
          "old_text": null,
          "new_text": "compaction_inputs.push_back(output_level_inputs)",
          "old_line_content": "      *manual_conflict = true;",
          "new_line_content": "    compaction_inputs.push_back(output_level_inputs);",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "compaction_inputs.size()",
          "old_line_content": "    }",
          "new_line_content": "  for (size_t i = 0; i < compaction_inputs.size(); i++) {",
          "content_same": false
        },
        {
          "line": 794,
          "old_api": null,
          "new_api": "AreFilesInCompaction",
          "old_text": null,
          "new_text": "AreFilesInCompaction(compaction_inputs[i].files)",
          "old_line_content": "  }",
          "new_line_content": "    if (AreFilesInCompaction(compaction_inputs[i].files)) {",
          "content_same": false
        },
        {
          "line": 802,
          "old_api": null,
          "new_api": "FilesRangeOverlapWithCompaction",
          "old_text": null,
          "new_text": "FilesRangeOverlapWithCompaction(compaction_inputs, output_level)",
          "old_line_content": "    return nullptr;",
          "new_line_content": "  if (FilesRangeOverlapWithCompaction(compaction_inputs, output_level)) {",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": null,
          "new_api": "std::move(compaction_inputs)",
          "old_text": null,
          "new_text": "std::move(compaction_inputs)",
          "old_line_content": "      mutable_cf_options.max_compaction_bytes,",
          "new_line_content": "      std::move(compaction_inputs), output_level,",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": null,
          "new_api": "base_level",
          "old_text": null,
          "new_text": "MaxFileSizeForLevel(mutable_cf_options, output_level,\n                          ioptions_.compaction_style, vstorage->base_level(),\n                          ioptions_.level_compaction_dynamic_level_bytes)",
          "old_line_content": "      compact_range_options.target_path_id,",
          "new_line_content": "      MaxFileSizeForLevel(mutable_cf_options, output_level,",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": null,
          "new_api": "base_level",
          "old_text": null,
          "new_text": "vstorage->base_level()",
          "old_line_content": "      /* is manual compaction */ true);",
          "new_line_content": "                         vstorage->base_level()),",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "GetCompressionOptions",
          "old_text": null,
          "new_text": "GetCompressionOptions(mutable_cf_options, vstorage, output_level)",
          "old_line_content": "",
          "new_line_content": "      GetCompressionOptions(mutable_cf_options, vstorage, output_level),",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "TEST_SYNC_POINT_CALLBACK",
          "old_text": null,
          "new_text": "TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::CompactRange:Return\", compaction)",
          "old_line_content": "  // takes running compactions into account (by skipping files that are already",
          "new_line_content": "  TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::CompactRange:Return\", compaction);",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "RegisterCompaction",
          "old_text": null,
          "new_text": "RegisterCompaction(compaction)",
          "old_line_content": "  // being compacted). Since we just changed compaction score, we recalculate it",
          "new_line_content": "  RegisterCompaction(compaction);",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": null,
          "new_api": "ComputeCompactionScore",
          "old_text": null,
          "new_text": "vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options)",
          "old_line_content": "",
          "new_line_content": "  vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "c->Compare(a.smallestkey, b.smallestkey)",
          "old_line_content": "    }",
          "new_line_content": "  if (c->Compare(a.smallestkey, b.smallestkey) >= 0) {",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "c->Compare(a.largestkey, b.largestkey)",
          "old_line_content": "    }",
          "new_line_content": "  if (c->Compare(a.largestkey, b.largestkey) <= 0) {",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "c->Compare(a.smallestkey, b.largestkey)",
          "old_line_content": "  return false;",
          "new_line_content": "  } else if (c->Compare(a.smallestkey, b.largestkey) <= 0) {",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": null,
          "new_api": "user_comparator",
          "old_text": null,
          "new_text": "icmp_->user_comparator()",
          "old_line_content": "  // the smallest and largest key of the current compaction input",
          "new_line_content": "  auto comparator = icmp_->user_comparator();",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "current_files.size()",
          "old_line_content": "    // in the current level.",
          "new_line_content": "    int first_included = static_cast<int>(current_files.size());",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "TableFileNameToNumber",
          "old_text": null,
          "new_text": "TableFileNameToNumber(current_files[f].name)",
          "old_line_content": "        if (is_first == false) {",
          "new_line_content": "      if (input_files->find(TableFileNameToNumber(current_files[f].name)) !=",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "input_files->end()",
          "old_line_content": "          smallestkey = current_files[f].smallestkey;",
          "new_line_content": "          input_files->end()) {",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "static_cast<int>(f)",
          "old_text": null,
          "new_text": "static_cast<int>(f)",
          "old_line_content": "          largestkey = current_files[f].largestkey;",
          "new_line_content": "        first_included = std::min(first_included, static_cast<int>(f));",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": null,
          "new_api": "static_cast<int>(f)",
          "old_text": null,
          "new_text": "static_cast<int>(f)",
          "old_line_content": "          is_first = true;",
          "new_line_content": "        last_included = std::max(last_included, static_cast<int>(f));",
          "content_same": false
        },
        {
          "line": 916,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "comparator->Compare(current_files[first_included - 1].largestkey,\n                                current_files[first_included].smallestkey)",
          "old_line_content": "        }",
          "new_line_content": "        if (comparator->Compare(current_files[first_included - 1].largestkey,",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "current_files.size()",
          "old_line_content": "        }",
          "new_line_content": "      while (last_included < static_cast<int>(current_files.size()) - 1) {",
          "content_same": false
        },
        {
          "line": 925,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "comparator->Compare(current_files[last_included + 1].smallestkey,\n                                current_files[last_included].largestkey)",
          "old_line_content": "        last_included++;",
          "new_line_content": "        if (comparator->Compare(current_files[last_included + 1].smallestkey,",
          "content_same": false
        },
        {
          "line": 932,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "current_files.size()",
          "old_line_content": "    for (int f = first_included; f <= last_included; ++f) {",
          "new_line_content": "      last_included = static_cast<int>(current_files.size() - 1);",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": null,
          "new_api": "TableFileNameToNumber",
          "old_text": null,
          "new_text": "TableFileNameToNumber(current_files[f].name)",
          "old_line_content": "    if (l == 0) {",
          "new_line_content": "      input_files->insert(TableFileNameToNumber(current_files[f].name));",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "comparator->Compare(largestkey, current_files[f].largestkey)",
          "old_line_content": "    } else {",
          "new_line_content": "        if (comparator->Compare(largestkey, current_files[f].largestkey) < 0) {",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "Compare",
          "old_text": null,
          "new_text": "comparator->Compare(largestkey,\n                              current_files[last_included].largestkey)",
          "old_line_content": "    }",
          "new_line_content": "      if (comparator->Compare(largestkey,",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "std::max(l, 1)",
          "old_text": null,
          "new_text": "std::max(l, 1)",
          "old_line_content": "          if (next_lv_file.being_compacted) {",
          "new_line_content": "    for (int m = std::max(l, 1); m <= output_level; ++m) {",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": null,
          "new_api": "HaveOverlappingKeyRanges",
          "old_text": null,
          "new_text": "HaveOverlappingKeyRanges(comparator, aggregated_file_meta,\n                                     next_lv_file)",
          "old_line_content": "                \"File \" + next_lv_file.name +",
          "new_line_content": "        if (HaveOverlappingKeyRanges(comparator, aggregated_file_meta,",
          "content_same": false
        },
        {
          "line": 982,
          "old_api": null,
          "new_api": "Status::Aborted(\n                \"File \" + next_lv_file.name +\n                \" that has overlapping key range with one of the compaction \"\n                \" input file is currently being compacted.\")",
          "old_text": null,
          "new_text": "Status::Aborted(\n                \"File \" + next_lv_file.name +\n                \" that has overlapping key range with one of the compaction \"\n                \" input file is currently being compacted.\")",
          "old_line_content": "          }",
          "new_line_content": "            return Status::Aborted(",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": null,
          "new_api": "TableFileNameToNumber",
          "old_text": null,
          "new_text": "TableFileNameToNumber(next_lv_file.name)",
          "old_line_content": "  }",
          "new_line_content": "          input_files->insert(TableFileNameToNumber(next_lv_file.name));",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "RangeOverlapWithCompaction",
          "old_text": null,
          "new_text": "RangeOverlapWithCompaction(smallestkey, largestkey, output_level)",
          "old_line_content": "  }",
          "new_line_content": "  if (RangeOverlapWithCompaction(smallestkey, largestkey, output_level)) {",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "Status::OK()",
          "old_text": null,
          "new_text": "Status::OK()",
          "old_line_content": "    std::unordered_set<uint64_t>* input_files,",
          "new_line_content": "  return Status::OK();",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "cf_meta.levels.size()",
          "old_line_content": "        \"Output level for column family \" + cf_meta.name +",
          "new_line_content": "  assert(static_cast<int>(cf_meta.levels.size()) - 1 ==",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "cf_meta.levels.size()",
          "old_line_content": "        \" must between [0, \" +",
          "new_line_content": "         cf_meta.levels[cf_meta.levels.size() - 1].level);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "Status::InvalidArgument(\n        \"Output level for column family \" + cf_meta.name +\n        \" must between [0, \" +\n        ToString(cf_meta.levels[cf_meta.levels.size() - 1].level) + \"].\")",
          "old_line_content": "  }",
          "new_line_content": "    return Status::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "Status::InvalidArgument(\n        \"Exceed the maximum output level defined by \"\n        \"the current compaction algorithm --- \" +\n        ToString(MaxOutputLevel()))",
          "old_text": null,
          "new_text": "Status::InvalidArgument(\n        \"Exceed the maximum output level defined by \"\n        \"the current compaction algorithm --- \" +\n        ToString(MaxOutputLevel()))",
          "old_line_content": "  }",
          "new_line_content": "    return Status::InvalidArgument(",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": null,
          "new_api": "size",
          "old_text": null,
          "new_text": "input_files->size()",
          "old_line_content": "",
          "new_line_content": "  if (input_files->size() == 0) {",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1027,
          "old_api": "ok",
          "new_api": null,
          "old_text": "s.ok()",
          "new_text": null,
          "old_line_content": "  if (!s.ok()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "TableFileNameToNumber",
          "new_api": null,
          "old_text": "TableFileNameToNumber(file_meta.name)",
          "new_text": null,
          "old_line_content": "        if (file_num == TableFileNameToNumber(file_meta.name)) {",
          "new_line_content": "    bool found = false;",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "Status::Aborted(\"Specified compaction input file \" +\n                                   MakeTableFileName(\"\", file_num) +\n                                   \" is already being compacted.\")",
          "new_api": null,
          "old_text": "Status::Aborted(\"Specified compaction input file \" +\n                                   MakeTableFileName(\"\", file_num) +\n                                   \" is already being compacted.\")",
          "new_text": null,
          "old_line_content": "            return Status::Aborted(\"Specified compaction input file \" +",
          "new_line_content": "    for (const auto& level_meta : cf_meta.levels) {",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "MakeTableFileName",
          "new_api": null,
          "old_text": "MakeTableFileName(\"\", file_num)",
          "new_text": null,
          "old_line_content": "                                   MakeTableFileName(\"\", file_num) +",
          "new_line_content": "      for (const auto& file_meta : level_meta.files) {",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "Status::InvalidArgument(\n          \"Specified compaction input file \" + MakeTableFileName(\"\", file_num) +\n          \" does not exist in column family \" + cf_meta.name + \".\")",
          "new_api": null,
          "old_text": "Status::InvalidArgument(\n          \"Specified compaction input file \" + MakeTableFileName(\"\", file_num) +\n          \" does not exist in column family \" + cf_meta.name + \".\")",
          "new_text": null,
          "old_line_content": "      return Status::InvalidArgument(",
          "new_line_content": "        break;",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "MakeTableFileName",
          "new_api": null,
          "old_text": "MakeTableFileName(\"\", file_num)",
          "new_text": null,
          "old_line_content": "          \"Specified compaction input file \" + MakeTableFileName(\"\", file_num) +",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "MakeTableFileName",
          "new_api": null,
          "old_text": "MakeTableFileName(\"\", file_num)",
          "new_text": null,
          "old_line_content": "          MakeTableFileName(\"\", file_num) + \" level \" +",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "ToString",
          "new_api": null,
          "old_text": "ToString(input_file_level)",
          "new_text": null,
          "old_line_content": "          ToString(input_file_level) + \" > output level \" +",
          "new_line_content": "    if (input_file_level > output_level) {",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": "NumberLevels",
          "new_api": null,
          "old_text": "NumberLevels()",
          "new_text": null,
          "old_line_content": "  if (output_level_inputs.level + 1 < NumberLevels()) {",
          "new_line_content": "  // level after that has overlapping files)",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": "output_level",
          "new_api": null,
          "old_text": "assert(ioptions_.compaction_style != kCompactionStyleLevel ||\n         c->output_level() == 0 ||\n         !FilesRangeOverlapWithCompaction(*c->inputs(), c->output_level()))",
          "new_text": null,
          "old_line_content": "  assert(ioptions_.compaction_style != kCompactionStyleLevel ||",
          "new_line_content": "void CompactionPicker::RegisterCompaction(Compaction* c) {",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "output_level",
          "new_api": null,
          "old_text": "c->output_level()",
          "new_text": null,
          "old_line_content": "         c->output_level() == 0 ||",
          "new_line_content": "  if (c == nullptr) {",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "output_level",
          "new_api": null,
          "old_text": "c->output_level()",
          "new_text": null,
          "old_line_content": "         !FilesRangeOverlapWithCompaction(*c->inputs(), c->output_level()));",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "start_level",
          "new_api": null,
          "old_text": "c->start_level()",
          "new_text": null,
          "old_line_content": "  if (c->start_level() == 0 ||",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 1083,
          "old_api": "TEST_SYNC_POINT_CALLBACK",
          "new_api": null,
          "old_text": "TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::RegisterCompaction:Registered\",\n                           c)",
          "new_text": null,
          "old_line_content": "  TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::RegisterCompaction:Registered\",",
          "new_line_content": "      ioptions_.compaction_style == kCompactionStyleUniversal) {",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(ioptions_.compaction_style != kCompactionStyleFIFO)",
          "new_text": null,
          "old_line_content": "  assert(ioptions_.compaction_style != kCompactionStyleFIFO);",
          "new_line_content": "    const CompactRangeOptions& compact_range_options, const InternalKey* begin,",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(ioptions_.compaction_style == kCompactionStyleUniversal)",
          "new_text": null,
          "old_line_content": "    assert(ioptions_.compaction_style == kCompactionStyleUniversal);",
          "new_line_content": "  // CompactionPickerFIFO has its own implementation of compact range",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "start_level",
          "new_api": null,
          "old_text": "c->start_level()",
          "new_text": null,
          "old_line_content": "  if (c->start_level() == 0 ||",
          "new_line_content": "void CompactionPicker::UnregisterCompaction(Compaction* c) {",
          "content_same": false
        },
        {
          "line": 1093,
          "old_api": "erase",
          "new_api": null,
          "old_text": "level0_compactions_in_progress_.erase(c)",
          "new_text": null,
          "old_line_content": "    level0_compactions_in_progress_.erase(c);",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "num_levels",
          "new_api": null,
          "old_text": "vstorage->num_levels()",
          "new_text": null,
          "old_line_content": "      assert(output_level == vstorage->num_levels() - 2);",
          "new_line_content": "    // files together to the last level.",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "num_levels",
          "new_api": null,
          "old_text": "vstorage->num_levels()",
          "new_text": null,
          "old_line_content": "      assert(output_level == vstorage->num_levels() - 1);",
          "new_line_content": "    // DBImpl::CompactRange() set output level to be the last level",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(begin == nullptr)",
          "new_text": null,
          "old_line_content": "    assert(begin == nullptr);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "empty",
          "new_api": null,
          "old_text": "vstorage->FilesMarkedForCompaction().empty()",
          "new_text": null,
          "old_line_content": "  if (vstorage->FilesMarkedForCompaction().empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": "NumLevelFiles",
          "new_api": null,
          "old_text": "vstorage->NumLevelFiles(start_level)",
          "new_text": null,
          "old_line_content": "           vstorage->NumLevelFiles(start_level) == 0;",
          "new_line_content": "    *compaction_end = nullptr;",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!level_file.second->being_compacted)",
          "new_text": null,
          "old_line_content": "    assert(!level_file.second->being_compacted);",
          "new_line_content": "  auto continuation = [&, cf_name](std::pair<int, FileMetaData*> level_file) {",
          "content_same": false
        },
        {
          "line": 1112,
          "old_api": "base_level",
          "new_api": null,
          "old_text": "vstorage->base_level()",
          "new_text": null,
          "old_line_content": "        (*start_level == 0) ? vstorage->base_level() : *start_level + 1;",
          "new_line_content": "    // files as being_compacted, but didn't call ComputeCompactionScore()",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "empty",
          "new_api": null,
          "old_text": "level0_compactions_in_progress()->empty()",
          "new_text": null,
          "old_line_content": "    if (*start_level == 0 && !level0_compactions_in_progress()->empty()) {",
          "new_line_content": "    *start_level = level_file.first;",
          "content_same": false
        },
        {
          "line": 606,
          "old_api": "num_levels",
          "new_api": null,
          "old_text": "vstorage->num_levels()",
          "new_text": null,
          "old_line_content": "    std::vector<CompactionInputFiles> inputs(vstorage->num_levels() -",
          "new_line_content": "      // Only one level 0 compaction allowed",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": "num_levels",
          "new_api": null,
          "old_text": "vstorage->num_levels()",
          "new_text": null,
          "old_line_content": "    for (int level = start_level; level < vstorage->num_levels(); level++) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "ExpandInputsToCleanCut",
          "new_api": null,
          "old_text": "ExpandInputsToCleanCut(cf_name, vstorage, start_level_inputs)",
          "new_text": null,
          "old_line_content": "    return ExpandInputsToCleanCut(cf_name, vstorage, start_level_inputs);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 611,
          "old_api": "LevelFiles",
          "new_api": null,
          "old_text": "vstorage->LevelFiles(level)",
          "new_text": null,
          "old_line_content": "      for (FileMetaData* f : vstorage->LevelFiles(level)) {",
          "new_line_content": "                                             start_level);",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "Uniform",
          "new_api": null,
          "old_text": "rnd.Uniform(\n      static_cast<uint64_t>(vstorage->FilesMarkedForCompaction().size()))",
          "new_text": null,
          "old_line_content": "  size_t random_file_index = static_cast<size_t>(rnd.Uniform(",
          "new_line_content": "  };",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": "AreFilesInCompaction",
          "new_api": null,
          "old_text": "AreFilesInCompaction(files)",
          "new_text": null,
          "old_line_content": "      if (AreFilesInCompaction(files)) {",
          "new_line_content": "      auto& files = inputs[level - start_level].files;",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": "size",
          "new_api": null,
          "old_text": "vstorage->FilesMarkedForCompaction().size()",
          "new_text": null,
          "old_line_content": "      static_cast<uint64_t>(vstorage->FilesMarkedForCompaction().size())));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": "TEST_SYNC_POINT_CALLBACK",
          "new_api": null,
          "old_text": "TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::PickFilesMarkedForCompaction\",\n                           &random_file_index)",
          "new_text": null,
          "old_line_content": "  TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::PickFilesMarkedForCompaction\",",
          "new_line_content": "  // take a chance on a random file first",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "FilesRangeOverlapWithCompaction",
          "new_api": null,
          "old_text": "FilesRangeOverlapWithCompaction(inputs, output_level)",
          "new_text": null,
          "old_line_content": "    if (FilesRangeOverlapWithCompaction(inputs, output_level)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1135,
          "old_api": "FilesMarkedForCompaction",
          "new_api": null,
          "old_text": "vstorage->FilesMarkedForCompaction()",
          "new_text": null,
          "old_line_content": "  for (auto& level_file : vstorage->FilesMarkedForCompaction()) {",
          "new_line_content": "    // found the compaction!",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": "continuation",
          "new_api": null,
          "old_text": "continuation(level_file)",
          "new_text": null,
          "old_line_content": "    if (continuation(level_file)) {",
          "new_line_content": "    return;",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "clear",
          "new_api": null,
          "old_text": "start_level_inputs->files.clear()",
          "new_text": null,
          "old_line_content": "  start_level_inputs->files.clear();",
          "new_line_content": "      // found the compaction!",
          "content_same": false
        },
        {
          "line": 631,
          "old_api": "std::move(inputs)",
          "new_api": null,
          "old_text": "std::move(inputs)",
          "new_text": null,
          "old_line_content": "        std::move(inputs), output_level,",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": "MaxFileSizeForLevel",
          "new_api": null,
          "old_text": "MaxFileSizeForLevel(mutable_cf_options, output_level,\n                            ioptions_.compaction_style)",
          "new_text": null,
          "old_line_content": "        MaxFileSizeForLevel(mutable_cf_options, output_level,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1149,
          "old_api": "empty",
          "new_api": null,
          "old_text": "level0_compactions_in_progress()->empty()",
          "new_text": null,
          "old_line_content": "  assert(level0_compactions_in_progress()->empty());",
          "new_line_content": "    VersionStorageInfo* vstorage, CompactionInputFiles* start_level_inputs,",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": "GetCompressionOptions",
          "new_api": null,
          "old_text": "GetCompressionOptions(mutable_cf_options, vstorage, output_level)",
          "new_text": null,
          "old_line_content": "        GetCompressionOptions(mutable_cf_options, vstorage, output_level),",
          "new_line_content": "        /* max_compaction_bytes */ LLONG_MAX,",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": "GetRange",
          "new_api": null,
          "old_text": "GetRange(*start_level_inputs, &smallest, &largest)",
          "new_text": null,
          "old_line_content": "  GetRange(*start_level_inputs, &smallest, &largest);",
          "new_line_content": "  // Two level 0 compaction won't run at the same time, so don't need to worry",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": "ComputeCompactionScore",
          "new_api": null,
          "old_text": "vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options)",
          "new_text": null,
          "old_line_content": "    vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options);",
          "new_line_content": "        Temperature::kUnknown, compact_range_options.max_subcompactions,",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "GetOverlappingInputs",
          "new_api": null,
          "old_text": "vstorage->GetOverlappingInputs(0, &smallest, &largest,\n                                 &(start_level_inputs->files))",
          "new_text": null,
          "old_line_content": "  vstorage->GetOverlappingInputs(0, &smallest, &largest,",
          "new_line_content": "  // Note that the next call will discard the file we placed in",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": "GetRange",
          "new_api": null,
          "old_text": "GetRange(*start_level_inputs, &smallest, &largest)",
          "new_text": null,
          "old_line_content": "  GetRange(*start_level_inputs, &smallest, &largest);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": "IsRangeInCompaction",
          "new_api": null,
          "old_text": "IsRangeInCompaction(vstorage, &smallest, &largest, output_level,\n                          parent_index)",
          "new_text": null,
          "old_line_content": "  if (IsRangeInCompaction(vstorage, &smallest, &largest, output_level,",
          "new_line_content": "  // If we include more L0 files in the same compaction run it can",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "GetOverlappingInputs",
          "new_api": null,
          "old_text": "vstorage->GetOverlappingInputs(input_level, begin, end, &inputs.files)",
          "new_text": null,
          "old_line_content": "  vstorage->GetOverlappingInputs(input_level, begin, end, &inputs.files);",
          "new_line_content": "    begin = nullptr;",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": "empty",
          "new_api": null,
          "old_text": "inputs.empty()",
          "new_text": null,
          "old_line_content": "  if (inputs.empty()) {",
          "new_line_content": "    end = nullptr;",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "TEST_SYNC_POINT",
          "new_api": null,
          "old_text": "TEST_SYNC_POINT(\"CompactionPicker::CompactRange:Conflict\")",
          "new_text": null,
          "old_line_content": "    TEST_SYNC_POINT(\"CompactionPicker::CompactRange:Conflict\");",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 680,
          "old_api": "size",
          "new_api": null,
          "old_text": "inputs.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i + 1 < inputs.size(); ++i) {",
          "new_line_content": "    uint64_t input_level_total = 0;",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "num_non_empty_levels",
          "new_api": null,
          "old_text": "vstorage->num_non_empty_levels()",
          "new_text": null,
          "old_line_content": "      if (output_level < vstorage->num_non_empty_levels()) {",
          "new_line_content": "      largest = &inputs[i]->largest;",
          "content_same": false
        },
        {
          "line": 690,
          "old_api": "GetOverlappingInputsRangeBinarySearch",
          "new_api": null,
          "old_text": "vstorage->GetOverlappingInputsRangeBinarySearch(\n            output_level, smallest, largest, &files, hint_index, &hint_index)",
          "new_text": null,
          "old_line_content": "        vstorage->GetOverlappingInputsRangeBinarySearch(",
          "new_line_content": "      uint64_t s = inputs[i]->compensated_file_size;",
          "content_same": false
        },
        {
          "line": 705,
          "old_api": "resize",
          "new_api": null,
          "old_text": "inputs.files.resize(i + 1)",
          "new_text": null,
          "old_line_content": "        inputs.files.resize(i + 1);",
          "new_line_content": "        // still include the current file, so the compaction could be larger",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": "size",
          "new_api": null,
          "old_text": "assert(compact_range_options.target_path_id <\n         static_cast<uint32_t>(ioptions_.cf_paths.size()))",
          "new_text": null,
          "old_line_content": "  assert(compact_range_options.target_path_id <",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "size",
          "new_api": null,
          "old_text": "ioptions_.cf_paths.size()",
          "new_text": null,
          "old_line_content": "         static_cast<uint32_t>(ioptions_.cf_paths.size()));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(input_level == output_level)",
          "new_text": null,
          "old_line_content": "    assert(input_level == output_level);",
          "new_line_content": "  // files that are created during the current compaction.",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "size",
          "new_api": null,
          "old_text": "inputs.size()",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < inputs.size(); ++i) {",
          "new_line_content": "    // inputs_shrunk holds a continuous subset of input files which were all",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "GetNumber",
          "new_api": null,
          "old_text": "inputs[i]->fd.GetNumber()",
          "new_text": null,
          "old_line_content": "      if (inputs[i]->fd.GetNumber() < max_file_num_to_ignore) {",
          "new_line_content": "    // created before the current manual compaction",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "inputs_shrunk.push_back(inputs[i])",
          "new_text": null,
          "old_line_content": "        inputs_shrunk.push_back(inputs[i]);",
          "new_line_content": "    std::vector<FileMetaData*> inputs_shrunk;",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": "empty",
          "new_api": null,
          "old_text": "inputs_shrunk.empty()",
          "new_text": null,
          "old_line_content": "    if (inputs_shrunk.empty()) {",
          "new_line_content": "        skip_input_index = i;",
          "content_same": false
        },
        {
          "line": 737,
          "old_api": "size",
          "new_api": null,
          "old_text": "inputs_shrunk.size()",
          "new_text": null,
          "old_line_content": "    if (inputs.size() != inputs_shrunk.size()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "GetNumber",
          "new_api": null,
          "old_text": "inputs[i]->fd.GetNumber()",
          "new_text": null,
          "old_line_content": "      if (inputs[i]->fd.GetNumber() < max_file_num_to_ignore) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": "ExpandInputsToCleanCut",
          "new_api": null,
          "old_text": "ExpandInputsToCleanCut(cf_name, vstorage, &inputs, &next_smallest)",
          "new_text": null,
          "old_line_content": "  if (ExpandInputsToCleanCut(cf_name, vstorage, &inputs, &next_smallest) ==",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(input_level == 0)",
          "new_text": null,
          "old_line_content": "    assert(input_level == 0);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 769,
          "old_api": "base_level",
          "new_api": null,
          "old_text": "vstorage->base_level()",
          "new_text": null,
          "old_line_content": "    output_level = vstorage->base_level();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(output_level > 0)",
          "new_text": null,
          "old_line_content": "    assert(output_level > 0);",
          "new_line_content": "  CompactionInputFiles output_level_inputs;",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "SetupOtherInputs",
          "new_api": null,
          "old_text": "SetupOtherInputs(cf_name, mutable_cf_options, vstorage, &inputs,\n                          &output_level_inputs, &parent_index, -1)",
          "new_text": null,
          "old_line_content": "    if (!SetupOtherInputs(cf_name, mutable_cf_options, vstorage, &inputs,",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 786,
          "old_api": "empty",
          "new_api": null,
          "old_text": "output_level_inputs.empty()",
          "new_text": null,
          "old_line_content": "  if (!output_level_inputs.empty()) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "push_back",
          "new_api": null,
          "old_text": "compaction_inputs.push_back(output_level_inputs)",
          "new_text": null,
          "old_line_content": "    compaction_inputs.push_back(output_level_inputs);",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": "size",
          "new_api": null,
          "old_text": "compaction_inputs.size()",
          "new_text": null,
          "old_line_content": "  for (size_t i = 0; i < compaction_inputs.size(); i++) {",
          "new_line_content": "  std::vector<CompactionInputFiles> compaction_inputs({inputs});",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "FilesRangeOverlapWithCompaction",
          "new_api": null,
          "old_text": "FilesRangeOverlapWithCompaction(compaction_inputs, output_level)",
          "new_text": null,
          "old_line_content": "  if (FilesRangeOverlapWithCompaction(compaction_inputs, output_level)) {",
          "new_line_content": "  }",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": "GetGrandparents",
          "new_api": null,
          "old_text": "GetGrandparents(vstorage, inputs, output_level_inputs, &grandparents)",
          "new_text": null,
          "old_line_content": "  GetGrandparents(vstorage, inputs, output_level_inputs, &grandparents);",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "std::move(compaction_inputs)",
          "new_api": null,
          "old_text": "std::move(compaction_inputs)",
          "new_text": null,
          "old_line_content": "      std::move(compaction_inputs), output_level,",
          "new_line_content": "  std::vector<FileMetaData*> grandparents;",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "base_level",
          "new_api": null,
          "old_text": "vstorage->base_level()",
          "new_text": null,
          "old_line_content": "                          ioptions_.compaction_style, vstorage->base_level(),",
          "new_line_content": "  Compaction* compaction = new Compaction(",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "base_level",
          "new_api": null,
          "old_text": "vstorage->base_level()",
          "new_text": null,
          "old_line_content": "                         vstorage->base_level()),",
          "new_line_content": "                          ioptions_.level_compaction_dynamic_level_bytes),",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "GetCompressionOptions",
          "new_api": null,
          "old_text": "GetCompressionOptions(mutable_cf_options, vstorage, output_level)",
          "new_text": null,
          "old_line_content": "      GetCompressionOptions(mutable_cf_options, vstorage, output_level),",
          "new_line_content": "      mutable_cf_options.max_compaction_bytes,",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": "TEST_SYNC_POINT_CALLBACK",
          "new_api": null,
          "old_text": "TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::CompactRange:Return\", compaction)",
          "new_text": null,
          "old_line_content": "  TEST_SYNC_POINT_CALLBACK(\"CompactionPicker::CompactRange:Return\", compaction);",
          "new_line_content": "      Temperature::kUnknown, compact_range_options.max_subcompactions,",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "ComputeCompactionScore",
          "new_api": null,
          "old_text": "vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options)",
          "new_text": null,
          "old_line_content": "  vstorage->ComputeCompactionScore(ioptions_, mutable_cf_options);",
          "new_line_content": "  // Creating a compaction influences the compaction score because the score",
          "content_same": false
        },
        {
          "line": 839,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "c->Compare(a.smallestkey, b.smallestkey)",
          "new_text": null,
          "old_line_content": "  if (c->Compare(a.smallestkey, b.smallestkey) >= 0) {",
          "new_line_content": "namespace {",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "c->Compare(a.smallestkey, b.largestkey)",
          "new_text": null,
          "old_line_content": "    if (c->Compare(a.smallestkey, b.largestkey) <= 0) {",
          "new_line_content": "// Test whether two files have overlapping key-ranges.",
          "content_same": false
        },
        {
          "line": 849,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "c->Compare(a.largestkey, b.smallestkey)",
          "new_text": null,
          "old_line_content": "    if (c->Compare(a.largestkey, b.smallestkey) >= 0) {",
          "new_line_content": "    // a.smallestkey < b.smallestkey <= a.largestkey",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "user_comparator",
          "new_api": null,
          "old_text": "icmp_->user_comparator()",
          "new_text": null,
          "old_line_content": "  auto comparator = icmp_->user_comparator();",
          "new_line_content": "Status CompactionPicker::SanitizeCompactionInputFilesForAllLevels(",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "size",
          "new_api": null,
          "old_text": "current_files.size()",
          "new_text": null,
          "old_line_content": "    int first_included = static_cast<int>(current_files.size());",
          "new_line_content": "  // 4. For all remaining levels, include files that have",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "size",
          "new_api": null,
          "old_text": "current_files.size()",
          "new_text": null,
          "old_line_content": "    for (size_t f = 0; f < current_files.size(); ++f) {",
          "new_line_content": "    int last_included = kNotFound;",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": "TableFileNameToNumber",
          "new_api": null,
          "old_text": "TableFileNameToNumber(current_files[f].name)",
          "new_text": null,
          "old_line_content": "      if (input_files->find(TableFileNameToNumber(current_files[f].name)) !=",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "end",
          "new_api": null,
          "old_text": "input_files->end()",
          "new_text": null,
          "old_line_content": "          input_files->end()) {",
          "new_line_content": "    // identify the first and the last compaction input files",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "static_cast<int>(f)",
          "new_api": null,
          "old_text": "static_cast<int>(f)",
          "new_text": null,
          "old_line_content": "        first_included = std::min(first_included, static_cast<int>(f));",
          "new_line_content": "    // in the current level.",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "comparator->Compare(current_files[first_included - 1].largestkey,\n                                current_files[first_included].smallestkey)",
          "new_text": null,
          "old_line_content": "        if (comparator->Compare(current_files[first_included - 1].largestkey,",
          "new_line_content": "      // expend the compaction input of the current level if it",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "size",
          "new_api": null,
          "old_text": "current_files.size()",
          "new_text": null,
          "old_line_content": "      while (last_included < static_cast<int>(current_files.size()) - 1) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "comparator->Compare(current_files[last_included + 1].smallestkey,\n                                current_files[last_included].largestkey)",
          "new_text": null,
          "old_line_content": "        if (comparator->Compare(current_files[last_included + 1].smallestkey,",
          "new_line_content": "        first_included--;",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "size",
          "new_api": null,
          "old_text": "current_files.size()",
          "new_text": null,
          "old_line_content": "      last_included = static_cast<int>(current_files.size() - 1);",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "Status::Aborted(\"Necessary compaction input file \" +\n                               current_files[f].name +\n                               \" is currently being compacted.\")",
          "new_api": null,
          "old_text": "Status::Aborted(\"Necessary compaction input file \" +\n                               current_files[f].name +\n                               \" is currently being compacted.\")",
          "new_text": null,
          "old_line_content": "        return Status::Aborted(\"Necessary compaction input file \" +",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "comparator->Compare(smallestkey, current_files[f].smallestkey)",
          "new_text": null,
          "old_line_content": "        if (comparator->Compare(smallestkey, current_files[f].smallestkey) >",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "Compare",
          "new_api": null,
          "old_text": "comparator->Compare(smallestkey,\n                              current_files[first_included].smallestkey)",
          "new_text": null,
          "old_line_content": "      if (comparator->Compare(smallestkey,",
          "new_line_content": "          largestkey = current_files[f].largestkey;",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "std::max(l, 1)",
          "new_api": null,
          "old_text": "std::max(l, 1)",
          "new_text": null,
          "old_line_content": "    for (int m = std::max(l, 1); m <= output_level; ++m) {",
          "new_line_content": "    // if there no input_files in level l, we would still need to add files",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "HaveOverlappingKeyRanges",
          "new_api": null,
          "old_text": "HaveOverlappingKeyRanges(comparator, aggregated_file_meta,\n                                     next_lv_file)",
          "new_text": null,
          "old_line_content": "        if (HaveOverlappingKeyRanges(comparator, aggregated_file_meta,",
          "new_line_content": "    // Level 0 doesn't need to be handled this way because files are sorted by",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "Status::Aborted(\n                \"File \" + next_lv_file.name +\n                \" that has overlapping key range with one of the compaction \"\n                \" input file is currently being compacted.\")",
          "new_api": null,
          "old_text": "Status::Aborted(\n                \"File \" + next_lv_file.name +\n                \" that has overlapping key range with one of the compaction \"\n                \" input file is currently being compacted.\")",
          "new_text": null,
          "old_line_content": "            return Status::Aborted(",
          "new_line_content": "      for (auto& next_lv_file : levels[m].files) {",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "TableFileNameToNumber",
          "new_api": null,
          "old_text": "TableFileNameToNumber(next_lv_file.name)",
          "new_text": null,
          "old_line_content": "          input_files->insert(TableFileNameToNumber(next_lv_file.name));",
          "new_line_content": "                \"File \" + next_lv_file.name +",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "RangeOverlapWithCompaction",
          "new_api": null,
          "old_text": "RangeOverlapWithCompaction(smallestkey, largestkey, output_level)",
          "new_text": null,
          "old_line_content": "  if (RangeOverlapWithCompaction(smallestkey, largestkey, output_level)) {",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "Status::Aborted(\n        \"A running compaction is writing to the same output level in an \"\n        \"overlapping key range\")",
          "new_api": null,
          "old_text": "Status::Aborted(\n        \"A running compaction is writing to the same output level in an \"\n        \"overlapping key range\")",
          "new_text": null,
          "old_line_content": "    return Status::Aborted(",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "size",
          "new_api": null,
          "old_text": "cf_meta.levels.size()",
          "new_text": null,
          "old_line_content": "  assert(static_cast<int>(cf_meta.levels.size()) - 1 ==",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "size",
          "new_api": null,
          "old_text": "cf_meta.levels.size()",
          "new_text": null,
          "old_line_content": "         cf_meta.levels[cf_meta.levels.size() - 1].level);",
          "new_line_content": "Status CompactionPicker::SanitizeCompactionInputFiles(",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "size",
          "new_api": null,
          "old_text": "cf_meta.levels.size()",
          "new_text": null,
          "old_line_content": "  if (output_level >= static_cast<int>(cf_meta.levels.size())) {",
          "new_line_content": "    std::unordered_set<uint64_t>* input_files,",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "size",
          "new_api": null,
          "old_text": "Status::InvalidArgument(\n        \"Output level for column family \" + cf_meta.name +\n        \" must between [0, \" +\n        ToString(cf_meta.levels[cf_meta.levels.size() - 1].level) + \"].\")",
          "new_text": null,
          "old_line_content": "    return Status::InvalidArgument(",
          "new_line_content": "    const ColumnFamilyMetaData& cf_meta, const int output_level) const {",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": "MaxOutputLevel",
          "new_api": null,
          "old_text": "MaxOutputLevel()",
          "new_text": null,
          "old_line_content": "  if (output_level > MaxOutputLevel()) {",
          "new_line_content": "        \" must between [0, \" +",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": "size",
          "new_api": null,
          "old_text": "input_files->size()",
          "new_text": null,
          "old_line_content": "  if (input_files->size() == 0) {",
          "new_line_content": "  if (output_level < 0) {",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 32,
      "total_additions": 108,
      "total_deletions": 107,
      "total_api_changes": 247
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 247,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          560,
          563,
          564,
          557
        ]
      }
    },
    "api_calls_before": 315,
    "api_calls_after": 316,
    "diff_info": {
      "added_lines": 8,
      "removed_lines": 4,
      "total_diff_lines": 24
    }
  }
}