{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/242dfcbafac592a3f097ec2e4e36fe1b739f7f29",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/242dfcbafac592a3f097ec2e4e36fe1b739f7f29/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/242dfcbafac592a3f097ec2e4e36fe1b739f7f29/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/242dfcbafac592a3f097ec2e4e36fe1b739f7f29/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1998,
          "old_api": "LWLockRelease",
          "new_api": "elog",
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": "elog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",\n\t\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "\t\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t\telog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": "elog",
          "new_api": "RelationGetRelationName",
          "old_text": "elog(ERROR, \"out of btvacinfo slots\")",
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\t\telog(ERROR, \"out of btvacinfo slots\");",
          "new_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "build_reloptions",
          "new_api": "offsetof",
          "old_text": "build_reloptions(reloptions, validate,\n\t\t\t\t\t\t\t\t\t  RELOPT_KIND_BTREE,\n\t\t\t\t\t\t\t\t\t  sizeof(BTOptions),\n\t\t\t\t\t\t\t\t\t  tab, lengthof(tab))",
          "new_text": "offsetof(BTOptions, fillfactor)",
          "old_line_content": "\treturn (bytea *) build_reloptions(reloptions, validate,",
          "new_line_content": "\t\t{\"fillfactor\", RELOPT_TYPE_INT, offsetof(BTOptions, fillfactor)},",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": "Min",
          "new_api": "_bt_keep_natts",
          "old_text": "Min(keepnatts, nkeyatts)",
          "new_text": "_bt_keep_natts(rel, lastleft, firstright, itup_key)",
          "old_line_content": "\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts));",
          "new_line_content": "\tkeepnatts = _bt_keep_natts(rel, lastleft, firstright, itup_key);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": "IndexRelationGetNumberOfAttributes",
          "new_api": "BTreeTupleIsPosting",
          "old_text": "IndexRelationGetNumberOfAttributes(rel)",
          "new_text": "BTreeTupleIsPosting(pivot)",
          "old_line_content": "\t\tAssert(IndexRelationGetNumberOfAttributes(rel) == nkeyatts);",
          "new_line_content": "\tif (BTreeTupleIsPosting(pivot))",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": "BTreeTupleSetNAtts",
          "new_api": "pfree",
          "old_text": "BTreeTupleSetNAtts(tidpivot, nkeyatts, true)",
          "new_text": "pfree(pivot)",
          "old_line_content": "\tBTreeTupleSetNAtts(tidpivot, nkeyatts, true);",
          "new_line_content": "\tpfree(pivot);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": "ItemPointerGetOffsetNumber",
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": "ItemPointerGetOffsetNumber(pivotheaptid)",
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)));",
          "new_line_content": "\tItemPointerCopy(BTreeTupleGetHeapTID(firstright), pivotheaptid);",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": "datum_image_eq",
          "new_api": "index_getattr",
          "old_text": "datum_image_eq(datum1, datum2, att->attbyval, att->attlen)",
          "new_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "old_line_content": "\t\t\t!datum_image_eq(datum1, datum2, att->attbyval, att->attlen))",
          "new_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "P_IGNORE",
          "new_api": "PageGetSpecialPointer",
          "old_text": "P_IGNORE(opaque)",
          "new_text": "PageGetSpecialPointer(page)",
          "old_line_content": "\tif (P_IGNORE(opaque))",
          "new_line_content": "\tBTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "BTreeTupleIsPosting",
          "new_api": "PageGetItemId",
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": "PageGetItemId(page, offnum)",
          "old_line_content": "\tif (BTreeTupleIsPosting(itup) &&",
          "new_line_content": "\titup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": "ItemPointerGetOffsetNumberNoCheck",
          "new_api": "BTreeTupleGetNAtts",
          "old_text": "ItemPointerGetOffsetNumberNoCheck(&itup->t_tid)",
          "new_text": "BTreeTupleGetNAtts(itup, rel)",
          "old_line_content": "\t\t(ItemPointerGetOffsetNumberNoCheck(&itup->t_tid) &",
          "new_line_content": "\ttupnatts = BTreeTupleGetNAtts(itup, rel);",
          "content_same": false
        },
        {
          "line": 2499,
          "old_api": "P_ISLEAF",
          "new_api": "ItemPointerGetOffsetNumberNoCheck",
          "old_text": "P_ISLEAF(opaque)",
          "new_text": "ItemPointerGetOffsetNumberNoCheck(&itup->t_tid)",
          "old_line_content": "\tif (P_ISLEAF(opaque))",
          "new_line_content": "\t\t(ItemPointerGetOffsetNumberNoCheck(&itup->t_tid) &",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": "BTreeTupleIsPivot",
          "new_api": "P_ISLEAF",
          "old_text": "BTreeTupleIsPivot(itup)",
          "new_text": "P_ISLEAF(opaque)",
          "old_line_content": "\t\t\tif (BTreeTupleIsPivot(itup))",
          "new_line_content": "\tif (P_ISLEAF(opaque))",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": "BTMaxItemSizeNoHeapTid",
          "new_api": "BTMaxItemSize",
          "old_text": "BTMaxItemSizeNoHeapTid(page)",
          "new_text": "BTMaxItemSize(page)",
          "old_line_content": "\tif (!needheaptidspace && itemsz <= BTMaxItemSizeNoHeapTid(page))",
          "new_line_content": "\tif (itemsz <= BTMaxItemSize(page))",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": "P_ISLEAF",
          "new_api": "BTMaxItemSizeNoHeapTid",
          "old_text": "P_ISLEAF(opaque)",
          "new_text": "BTMaxItemSizeNoHeapTid(page)",
          "old_line_content": "\tif (!P_ISLEAF(opaque))",
          "new_line_content": "\tif (!needheaptidspace && itemsz <= BTMaxItemSizeNoHeapTid(page))",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "BTMaxItemSize",
          "new_api": "elog",
          "old_text": "BTMaxItemSize(page)",
          "new_text": "elog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",\n\t\t\t itemsz, RelationGetRelationName(rel))",
          "old_line_content": "\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :",
          "new_line_content": "\t\telog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "BTMaxItemSizeNoHeapTid",
          "new_api": "RelationGetRelationName",
          "old_text": "BTMaxItemSizeNoHeapTid(page)",
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),",
          "new_line_content": "\t\t\t itemsz, RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": "errdetail",
          "new_api": "ereport",
          "old_text": "errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap))",
          "new_text": "ereport(ERROR,\n\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel)),\n\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap)),\n\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\"),\n\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))))",
          "old_line_content": "\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",",
          "new_line_content": "\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 2663,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": "errcode",
          "old_text": "BTreeTupleGetHeapTID(newtup)",
          "new_text": "errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED)",
          "old_line_content": "\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),",
          "new_line_content": "\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": "errmsg",
          "old_text": "BTreeTupleGetHeapTID(newtup)",
          "new_text": "errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel))",
          "old_line_content": "\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),",
          "new_line_content": "\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": "OidFunctionCall1Coll",
          "new_api": "get_opfamily_proc",
          "old_text": "OidFunctionCall1Coll(equalimageproc, collation,\n\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))",
          "new_text": "get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC)",
          "old_line_content": "\t\t\t!DatumGetBool(OidFunctionCall1Coll(equalimageproc, collation,",
          "new_line_content": "\t\tequalimageproc = get_opfamily_proc(opfamily, opcintype, opcintype,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2055,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(arg)",
          "old_line_content": "{",
          "new_line_content": "\t_bt_end_vacuum((Relation) DatumGetPointer(arg));",
          "content_same": false
        },
        {
          "line": 2571,
          "old_api": null,
          "new_api": "ItemPointerGetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerGetOffsetNumber(&(itup->t_tid))",
          "old_line_content": "\t\t\t * have non-key attributes.",
          "new_line_content": "\t\t\t\tItemPointerGetOffsetNumber(&(itup->t_tid)) == P_HIKEY;",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(BTVacInfo, vacuums)",
          "old_line_content": "void",
          "new_line_content": "\tsize = offsetof(BTVacInfo, vacuums);",
          "content_same": false
        },
        {
          "line": 2067,
          "old_api": null,
          "new_api": "mul_size",
          "old_text": null,
          "new_text": "mul_size(MaxBackends, sizeof(BTOneVacInfo))",
          "old_line_content": "BTreeShmemInit(void)",
          "new_line_content": "\tsize = add_size(size, mul_size(MaxBackends, sizeof(BTOneVacInfo)));",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(heapkeyspace)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\tAssert(heapkeyspace);",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": null,
          "new_api": "ShmemInitStruct",
          "old_text": null,
          "new_text": "ShmemInitStruct(\"BTree Vacuum State\",\n\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),\n\t\t\t\t\t\t\t\t\t\t\t  &found)",
          "old_line_content": "",
          "new_line_content": "\tbtvacinfo = (BTVacInfo *) ShmemInitStruct(\"BTree Vacuum State\",",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "BTreeShmemSize",
          "old_text": null,
          "new_text": "BTreeShmemSize()",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),",
          "content_same": false
        },
        {
          "line": 2597,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(itup)",
          "old_line_content": "\t * Heap TID is a tiebreaker key attribute, so it cannot be untruncated",
          "new_line_content": "\tif (!BTreeTupleIsPivot(itup))",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!found)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(!found);",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\tif (BTreeTupleIsPosting(itup))",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": null,
          "new_api": "time",
          "old_text": null,
          "new_text": "time(NULL)",
          "old_line_content": "",
          "new_line_content": "\t\tbtvacinfo->cycle_ctr = (BTCycleId) time(NULL);",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(itup)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (BTreeTupleGetHeapTID(itup) != NULL && tupnatts != nkeyatts)",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(found)",
          "old_line_content": "\t\t{\"vacuum_cleanup_index_scale_factor\", RELOPT_TYPE_REAL,",
          "new_line_content": "\t\tAssert(found);",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(BTOptions, vacuum_cleanup_index_scale_factor)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t  sizeof(BTOptions),",
          "new_line_content": "\t\toffsetof(BTOptions, vacuum_cleanup_index_scale_factor)},",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(BTOptions, deduplicate_items)",
          "old_line_content": "",
          "new_line_content": "\t\toffsetof(BTOptions, deduplicate_items)}",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": null,
          "new_api": "build_reloptions",
          "old_text": null,
          "new_text": "build_reloptions(reloptions, validate,\n\t\t\t\t\t\t\t\t\t  RELOPT_KIND_BTREE,\n\t\t\t\t\t\t\t\t\t  sizeof(BTOptions),\n\t\t\t\t\t\t\t\t\t  tab, lengthof(tab))",
          "old_line_content": " *\tbtproperty() -- Check boolean properties of indexes.",
          "new_line_content": "\treturn (bytea *) build_reloptions(reloptions, validate,",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": null,
          "new_api": "lengthof",
          "old_text": null,
          "new_text": "lengthof(tab)",
          "old_line_content": " * to call btcanreturn.",
          "new_line_content": "\t\t\t\t\t\t\t\t\t  tab, lengthof(tab));",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": null,
          "new_api": "IndexTupleSize",
          "old_text": null,
          "new_text": "IndexTupleSize(newtup)",
          "old_line_content": "\t * index uses version 2 or version 3, or that page is an internal page, in",
          "new_line_content": "\titemsz = MAXALIGN(IndexTupleSize(newtup));",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": null,
          "new_api": "PageGetSpecialPointer",
          "old_text": null,
          "new_text": "PageGetSpecialPointer(page)",
          "old_line_content": "\t\t\t\t\titemsz,",
          "new_line_content": "\topaque = (BTPageOpaque) PageGetSpecialPointer(page);",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": null,
          "new_api": "P_ISLEAF",
          "old_text": null,
          "new_text": "P_ISLEAF(opaque)",
          "old_line_content": "\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,",
          "new_line_content": "\tif (!P_ISLEAF(opaque))",
          "content_same": false
        },
        {
          "line": 2667,
          "old_api": null,
          "new_api": "BTMaxItemSize",
          "old_text": null,
          "new_text": "BTMaxItemSize(page)",
          "old_line_content": "\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"",
          "new_line_content": "\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": null,
          "new_api": "BTMaxItemSizeNoHeapTid",
          "old_text": null,
          "new_text": "BTMaxItemSizeNoHeapTid(page)",
          "old_line_content": "\t\t\t\t\t \"or use full text indexing.\"),",
          "new_line_content": "\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": null,
          "new_api": "errdetail",
          "old_text": null,
          "new_text": "errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap))",
          "old_line_content": "}",
          "new_line_content": "\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(newtup)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(newtup)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(heap)",
          "old_line_content": " * Are all attributes in rel \"equality is image equality\" attributes?",
          "new_line_content": "\t\t\t\t\t   RelationGetRelationName(heap)),",
          "content_same": false
        },
        {
          "line": 2674,
          "old_api": null,
          "new_api": "errhint",
          "old_text": null,
          "new_text": "errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\")",
          "old_line_content": " *",
          "new_line_content": "\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": " * return false; otherwise we return true.",
          "new_line_content": "\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))));",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfAttributes(rel)",
          "old_line_content": "\t * alternative is to force users to always use deduplication, without",
          "new_line_content": "\tif (IndexRelationGetNumberOfAttributes(rel) !=",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t * being able to opt out.  (ALTER INDEX is not supported with system",
          "new_line_content": "\t\tIndexRelationGetNumberOfKeyAttributes(rel))",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": null,
          "new_api": "IsSystemRelation",
          "old_text": null,
          "new_text": "IsSystemRelation(rel)",
          "old_line_content": "\t\tOid\t\t\tequalimageproc;",
          "new_line_content": "\tif (IsSystemRelation(rel))",
          "content_same": false
        },
        {
          "line": 2712,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC);",
          "new_line_content": "\tfor (int i = 0; i < IndexRelationGetNumberOfKeyAttributes(rel); i++)",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "RelationGetDescr",
          "old_text": null,
          "new_text": "RelationGetDescr(rel)",
          "old_line_content": "\t/*",
          "new_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t * We should only ever truncate non-pivot tuples from leaf pages.  It's",
          "new_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(firstright)",
          "old_line_content": "#endif",
          "new_line_content": "\tAssert(!BTreeTupleIsPivot(lastleft) && !BTreeTupleIsPivot(firstright));",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(equalimageproc)",
          "old_line_content": "",
          "new_line_content": "\t\tif (!OidIsValid(equalimageproc) ||",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": null,
          "new_api": "OidFunctionCall1Coll",
          "old_text": null,
          "new_text": "OidFunctionCall1Coll(equalimageproc, collation,\n\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))",
          "old_line_content": "\t/*",
          "new_line_content": "\t\t\t!DatumGetBool(OidFunctionCall1Coll(equalimageproc, collation,",
          "content_same": false
        },
        {
          "line": 2728,
          "old_api": null,
          "new_api": "ObjectIdGetDatum",
          "old_text": null,
          "new_text": "ObjectIdGetDatum(opcintype)",
          "old_line_content": "\t * Don't elog() until here to avoid reporting on a system relation index",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))))",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "index_truncate_tuple",
          "old_text": null,
          "new_text": "index_truncate_tuple(itupdesc, firstright,\n\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts))",
          "old_line_content": "\t\t * need to truncate away a posting list here instead.",
          "new_line_content": "\tpivot = index_truncate_tuple(itupdesc, firstright,",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(keepnatts, nkeyatts)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts));",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "}",
          "new_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 2745,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "",
          "new_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1)",
          "old_line_content": "\t * done",
          "new_line_content": "\t\tAssert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1);",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfAttributes(rel)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tAssert(IndexRelationGetNumberOfAttributes(rel) == nkeyatts);",
          "content_same": false
        },
        {
          "line": 2746,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "BTreeTupleGetPostingOffset",
          "old_text": null,
          "new_text": "BTreeTupleGetPostingOffset(firstright)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tpivot->t_info |= MAXALIGN(BTreeTupleGetPostingOffset(firstright));",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": null,
          "new_api": "BTreeTupleSetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleSetNAtts(pivot, keepnatts, false)",
          "old_line_content": "\t * inability to truncate away any key attributes, since heap TID is",
          "new_line_content": "\t\tBTreeTupleSetNAtts(pivot, keepnatts, false);",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": null,
          "new_api": "MAXALIGN",
          "old_text": null,
          "new_text": "MAXALIGN(sizeof(ItemPointerData))",
          "old_line_content": "\t * TID value in enlarged pivot tuple",
          "new_line_content": "\tnewsize = MAXALIGN(IndexTupleSize(pivot)) + MAXALIGN(sizeof(ItemPointerData));",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(newsize)",
          "old_line_content": "\t */",
          "new_line_content": "\ttidpivot = palloc0(newsize);",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "IndexTupleSize",
          "old_text": null,
          "new_text": "IndexTupleSize(pivot)",
          "old_line_content": "\ttidpivot->t_info &= ~INDEX_SIZE_MASK;",
          "new_line_content": "\tmemcpy(tidpivot, pivot, MAXALIGN(IndexTupleSize(pivot)));",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": null,
          "new_api": "BTreeTupleSetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleSetNAtts(tidpivot, nkeyatts, true)",
          "old_line_content": "\t * legally usable.)",
          "new_line_content": "\tBTreeTupleSetNAtts(tidpivot, nkeyatts, true);",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(tidpivot)",
          "old_line_content": "\t */",
          "new_line_content": "\tpivotheaptid = BTreeTupleGetHeapTID(tidpivot);",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "BTreeTupleGetMaxHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "old_line_content": "\t * bound for items on the left page.  Assert that heap TIDs follow these",
          "new_line_content": "\tItemPointerCopy(BTreeTupleGetMaxHeapTID(lastleft), pivotheaptid);",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "BTreeTupleGetMaxHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert(ItemPointerCompare(BTreeTupleGetMaxHeapTID(lastleft),",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "\t * Those invariants aren't guaranteed to hold for lastleft + firstright",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "content_same": false
        },
        {
          "line": 2300,
          "old_api": null,
          "new_api": "ItemPointerCompare",
          "old_text": null,
          "new_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft))",
          "old_line_content": "\t * heap TID attribute values when they're considered here only because",
          "new_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(lastleft)",
          "old_line_content": "\t * DEBUG_NO_TRUNCATE is defined (a heap TID is probably not actually",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft)) >= 0);",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": null,
          "new_api": "ItemPointerCompare",
          "old_text": null,
          "new_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "old_line_content": "\t * needed as a tiebreaker).  DEBUG_NO_TRUNCATE must therefore use a heap",
          "new_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "\t * TID value that always works as a strict lower bound for items to the",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": null,
          "new_api": "ItemPointerSetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerSetOffsetNumber(pivotheaptid,\n\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)))",
          "old_line_content": "",
          "new_line_content": "\tItemPointerSetOffsetNumber(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": null,
          "new_api": "ItemPointerGetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerGetOffsetNumber(pivotheaptid)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)));",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": null,
          "new_api": "ItemPointerCompare",
          "old_text": null,
          "new_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "old_line_content": " * _bt_keep_natts - how many key attributes to keep when truncating.",
          "new_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": " *",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t * must still truncate away non-key attribute values, though.",
          "new_line_content": "\tint\t\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": null,
          "new_api": "RelationGetDescr",
          "old_text": null,
          "new_text": "RelationGetDescr(rel)",
          "old_line_content": "\t */",
          "new_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\tscankey->sk_collation,",
          "new_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\tdatum1,",
          "new_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(&scankey->sk_func,\n\t\t\t\t\t\t\t\t\t\t\tscankey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\tdatum1,\n\t\t\t\t\t\t\t\t\t\t\tdatum2)",
          "old_line_content": "",
          "new_line_content": "\t\t\tDatumGetInt32(FunctionCall2Coll(&scankey->sk_func,",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "ItemIdIsDead",
          "old_text": null,
          "new_text": "ItemIdIsDead(iid)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tif (killtuple && !ItemIdIsDead(iid))",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": null,
          "new_api": "ItemIdMarkDead",
          "old_text": null,
          "new_text": "ItemIdMarkDead(iid)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\t\t\tItemIdMarkDead(iid);",
          "content_same": false
        },
        {
          "line": 1872,
          "old_api": null,
          "new_api": "OffsetNumberNext",
          "old_text": null,
          "new_text": "OffsetNumberNext(offnum)",
          "old_line_content": "\t * BTP_HAS_GARBAGE flag, which is likewise just a hint.",
          "new_line_content": "\t\t\toffnum = OffsetNumberNext(offnum);",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!itup_key->allequalimage ||\n\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright))",
          "old_line_content": " *",
          "new_line_content": "\tAssert(!itup_key->allequalimage ||",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "_bt_keep_natts_fast",
          "old_text": null,
          "new_text": "_bt_keep_natts_fast(rel, lastleft, firstright)",
          "old_line_content": " * This is exported so that a candidate split point can have its effect on",
          "new_line_content": "\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright));",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": null,
          "new_api": "MarkBufferDirtyHint",
          "old_text": null,
          "new_text": "MarkBufferDirtyHint(so->currPos.buf, true)",
          "old_line_content": " * The following routines manage a shared-memory area in which we track",
          "new_line_content": "\t\tMarkBufferDirtyHint(so->currPos.buf, true);",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK)",
          "old_line_content": " * start a vacuum to assign it a cycle ID.  Since multiple vacuums could",
          "new_line_content": "\tLockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);",
          "content_same": false
        },
        {
          "line": 2420,
          "old_api": null,
          "new_api": "RelationGetDescr",
          "old_text": null,
          "new_text": "RelationGetDescr(rel)",
          "old_line_content": "\t\t\t\t\tdatum2;",
          "new_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "content_same": false
        },
        {
          "line": 2421,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t\tbool\t\tisNull1,",
          "new_line_content": "\tint\t\t\tkeysz = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": null,
          "new_api": "TupleDescAttr",
          "old_text": null,
          "new_text": "TupleDescAttr(itupdesc, attnum - 1)",
          "old_line_content": "",
          "new_line_content": "\t\tatt = TupleDescAttr(itupdesc, attnum - 1);",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": null,
          "new_api": "datum_image_eq",
          "old_text": null,
          "new_text": "datum_image_eq(datum1, datum2, att->attbyval, att->attlen)",
          "old_line_content": "",
          "new_line_content": "\t\t\t!datum_image_eq(datum1, datum2, att->attbyval, att->attlen))",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(BtreeVacuumLock, LW_SHARED)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": " * _bt_end_vacuum, else we'll permanently leak an array slot.  To ensure",
          "new_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 2467,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfAttributes(rel)",
          "old_line_content": "\t * dummy high keys",
          "new_line_content": "\tint16\t\tnatts = IndexRelationGetNumberOfAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2468,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t */",
          "new_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": null,
          "new_api": "P_IGNORE",
          "old_text": null,
          "new_text": "P_IGNORE(opaque)",
          "old_line_content": "\t * maximum possible number of index attributes",
          "new_line_content": "\tif (P_IGNORE(opaque))",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(offnum >= FirstOffsetNumber &&\n\t\t   offnum <= PageGetMaxOffsetNumber(page))",
          "old_line_content": "\t\t\t\t\t \"BT_OFFSET_MASK can't fit INDEX_MAX_KEYS\");",
          "new_line_content": "\tAssert(offnum >= FirstOffsetNumber &&",
          "content_same": false
        },
        {
          "line": 2481,
          "old_api": null,
          "new_api": "PageGetMaxOffsetNumber",
          "old_text": null,
          "new_text": "PageGetMaxOffsetNumber(page)",
          "old_line_content": "",
          "new_line_content": "\t\t   offnum <= PageGetMaxOffsetNumber(page));",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "old_line_content": "\t\tresult = btvacinfo->cycle_ctr = 1;",
          "new_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "StaticAssertStmt",
          "old_text": null,
          "new_text": "StaticAssertStmt(BT_OFFSET_MASK >= INDEX_MAX_KEYS,\n\t\t\t\t\t \"BT_OFFSET_MASK can't fit INDEX_MAX_KEYS\")",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\tStaticAssertStmt(BT_OFFSET_MASK >= INDEX_MAX_KEYS,",
          "content_same": false
        },
        {
          "line": 2494,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "",
          "new_line_content": "\tif (!heapkeyspace && BTreeTupleIsPosting(itup))",
          "content_same": false
        },
        {
          "line": 2498,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "",
          "new_line_content": "\tif (BTreeTupleIsPosting(itup) &&",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "\t\t\t * Non-pivot tuple should never be explicitly marked as a pivot",
          "new_line_content": "\tif (natts != nkeyatts && BTreeTupleIsPosting(itup))",
          "content_same": false
        },
        {
          "line": 1997,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": null,
          "new_api": "P_FIRSTDATAKEY",
          "old_text": null,
          "new_text": "P_FIRSTDATAKEY(opaque)",
          "old_line_content": "",
          "new_line_content": "\t\tif (offnum >= P_FIRSTDATAKEY(opaque))",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(itup)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tif (BTreeTupleIsPivot(itup))",
          "content_same": false
        },
        {
          "line": 2007,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"out of btvacinfo slots\")",
          "old_line_content": "\treturn result;",
          "new_line_content": "\t\telog(ERROR, \"out of btvacinfo slots\");",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": " * this allows the caller to put PG_TRY around the start_vacuum operation.",
          "new_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": null,
          "new_api": "P_RIGHTMOST",
          "old_text": null,
          "new_text": "P_RIGHTMOST(opaque)",
          "old_line_content": "\t\t\t\treturn tupnatts == nkeyatts;",
          "new_line_content": "\t\t\tAssert(!P_RIGHTMOST(opaque));",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "old_line_content": "\t\t\tvac->relid.dbId == rel->rd_lockInfo.lockRelId.dbId)",
          "new_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": null,
          "new_api": "P_FIRSTDATAKEY",
          "old_text": null,
          "new_text": "P_FIRSTDATAKEY(opaque)",
          "old_line_content": "\t\t\tif (heapkeyspace)",
          "new_line_content": "\t\tif (offnum == P_FIRSTDATAKEY(opaque))",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": "{",
          "new_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2563,
          "old_api": "ItemPointerGetOffsetNumber",
          "new_api": null,
          "old_text": "ItemPointerGetOffsetNumber(&(itup->t_tid))",
          "new_text": null,
          "old_line_content": "\t\t\t\tItemPointerGetOffsetNumber(&(itup->t_tid)) == P_HIKEY;",
          "new_line_content": "\t\t\t * non-zero, or when there is no explicit representation and the",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTVacInfo, vacuums)",
          "new_text": null,
          "old_line_content": "\tsize = offsetof(BTVacInfo, vacuums);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "mul_size",
          "new_api": null,
          "old_text": "mul_size(MaxBackends, sizeof(BTOneVacInfo))",
          "new_text": null,
          "old_line_content": "\tsize = add_size(size, mul_size(MaxBackends, sizeof(BTOneVacInfo)));",
          "new_line_content": " * BTreeShmemSize --- report amount of shared memory space needed",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(heapkeyspace)",
          "new_text": null,
          "old_line_content": "\tAssert(heapkeyspace);",
          "new_line_content": "\t\t\t\treturn tupnatts == nkeyatts;",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": "ShmemInitStruct",
          "new_api": null,
          "old_text": "ShmemInitStruct(\"BTree Vacuum State\",\n\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),\n\t\t\t\t\t\t\t\t\t\t\t  &found)",
          "new_text": null,
          "old_line_content": "\tbtvacinfo = (BTVacInfo *) ShmemInitStruct(\"BTree Vacuum State\",",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": "BTreeShmemSize",
          "new_api": null,
          "old_text": "BTreeShmemSize()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),",
          "new_line_content": " * BTreeShmemInit --- initialize this module's shared memory",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "BTreeTupleIsPivot",
          "new_api": null,
          "old_text": "BTreeTupleIsPivot(itup)",
          "new_text": null,
          "old_line_content": "\tif (!BTreeTupleIsPivot(itup))",
          "new_line_content": "\t/* Handle heapkeyspace pivot tuples (excluding minus infinity items) */",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!found)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!found);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleIsPosting(itup))",
          "new_line_content": "\t * Explicit representation of the number of attributes is mandatory with",
          "content_same": false
        },
        {
          "line": 2085,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(NULL)",
          "new_text": null,
          "old_line_content": "\t\tbtvacinfo->cycle_ctr = (BTCycleId) time(NULL);",
          "new_line_content": "\t\t/* Initialize shared memory area */",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(itup)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleGetHeapTID(itup) != NULL && tupnatts != nkeyatts)",
          "new_line_content": "\t/* Pivot tuple should not use posting list representation (redundant) */",
          "content_same": false
        },
        {
          "line": 2091,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(found)",
          "new_text": null,
          "old_line_content": "\t\tAssert(found);",
          "new_line_content": "\t\t * low-order bits of time() instead.",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTOptions, fillfactor)",
          "new_text": null,
          "old_line_content": "\t\t{\"fillfactor\", RELOPT_TYPE_INT, offsetof(BTOptions, fillfactor)},",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTOptions, vacuum_cleanup_index_scale_factor)",
          "new_text": null,
          "old_line_content": "\t\toffsetof(BTOptions, vacuum_cleanup_index_scale_factor)},",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTOptions, deduplicate_items)",
          "new_text": null,
          "old_line_content": "\t\toffsetof(BTOptions, deduplicate_items)}",
          "new_line_content": "bytea *",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "lengthof",
          "new_api": null,
          "old_text": "lengthof(tab)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t  tab, lengthof(tab));",
          "new_line_content": "\t\t{\"deduplicate_items\", RELOPT_TYPE_BOOL,",
          "content_same": false
        },
        {
          "line": 2631,
          "old_api": "IndexTupleSize",
          "new_api": null,
          "old_text": "IndexTupleSize(newtup)",
          "new_text": null,
          "old_line_content": "\titemsz = MAXALIGN(IndexTupleSize(newtup));",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": "BTMaxItemSize",
          "new_api": null,
          "old_text": "BTMaxItemSize(page)",
          "new_text": null,
          "old_line_content": "\tif (itemsz <= BTMaxItemSize(page))",
          "new_line_content": "\t\t\t\t\t Page page, IndexTuple newtup)",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "PageGetSpecialPointer",
          "new_api": null,
          "old_text": "PageGetSpecialPointer(page)",
          "new_text": null,
          "old_line_content": "\topaque = (BTPageOpaque) PageGetSpecialPointer(page);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",\n\t\t\t itemsz, RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2652,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t itemsz, RelationGetRelationName(rel));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel)),\n\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap)),\n\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\"),\n\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))))",
          "new_text": null,
          "old_line_content": "\tereport(ERROR,",
          "new_line_content": "\t * Internal page insertions cannot fail here, because that would mean that",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED)",
          "new_text": null,
          "old_line_content": "\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "new_line_content": "\t * an earlier leaf level insertion that should have failed didn't",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tRelationGetRelationName(rel)),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(heap)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t   RelationGetRelationName(heap)),",
          "new_line_content": "\t\t\t\t\titemsz,",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": "errhint",
          "new_api": null,
          "old_text": "errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\")",
          "new_text": null,
          "old_line_content": "\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"",
          "new_line_content": "\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": "IndexRelationGetNumberOfAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tif (IndexRelationGetNumberOfAttributes(rel) !=",
          "new_line_content": " * Deduplication can only be used when we return true.",
          "content_same": false
        },
        {
          "line": 2689,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\t\tIndexRelationGetNumberOfKeyAttributes(rel))",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": "IsSystemRelation",
          "new_api": null,
          "old_text": "IsSystemRelation(rel)",
          "new_text": null,
          "old_line_content": "\tif (IsSystemRelation(rel))",
          "new_line_content": "\t * There is no special reason why deduplication cannot work with system",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tfor (int i = 0; i < IndexRelationGetNumberOfKeyAttributes(rel); i++)",
          "new_line_content": "\t * alternative is to force users to always use deduplication, without",
          "content_same": false
        },
        {
          "line": 2194,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(rel)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "new_line_content": " * within an attribute/datum, it will need to avoid returning an enlarged",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * tuple to caller when truncation + TOAST compression ends up enlarging the",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "get_opfamily_proc",
          "new_api": null,
          "old_text": "get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC)",
          "new_text": null,
          "old_line_content": "\t\tequalimageproc = get_opfamily_proc(opfamily, opcintype, opcintype,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "BTreeTupleIsPivot",
          "new_api": null,
          "old_text": "BTreeTupleIsPivot(firstright)",
          "new_text": null,
          "old_line_content": "\tAssert(!BTreeTupleIsPivot(lastleft) && !BTreeTupleIsPivot(firstright));",
          "new_line_content": "\tIndexTuple\ttidpivot;",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(equalimageproc)",
          "new_text": null,
          "old_line_content": "\t\tif (!OidIsValid(equalimageproc) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2720,
          "old_api": "ObjectIdGetDatum",
          "new_api": null,
          "old_text": "ObjectIdGetDatum(opcintype)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))))",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC);",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "_bt_keep_natts",
          "new_api": null,
          "old_text": "_bt_keep_natts(rel, lastleft, firstright, itup_key)",
          "new_text": null,
          "old_line_content": "\tkeepnatts = _bt_keep_natts(rel, lastleft, firstright, itup_key);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": "index_truncate_tuple",
          "new_api": null,
          "old_text": "index_truncate_tuple(itupdesc, firstright,\n\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts))",
          "new_text": null,
          "old_line_content": "\tpivot = index_truncate_tuple(itupdesc, firstright,",
          "new_line_content": "\t/* Determine how many attributes must be kept in truncated tuple */",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(pivot)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleIsPosting(pivot))",
          "new_line_content": "#ifdef DEBUG_NO_TRUNCATE",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2735,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2737,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",",
          "new_line_content": "\t * or an INCLUDE index",
          "content_same": false
        },
        {
          "line": 2226,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1)",
          "new_text": null,
          "old_line_content": "\t\tAssert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2738,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": "BTreeTupleGetPostingOffset",
          "new_api": null,
          "old_text": "BTreeTupleGetPostingOffset(firstright)",
          "new_text": null,
          "old_line_content": "\t\tpivot->t_info |= MAXALIGN(BTreeTupleGetPostingOffset(firstright));",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "BTreeTupleSetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleSetNAtts(pivot, keepnatts, false)",
          "new_text": null,
          "old_line_content": "\t\tBTreeTupleSetNAtts(pivot, keepnatts, false);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "MAXALIGN",
          "new_api": null,
          "old_text": "MAXALIGN(sizeof(ItemPointerData))",
          "new_text": null,
          "old_line_content": "\tnewsize = MAXALIGN(IndexTupleSize(pivot)) + MAXALIGN(sizeof(ItemPointerData));",
          "new_line_content": "\t * treated as just another key attribute (despite lacking a pg_attribute",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "palloc0",
          "new_api": null,
          "old_text": "palloc0(newsize)",
          "new_text": null,
          "old_line_content": "\ttidpivot = palloc0(newsize);",
          "new_line_content": "\t * entry).",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": "IndexTupleSize",
          "new_api": null,
          "old_text": "IndexTupleSize(pivot)",
          "new_text": null,
          "old_line_content": "\tmemcpy(tidpivot, pivot, MAXALIGN(IndexTupleSize(pivot)));",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(pivot)",
          "new_text": null,
          "old_line_content": "\tpfree(pivot);",
          "new_line_content": "\t * to store a heap TID at the end (using the special pivot tuple",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(tidpivot)",
          "new_text": null,
          "old_line_content": "\tpivotheaptid = BTreeTupleGetHeapTID(tidpivot);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "BTreeTupleGetMaxHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "new_text": null,
          "old_line_content": "\tItemPointerCopy(BTreeTupleGetMaxHeapTID(lastleft), pivotheaptid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2290,
          "old_api": "BTreeTupleGetMaxHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(BTreeTupleGetMaxHeapTID(lastleft),",
          "new_line_content": "\t * Lehman and Yao require that the downlink to the right page, which is to",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "new_line_content": "\t * be inserted into the parent page in the second phase of a page split be",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "ItemPointerCompare",
          "new_api": null,
          "old_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft))",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "new_line_content": "\t * a strict lower bound on items on the right page, and a non-strict upper",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(lastleft)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft)) >= 0);",
          "new_line_content": "\t * bound for items on the left page.  Assert that heap TIDs follow these",
          "content_same": false
        },
        {
          "line": 2294,
          "old_api": "ItemPointerCompare",
          "new_api": null,
          "old_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "new_line_content": "\t * invariants, since a heap TID value is apparently needed as a",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "new_line_content": "\t * tiebreaker.",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\tItemPointerCopy(BTreeTupleGetHeapTID(firstright), pivotheaptid);",
          "new_line_content": "\t * heap TID attribute values when they're considered here only because",
          "content_same": false
        },
        {
          "line": 2315,
          "old_api": "ItemPointerSetOffsetNumber",
          "new_api": null,
          "old_text": "ItemPointerSetOffsetNumber(pivotheaptid,\n\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)))",
          "new_text": null,
          "old_line_content": "\tItemPointerSetOffsetNumber(pivotheaptid,",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2317,
          "old_api": "ItemPointerCompare",
          "new_api": null,
          "old_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint\t\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * This can return a number of attributes that is one greater than the",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(rel)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "new_line_content": " * number of key attributes for the index relation.  This indicates that the",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "new_text": null,
          "old_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "new_line_content": "\tkeepnatts = 1;",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "new_text": null,
          "old_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "new_line_content": "\tfor (int attnum = 1; attnum <= nkeyatts; attnum++, scankey++)",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "FunctionCall2Coll",
          "new_api": null,
          "old_text": "FunctionCall2Coll(&scankey->sk_func,\n\t\t\t\t\t\t\t\t\t\t\tscankey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\tdatum1,\n\t\t\t\t\t\t\t\t\t\t\tdatum2)",
          "new_text": null,
          "old_line_content": "\t\t\tDatumGetInt32(FunctionCall2Coll(&scankey->sk_func,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "ItemIdMarkDead",
          "new_api": null,
          "old_text": "ItemIdMarkDead(iid)",
          "new_text": null,
          "old_line_content": "\t\t\t\tItemIdMarkDead(iid);",
          "new_line_content": "\t\t\t * it's possible that multiple processes attempt to do this",
          "content_same": false
        },
        {
          "line": 1864,
          "old_api": "OffsetNumberNext",
          "new_api": null,
          "old_text": "OffsetNumberNext(offnum)",
          "new_text": null,
          "old_line_content": "\t\t\toffnum = OffsetNumberNext(offnum);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 2381,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!itup_key->allequalimage ||\n\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright))",
          "new_text": null,
          "old_line_content": "\tAssert(!itup_key->allequalimage ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2382,
          "old_api": "_bt_keep_natts_fast",
          "new_api": null,
          "old_text": "_bt_keep_natts_fast(rel, lastleft, firstright)",
          "new_text": null,
          "old_line_content": "\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright));",
          "new_line_content": "\t\tkeepnatts++;",
          "content_same": false
        },
        {
          "line": 1877,
          "old_api": "MarkBufferDirtyHint",
          "new_api": null,
          "old_text": "MarkBufferDirtyHint(so->currPos.buf, true)",
          "new_text": null,
          "old_line_content": "\t\tMarkBufferDirtyHint(so->currPos.buf, true);",
          "new_line_content": "\t * Since this can be redone later if needed, mark as dirty hint.",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": "LockBuffer",
          "new_api": null,
          "old_text": "LockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK)",
          "new_text": null,
          "old_line_content": "\tLockBuffer(so->currPos.buf, BUFFER_LOCK_UNLOCK);",
          "new_line_content": "\t * BTP_HAS_GARBAGE flag, which is likewise just a hint.",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(rel)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "new_line_content": " * an opclass or collation that is not \"allequalimage\"/deduplication-safe.",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint\t\t\tkeysz = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * This weaker guarantee is good enough for nbtsplitloc.c caller, since false",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "new_text": null,
          "old_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "new_line_content": "\tfor (int attnum = 1; attnum <= keysz; attnum++)",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "new_text": null,
          "old_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "TupleDescAttr",
          "new_api": null,
          "old_text": "TupleDescAttr(itupdesc, attnum - 1)",
          "new_text": null,
          "old_line_content": "\t\tatt = TupleDescAttr(itupdesc, attnum - 1);",
          "new_line_content": "\t\tDatum\t\tdatum1,",
          "content_same": false
        },
        {
          "line": 1932,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(BtreeVacuumLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_SHARED);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1946,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\tif (vac->relid.relId == rel->rd_lockInfo.lockRelId.relId &&",
          "content_same": false
        },
        {
          "line": 2459,
          "old_api": "IndexRelationGetNumberOfAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint16\t\tnatts = IndexRelationGetNumberOfAttributes(rel);",
          "new_line_content": " * more explicit.  Call here instead when offnum's tuple may be a negative",
          "content_same": false
        },
        {
          "line": 2460,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * infinity tuple that uses the pre-v11 on-disk representation, or when a low",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "PageGetSpecialPointer",
          "new_api": null,
          "old_text": "PageGetSpecialPointer(page)",
          "new_text": null,
          "old_line_content": "\tBTPageOpaque opaque = (BTPageOpaque) PageGetSpecialPointer(page);",
          "new_line_content": " * context check is appropriate.  This routine is as strict as possible about",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(offnum >= FirstOffsetNumber &&\n\t\t   offnum <= PageGetMaxOffsetNumber(page))",
          "new_text": null,
          "old_line_content": "\tAssert(offnum >= FirstOffsetNumber &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2473,
          "old_api": "PageGetMaxOffsetNumber",
          "new_api": null,
          "old_text": "PageGetMaxOffsetNumber(page)",
          "new_text": null,
          "old_line_content": "\t\t   offnum <= PageGetMaxOffsetNumber(page));",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": "StaticAssertStmt",
          "new_api": null,
          "old_text": "StaticAssertStmt(BT_OFFSET_MASK >= INDEX_MAX_KEYS,\n\t\t\t\t\t \"BT_OFFSET_MASK can't fit INDEX_MAX_KEYS\")",
          "new_text": null,
          "old_line_content": "\tStaticAssertStmt(BT_OFFSET_MASK >= INDEX_MAX_KEYS,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": "PageGetItemId",
          "new_api": null,
          "old_text": "PageGetItemId(page, offnum)",
          "new_text": null,
          "old_line_content": "\titup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": "BTreeTupleGetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleGetNAtts(itup, rel)",
          "new_text": null,
          "old_line_content": "\ttupnatts = BTreeTupleGetNAtts(itup, rel);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2486,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": null,
          "old_line_content": "\tif (!heapkeyspace && BTreeTupleIsPosting(itup))",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": null,
          "old_line_content": "\tif (natts != nkeyatts && BTreeTupleIsPosting(itup))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t\tvac->relid.dbId == rel->rd_lockInfo.lockRelId.dbId)",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",\n\t\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1991,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": "P_FIRSTDATAKEY",
          "new_api": null,
          "old_text": "P_FIRSTDATAKEY(opaque)",
          "new_text": null,
          "old_line_content": "\t\tif (offnum >= P_FIRSTDATAKEY(opaque))",
          "new_line_content": "\t\treturn false;",
          "content_same": false
        },
        {
          "line": 2524,
          "old_api": "P_RIGHTMOST",
          "new_api": null,
          "old_text": "P_RIGHTMOST(opaque)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!P_RIGHTMOST(opaque));",
          "new_line_content": "\t\t\treturn tupnatts == natts;",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "new_line_content": " * Note: this is deliberately coded not to complain if no entry is found;",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": "P_FIRSTDATAKEY",
          "new_api": null,
          "old_text": "P_FIRSTDATAKEY(opaque)",
          "new_text": null,
          "old_line_content": "\t\tif (offnum == P_FIRSTDATAKEY(opaque))",
          "new_line_content": "\t\t\tif (!heapkeyspace)",
          "content_same": false
        },
        {
          "line": 2038,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2047,
          "old_api": "DatumGetPointer",
          "new_api": null,
          "old_text": "DatumGetPointer(arg)",
          "new_text": null,
          "old_line_content": "\t_bt_end_vacuum((Relation) DatumGetPointer(arg));",
          "new_line_content": "}",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 21,
      "total_additions": 102,
      "total_deletions": 101,
      "total_api_changes": 224
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 9,
        "api_related_lines": 224,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          1857,
          1858,
          1859,
          1861,
          1862,
          1863
        ]
      }
    },
    "api_calls_before": 308,
    "api_calls_after": 309,
    "diff_info": {
      "added_lines": 9,
      "removed_lines": 1,
      "total_diff_lines": 22
    }
  }
}