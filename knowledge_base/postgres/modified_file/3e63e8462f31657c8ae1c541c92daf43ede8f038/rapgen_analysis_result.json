{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/3e63e8462f31657c8ae1c541c92daf43ede8f038",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/3e63e8462f31657c8ae1c541c92daf43ede8f038/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/3e63e8462f31657c8ae1c541c92daf43ede8f038/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/3e63e8462f31657c8ae1c541c92daf43ede8f038/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 3743,
          "old_api": "ReadBufferWithoutRelcache",
          "new_api": "GetAccessStrategy",
          "old_text": "ReadBufferWithoutRelcache(srclocator, forkNum, blkno,\n\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_src,\n\t\t\t\t\t\t\t\t\t\t   permanent)",
          "new_text": "GetAccessStrategy(BAS_BULKREAD)",
          "old_line_content": "\t\tsrcBuf = ReadBufferWithoutRelcache(srclocator, forkNum, blkno,",
          "new_line_content": "\tbstrategy_src = GetAccessStrategy(BAS_BULKREAD);",
          "content_same": false
        },
        {
          "line": 3756,
          "old_api": "START_CRIT_SECTION",
          "new_api": "BufferGetPage",
          "old_text": "START_CRIT_SECTION()",
          "new_text": "BufferGetPage(srcBuf)",
          "old_line_content": "\t\tSTART_CRIT_SECTION();",
          "new_line_content": "\t\tsrcPage = BufferGetPage(srcBuf);",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": "memcpy",
          "new_api": "ReadBufferWithoutRelcache",
          "old_text": "memcpy(dstPage, srcPage, BLCKSZ)",
          "new_text": "ReadBufferWithoutRelcache(dstlocator, forkNum, blkno,\n\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_dst,\n\t\t\t\t\t\t\t\t\t\t   permanent)",
          "old_line_content": "\t\tmemcpy(dstPage, srcPage, BLCKSZ);",
          "new_line_content": "\t\tdstBuf = ReadBufferWithoutRelcache(dstlocator, forkNum, blkno,",
          "content_same": false
        },
        {
          "line": 3768,
          "old_api": "UnlockReleaseBuffer",
          "new_api": "memcpy",
          "old_text": "UnlockReleaseBuffer(dstBuf)",
          "new_text": "memcpy(dstPage, srcPage, BLCKSZ)",
          "old_line_content": "\t\tUnlockReleaseBuffer(dstBuf);",
          "new_line_content": "\t\tmemcpy(dstPage, srcPage, BLCKSZ);",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": "UnlockReleaseBuffer",
          "new_api": "MarkBufferDirty",
          "old_text": "UnlockReleaseBuffer(srcBuf)",
          "new_text": "MarkBufferDirty(dstBuf)",
          "old_line_content": "\t\tUnlockReleaseBuffer(srcBuf);",
          "new_line_content": "\t\tMarkBufferDirty(dstBuf);",
          "content_same": false
        },
        {
          "line": 3813,
          "old_api": "smgropen",
          "new_api": "RelationCopyStorageUsingBuffer",
          "old_text": "smgropen(dst_rlocator, InvalidBackendId)",
          "new_text": "RelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, MAIN_FORKNUM,\n\t\t\t\t\t\t\t\t   permanent)",
          "old_line_content": "\t\t\tsmgrcreate(smgropen(dst_rlocator, InvalidBackendId), forkNum, false);",
          "new_line_content": "\tRelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, MAIN_FORKNUM,",
          "content_same": false
        },
        {
          "line": 3820,
          "old_api": "log_smgrcreate",
          "new_api": "smgropen",
          "old_text": "log_smgrcreate(&dst_rlocator, forkNum)",
          "new_text": "smgropen(src_rlocator, InvalidBackendId)",
          "old_line_content": "\t\t\t\tlog_smgrcreate(&dst_rlocator, forkNum);",
          "new_line_content": "\t\tif (smgrexists(smgropen(src_rlocator, InvalidBackendId), forkNum))",
          "content_same": false
        },
        {
          "line": 3832,
          "old_api": "smgrcloserellocator",
          "new_api": "RelationCopyStorageUsingBuffer",
          "old_text": "smgrcloserellocator(rlocator)",
          "new_text": "RelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, forkNum,\n\t\t\t\t\t\t\t\t\t\t   permanent)",
          "old_line_content": "\tsmgrcloserellocator(rlocator);",
          "new_line_content": "\t\t\tRelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, forkNum,",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "ReservePrivateRefCountEntry",
          "new_api": "GetBufferDescriptor",
          "old_text": "ReservePrivateRefCountEntry()",
          "new_text": "GetBufferDescriptor(i)",
          "old_line_content": "\t\tReservePrivateRefCountEntry();",
          "new_line_content": "\t\tbufHdr = GetBufferDescriptor(i);",
          "content_same": false
        },
        {
          "line": 3884,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": "ReservePrivateRefCountEntry",
          "old_text": "BufferDescriptorGetContentLock(bufHdr)",
          "new_text": "ReservePrivateRefCountEntry()",
          "old_line_content": "\t\t\tLWLockRelease(BufferDescriptorGetContentLock(bufHdr));",
          "new_line_content": "\t\tReservePrivateRefCountEntry();",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": "BufferIsValid",
          "new_api": "FlushBuffer",
          "old_text": "BufferIsValid(buffer)",
          "new_text": "FlushBuffer(bufHdr, NULL)",
          "old_line_content": "\tif (!BufferIsValid(buffer))",
          "new_line_content": "\tFlushBuffer(bufHdr, NULL);",
          "content_same": false
        },
        {
          "line": 3931,
          "old_api": "GetBufferDescriptor",
          "new_api": "BufferIsLocal",
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\tUnpinBuffer(GetBufferDescriptor(buffer - 1), true);",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": "Assert",
          "new_api": "BufferIsPinned",
          "old_text": "Assert(ref != NULL)",
          "new_text": "BufferIsPinned(buffer)",
          "old_line_content": "\t\tAssert(ref != NULL);",
          "new_line_content": "\tAssert(BufferIsPinned(buffer));",
          "content_same": false
        },
        {
          "line": 4001,
          "old_api": "GetBufferDescriptor",
          "new_api": "BufferIsValid",
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": "BufferIsValid(buffer)",
          "old_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "\tif (!BufferIsValid(buffer))",
          "content_same": false
        },
        {
          "line": 4171,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": "BufferIsPinned",
          "old_text": "BufferDescriptorGetContentLock(buf)",
          "new_text": "BufferIsPinned(buffer)",
          "old_line_content": "\t\tLWLockAcquire(BufferDescriptorGetContentLock(buf), LW_SHARED);",
          "new_line_content": "\tAssert(BufferIsPinned(buffer));",
          "content_same": false
        },
        {
          "line": 4175,
          "old_api": "elog",
          "new_api": "GetBufferDescriptor",
          "old_text": "elog(ERROR, \"unrecognized buffer lock mode: %d\", mode)",
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": "\t\telog(ERROR, \"unrecognized buffer lock mode: %d\", mode);",
          "new_line_content": "\tbuf = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4238,
          "old_api": "GetPrivateRefCount",
          "new_api": "elog",
          "old_text": "GetPrivateRefCount(buffer)",
          "new_text": "elog(ERROR, \"incorrect local pin count: %d\",\n\t\t\t\t LocalRefCount[-buffer - 1])",
          "old_line_content": "\t\t\t GetPrivateRefCount(buffer));",
          "new_line_content": "\t\t\telog(ERROR, \"incorrect local pin count: %d\",",
          "content_same": false
        },
        {
          "line": 4247,
          "old_api": "LockBuffer",
          "new_api": "GetPrivateRefCount",
          "old_text": "LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE)",
          "new_text": "GetPrivateRefCount(buffer)",
          "old_line_content": "\t\tLockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);",
          "new_line_content": "\t\t\t GetPrivateRefCount(buffer));",
          "content_same": false
        },
        {
          "line": 4263,
          "old_api": "GetCurrentTimestamp",
          "new_api": "UnlockBufHdr",
          "old_text": "GetCurrentTimestamp()",
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "\t\t\t\t\t\t\t\t\twaitStart, GetCurrentTimestamp(),",
          "new_line_content": "\t\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 4278,
          "old_api": "LockBuffer",
          "new_api": "set_ps_display",
          "old_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "new_text": "set_ps_display(new_status)",
          "old_line_content": "\t\t\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "new_line_content": "\t\t\t\tset_ps_display(new_status);",
          "content_same": false
        },
        {
          "line": 4279,
          "old_api": "elog",
          "new_api": "pfree",
          "old_text": "elog(ERROR, \"multiple backends attempting to wait for pincount 1\")",
          "new_text": "pfree(new_status)",
          "old_line_content": "\t\t\telog(ERROR, \"multiple backends attempting to wait for pincount 1\");",
          "new_line_content": "\t\t\t\tpfree(new_status);",
          "content_same": false
        },
        {
          "line": 4421,
          "old_api": "GetBufferDescriptor",
          "new_api": "GetPrivateRefCount",
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": "GetPrivateRefCount(buffer)",
          "old_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "\trefcount = GetPrivateRefCount(buffer);",
          "content_same": false
        },
        {
          "line": 4422,
          "old_api": "LockBufHdr",
          "new_api": "Assert",
          "old_text": "LockBufHdr(bufHdr)",
          "new_text": "Assert(refcount)",
          "old_line_content": "\tbuf_state = LockBufHdr(bufHdr);",
          "new_line_content": "\tAssert(refcount);",
          "content_same": false
        },
        {
          "line": 4434,
          "old_api": "UnlockBufHdr",
          "new_api": "Assert",
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": "Assert(refcount > 0)",
          "old_line_content": "\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\tAssert(refcount > 0);",
          "content_same": false
        },
        {
          "line": 4474,
          "old_api": "LockBufHdr",
          "new_api": "GetPrivateRefCount",
          "old_text": "LockBufHdr(bufHdr)",
          "new_text": "GetPrivateRefCount(buffer)",
          "old_line_content": "\tbuf_state = LockBufHdr(bufHdr);",
          "new_line_content": "\tif (GetPrivateRefCount(buffer) != 1)",
          "content_same": false
        },
        {
          "line": 4477,
          "old_api": "BUF_STATE_GET_REFCOUNT",
          "new_api": "GetBufferDescriptor",
          "old_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": "\tif (BUF_STATE_GET_REFCOUNT(buf_state) == 1)",
          "new_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4480,
          "old_api": "UnlockBufHdr",
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": "BufferDescriptorGetContentLock(bufHdr)",
          "old_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\tAssert(LWLockHeldByMeInMode(BufferDescriptorGetContentLock(bufHdr),",
          "content_same": false
        },
        {
          "line": 4558,
          "old_api": "WaitIO",
          "new_api": "Assert",
          "old_text": "WaitIO(buf)",
          "new_text": "Assert(!InProgressBuf)",
          "old_line_content": "\t\tWaitIO(buf);",
          "new_line_content": "\tAssert(!InProgressBuf);",
          "content_same": false
        },
        {
          "line": 4611,
          "old_api": "UnlockBufHdr",
          "new_api": "LockBufHdr",
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": "LockBufHdr(buf)",
          "old_line_content": "\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "\tbuf_state = LockBufHdr(buf);",
          "content_same": false
        },
        {
          "line": 4649,
          "old_api": "UnlockBufHdr",
          "new_api": "Assert",
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": "Assert(!(buf_state & BM_DIRTY))",
          "old_line_content": "\t\t\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "\t\t\tAssert(!(buf_state & BM_DIRTY));",
          "content_same": false
        },
        {
          "line": 4657,
          "old_api": "ereport",
          "new_api": "Assert",
          "old_text": "ereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_IO_ERROR),\n\t\t\t\t\t\t errmsg(\"could not write block %u of %s\",\n\t\t\t\t\t\t\t\tbuf->tag.blockNum, path),\n\t\t\t\t\t\t errdetail(\"Multiple failures --- write error might be permanent.\")))",
          "new_text": "Assert(buf_state & BM_DIRTY)",
          "old_line_content": "\t\t\t\tereport(WARNING,",
          "new_line_content": "\t\t\tAssert(buf_state & BM_DIRTY);",
          "content_same": false
        },
        {
          "line": 4658,
          "old_api": "errcode",
          "new_api": "UnlockBufHdr",
          "old_text": "errcode(ERRCODE_IO_ERROR)",
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": "\t\t\t\t\t\t(errcode(ERRCODE_IO_ERROR),",
          "new_line_content": "\t\t\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4665,
          "old_api": "TerminateBufferIO",
          "new_api": "relpathperm",
          "old_text": "TerminateBufferIO(buf, false, BM_IO_ERROR)",
          "new_text": "relpathperm(buf->tag.rlocator, buf->tag.forkNum)",
          "old_line_content": "\t\tTerminateBufferIO(buf, false, BM_IO_ERROR);",
          "new_line_content": "\t\t\t\tpath = relpathperm(buf->tag.rlocator, buf->tag.forkNum);",
          "content_same": false
        },
        {
          "line": 4752,
          "old_api": "perform_spin_delay",
          "new_api": "init_local_spin_delay",
          "old_text": "perform_spin_delay(&delayStatus)",
          "new_text": "init_local_spin_delay(&delayStatus)",
          "old_line_content": "\t\tperform_spin_delay(&delayStatus);",
          "new_line_content": "\tinit_local_spin_delay(&delayStatus);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 4609,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(buf == InProgressBuf)",
          "old_line_content": "",
          "new_line_content": "\tAssert(buf == InProgressBuf);",
          "content_same": false
        },
        {
          "line": 4613,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(buf_state & BM_IO_IN_PROGRESS)",
          "old_line_content": "\tInProgressBuf = NULL;",
          "new_line_content": "\tAssert(buf_state & BM_IO_IN_PROGRESS);",
          "content_same": false
        },
        {
          "line": 4620,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": " *",
          "new_line_content": "\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4109,
          "old_api": null,
          "new_api": "XLogRecPtrIsInvalid",
          "old_text": null,
          "new_text": "XLogRecPtrIsInvalid(lsn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (!XLogRecPtrIsInvalid(lsn))",
          "content_same": false
        },
        {
          "line": 4110,
          "old_api": null,
          "new_api": "PageSetLSN",
          "old_text": null,
          "new_text": "PageSetLSN(page, lsn)",
          "old_line_content": "\t\tif (dirtied)",
          "new_line_content": "\t\t\t\tPageSetLSN(page, lsn);",
          "content_same": false
        },
        {
          "line": 4624,
          "old_api": null,
          "new_api": "BufferDescriptorGetIOCV",
          "old_text": null,
          "new_text": "BufferDescriptorGetIOCV(buf)",
          "old_line_content": " *\tIf I/O was in progress, we always set BM_IO_ERROR, even though it's",
          "new_line_content": "\tConditionVariableBroadcast(BufferDescriptorGetIOCV(buf));",
          "content_same": false
        },
        {
          "line": 4114,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "\t\t\tif (VacuumCostActive)",
          "new_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 4645,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(buf)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "content_same": false
        },
        {
          "line": 4646,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(buf_state & BM_IO_IN_PROGRESS)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\tAssert(buf_state & BM_IO_IN_PROGRESS);",
          "content_same": false
        },
        {
          "line": 4652,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!(buf_state & BM_VALID))",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tAssert(!(buf_state & BM_VALID));",
          "content_same": false
        },
        {
          "line": 4653,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": "\t\t\t\t/* Buffer is pinned, so we can read tag without spinlock */",
          "new_line_content": "\t\t\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4147,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(buf)",
          "old_line_content": "",
          "new_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "content_same": false
        },
        {
          "line": 4666,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_IO_ERROR),\n\t\t\t\t\t\t errmsg(\"could not write block %u of %s\",\n\t\t\t\t\t\t\t\tbuf->tag.blockNum, path),\n\t\t\t\t\t\t errdetail(\"Multiple failures --- write error might be permanent.\")))",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tereport(WARNING,",
          "content_same": false
        },
        {
          "line": 4667,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_IO_ERROR)",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\t\t\t(errcode(ERRCODE_IO_ERROR),",
          "content_same": false
        },
        {
          "line": 4668,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not write block %u of %s\",\n\t\t\t\t\t\t\t\tbuf->tag.blockNum, path)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t errmsg(\"could not write block %u of %s\",",
          "content_same": false
        },
        {
          "line": 4157,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": "void",
          "new_line_content": "\t\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4670,
          "old_api": null,
          "new_api": "errdetail",
          "old_text": null,
          "new_text": "errdetail(\"Multiple failures --- write error might be permanent.\")",
          "old_line_content": " * Error context callback for errors occurring during shared buffer writes.",
          "new_line_content": "\t\t\t\t\t\t errdetail(\"Multiple failures --- write error might be permanent.\")));",
          "content_same": false
        },
        {
          "line": 4671,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(path)",
          "old_line_content": " */",
          "new_line_content": "\t\t\t\tpfree(path);",
          "content_same": false
        },
        {
          "line": 4674,
          "old_api": null,
          "new_api": "TerminateBufferIO",
          "old_text": null,
          "new_text": "TerminateBufferIO(buf, false, BM_IO_ERROR)",
          "old_line_content": "{",
          "new_line_content": "\t\tTerminateBufferIO(buf, false, BM_IO_ERROR);",
          "content_same": false
        },
        {
          "line": 4172,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\telse if (mode == BUFFER_LOCK_EXCLUSIVE)",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 4689,
          "old_api": null,
          "new_api": "relpathperm",
          "old_text": null,
          "new_text": "relpathperm(bufHdr->tag.rlocator, bufHdr->tag.forkNum)",
          "old_line_content": " * Error context callback for errors occurring during local buffer writes.",
          "new_line_content": "\t\tchar\t   *path = relpathperm(bufHdr->tag.rlocator, bufHdr->tag.forkNum);",
          "content_same": false
        },
        {
          "line": 4178,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(buf)",
          "old_line_content": "/*",
          "new_line_content": "\t\tLWLockRelease(BufferDescriptorGetContentLock(buf));",
          "content_same": false
        },
        {
          "line": 4691,
          "old_api": null,
          "new_api": "errcontext",
          "old_text": null,
          "new_text": "errcontext(\"writing block %u of relation %s\",\n\t\t\t\t   bufHdr->tag.blockNum, path)",
          "old_line_content": "static void",
          "new_line_content": "\t\terrcontext(\"writing block %u of relation %s\",",
          "content_same": false
        },
        {
          "line": 4180,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(buf)",
          "old_line_content": " *",
          "new_line_content": "\t\tLWLockAcquire(BufferDescriptorGetContentLock(buf), LW_SHARED);",
          "content_same": false
        },
        {
          "line": 4693,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(path)",
          "old_line_content": "{",
          "new_line_content": "\t\tpfree(path);",
          "content_same": false
        },
        {
          "line": 4182,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(buf)",
          "old_line_content": " */",
          "new_line_content": "\t\tLWLockAcquire(BufferDescriptorGetContentLock(buf), LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 4184,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"unrecognized buffer lock mode: %d\", mode)",
          "old_line_content": "ConditionalLockBuffer(Buffer buffer)",
          "new_line_content": "\t\telog(ERROR, \"unrecognized buffer lock mode: %d\", mode);",
          "content_same": false
        },
        {
          "line": 4707,
          "old_api": null,
          "new_api": "relpathbackend",
          "old_text": null,
          "new_text": "relpathbackend(bufHdr->tag.rlocator, MyBackendId,\n\t\t\t\t\t\t\t\t\t\t  bufHdr->tag.forkNum)",
          "old_line_content": "/*",
          "new_line_content": "\t\tchar\t   *path = relpathbackend(bufHdr->tag.rlocator, MyBackendId,",
          "content_same": false
        },
        {
          "line": 4197,
          "old_api": null,
          "new_api": "BufferIsPinned",
          "old_text": null,
          "new_text": "BufferIsPinned(buffer)",
          "old_line_content": "",
          "new_line_content": "\tAssert(BufferIsPinned(buffer));",
          "content_same": false
        },
        {
          "line": 4198,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "/*",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 4710,
          "old_api": null,
          "new_api": "errcontext",
          "old_text": null,
          "new_text": "errcontext(\"writing block %u of relation %s\",\n\t\t\t\t   bufHdr->tag.blockNum, path)",
          "old_line_content": "static int",
          "new_line_content": "\t\terrcontext(\"writing block %u of relation %s\",",
          "content_same": false
        },
        {
          "line": 4712,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(path)",
          "old_line_content": "{",
          "new_line_content": "\t\tpfree(path);",
          "content_same": false
        },
        {
          "line": 4201,
          "old_api": null,
          "new_api": "GetBufferDescriptor",
          "old_text": null,
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": " * Items may be deleted from a disk page only when the caller (a) holds an",
          "new_line_content": "\tbuf = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4203,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(buf)",
          "old_line_content": " * holds a pin on the buffer.  If there is a pin, then the other backend",
          "new_line_content": "\treturn LWLockConditionalAcquire(BufferDescriptorGetContentLock(buf),",
          "content_same": false
        },
        {
          "line": 4231,
          "old_api": null,
          "new_api": "BufferIsPinned",
          "old_text": null,
          "new_text": "BufferIsPinned(buffer)",
          "old_line_content": "\t\t/* Nobody else to wait for */",
          "new_line_content": "\tAssert(BufferIsPinned(buffer));",
          "content_same": false
        },
        {
          "line": 4232,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(PinCountWaitBuf == NULL)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\tAssert(PinCountWaitBuf == NULL);",
          "content_same": false
        },
        {
          "line": 4234,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 3724,
          "old_api": null,
          "new_api": "XLogIsNeeded",
          "old_text": null,
          "new_text": "XLogIsNeeded()",
          "old_line_content": "",
          "new_line_content": "\tuse_wal = XLogIsNeeded() && (permanent || forkNum == INIT_FORKNUM);",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": null,
          "new_api": "smgropen",
          "old_text": null,
          "new_text": "smgropen(srclocator, InvalidBackendId)",
          "old_line_content": "\t\t\t\t\t\t  forkNum);",
          "new_line_content": "\tnblocks = smgrnblocks(smgropen(srclocator, InvalidBackendId),",
          "content_same": false
        },
        {
          "line": 4245,
          "old_api": null,
          "new_api": "GetPrivateRefCount",
          "old_text": null,
          "new_text": "GetPrivateRefCount(buffer)",
          "old_line_content": "",
          "new_line_content": "\tif (GetPrivateRefCount(buffer) != 1)",
          "content_same": false
        },
        {
          "line": 4246,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"incorrect local pin count: %d\",\n\t\t\t GetPrivateRefCount(buffer))",
          "old_line_content": "\t\t/* Try to acquire lock */",
          "new_line_content": "\t\telog(ERROR, \"incorrect local pin count: %d\",",
          "content_same": false
        },
        {
          "line": 4757,
          "old_api": null,
          "new_api": "pg_atomic_fetch_or_u32",
          "old_text": null,
          "new_text": "pg_atomic_fetch_or_u32(&desc->state, BM_LOCKED)",
          "old_line_content": "",
          "new_line_content": "\t\told_buf_state = pg_atomic_fetch_or_u32(&desc->state, BM_LOCKED);",
          "content_same": false
        },
        {
          "line": 4249,
          "old_api": null,
          "new_api": "GetBufferDescriptor",
          "old_text": null,
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": "",
          "new_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4761,
          "old_api": null,
          "new_api": "perform_spin_delay",
          "old_text": null,
          "new_text": "perform_spin_delay(&delayStatus)",
          "old_line_content": " *",
          "new_line_content": "\t\tperform_spin_delay(&delayStatus);",
          "content_same": false
        },
        {
          "line": 4763,
          "old_api": null,
          "new_api": "finish_spin_delay",
          "old_text": null,
          "new_text": "finish_spin_delay(&delayStatus)",
          "old_line_content": " * this is primarily useful in CAS style loops.",
          "new_line_content": "\tfinish_spin_delay(&delayStatus);",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(buf.data, 0, BLCKSZ)",
          "old_line_content": "\tfor (blkno = 0; blkno < nblocks; blkno++)",
          "new_line_content": "\tmemset(buf.data, 0, BLCKSZ);",
          "content_same": false
        },
        {
          "line": 3739,
          "old_api": null,
          "new_api": "smgropen",
          "old_text": null,
          "new_text": "smgropen(dstlocator, InvalidBackendId)",
          "old_line_content": "\t{",
          "new_line_content": "\tsmgrextend(smgropen(dstlocator, InvalidBackendId), forkNum, nblocks - 1,",
          "content_same": false
        },
        {
          "line": 4256,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\tLockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 4257,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(bufHdr)",
          "old_line_content": "\t\t\t * Emit the log message if recovery conflict on buffer pin was",
          "new_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": null,
          "new_api": "GetAccessStrategy",
          "old_text": null,
          "new_text": "GetAccessStrategy(BAS_BULKWRITE)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_src,",
          "new_line_content": "\tbstrategy_dst = GetAccessStrategy(BAS_BULKWRITE);",
          "content_same": false
        },
        {
          "line": 4259,
          "old_api": null,
          "new_api": "BUF_STATE_GET_REFCOUNT",
          "old_text": null,
          "new_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "old_line_content": "\t\t\t * deadlock_timeout for it.",
          "new_line_content": "\t\tAssert(BUF_STATE_GET_REFCOUNT(buf_state) > 0);",
          "content_same": false
        },
        {
          "line": 4260,
          "old_api": null,
          "new_api": "BUF_STATE_GET_REFCOUNT",
          "old_text": null,
          "new_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\tif (BUF_STATE_GET_REFCOUNT(buf_state) == 1)",
          "content_same": false
        },
        {
          "line": 3749,
          "old_api": null,
          "new_api": "CHECK_FOR_INTERRUPTS",
          "old_text": null,
          "new_text": "CHECK_FOR_INTERRUPTS()",
          "old_line_content": "\t\t/* Use P_NEW to extend the destination relation. */",
          "new_line_content": "\t\tCHECK_FOR_INTERRUPTS();",
          "content_same": false
        },
        {
          "line": 3752,
          "old_api": null,
          "new_api": "ReadBufferWithoutRelcache",
          "old_text": null,
          "new_text": "ReadBufferWithoutRelcache(srclocator, forkNum, blkno,\n\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_src,\n\t\t\t\t\t\t\t\t\t\t   permanent)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t   permanent);",
          "new_line_content": "\t\tsrcBuf = ReadBufferWithoutRelcache(srclocator, forkNum, blkno,",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(srcBuf, BUFFER_LOCK_SHARE)",
          "old_line_content": "",
          "new_line_content": "\t\tLockBuffer(srcBuf, BUFFER_LOCK_SHARE);",
          "content_same": false
        },
        {
          "line": 4780,
          "old_api": null,
          "new_api": "init_local_spin_delay",
          "old_text": null,
          "new_text": "init_local_spin_delay(&delayStatus)",
          "old_line_content": "",
          "new_line_content": "\tinit_local_spin_delay(&delayStatus);",
          "content_same": false
        },
        {
          "line": 4782,
          "old_api": null,
          "new_api": "pg_atomic_read_u32",
          "old_text": null,
          "new_text": "pg_atomic_read_u32(&buf->state)",
          "old_line_content": "",
          "new_line_content": "\tbuf_state = pg_atomic_read_u32(&buf->state);",
          "content_same": false
        },
        {
          "line": 4271,
          "old_api": null,
          "new_api": "LogRecoveryConflict",
          "old_text": null,
          "new_text": "LogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,\n\t\t\t\t\t\t\t\t\twaitStart, GetCurrentTimestamp(),\n\t\t\t\t\t\t\t\t\tNULL, false)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tLogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,",
          "content_same": false
        },
        {
          "line": 4272,
          "old_api": null,
          "new_api": "GetCurrentTimestamp",
          "old_text": null,
          "new_text": "GetCurrentTimestamp()",
          "old_line_content": "\t\t\treturn;",
          "new_line_content": "\t\t\t\t\t\t\t\t\twaitStart, GetCurrentTimestamp(),",
          "content_same": false
        },
        {
          "line": 4786,
          "old_api": null,
          "new_api": "perform_spin_delay",
          "old_text": null,
          "new_text": "perform_spin_delay(&delayStatus)",
          "old_line_content": "/*",
          "new_line_content": "\t\tperform_spin_delay(&delayStatus);",
          "content_same": false
        },
        {
          "line": 4787,
          "old_api": null,
          "new_api": "pg_atomic_read_u32",
          "old_text": null,
          "new_text": "pg_atomic_read_u32(&buf->state)",
          "old_line_content": " * BufferTag comparator.",
          "new_line_content": "\t\tbuf_state = pg_atomic_read_u32(&buf->state);",
          "content_same": false
        },
        {
          "line": 3762,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(dstBuf, BUFFER_LOCK_EXCLUSIVE)",
          "old_line_content": "\t\t/* WAL-log the copied page. */",
          "new_line_content": "\t\tLockBuffer(dstBuf, BUFFER_LOCK_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3763,
          "old_api": null,
          "new_api": "BufferGetPage",
          "old_text": null,
          "new_text": "BufferGetPage(dstBuf)",
          "old_line_content": "\t\tif (use_wal)",
          "new_line_content": "\t\tdstPage = BufferGetPage(dstBuf);",
          "content_same": false
        },
        {
          "line": 4790,
          "old_api": null,
          "new_api": "finish_spin_delay",
          "old_text": null,
          "new_text": "finish_spin_delay(&delayStatus)",
          "old_line_content": "buffertag_comparator(const BufferTag *ba, const BufferTag *bb)",
          "new_line_content": "\tfinish_spin_delay(&delayStatus);",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": null,
          "new_api": "START_CRIT_SECTION",
          "old_text": null,
          "new_text": "START_CRIT_SECTION()",
          "old_line_content": "",
          "new_line_content": "\t\tSTART_CRIT_SECTION();",
          "content_same": false
        },
        {
          "line": 3773,
          "old_api": null,
          "new_api": "log_newpage_buffer",
          "old_text": null,
          "new_text": "log_newpage_buffer(dstBuf, true)",
          "old_line_content": "/* ---------------------------------------------------------------------",
          "new_line_content": "\t\t\tlog_newpage_buffer(dstBuf, true);",
          "content_same": false
        },
        {
          "line": 4286,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "",
          "new_line_content": "\t\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 4287,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "old_line_content": "\t\t/* Wait to be signaled by UnpinBuffer() */",
          "new_line_content": "\t\t\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "content_same": false
        },
        {
          "line": 4288,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"multiple backends attempting to wait for pincount 1\")",
          "old_line_content": "\t\tif (InHotStandby)",
          "new_line_content": "\t\t\telog(ERROR, \"multiple backends attempting to wait for pincount 1\");",
          "content_same": false
        },
        {
          "line": 3775,
          "old_api": null,
          "new_api": "END_CRIT_SECTION",
          "old_text": null,
          "new_text": "END_CRIT_SECTION()",
          "old_line_content": " *",
          "new_line_content": "\t\tEND_CRIT_SECTION();",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": null,
          "new_api": "UnlockReleaseBuffer",
          "old_text": null,
          "new_text": "UnlockReleaseBuffer(dstBuf)",
          "old_line_content": " *\t\tsource relation to the destination.",
          "new_line_content": "\t\tUnlockReleaseBuffer(dstBuf);",
          "content_same": false
        },
        {
          "line": 4803,
          "old_api": null,
          "new_api": "rlocator_comparator",
          "old_text": null,
          "new_text": "rlocator_comparator(&ba->rlocator, &bb->rlocator)",
          "old_line_content": "",
          "new_line_content": "\tret = rlocator_comparator(&ba->rlocator, &bb->rlocator);",
          "content_same": false
        },
        {
          "line": 3778,
          "old_api": null,
          "new_api": "UnlockReleaseBuffer",
          "old_text": null,
          "new_text": "UnlockReleaseBuffer(srcBuf)",
          "old_line_content": " *",
          "new_line_content": "\t\tUnlockReleaseBuffer(srcBuf);",
          "content_same": false
        },
        {
          "line": 4293,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "\t\t\t\tconst char *old_status;",
          "new_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 4294,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "old_line_content": "\t\t\t\tint\t\t\tlen;",
          "new_line_content": "\t\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "content_same": false
        },
        {
          "line": 4305,
          "old_api": null,
          "new_api": "get_ps_display",
          "old_text": null,
          "new_text": "get_ps_display(&len)",
          "old_line_content": "\t\t\t * Emit the log message if the startup process is waiting longer",
          "new_line_content": "\t\t\t\told_status = get_ps_display(&len);",
          "content_same": false
        },
        {
          "line": 4306,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(len + 8 + 1)",
          "old_line_content": "\t\t\t * than deadlock_timeout for recovery conflict on buffer pin.",
          "new_line_content": "\t\t\t\tnew_status = (char *) palloc(len + 8 + 1);",
          "content_same": false
        },
        {
          "line": 4307,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(new_status, old_status, len)",
          "old_line_content": "\t\t\t *",
          "new_line_content": "\t\t\t\tmemcpy(new_status, old_status, len);",
          "content_same": false
        },
        {
          "line": 4308,
          "old_api": null,
          "new_api": "strcpy",
          "old_text": null,
          "new_text": "strcpy(new_status + len, \" waiting\")",
          "old_line_content": "\t\t\t * Skip this if first time through because the startup process has",
          "new_line_content": "\t\t\t\tstrcpy(new_status + len, \" waiting\");",
          "content_same": false
        },
        {
          "line": 4309,
          "old_api": null,
          "new_api": "set_ps_display",
          "old_text": null,
          "new_text": "set_ps_display(new_status)",
          "old_line_content": "\t\t\t * not started waiting yet in this case. So, the wait start",
          "new_line_content": "\t\t\t\tset_ps_display(new_status);",
          "content_same": false
        },
        {
          "line": 3810,
          "old_api": null,
          "new_api": "RelationCreateStorage",
          "old_text": null,
          "new_text": "RelationCreateStorage(dst_rlocator, relpersistence, false)",
          "old_line_content": "\t{",
          "new_line_content": "\tRelationCreateStorage(dst_rlocator, relpersistence, false);",
          "content_same": false
        },
        {
          "line": 4323,
          "old_api": null,
          "new_api": "GetCurrentTimestamp",
          "old_text": null,
          "new_text": "GetCurrentTimestamp()",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tTimestampTz now = GetCurrentTimestamp();",
          "content_same": false
        },
        {
          "line": 4325,
          "old_api": null,
          "new_api": "TimestampDifferenceExceeds",
          "old_text": null,
          "new_text": "TimestampDifferenceExceeds(waitStart, now,\n\t\t\t\t\t\t\t\t\t\t\t   DeadlockTimeout)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\t\tif (TimestampDifferenceExceeds(waitStart, now,",
          "content_same": false
        },
        {
          "line": 4328,
          "old_api": null,
          "new_api": "LogRecoveryConflict",
          "old_text": null,
          "new_text": "LogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,\n\t\t\t\t\t\t\t\t\t\twaitStart, now, NULL, true)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t\t\tLogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,",
          "content_same": false
        },
        {
          "line": 3822,
          "old_api": null,
          "new_api": "smgropen",
          "old_text": null,
          "new_text": "smgropen(dst_rlocator, InvalidBackendId)",
          "old_line_content": "\t\t\t/* Copy a fork's data, block by block. */",
          "new_line_content": "\t\t\tsmgrcreate(smgropen(dst_rlocator, InvalidBackendId), forkNum, false);",
          "content_same": false
        },
        {
          "line": 4339,
          "old_api": null,
          "new_api": "GetCurrentTimestamp",
          "old_text": null,
          "new_text": "GetCurrentTimestamp()",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\t\twaitStart = GetCurrentTimestamp();",
          "content_same": false
        },
        {
          "line": 3829,
          "old_api": null,
          "new_api": "log_smgrcreate",
          "old_text": null,
          "new_text": "log_smgrcreate(&dst_rlocator, forkNum)",
          "old_line_content": "\trlocator.backend = InvalidBackendId;",
          "new_line_content": "\t\t\t\tlog_smgrcreate(&dst_rlocator, forkNum);",
          "content_same": false
        },
        {
          "line": 4342,
          "old_api": null,
          "new_api": "SetStartupBufferPinWaitBufId",
          "old_text": null,
          "new_text": "SetStartupBufferPinWaitBufId(buffer - 1)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tSetStartupBufferPinWaitBufId(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4344,
          "old_api": null,
          "new_api": "ResolveRecoveryConflictWithBufferPin",
          "old_text": null,
          "new_text": "ResolveRecoveryConflictWithBufferPin()",
          "old_line_content": "\t\t * anymore, but ProcWaitForSignal() can return for other signals as",
          "new_line_content": "\t\t\tResolveRecoveryConflictWithBufferPin();",
          "content_same": false
        },
        {
          "line": 4346,
          "old_api": null,
          "new_api": "SetStartupBufferPinWaitBufId",
          "old_text": null,
          "new_text": "SetStartupBufferPinWaitBufId(-1)",
          "old_line_content": "\t\t * theoretically another backend could have started waiting. That's",
          "new_line_content": "\t\t\tSetStartupBufferPinWaitBufId(-1);",
          "content_same": false
        },
        {
          "line": 4349,
          "old_api": null,
          "new_api": "ProcWaitForSignal",
          "old_text": null,
          "new_text": "ProcWaitForSignal(PG_WAIT_BUFFER_PIN)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\tProcWaitForSignal(PG_WAIT_BUFFER_PIN);",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": null,
          "new_api": "smgrcloserellocator",
          "old_text": null,
          "new_text": "smgrcloserellocator(rlocator)",
          "old_line_content": " *\t\tThis function writes all dirty pages of a database out to disk",
          "new_line_content": "\tsmgrcloserellocator(rlocator);",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": null,
          "new_api": "smgrcloserellocator",
          "old_text": null,
          "new_text": "smgrcloserellocator(rlocator)",
          "old_line_content": " *",
          "new_line_content": "\tsmgrcloserellocator(rlocator);",
          "content_same": false
        },
        {
          "line": 4359,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(bufHdr)",
          "old_line_content": "}",
          "new_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "content_same": false
        },
        {
          "line": 4363,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": " * process requests cancellation of all pin holders that are blocking it.",
          "new_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 4884,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(*max_pending <= WRITEBACK_MAX_PENDING_FLUSHES)",
          "old_line_content": "void",
          "new_line_content": "\tAssert(*max_pending <= WRITEBACK_MAX_PENDING_FLUSHES);",
          "content_same": false
        },
        {
          "line": 4377,
          "old_api": null,
          "new_api": "GetStartupBufferPinWaitBufId",
          "old_text": null,
          "new_text": "GetStartupBufferPinWaitBufId()",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\tint\t\t\tbufid = GetStartupBufferPinWaitBufId();",
          "content_same": false
        },
        {
          "line": 3869,
          "old_api": null,
          "new_api": "ResourceOwnerEnlargeBuffers",
          "old_text": null,
          "new_text": "ResourceOwnerEnlargeBuffers(CurrentResourceOwner)",
          "old_line_content": "\t\t * As in DropRelationBuffers, an unlocked precheck should be",
          "new_line_content": "\tResourceOwnerEnlargeBuffers(CurrentResourceOwner);",
          "content_same": false
        },
        {
          "line": 4388,
          "old_api": null,
          "new_api": "GetPrivateRefCount",
          "old_text": null,
          "new_text": "GetPrivateRefCount(bufid + 1)",
          "old_line_content": " * We won't loop, but just check once to see if the pin count is OK.  If",
          "new_line_content": "\tif (GetPrivateRefCount(bufid + 1) > 0)",
          "content_same": false
        },
        {
          "line": 4904,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(*context->max_pending <= WRITEBACK_MAX_PENDING_FLUSHES)",
          "old_line_content": "\t * includes the case where previously an item has been added, but control",
          "new_line_content": "\t\tAssert(*context->max_pending <= WRITEBACK_MAX_PENDING_FLUSHES);",
          "content_same": false
        },
        {
          "line": 3886,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(bufHdr)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": null,
          "new_api": "PinBuffer_Locked",
          "old_text": null,
          "new_text": "PinBuffer_Locked(bufHdr)",
          "old_line_content": "}",
          "new_line_content": "\t\t\tPinBuffer_Locked(bufHdr);",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(bufHdr)",
          "old_line_content": "",
          "new_line_content": "\t\t\tLWLockAcquire(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);",
          "content_same": false
        },
        {
          "line": 3892,
          "old_api": null,
          "new_api": "FlushBuffer",
          "old_text": null,
          "new_text": "FlushBuffer(bufHdr, NULL)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\tFlushBuffer(bufHdr, NULL);",
          "content_same": false
        },
        {
          "line": 4917,
          "old_api": null,
          "new_api": "IssuePendingWritebacks",
          "old_text": null,
          "new_text": "IssuePendingWritebacks(context)",
          "old_line_content": "",
          "new_line_content": "\t\tIssuePendingWritebacks(context);",
          "content_same": false
        },
        {
          "line": 3893,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(bufHdr)",
          "old_line_content": " * Flush a previously, shared or exclusively, locked and pinned buffer to the",
          "new_line_content": "\t\t\tLWLockRelease(BufferDescriptorGetContentLock(bufHdr));",
          "content_same": false
        },
        {
          "line": 4407,
          "old_api": null,
          "new_api": "BufferIsValid",
          "old_text": null,
          "new_text": "BufferIsValid(buffer)",
          "old_line_content": "\t\t/* Nobody else to wait for */",
          "new_line_content": "\tAssert(BufferIsValid(buffer));",
          "content_same": false
        },
        {
          "line": 3894,
          "old_api": null,
          "new_api": "UnpinBuffer",
          "old_text": null,
          "new_text": "UnpinBuffer(bufHdr, true)",
          "old_line_content": " * OS.",
          "new_line_content": "\t\t\tUnpinBuffer(bufHdr, true);",
          "content_same": false
        },
        {
          "line": 4409,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\t}",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "FlushOneBuffer(Buffer buffer)",
          "new_line_content": "\t\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 3911,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "}",
          "new_line_content": "\tAssert(!BufferIsLocal(buffer));",
          "content_same": false
        },
        {
          "line": 3913,
          "old_api": null,
          "new_api": "BufferIsPinned",
          "old_text": null,
          "new_text": "BufferIsPinned(buffer)",
          "old_line_content": "/*",
          "new_line_content": "\tAssert(BufferIsPinned(buffer));",
          "content_same": false
        },
        {
          "line": 4427,
          "old_api": null,
          "new_api": "ConditionalLockBuffer",
          "old_text": null,
          "new_text": "ConditionalLockBuffer(buffer)",
          "old_line_content": "\t{",
          "new_line_content": "\tif (!ConditionalLockBuffer(buffer))",
          "content_same": false
        },
        {
          "line": 3915,
          "old_api": null,
          "new_api": "GetBufferDescriptor",
          "old_text": null,
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": " */",
          "new_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 3917,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(bufHdr)",
          "old_line_content": "ReleaseBuffer(Buffer buffer)",
          "new_line_content": "\tAssert(LWLockHeldByMe(BufferDescriptorGetContentLock(bufHdr)));",
          "content_same": false
        },
        {
          "line": 4430,
          "old_api": null,
          "new_api": "GetBufferDescriptor",
          "old_text": null,
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": "\t\treturn true;",
          "new_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4431,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(bufHdr)",
          "old_line_content": "\t}",
          "new_line_content": "\tbuf_state = LockBufHdr(bufHdr);",
          "content_same": false
        },
        {
          "line": 4432,
          "old_api": null,
          "new_api": "BUF_STATE_GET_REFCOUNT",
          "old_text": null,
          "new_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "old_line_content": "",
          "new_line_content": "\trefcount = BUF_STATE_GET_REFCOUNT(buf_state);",
          "content_same": false
        },
        {
          "line": 4946,
          "old_api": null,
          "new_api": "sort_pending_writebacks",
          "old_text": null,
          "new_text": "sort_pending_writebacks(context->pending_writebacks, context->nr_pending)",
          "old_line_content": "\t\tPendingWriteback *cur;",
          "new_line_content": "\tsort_pending_writebacks(context->pending_writebacks, context->nr_pending);",
          "content_same": false
        },
        {
          "line": 4438,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "",
          "new_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": null,
          "new_api": "BufferIsValid",
          "old_text": null,
          "new_text": "BufferIsValid(buffer)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\tif (!BufferIsValid(buffer))",
          "content_same": false
        },
        {
          "line": 3929,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"bad buffer ID: %d\", buffer)",
          "old_line_content": "\t}",
          "new_line_content": "\t\telog(ERROR, \"bad buffer ID: %d\", buffer);",
          "content_same": false
        },
        {
          "line": 4443,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": " * locked.  If we observe that the pin count is 1, our exclusive lock",
          "new_line_content": "\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 4444,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "old_line_content": " * happens to be a cleanup lock, and we can proceed with anything that",
          "new_line_content": "\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": null,
          "new_api": "ResourceOwnerForgetBuffer",
          "old_text": null,
          "new_text": "ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer)",
          "old_line_content": "",
          "new_line_content": "\t\tResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(LocalRefCount[-buffer - 1] > 0)",
          "old_line_content": " * UnlockReleaseBuffer -- release the content lock and pin on a buffer",
          "new_line_content": "\t\tAssert(LocalRefCount[-buffer - 1] > 0);",
          "content_same": false
        },
        {
          "line": 3940,
          "old_api": null,
          "new_api": "GetBufferDescriptor",
          "old_text": null,
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": "UnlockReleaseBuffer(Buffer buffer)",
          "new_line_content": "\tUnpinBuffer(GetBufferDescriptor(buffer - 1), true);",
          "content_same": false
        },
        {
          "line": 4462,
          "old_api": null,
          "new_api": "BufferIsValid",
          "old_text": null,
          "new_text": "BufferIsValid(buffer)",
          "old_line_content": "\t}",
          "new_line_content": "\tAssert(BufferIsValid(buffer));",
          "content_same": false
        },
        {
          "line": 4974,
          "old_api": null,
          "new_api": "RelFileLocatorEquals",
          "old_text": null,
          "new_text": "RelFileLocatorEquals(cur->tag.rlocator, next->tag.rlocator)",
          "old_line_content": "\t\t\tif (cur->tag.blockNum + 1 != next->tag.blockNum)",
          "new_line_content": "\t\t\tif (!RelFileLocatorEquals(cur->tag.rlocator, next->tag.rlocator) ||",
          "content_same": false
        },
        {
          "line": 4464,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\t/* There should be exactly one local pin */",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 3951,
          "old_api": null,
          "new_api": "LockBuffer",
          "old_text": null,
          "new_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "old_line_content": " *\t\tThis function cannot be used on a buffer we do not have pinned,",
          "new_line_content": "\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "content_same": false
        },
        {
          "line": 3952,
          "old_api": null,
          "new_api": "ReleaseBuffer",
          "old_text": null,
          "new_text": "ReleaseBuffer(buffer)",
          "old_line_content": " *\t\tbecause it doesn't change the shared buffer state.",
          "new_line_content": "\tReleaseBuffer(buffer);",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": null,
          "new_api": "ResourceOwnerEnlargeBuffers",
          "old_text": null,
          "new_text": "ResourceOwnerEnlargeBuffers(CurrentResourceOwner)",
          "old_line_content": "\t\tref->refcount++;",
          "new_line_content": "\tResourceOwnerEnlargeBuffers(CurrentResourceOwner);",
          "content_same": false
        },
        {
          "line": 3968,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\t}",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 4993,
          "old_api": null,
          "new_api": "smgropen",
          "old_text": null,
          "new_text": "smgropen(tag.rlocator, InvalidBackendId)",
          "old_line_content": " * Implement slower/larger portions of TestForOldSnapshot",
          "new_line_content": "\t\treln = smgropen(tag.rlocator, InvalidBackendId);",
          "content_same": false
        },
        {
          "line": 4994,
          "old_api": null,
          "new_api": "smgrwriteback",
          "old_text": null,
          "new_text": "smgrwriteback(reln, tag.forkNum, tag.blockNum, nblocks)",
          "old_line_content": " *",
          "new_line_content": "\t\tsmgrwriteback(reln, tag.forkNum, tag.blockNum, nblocks);",
          "content_same": false
        },
        {
          "line": 4483,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(bufHdr)",
          "old_line_content": "",
          "new_line_content": "\tbuf_state = LockBufHdr(bufHdr);",
          "content_same": false
        },
        {
          "line": 4485,
          "old_api": null,
          "new_api": "BUF_STATE_GET_REFCOUNT",
          "old_text": null,
          "new_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "old_line_content": "\treturn false;",
          "new_line_content": "\tAssert(BUF_STATE_GET_REFCOUNT(buf_state) > 0);",
          "content_same": false
        },
        {
          "line": 4486,
          "old_api": null,
          "new_api": "BUF_STATE_GET_REFCOUNT",
          "old_text": null,
          "new_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "old_line_content": "}",
          "new_line_content": "\tif (BUF_STATE_GET_REFCOUNT(buf_state) == 1)",
          "content_same": false
        },
        {
          "line": 3974,
          "old_api": null,
          "new_api": "GetPrivateRefCountEntry",
          "old_text": null,
          "new_text": "GetPrivateRefCountEntry(buffer, true)",
          "old_line_content": " *",
          "new_line_content": "\t\tref = GetPrivateRefCountEntry(buffer, true);",
          "content_same": false
        },
        {
          "line": 3975,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(ref != NULL)",
          "old_line_content": " *\tMark a buffer dirty for non-critical changes.",
          "new_line_content": "\t\tAssert(ref != NULL);",
          "content_same": false
        },
        {
          "line": 4489,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": "/*",
          "new_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 3978,
          "old_api": null,
          "new_api": "ResourceOwnerRememberBuffer",
          "old_text": null,
          "new_text": "ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer)",
          "old_line_content": " *",
          "new_line_content": "\tResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);",
          "content_same": false
        },
        {
          "line": 4493,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(bufHdr, buf_state)",
          "old_line_content": " *\ti.e at most one BM_IO_IN_PROGRESS bit is set per proc.",
          "new_line_content": "\tUnlockBufHdr(bufHdr, buf_state);",
          "content_same": false
        },
        {
          "line": 5010,
          "old_api": null,
          "new_api": "RelationAllowsEarlyPruning",
          "old_text": null,
          "new_text": "RelationAllowsEarlyPruning(relation)",
          "old_line_content": "",
          "new_line_content": "\tif (RelationAllowsEarlyPruning(relation)",
          "content_same": false
        },
        {
          "line": 5011,
          "old_api": null,
          "new_api": "GetOldSnapshotThresholdTimestamp",
          "old_text": null,
          "new_text": "GetOldSnapshotThresholdTimestamp()",
          "old_line_content": "",
          "new_line_content": "\t\t&& (snapshot)->whenTaken < GetOldSnapshotThresholdTimestamp())",
          "content_same": false
        },
        {
          "line": 5012,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SNAPSHOT_TOO_OLD),\n\t\t\t\t errmsg(\"snapshot too old\")))",
          "old_line_content": "",
          "new_line_content": "\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 5013,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_SNAPSHOT_TOO_OLD)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t(errcode(ERRCODE_SNAPSHOT_TOO_OLD),",
          "content_same": false
        },
        {
          "line": 5014,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"snapshot too old\")",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t errmsg(\"snapshot too old\")));",
          "content_same": false
        },
        {
          "line": 3999,
          "old_api": null,
          "new_api": "BufferGetPage",
          "old_text": null,
          "new_text": "BufferGetPage(buffer)",
          "old_line_content": "\t}",
          "new_line_content": "\tPage\t\tpage = BufferGetPage(buffer);",
          "content_same": false
        },
        {
          "line": 4513,
          "old_api": null,
          "new_api": "BufferDescriptorGetIOCV",
          "old_text": null,
          "new_text": "BufferDescriptorGetIOCV(buf)",
          "old_line_content": "\t\t * here, but since this test is essential for correctness, we'd better",
          "new_line_content": "\tConditionVariable *cv = BufferDescriptorGetIOCV(buf);",
          "content_same": false
        },
        {
          "line": 4002,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"bad buffer ID: %d\", buffer)",
          "old_line_content": "",
          "new_line_content": "\t\telog(ERROR, \"bad buffer ID: %d\", buffer);",
          "content_same": false
        },
        {
          "line": 4515,
          "old_api": null,
          "new_api": "ConditionVariablePrepareToSleep",
          "old_text": null,
          "new_text": "ConditionVariablePrepareToSleep(cv)",
          "old_line_content": "\t\t */",
          "new_line_content": "\tConditionVariablePrepareToSleep(cv);",
          "content_same": false
        },
        {
          "line": 4004,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\t/* here, either share or exclusive lock is OK */",
          "new_line_content": "\tif (BufferIsLocal(buffer))",
          "content_same": false
        },
        {
          "line": 4006,
          "old_api": null,
          "new_api": "MarkLocalBufferDirty",
          "old_text": null,
          "new_text": "MarkLocalBufferDirty(buffer)",
          "old_line_content": "",
          "new_line_content": "\t\tMarkLocalBufferDirty(buffer);",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": null,
          "new_api": "GetBufferDescriptor",
          "old_text": null,
          "new_text": "GetBufferDescriptor(buffer - 1)",
          "old_line_content": "\t * tuples. So, be as quick as we can if the buffer is already dirty.  We",
          "new_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "content_same": false
        },
        {
          "line": 4012,
          "old_api": null,
          "new_api": "GetPrivateRefCount",
          "old_text": null,
          "new_text": "GetPrivateRefCount(buffer)",
          "old_line_content": "\t * already set.  Since we make this test unlocked, there's a chance we",
          "new_line_content": "\tAssert(GetPrivateRefCount(buffer) > 0);",
          "content_same": false
        },
        {
          "line": 4525,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(buf)",
          "old_line_content": "",
          "new_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "content_same": false
        },
        {
          "line": 4526,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": "/*",
          "new_line_content": "\t\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4014,
          "old_api": null,
          "new_api": "BufferDescriptorGetContentLock",
          "old_text": null,
          "new_text": "BufferDescriptorGetContentLock(bufHdr)",
          "old_line_content": "\t * to reset them, due to memory-ordering issues.  But since this function",
          "new_line_content": "\tAssert(LWLockHeldByMe(BufferDescriptorGetContentLock(bufHdr)));",
          "content_same": false
        },
        {
          "line": 4530,
          "old_api": null,
          "new_api": "ConditionVariableSleep",
          "old_text": null,
          "new_text": "ConditionVariableSleep(cv, WAIT_EVENT_BUFFER_IO)",
          "old_line_content": " *\tThe buffer is Pinned",
          "new_line_content": "\t\tConditionVariableSleep(cv, WAIT_EVENT_BUFFER_IO);",
          "content_same": false
        },
        {
          "line": 4532,
          "old_api": null,
          "new_api": "ConditionVariableCancelSleep",
          "old_text": null,
          "new_text": "ConditionVariableCancelSleep()",
          "old_line_content": " * In some scenarios there are race conditions in which multiple backends",
          "new_line_content": "\tConditionVariableCancelSleep();",
          "content_same": false
        },
        {
          "line": 4027,
          "old_api": null,
          "new_api": "pg_atomic_read_u32",
          "old_text": null,
          "new_text": "pg_atomic_read_u32(&bufHdr->state)",
          "old_line_content": "\t\t * If we need to protect hint bit updates from torn writes, WAL-log a",
          "new_line_content": "\tif ((pg_atomic_read_u32(&bufHdr->state) & (BM_DIRTY | BM_JUST_DIRTIED)) !=",
          "content_same": false
        },
        {
          "line": 4044,
          "old_api": null,
          "new_api": "XLogHintBitIsNeeded",
          "old_text": null,
          "new_text": "XLogHintBitIsNeeded()",
          "old_line_content": "\t\t\t * See src/backend/storage/page/README for longer discussion.",
          "new_line_content": "\t\tif (XLogHintBitIsNeeded() &&",
          "content_same": false
        },
        {
          "line": 4045,
          "old_api": null,
          "new_api": "pg_atomic_read_u32",
          "old_text": null,
          "new_text": "pg_atomic_read_u32(&bufHdr->state)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t(pg_atomic_read_u32(&bufHdr->state) & BM_PERMANENT))",
          "content_same": false
        },
        {
          "line": 4562,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(buf)",
          "old_line_content": "",
          "new_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "content_same": false
        },
        {
          "line": 4567,
          "old_api": null,
          "new_api": "WaitIO",
          "old_text": null,
          "new_text": "WaitIO(buf)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\t\tWaitIO(buf);",
          "content_same": false
        },
        {
          "line": 4055,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\t\t\t * bits would reduce the call rate...",
          "new_line_content": "\t\t\tif (RecoveryInProgress() ||",
          "content_same": false
        },
        {
          "line": 4056,
          "old_api": null,
          "new_api": "RelFileLocatorSkippingWAL",
          "old_text": null,
          "new_text": "RelFileLocatorSkippingWAL(bufHdr->tag.rlocator)",
          "old_line_content": "\t\t\t *",
          "new_line_content": "\t\t\t\tRelFileLocatorSkippingWAL(bufHdr->tag.rlocator))",
          "content_same": false
        },
        {
          "line": 4575,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": "",
          "new_line_content": "\t\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4580,
          "old_api": null,
          "new_api": "UnlockBufHdr",
          "old_text": null,
          "new_text": "UnlockBufHdr(buf, buf_state)",
          "old_line_content": " * TerminateBufferIO: release a buffer we were doing I/O on",
          "new_line_content": "\tUnlockBufHdr(buf, buf_state);",
          "content_same": false
        },
        {
          "line": 4082,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert((MyProc->delayChkptFlags & DELAY_CHKPT_START) == 0)",
          "old_line_content": "",
          "new_line_content": "\t\t\tAssert((MyProc->delayChkptFlags & DELAY_CHKPT_START) == 0);",
          "content_same": false
        },
        {
          "line": 4085,
          "old_api": null,
          "new_api": "XLogSaveBufferForHint",
          "old_text": null,
          "new_text": "XLogSaveBufferForHint(buffer, buffer_std)",
          "old_line_content": "\t\t\tdirtied = true;\t\t/* Means \"will be dirtied by this action\" */",
          "new_line_content": "\t\t\tlsn = XLogSaveBufferForHint(buffer, buffer_std);",
          "content_same": false
        },
        {
          "line": 4088,
          "old_api": null,
          "new_api": "LockBufHdr",
          "old_text": null,
          "new_text": "LockBufHdr(bufHdr)",
          "old_line_content": "\t\t\t * Set the page LSN if we wrote a backup block. We aren't supposed",
          "new_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "content_same": false
        },
        {
          "line": 4090,
          "old_api": null,
          "new_api": "BUF_STATE_GET_REFCOUNT",
          "old_text": null,
          "new_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "old_line_content": "\t\t\t * serialise it somehow we're OK. We choose to set LSN while",
          "new_line_content": "\t\tAssert(BUF_STATE_GET_REFCOUNT(buf_state) > 0);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4100,
          "old_api": "XLogRecPtrIsInvalid",
          "new_api": null,
          "old_text": "XLogRecPtrIsInvalid(lsn)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!XLogRecPtrIsInvalid(lsn))",
          "new_line_content": "\t\t\t * holding the buffer header lock, which causes any reader of an",
          "content_same": false
        },
        {
          "line": 4101,
          "old_api": "PageSetLSN",
          "new_api": null,
          "old_text": "PageSetLSN(page, lsn)",
          "new_text": null,
          "old_line_content": "\t\t\t\tPageSetLSN(page, lsn);",
          "new_line_content": "\t\t\t * LSN who holds only a share lock to also obtain a buffer header",
          "content_same": false
        },
        {
          "line": 4615,
          "old_api": "BufferDescriptorGetIOCV",
          "new_api": null,
          "old_text": "BufferDescriptorGetIOCV(buf)",
          "new_text": null,
          "old_line_content": "\tConditionVariableBroadcast(BufferDescriptorGetIOCV(buf));",
          "new_line_content": "\tbuf_state &= ~(BM_IO_IN_PROGRESS | BM_IO_ERROR);",
          "content_same": false
        },
        {
          "line": 4105,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\t\t\t * If checksums are enabled, you might think we should reset the",
          "content_same": false
        },
        {
          "line": 4636,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(buf)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 4637,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(buf_state & BM_IO_IN_PROGRESS)",
          "new_text": null,
          "old_line_content": "\t\tAssert(buf_state & BM_IO_IN_PROGRESS);",
          "new_line_content": "AbortBufferIO(void)",
          "content_same": false
        },
        {
          "line": 4640,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!(buf_state & BM_DIRTY))",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!(buf_state & BM_DIRTY));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4643,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!(buf_state & BM_VALID))",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!(buf_state & BM_VALID));",
          "new_line_content": "\t\tuint32\t\tbuf_state;",
          "content_same": false
        },
        {
          "line": 4644,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": null,
          "old_line_content": "\t\t\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4648,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(buf_state & BM_DIRTY)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(buf_state & BM_DIRTY);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 4138,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(buf)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 4656,
          "old_api": "relpathperm",
          "new_api": null,
          "old_text": "relpathperm(buf->tag.rlocator, buf->tag.forkNum)",
          "new_text": null,
          "old_line_content": "\t\t\t\tpath = relpathperm(buf->tag.rlocator, buf->tag.forkNum);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 4659,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not write block %u of %s\",\n\t\t\t\t\t\t\t\tbuf->tag.blockNum, path)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t errmsg(\"could not write block %u of %s\",",
          "new_line_content": "\t\t\t/* Issue notice if this is not the first failure... */",
          "content_same": false
        },
        {
          "line": 4148,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4661,
          "old_api": "errdetail",
          "new_api": null,
          "old_text": "errdetail(\"Multiple failures --- write error might be permanent.\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t errdetail(\"Multiple failures --- write error might be permanent.\")));",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 4662,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(path)",
          "new_text": null,
          "old_line_content": "\t\t\t\tpfree(path);",
          "new_line_content": "\t\t\t\t/* Buffer is pinned, so we can read tag without spinlock */",
          "content_same": false
        },
        {
          "line": 4162,
          "old_api": "BufferIsPinned",
          "new_api": null,
          "old_text": "BufferIsPinned(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsPinned(buffer));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4163,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 4166,
          "old_api": "GetBufferDescriptor",
          "new_api": null,
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": null,
          "old_line_content": "\tbuf = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 4680,
          "old_api": "relpathperm",
          "new_api": null,
          "old_text": "relpathperm(bufHdr->tag.rlocator, bufHdr->tag.forkNum)",
          "new_text": null,
          "old_line_content": "\t\tchar\t   *path = relpathperm(bufHdr->tag.rlocator, bufHdr->tag.forkNum);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4169,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(buf)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(BufferDescriptorGetContentLock(buf));",
          "new_line_content": "\tBufferDesc *buf;",
          "content_same": false
        },
        {
          "line": 4682,
          "old_api": "errcontext",
          "new_api": null,
          "old_text": "errcontext(\"writing block %u of relation %s\",\n\t\t\t\t   bufHdr->tag.blockNum, path)",
          "new_text": null,
          "old_line_content": "\t\terrcontext(\"writing block %u of relation %s\",",
          "new_line_content": "shared_buffer_write_error_callback(void *arg)",
          "content_same": false
        },
        {
          "line": 4684,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(path)",
          "new_text": null,
          "old_line_content": "\t\tpfree(path);",
          "new_line_content": "\tBufferDesc *bufHdr = (BufferDesc *) arg;",
          "content_same": false
        },
        {
          "line": 4173,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(buf)",
          "new_text": null,
          "old_line_content": "\t\tLWLockAcquire(BufferDescriptorGetContentLock(buf), LW_EXCLUSIVE);",
          "new_line_content": "\t\treturn;\t\t\t\t\t/* local buffers need no lock */",
          "content_same": false
        },
        {
          "line": 4698,
          "old_api": "relpathbackend",
          "new_api": null,
          "old_text": "relpathbackend(bufHdr->tag.rlocator, MyBackendId,\n\t\t\t\t\t\t\t\t\t\t  bufHdr->tag.forkNum)",
          "new_text": null,
          "old_line_content": "\t\tchar\t   *path = relpathbackend(bufHdr->tag.rlocator, MyBackendId,",
          "new_line_content": " * Error context callback for errors occurring during local buffer writes.",
          "content_same": false
        },
        {
          "line": 4188,
          "old_api": "BufferIsPinned",
          "new_api": null,
          "old_text": "BufferIsPinned(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsPinned(buffer));",
          "new_line_content": " * Acquire the content_lock for the buffer, but only if we don't have to wait.",
          "content_same": false
        },
        {
          "line": 4189,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4701,
          "old_api": "errcontext",
          "new_api": null,
          "old_text": "errcontext(\"writing block %u of relation %s\",\n\t\t\t\t   bufHdr->tag.blockNum, path)",
          "new_text": null,
          "old_line_content": "\t\terrcontext(\"writing block %u of relation %s\",",
          "new_line_content": "local_buffer_write_error_callback(void *arg)",
          "content_same": false
        },
        {
          "line": 4703,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(path)",
          "new_text": null,
          "old_line_content": "\t\tpfree(path);",
          "new_line_content": "\tBufferDesc *bufHdr = (BufferDesc *) arg;",
          "content_same": false
        },
        {
          "line": 4192,
          "old_api": "GetBufferDescriptor",
          "new_api": null,
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": null,
          "old_line_content": "\tbuf = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "bool",
          "content_same": false
        },
        {
          "line": 4194,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(buf)",
          "new_text": null,
          "old_line_content": "\treturn LWLockConditionalAcquire(BufferDescriptorGetContentLock(buf),",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4222,
          "old_api": "BufferIsPinned",
          "new_api": null,
          "old_text": "BufferIsPinned(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsPinned(buffer));",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4223,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(PinCountWaitBuf == NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(PinCountWaitBuf == NULL);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 4225,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4229,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"incorrect local pin count: %d\",\n\t\t\t\t LocalRefCount[-buffer - 1])",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"incorrect local pin count: %d\",",
          "new_line_content": "\tbool\t\tlogged_recovery_conflict = false;",
          "content_same": false
        },
        {
          "line": 4743,
          "old_api": "init_local_spin_delay",
          "new_api": null,
          "old_text": "init_local_spin_delay(&delayStatus)",
          "new_text": null,
          "old_line_content": "\tinit_local_spin_delay(&delayStatus);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3723,
          "old_api": "XLogIsNeeded",
          "new_api": null,
          "old_text": "XLogIsNeeded()",
          "new_text": null,
          "old_line_content": "\tuse_wal = XLogIsNeeded() && (permanent || forkNum == INIT_FORKNUM);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 4236,
          "old_api": "GetPrivateRefCount",
          "new_api": null,
          "old_text": "GetPrivateRefCount(buffer)",
          "new_text": null,
          "old_line_content": "\tif (GetPrivateRefCount(buffer) != 1)",
          "new_line_content": "\t\t/* There should be exactly one pin */",
          "content_same": false
        },
        {
          "line": 4237,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"incorrect local pin count: %d\",\n\t\t\t GetPrivateRefCount(buffer))",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"incorrect local pin count: %d\",",
          "new_line_content": "\t\tif (LocalRefCount[-buffer - 1] != 1)",
          "content_same": false
        },
        {
          "line": 4748,
          "old_api": "pg_atomic_fetch_or_u32",
          "new_api": null,
          "old_text": "pg_atomic_fetch_or_u32(&desc->state, BM_LOCKED)",
          "new_text": null,
          "old_line_content": "\t\told_buf_state = pg_atomic_fetch_or_u32(&desc->state, BM_LOCKED);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3726,
          "old_api": "smgropen",
          "new_api": null,
          "old_text": "smgropen(srclocator, InvalidBackendId)",
          "new_text": null,
          "old_line_content": "\tnblocks = smgrnblocks(smgropen(srclocator, InvalidBackendId),",
          "new_line_content": "\t/* Get number of blocks in the source relation. */",
          "content_same": false
        },
        {
          "line": 4240,
          "old_api": "GetBufferDescriptor",
          "new_api": null,
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": null,
          "old_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "\t\t/* Nobody else to wait for */",
          "content_same": false
        },
        {
          "line": 4754,
          "old_api": "finish_spin_delay",
          "new_api": null,
          "old_text": "finish_spin_delay(&delayStatus)",
          "new_text": null,
          "old_line_content": "\tfinish_spin_delay(&delayStatus);",
          "new_line_content": "\twhile (true)",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": "GetAccessStrategy",
          "new_api": null,
          "old_text": "GetAccessStrategy(BAS_BULKREAD)",
          "new_text": null,
          "old_line_content": "\tbstrategy_src = GetAccessStrategy(BAS_BULKREAD);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 3735,
          "old_api": "GetAccessStrategy",
          "new_api": null,
          "old_text": "GetAccessStrategy(BAS_BULKWRITE)",
          "new_text": null,
          "old_line_content": "\tbstrategy_dst = GetAccessStrategy(BAS_BULKWRITE);",
          "new_line_content": "\t * Bulk extend the destination relation of the same size as the source",
          "content_same": false
        },
        {
          "line": 4248,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(bufHdr)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4250,
          "old_api": "BUF_STATE_GET_REFCOUNT",
          "new_api": null,
          "old_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "new_text": null,
          "old_line_content": "\t\tAssert(BUF_STATE_GET_REFCOUNT(buf_state) > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4251,
          "old_api": "BUF_STATE_GET_REFCOUNT",
          "new_api": null,
          "old_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "new_text": null,
          "old_line_content": "\t\tif (BUF_STATE_GET_REFCOUNT(buf_state) == 1)",
          "new_line_content": "\tfor (;;)",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": "CHECK_FOR_INTERRUPTS",
          "new_api": null,
          "old_text": "CHECK_FOR_INTERRUPTS()",
          "new_text": null,
          "old_line_content": "\t\tCHECK_FOR_INTERRUPTS();",
          "new_line_content": "\t\t\t   buf.data, true);",
          "content_same": false
        },
        {
          "line": 4254,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3746,
          "old_api": "LockBuffer",
          "new_api": null,
          "old_text": "LockBuffer(srcBuf, BUFFER_LOCK_SHARE)",
          "new_text": null,
          "old_line_content": "\t\tLockBuffer(srcBuf, BUFFER_LOCK_SHARE);",
          "new_line_content": "\t/* Iterate over each block of the source relation file. */",
          "content_same": false
        },
        {
          "line": 4771,
          "old_api": "init_local_spin_delay",
          "new_api": null,
          "old_text": "init_local_spin_delay(&delayStatus)",
          "new_text": null,
          "old_line_content": "\tinit_local_spin_delay(&delayStatus);",
          "new_line_content": " * Obviously the buffer could be locked by the time the value is returned, so",
          "content_same": false
        },
        {
          "line": 3747,
          "old_api": "BufferGetPage",
          "new_api": null,
          "old_text": "BufferGetPage(srcBuf)",
          "new_text": null,
          "old_line_content": "\t\tsrcPage = BufferGetPage(srcBuf);",
          "new_line_content": "\tfor (blkno = 0; blkno < nblocks; blkno++)",
          "content_same": false
        },
        {
          "line": 4773,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&buf->state)",
          "new_text": null,
          "old_line_content": "\tbuf_state = pg_atomic_read_u32(&buf->state);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4262,
          "old_api": "LogRecoveryConflict",
          "new_api": null,
          "old_text": "LogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,\n\t\t\t\t\t\t\t\t\twaitStart, GetCurrentTimestamp(),\n\t\t\t\t\t\t\t\t\tNULL, false)",
          "new_text": null,
          "old_line_content": "\t\t\t\tLogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,",
          "new_line_content": "\t\t\t/* Successfully acquired exclusive lock with pincount 1 */",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": "ReadBufferWithoutRelcache",
          "new_api": null,
          "old_text": "ReadBufferWithoutRelcache(dstlocator, forkNum, P_NEW,\n\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_dst,\n\t\t\t\t\t\t\t\t\t\t   permanent)",
          "new_text": null,
          "old_line_content": "\t\tdstBuf = ReadBufferWithoutRelcache(dstlocator, forkNum, P_NEW,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4777,
          "old_api": "perform_spin_delay",
          "new_api": null,
          "old_text": "perform_spin_delay(&delayStatus)",
          "new_text": null,
          "old_line_content": "\t\tperform_spin_delay(&delayStatus);",
          "new_line_content": "\tSpinDelayStatus delayStatus;",
          "content_same": false
        },
        {
          "line": 4778,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&buf->state)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = pg_atomic_read_u32(&buf->state);",
          "new_line_content": "\tuint32\t\tbuf_state;",
          "content_same": false
        },
        {
          "line": 3753,
          "old_api": "LockBuffer",
          "new_api": null,
          "old_text": "LockBuffer(dstBuf, BUFFER_LOCK_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\t\tLockBuffer(dstBuf, BUFFER_LOCK_EXCLUSIVE);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_src,",
          "content_same": false
        },
        {
          "line": 3754,
          "old_api": "BufferGetPage",
          "new_api": null,
          "old_text": "BufferGetPage(dstBuf)",
          "new_text": null,
          "old_line_content": "\t\tdstPage = BufferGetPage(dstBuf);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   permanent);",
          "content_same": false
        },
        {
          "line": 4269,
          "old_api": "set_ps_display",
          "new_api": null,
          "old_text": "set_ps_display(new_status)",
          "new_text": null,
          "old_line_content": "\t\t\t\tset_ps_display(new_status);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 4270,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(new_status)",
          "new_text": null,
          "old_line_content": "\t\t\t\tpfree(new_status);",
          "new_line_content": "\t\t\tif (logged_recovery_conflict)",
          "content_same": false
        },
        {
          "line": 4781,
          "old_api": "finish_spin_delay",
          "new_api": null,
          "old_text": "finish_spin_delay(&delayStatus)",
          "new_text": null,
          "old_line_content": "\tfinish_spin_delay(&delayStatus);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "MarkBufferDirty",
          "new_api": null,
          "old_text": "MarkBufferDirty(dstBuf)",
          "new_text": null,
          "old_line_content": "\t\tMarkBufferDirty(dstBuf);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   RBM_NORMAL, bstrategy_dst,",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": "log_newpage_buffer",
          "new_api": null,
          "old_text": "log_newpage_buffer(dstBuf, true)",
          "new_text": null,
          "old_line_content": "\t\t\tlog_newpage_buffer(dstBuf, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4277,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "END_CRIT_SECTION",
          "new_api": null,
          "old_text": "END_CRIT_SECTION()",
          "new_text": null,
          "old_line_content": "\t\tEND_CRIT_SECTION();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4794,
          "old_api": "rlocator_comparator",
          "new_api": null,
          "old_text": "rlocator_comparator(&ba->rlocator, &bb->rlocator)",
          "new_text": null,
          "old_line_content": "\tret = rlocator_comparator(&ba->rlocator, &bb->rlocator);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4284,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\t\tif (buf_state & BM_PIN_COUNT_WAITER)",
          "content_same": false
        },
        {
          "line": 4285,
          "old_api": "LockBuffer",
          "new_api": null,
          "old_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "new_text": null,
          "old_line_content": "\t\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 4296,
          "old_api": "get_ps_display",
          "new_api": null,
          "old_text": "get_ps_display(&len)",
          "new_text": null,
          "old_line_content": "\t\t\t\told_status = get_ps_display(&len);",
          "new_line_content": "\t\t/* Wait to be signaled by UnpinBuffer() */",
          "content_same": false
        },
        {
          "line": 4297,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(len + 8 + 1)",
          "new_text": null,
          "old_line_content": "\t\t\t\tnew_status = (char *) palloc(len + 8 + 1);",
          "new_line_content": "\t\tif (InHotStandby)",
          "content_same": false
        },
        {
          "line": 4298,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(new_status, old_status, len)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(new_status, old_status, len);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 4299,
          "old_api": "strcpy",
          "new_api": null,
          "old_text": "strcpy(new_status + len, \" waiting\")",
          "new_text": null,
          "old_line_content": "\t\t\t\tstrcpy(new_status + len, \" waiting\");",
          "new_line_content": "\t\t\t/* Report change to waiting status */",
          "content_same": false
        },
        {
          "line": 4300,
          "old_api": "set_ps_display",
          "new_api": null,
          "old_text": "set_ps_display(new_status)",
          "new_text": null,
          "old_line_content": "\t\t\t\tset_ps_display(new_status);",
          "new_line_content": "\t\t\tif (update_process_title && new_status == NULL)",
          "content_same": false
        },
        {
          "line": 3801,
          "old_api": "RelationCreateStorage",
          "new_api": null,
          "old_text": "RelationCreateStorage(dst_rlocator, relpersistence, false)",
          "new_text": null,
          "old_line_content": "\tRelationCreateStorage(dst_rlocator, relpersistence, false);",
          "new_line_content": "\trelpersistence = permanent ?",
          "content_same": false
        },
        {
          "line": 4314,
          "old_api": "GetCurrentTimestamp",
          "new_api": null,
          "old_text": "GetCurrentTimestamp()",
          "new_text": null,
          "old_line_content": "\t\t\t\tTimestampTz now = GetCurrentTimestamp();",
          "new_line_content": "\t\t\t * Emit the log message if the startup process is waiting longer",
          "content_same": false
        },
        {
          "line": 4316,
          "old_api": "TimestampDifferenceExceeds",
          "new_api": null,
          "old_text": "TimestampDifferenceExceeds(waitStart, now,\n\t\t\t\t\t\t\t\t\t\t\t   DeadlockTimeout)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (TimestampDifferenceExceeds(waitStart, now,",
          "new_line_content": "\t\t\t *",
          "content_same": false
        },
        {
          "line": 3804,
          "old_api": "RelationCopyStorageUsingBuffer",
          "new_api": null,
          "old_text": "RelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, MAIN_FORKNUM,\n\t\t\t\t\t\t\t\t   permanent)",
          "new_text": null,
          "old_line_content": "\tRelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, MAIN_FORKNUM,",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4319,
          "old_api": "LogRecoveryConflict",
          "new_api": null,
          "old_text": "LogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,\n\t\t\t\t\t\t\t\t\t\twaitStart, now, NULL, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tLogRecoveryConflict(PROCSIG_RECOVERY_CONFLICT_BUFFERPIN,",
          "new_line_content": "\t\t\t * timestamp is set after this logic.",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": "smgropen",
          "new_api": null,
          "old_text": "smgropen(src_rlocator, InvalidBackendId)",
          "new_text": null,
          "old_line_content": "\t\tif (smgrexists(smgropen(src_rlocator, InvalidBackendId), forkNum))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4330,
          "old_api": "GetCurrentTimestamp",
          "new_api": null,
          "old_text": "GetCurrentTimestamp()",
          "new_text": null,
          "old_line_content": "\t\t\t\twaitStart = GetCurrentTimestamp();",
          "new_line_content": "\t\t\t\t\tlogged_recovery_conflict = true;",
          "content_same": false
        },
        {
          "line": 4333,
          "old_api": "SetStartupBufferPinWaitBufId",
          "new_api": null,
          "old_text": "SetStartupBufferPinWaitBufId(buffer - 1)",
          "new_text": null,
          "old_line_content": "\t\t\tSetStartupBufferPinWaitBufId(buffer - 1);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4335,
          "old_api": "ResolveRecoveryConflictWithBufferPin",
          "new_api": null,
          "old_text": "ResolveRecoveryConflictWithBufferPin()",
          "new_text": null,
          "old_line_content": "\t\t\tResolveRecoveryConflictWithBufferPin();",
          "new_line_content": "\t\t\t * Set the wait start timestamp if logging is enabled and first",
          "content_same": false
        },
        {
          "line": 3823,
          "old_api": "RelationCopyStorageUsingBuffer",
          "new_api": null,
          "old_text": "RelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, forkNum,\n\t\t\t\t\t\t\t\t\t\t   permanent)",
          "new_text": null,
          "old_line_content": "\t\t\tRelationCopyStorageUsingBuffer(src_rlocator, dst_rlocator, forkNum,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4337,
          "old_api": "SetStartupBufferPinWaitBufId",
          "new_api": null,
          "old_text": "SetStartupBufferPinWaitBufId(-1)",
          "new_text": null,
          "old_line_content": "\t\t\tSetStartupBufferPinWaitBufId(-1);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 4340,
          "old_api": "ProcWaitForSignal",
          "new_api": null,
          "old_text": "ProcWaitForSignal(PG_WAIT_BUFFER_PIN)",
          "new_text": null,
          "old_line_content": "\t\t\tProcWaitForSignal(PG_WAIT_BUFFER_PIN);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3835,
          "old_api": "smgrcloserellocator",
          "new_api": null,
          "old_text": "smgrcloserellocator(rlocator)",
          "new_text": null,
          "old_line_content": "\tsmgrcloserellocator(rlocator);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 4350,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(bufHdr)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4354,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\t\t * well.  We take care to only reset the flag if we're the waiter, as",
          "content_same": false
        },
        {
          "line": 4875,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(*max_pending <= WRITEBACK_MAX_PENDING_FLUSHES)",
          "new_text": null,
          "old_line_content": "\tAssert(*max_pending <= WRITEBACK_MAX_PENDING_FLUSHES);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4368,
          "old_api": "GetStartupBufferPinWaitBufId",
          "new_api": null,
          "old_text": "GetStartupBufferPinWaitBufId()",
          "new_text": null,
          "old_line_content": "\tint\t\t\tbufid = GetStartupBufferPinWaitBufId();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3860,
          "old_api": "ResourceOwnerEnlargeBuffers",
          "new_api": null,
          "old_text": "ResourceOwnerEnlargeBuffers(CurrentResourceOwner)",
          "new_text": null,
          "old_line_content": "\tResourceOwnerEnlargeBuffers(CurrentResourceOwner);",
          "new_line_content": " * --------------------------------------------------------------------",
          "content_same": false
        },
        {
          "line": 3866,
          "old_api": "GetBufferDescriptor",
          "new_api": null,
          "old_text": "GetBufferDescriptor(i)",
          "new_text": null,
          "old_line_content": "\t\tbufHdr = GetBufferDescriptor(i);",
          "new_line_content": "\tBufferDesc *bufHdr;",
          "content_same": false
        },
        {
          "line": 4379,
          "old_api": "GetPrivateRefCount",
          "new_api": null,
          "old_text": "GetPrivateRefCount(bufid + 1)",
          "new_text": null,
          "old_line_content": "\tif (GetPrivateRefCount(bufid + 1) > 0)",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4895,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(*context->max_pending <= WRITEBACK_MAX_PENDING_FLUSHES)",
          "new_text": null,
          "old_line_content": "\t\tAssert(*context->max_pending <= WRITEBACK_MAX_PENDING_FLUSHES);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3877,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(bufHdr)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 3881,
          "old_api": "PinBuffer_Locked",
          "new_api": null,
          "old_text": "PinBuffer_Locked(bufHdr)",
          "new_text": null,
          "old_line_content": "\t\t\tPinBuffer_Locked(bufHdr);",
          "new_line_content": "\t\tif (bufHdr->tag.rlocator.dbOid != dbid)",
          "content_same": false
        },
        {
          "line": 3882,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(bufHdr)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockAcquire(BufferDescriptorGetContentLock(bufHdr), LW_SHARED);",
          "new_line_content": "\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": "FlushBuffer",
          "new_api": null,
          "old_text": "FlushBuffer(bufHdr, NULL)",
          "new_text": null,
          "old_line_content": "\t\t\tFlushBuffer(bufHdr, NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4908,
          "old_api": "IssuePendingWritebacks",
          "new_api": null,
          "old_text": "IssuePendingWritebacks(context)",
          "new_text": null,
          "old_line_content": "\t\tIssuePendingWritebacks(context);",
          "new_line_content": "\t\tpending->tag = *tag;",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": "UnpinBuffer",
          "new_api": null,
          "old_text": "UnpinBuffer(bufHdr, true)",
          "new_text": null,
          "old_line_content": "\t\t\tUnpinBuffer(bufHdr, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4398,
          "old_api": "BufferIsValid",
          "new_api": null,
          "old_text": "BufferIsValid(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsValid(buffer));",
          "new_line_content": " * not, return false with no lock held.",
          "content_same": false
        },
        {
          "line": 4400,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": "bool",
          "content_same": false
        },
        {
          "line": 3888,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "\t\t\t(buf_state & (BM_VALID | BM_DIRTY)) == (BM_VALID | BM_DIRTY))",
          "content_same": false
        },
        {
          "line": 4404,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(refcount > 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(refcount > 0);",
          "new_line_content": "\tuint32\t\tbuf_state,",
          "content_same": false
        },
        {
          "line": 4412,
          "old_api": "GetPrivateRefCount",
          "new_api": null,
          "old_text": "GetPrivateRefCount(buffer)",
          "new_text": null,
          "old_line_content": "\trefcount = GetPrivateRefCount(buffer);",
          "new_line_content": "\t\t/* There should be exactly one pin */",
          "content_same": false
        },
        {
          "line": 3902,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(!BufferIsLocal(buffer));",
          "new_line_content": " * Flush a previously, shared or exclusively, locked and pinned buffer to the",
          "content_same": false
        },
        {
          "line": 3904,
          "old_api": "BufferIsPinned",
          "new_api": null,
          "old_text": "BufferIsPinned(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsPinned(buffer));",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4418,
          "old_api": "ConditionalLockBuffer",
          "new_api": null,
          "old_text": "ConditionalLockBuffer(buffer)",
          "new_text": null,
          "old_line_content": "\tif (!ConditionalLockBuffer(buffer))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "GetBufferDescriptor",
          "new_api": null,
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": null,
          "old_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "FlushOneBuffer(Buffer buffer)",
          "content_same": false
        },
        {
          "line": 3908,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(bufHdr)",
          "new_text": null,
          "old_line_content": "\tAssert(LWLockHeldByMe(BufferDescriptorGetContentLock(bufHdr)));",
          "new_line_content": "\tBufferDesc *bufHdr;",
          "content_same": false
        },
        {
          "line": 3910,
          "old_api": "FlushBuffer",
          "new_api": null,
          "old_text": "FlushBuffer(bufHdr, NULL)",
          "new_text": null,
          "old_line_content": "\tFlushBuffer(bufHdr, NULL);",
          "new_line_content": "\t/* currently not needed, but no fundamental reason not to support */",
          "content_same": false
        },
        {
          "line": 4423,
          "old_api": "BUF_STATE_GET_REFCOUNT",
          "new_api": null,
          "old_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "new_text": null,
          "old_line_content": "\trefcount = BUF_STATE_GET_REFCOUNT(buf_state);",
          "new_line_content": "\tif (refcount != 1)",
          "content_same": false
        },
        {
          "line": 4425,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(refcount > 0)",
          "new_text": null,
          "old_line_content": "\tAssert(refcount > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4937,
          "old_api": "sort_pending_writebacks",
          "new_api": null,
          "old_text": "sort_pending_writebacks(context->pending_writebacks, context->nr_pending)",
          "new_text": null,
          "old_line_content": "\tsort_pending_writebacks(context->pending_writebacks, context->nr_pending);",
          "new_line_content": "\tint\t\t\ti;",
          "content_same": false
        },
        {
          "line": 4429,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3920,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"bad buffer ID: %d\", buffer)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"bad buffer ID: %d\", buffer);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3922,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 4435,
          "old_api": "LockBuffer",
          "new_api": null,
          "old_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "new_text": null,
          "old_line_content": "\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "new_line_content": "\tif (refcount == 1)",
          "content_same": false
        },
        {
          "line": 3924,
          "old_api": "ResourceOwnerForgetBuffer",
          "new_api": null,
          "old_text": "ResourceOwnerForgetBuffer(CurrentResourceOwner, buffer)",
          "new_text": null,
          "old_line_content": "\t\tResourceOwnerForgetBuffer(CurrentResourceOwner, buffer);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 3926,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(LocalRefCount[-buffer - 1] > 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(LocalRefCount[-buffer - 1] > 0);",
          "new_line_content": "ReleaseBuffer(Buffer buffer)",
          "content_same": false
        },
        {
          "line": 4453,
          "old_api": "BufferIsValid",
          "new_api": null,
          "old_text": "BufferIsValid(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsValid(buffer));",
          "new_line_content": " * happens to be a cleanup lock, and we can proceed with anything that",
          "content_same": false
        },
        {
          "line": 4965,
          "old_api": "RelFileLocatorEquals",
          "new_api": null,
          "old_text": "RelFileLocatorEquals(cur->tag.rlocator, next->tag.rlocator)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!RelFileLocatorEquals(cur->tag.rlocator, next->tag.rlocator) ||",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 4455,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 3942,
          "old_api": "LockBuffer",
          "new_api": null,
          "old_text": "LockBuffer(buffer, BUFFER_LOCK_UNLOCK)",
          "new_text": null,
          "old_line_content": "\tLockBuffer(buffer, BUFFER_LOCK_UNLOCK);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": "ReleaseBuffer",
          "new_api": null,
          "old_text": "ReleaseBuffer(buffer)",
          "new_text": null,
          "old_line_content": "\tReleaseBuffer(buffer);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 4465,
          "old_api": "GetPrivateRefCount",
          "new_api": null,
          "old_text": "GetPrivateRefCount(buffer)",
          "new_text": null,
          "old_line_content": "\tif (GetPrivateRefCount(buffer) != 1)",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 4468,
          "old_api": "GetBufferDescriptor",
          "new_api": null,
          "old_text": "GetBufferDescriptor(buffer - 1)",
          "new_text": null,
          "old_line_content": "\tbufHdr = GetBufferDescriptor(buffer - 1);",
          "new_line_content": "\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 3957,
          "old_api": "BufferIsPinned",
          "new_api": null,
          "old_text": "BufferIsPinned(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(BufferIsPinned(buffer));",
          "new_line_content": " *\t\tIncrement the pin count on a buffer that we have *already* pinned",
          "content_same": false
        },
        {
          "line": 3958,
          "old_api": "ResourceOwnerEnlargeBuffers",
          "new_api": null,
          "old_text": "ResourceOwnerEnlargeBuffers(CurrentResourceOwner)",
          "new_text": null,
          "old_line_content": "\tResourceOwnerEnlargeBuffers(CurrentResourceOwner);",
          "new_line_content": " *\t\tat least once.",
          "content_same": false
        },
        {
          "line": 4471,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(bufHdr)",
          "new_text": null,
          "old_line_content": "\tAssert(LWLockHeldByMeInMode(BufferDescriptorGetContentLock(bufHdr),",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 4984,
          "old_api": "smgropen",
          "new_api": null,
          "old_text": "smgropen(tag.rlocator, InvalidBackendId)",
          "new_text": null,
          "old_line_content": "\t\treln = smgropen(tag.rlocator, InvalidBackendId);",
          "new_line_content": "\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 4985,
          "old_api": "smgrwriteback",
          "new_api": null,
          "old_text": "smgrwriteback(reln, tag.forkNum, tag.blockNum, nblocks)",
          "new_text": null,
          "old_line_content": "\t\tsmgrwriteback(reln, tag.forkNum, tag.blockNum, nblocks);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3959,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4476,
          "old_api": "BUF_STATE_GET_REFCOUNT",
          "new_api": null,
          "old_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "new_text": null,
          "old_line_content": "\tAssert(BUF_STATE_GET_REFCOUNT(buf_state) > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3965,
          "old_api": "GetPrivateRefCountEntry",
          "new_api": null,
          "old_text": "GetPrivateRefCountEntry(buffer, true)",
          "new_text": null,
          "old_line_content": "\t\tref = GetPrivateRefCountEntry(buffer, true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3969,
          "old_api": "ResourceOwnerRememberBuffer",
          "new_api": null,
          "old_text": "ResourceOwnerRememberBuffer(CurrentResourceOwner, buffer)",
          "new_text": null,
          "old_line_content": "\tResourceOwnerRememberBuffer(CurrentResourceOwner, buffer);",
          "new_line_content": "\t\tLocalRefCount[-buffer - 1]++;",
          "content_same": false
        },
        {
          "line": 4484,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(bufHdr, buf_state)",
          "new_text": null,
          "old_line_content": "\tUnlockBufHdr(bufHdr, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5001,
          "old_api": "RelationAllowsEarlyPruning",
          "new_api": null,
          "old_text": "RelationAllowsEarlyPruning(relation)",
          "new_text": null,
          "old_line_content": "\tif (RelationAllowsEarlyPruning(relation)",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 5002,
          "old_api": "GetOldSnapshotThresholdTimestamp",
          "new_api": null,
          "old_text": "GetOldSnapshotThresholdTimestamp()",
          "new_text": null,
          "old_line_content": "\t\t&& (snapshot)->whenTaken < GetOldSnapshotThresholdTimestamp())",
          "new_line_content": " * Implement slower/larger portions of TestForOldSnapshot",
          "content_same": false
        },
        {
          "line": 5003,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SNAPSHOT_TOO_OLD),\n\t\t\t\t errmsg(\"snapshot too old\")))",
          "new_text": null,
          "old_line_content": "\t\tereport(ERROR,",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 5004,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_SNAPSHOT_TOO_OLD)",
          "new_text": null,
          "old_line_content": "\t\t\t\t(errcode(ERRCODE_SNAPSHOT_TOO_OLD),",
          "new_line_content": " * Smaller/faster portions are put inline, but the entire set of logic is too",
          "content_same": false
        },
        {
          "line": 5005,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"snapshot too old\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t errmsg(\"snapshot too old\")));",
          "new_line_content": " * big for that.",
          "content_same": false
        },
        {
          "line": 3990,
          "old_api": "BufferGetPage",
          "new_api": null,
          "old_text": "BufferGetPage(buffer)",
          "new_text": null,
          "old_line_content": "\tPage\t\tpage = BufferGetPage(buffer);",
          "new_line_content": " * 2. The caller might have only share-lock instead of exclusive-lock on the",
          "content_same": false
        },
        {
          "line": 4504,
          "old_api": "BufferDescriptorGetIOCV",
          "new_api": null,
          "old_text": "BufferDescriptorGetIOCV(buf)",
          "new_text": null,
          "old_line_content": "\tConditionVariable *cv = BufferDescriptorGetIOCV(buf);",
          "new_line_content": " *\tAlso note that these are used only for shared buffers, not local ones.",
          "content_same": false
        },
        {
          "line": 3992,
          "old_api": "BufferIsValid",
          "new_api": null,
          "old_text": "BufferIsValid(buffer)",
          "new_text": null,
          "old_line_content": "\tif (!BufferIsValid(buffer))",
          "new_line_content": " * 3. This function does not guarantee that the buffer is always marked dirty",
          "content_same": false
        },
        {
          "line": 4506,
          "old_api": "ConditionVariablePrepareToSleep",
          "new_api": null,
          "old_text": "ConditionVariablePrepareToSleep(cv)",
          "new_text": null,
          "old_line_content": "\tConditionVariablePrepareToSleep(cv);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"bad buffer ID: %d\", buffer)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"bad buffer ID: %d\", buffer);",
          "new_line_content": " *\t  (due to a race condition), so it cannot be used for important changes.",
          "content_same": false
        },
        {
          "line": 3995,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tif (BufferIsLocal(buffer))",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": "MarkLocalBufferDirty",
          "new_api": null,
          "old_text": "MarkLocalBufferDirty(buffer)",
          "new_text": null,
          "old_line_content": "\t\tMarkLocalBufferDirty(buffer);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4003,
          "old_api": "GetPrivateRefCount",
          "new_api": null,
          "old_text": "GetPrivateRefCount(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(GetPrivateRefCount(buffer) > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4516,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(buf)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "new_line_content": "\tfor (;;)",
          "content_same": false
        },
        {
          "line": 4517,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 4005,
          "old_api": "BufferDescriptorGetContentLock",
          "new_api": null,
          "old_text": "BufferDescriptorGetContentLock(bufHdr)",
          "new_text": null,
          "old_line_content": "\tAssert(LWLockHeldByMe(BufferDescriptorGetContentLock(bufHdr)));",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 4521,
          "old_api": "ConditionVariableSleep",
          "new_api": null,
          "old_text": "ConditionVariableSleep(cv, WAIT_EVENT_BUFFER_IO)",
          "new_text": null,
          "old_line_content": "\t\tConditionVariableSleep(cv, WAIT_EVENT_BUFFER_IO);",
          "new_line_content": "\t\t * It may not be necessary to acquire the spinlock to check the flag",
          "content_same": false
        },
        {
          "line": 4523,
          "old_api": "ConditionVariableCancelSleep",
          "new_api": null,
          "old_text": "ConditionVariableCancelSleep()",
          "new_text": null,
          "old_line_content": "\tConditionVariableCancelSleep();",
          "new_line_content": "\t\t * play it safe.",
          "content_same": false
        },
        {
          "line": 4018,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&bufHdr->state)",
          "new_text": null,
          "old_line_content": "\tif ((pg_atomic_read_u32(&bufHdr->state) & (BM_DIRTY | BM_JUST_DIRTIED)) !=",
          "new_line_content": "\t * making the first scan after commit of an xact that added/deleted many",
          "content_same": false
        },
        {
          "line": 4035,
          "old_api": "XLogHintBitIsNeeded",
          "new_api": null,
          "old_text": "XLogHintBitIsNeeded()",
          "new_text": null,
          "old_line_content": "\t\tif (XLogHintBitIsNeeded() &&",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 4036,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&bufHdr->state)",
          "new_text": null,
          "old_line_content": "\t\t\t(pg_atomic_read_u32(&bufHdr->state) & BM_PERMANENT))",
          "new_line_content": "\t\t * If we need to protect hint bit updates from torn writes, WAL-log a",
          "content_same": false
        },
        {
          "line": 4549,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!InProgressBuf)",
          "new_text": null,
          "old_line_content": "\tAssert(!InProgressBuf);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 4553,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(buf)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(buf);",
          "new_line_content": "static bool",
          "content_same": false
        },
        {
          "line": 4557,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": null,
          "old_line_content": "\t\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4046,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\t\t\tif (RecoveryInProgress() ||",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 4047,
          "old_api": "RelFileLocatorSkippingWAL",
          "new_api": null,
          "old_text": "RelFileLocatorSkippingWAL(bufHdr->tag.rlocator)",
          "new_text": null,
          "old_line_content": "\t\t\t\tRelFileLocatorSkippingWAL(bufHdr->tag.rlocator))",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 4571,
          "old_api": "UnlockBufHdr",
          "new_api": null,
          "old_text": "UnlockBufHdr(buf, buf_state)",
          "new_text": null,
          "old_line_content": "\tUnlockBufHdr(buf, buf_state);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4073,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert((MyProc->delayChkptFlags & DELAY_CHKPT_START) == 0)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert((MyProc->delayChkptFlags & DELAY_CHKPT_START) == 0);",
          "new_line_content": "\t\t\t * until we have marked the buffer dirty. We don't start the",
          "content_same": false
        },
        {
          "line": 4076,
          "old_api": "XLogSaveBufferForHint",
          "new_api": null,
          "old_text": "XLogSaveBufferForHint(buffer, buffer_std)",
          "new_text": null,
          "old_line_content": "\t\t\tlsn = XLogSaveBufferForHint(buffer, buffer_std);",
          "new_line_content": "\t\t\t * never gets written, so crash recovery will fix.",
          "content_same": false
        },
        {
          "line": 4079,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(bufHdr)",
          "new_text": null,
          "old_line_content": "\t\tbuf_state = LockBufHdr(bufHdr);",
          "new_line_content": "\t\t\t * essential that CreateCheckPoint waits for virtual transactions",
          "content_same": false
        },
        {
          "line": 4081,
          "old_api": "BUF_STATE_GET_REFCOUNT",
          "new_api": null,
          "old_text": "BUF_STATE_GET_REFCOUNT(buf_state)",
          "new_text": null,
          "old_line_content": "\t\tAssert(BUF_STATE_GET_REFCOUNT(buf_state) > 0);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 4600,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(buf == InProgressBuf)",
          "new_text": null,
          "old_line_content": "\tAssert(buf == InProgressBuf);",
          "new_line_content": " * set_flag_bits gets ORed into the buffer's flags.  It must include",
          "content_same": false
        },
        {
          "line": 4602,
          "old_api": "LockBufHdr",
          "new_api": null,
          "old_text": "LockBufHdr(buf)",
          "new_text": null,
          "old_line_content": "\tbuf_state = LockBufHdr(buf);",
          "new_line_content": " * be 0, or BM_VALID if we just finished reading in the page.",
          "content_same": false
        },
        {
          "line": 4604,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(buf_state & BM_IO_IN_PROGRESS)",
          "new_text": null,
          "old_line_content": "\tAssert(buf_state & BM_IO_IN_PROGRESS);",
          "new_line_content": "static void",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 34,
      "total_additions": 175,
      "total_deletions": 173,
      "total_api_changes": 382
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 11,
        "api_related_lines": 382,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          3736,
          3737,
          3715,
          3741
        ]
      }
    },
    "api_calls_before": 772,
    "api_calls_after": 775,
    "diff_info": {
      "added_lines": 10,
      "removed_lines": 1,
      "total_diff_lines": 37
    }
  }
}