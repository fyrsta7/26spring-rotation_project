{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/56e59edd7509f8726157cd8039529fc077f57ebb",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/56e59edd7509f8726157cd8039529fc077f57ebb/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/56e59edd7509f8726157cd8039529fc077f57ebb/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/56e59edd7509f8726157cd8039529fc077f57ebb/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 110,
          "old_api": "linitial",
          "new_api": "IsA",
          "old_text": "linitial(parse->jointree->fromlist)",
          "new_text": "IsA(jtnode, FromExpr)",
          "old_line_content": "\trtr = (RangeTblRef *) linitial(parse->jointree->fromlist);",
          "new_line_content": "\twhile (IsA(jtnode, FromExpr))",
          "content_same": false
        },
        {
          "line": 116,
          "old_api": "find_base_rel",
          "new_api": "IsA",
          "old_text": "find_base_rel(root, rtr->rtindex)",
          "new_text": "IsA(jtnode, RangeTblRef)",
          "old_line_content": "\trel = find_base_rel(root, rtr->rtindex);",
          "new_line_content": "\tif (!IsA(jtnode, RangeTblRef))",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "replace_aggs_with_params_mutator",
          "new_api": "lfirst",
          "old_text": "replace_aggs_with_params_mutator((Node *) tlist,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &aggs_list)",
          "new_text": "lfirst(l)",
          "old_line_content": "\ttlist = (List *) replace_aggs_with_params_mutator((Node *) tlist,",
          "new_line_content": "\t\tmake_agg_subplan(root, (MinMaxAggInfo *) lfirst(l));",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "make_result",
          "new_api": "replace_aggs_with_params_mutator",
          "old_text": "make_result(tlist, hqual, NULL)",
          "new_text": "replace_aggs_with_params_mutator(parse->havingQual,\n\t\t\t\t\t\t\t\t\t\t\t &aggs_list)",
          "old_line_content": "\tplan = (Plan *) make_result(tlist, hqual, NULL);",
          "new_line_content": "\thqual = replace_aggs_with_params_mutator(parse->havingQual,",
          "content_same": false
        },
        {
          "line": 231,
          "old_api": "OidIsValid",
          "new_api": "Assert",
          "old_text": "OidIsValid(aggsortop)",
          "new_text": "Assert(aggref->agglevelsup == 0)",
          "old_line_content": "\t\tif (!OidIsValid(aggsortop))",
          "new_line_content": "\t\tAssert(aggref->agglevelsup == 0);",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "linitial",
          "new_api": "OidIsValid",
          "old_text": "linitial(aggref->args)",
          "new_text": "OidIsValid(aggsortop)",
          "old_line_content": "\t\tcurTarget = linitial(aggref->args);",
          "new_line_content": "\t\tif (!OidIsValid(aggsortop))",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "palloc0",
          "new_api": "lfirst",
          "old_text": "palloc0(sizeof(MinMaxAggInfo))",
          "new_text": "lfirst(l)",
          "old_line_content": "\t\tinfo = (MinMaxAggInfo *) palloc0(sizeof(MinMaxAggInfo));",
          "new_line_content": "\t\t\tinfo = (MinMaxAggInfo *) lfirst(l);",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "assignSortGroupRef",
          "new_api": "pstrdup",
          "old_text": "assignSortGroupRef(tle, subparse->targetList)",
          "new_text": "pstrdup(\"agg_target\")",
          "old_line_content": "\tsortcl->tleSortGroupRef = assignSortGroupRef(tle, subparse->targetList);",
          "new_line_content": "\t\t\t\t\t\t  pstrdup(\"agg_target\"),",
          "content_same": false
        },
        {
          "line": 502,
          "old_api": "IsA",
          "new_api": "copyObject",
          "old_text": "IsA(iplan, IndexScan)",
          "new_text": "copyObject(subparse->targetList)",
          "old_line_content": "\tAssert(IsA(iplan, IndexScan));",
          "new_line_content": "\tplan->targetlist = copyObject(subparse->targetList);",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "makeNode",
          "new_api": "IsA",
          "old_text": "makeNode(NullTest)",
          "new_text": "IsA(plan, Result)",
          "old_line_content": "\tntest = makeNode(NullTest);",
          "new_line_content": "\tif (IsA(plan, Result))",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "lcons",
          "new_api": "IsA",
          "old_text": "lcons(ntest, iplan->qual)",
          "new_text": "IsA(iplan, IndexScan)",
          "old_line_content": "\tiplan->qual = lcons(ntest, iplan->qual);",
          "new_line_content": "\tAssert(IsA(iplan, IndexScan));",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": "make_limit",
          "new_api": "makeNode",
          "old_text": "make_limit(plan,\n\t\t\t\t\t\t\t   subparse->limitOffset,\n\t\t\t\t\t\t\t   subparse->limitCount,\n\t\t\t\t\t\t\t   0, 1)",
          "new_text": "makeNode(NullTest)",
          "old_line_content": "\tplan = (Plan *) make_limit(plan,",
          "new_line_content": "\tntest = makeNode(NullTest);",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": "foreach",
          "new_api": "IsA",
          "old_text": "foreach(l, *context)",
          "new_text": "IsA(node, Aggref)",
          "old_line_content": "\t\tforeach(l, *context)",
          "new_line_content": "\tif (IsA(node, Aggref))",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": "elog",
          "new_api": "lfirst",
          "old_text": "elog(ERROR, \"failed to re-find aggregate info record\")",
          "new_text": "lfirst(l)",
          "old_line_content": "\t\telog(ERROR, \"failed to re-find aggregate info record\");",
          "new_line_content": "\t\t\tMinMaxAggInfo *info = (MinMaxAggInfo *) lfirst(l);",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "expression_tree_mutator",
          "new_api": "equal",
          "old_text": "expression_tree_mutator(node, replace_aggs_with_params_mutator,\n\t\t\t\t\t\t\t\t   (void *) context)",
          "new_text": "equal(info->target, curTarget)",
          "old_line_content": "\treturn expression_tree_mutator(node, replace_aggs_with_params_mutator,",
          "new_line_content": "\t\t\t\tequal(info->target, curTarget))",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": "ReleaseSysCache",
          "new_api": "ObjectIdGetDatum",
          "old_text": "ReleaseSysCache(aggTuple)",
          "new_text": "ObjectIdGetDatum(aggfnoid)",
          "old_line_content": "\tReleaseSysCache(aggTuple);",
          "new_line_content": "\t\t\t\t\t\t\t  ObjectIdGetDatum(aggfnoid),",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 512,
          "old_api": null,
          "new_api": "copyObject",
          "old_text": null,
          "new_text": "copyObject(info->target)",
          "old_line_content": "\t\t\t\t\t\t\t   subparse->limitCount,",
          "new_line_content": "\tntest->arg = copyObject(info->target);",
          "content_same": false
        },
        {
          "line": 257,
          "old_api": null,
          "new_api": "lappend",
          "old_text": null,
          "new_text": "lappend(*context, info)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\t\t*context = lappend(*context, info);",
          "content_same": false
        },
        {
          "line": 514,
          "old_api": null,
          "new_api": "lcons",
          "old_text": null,
          "new_text": "lcons(ntest, iplan->qual)",
          "old_line_content": "",
          "new_line_content": "\tiplan->qual = lcons(ntest, iplan->qual);",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": null,
          "new_api": "make_limit",
          "old_text": null,
          "new_text": "make_limit(plan,\n\t\t\t\t\t\t\t   subparse->limitOffset,\n\t\t\t\t\t\t\t   subparse->limitCount,\n\t\t\t\t\t\t\t   0, 1)",
          "old_line_content": "\t * Convert the plan into an InitPlan, and make a Param for its result.",
          "new_line_content": "\tplan = (Plan *) make_limit(plan,",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(indexscandir)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (ScanDirectionIsForward(indexscandir))",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(node, SubLink)",
          "old_line_content": " * build_minmax_path",
          "new_line_content": "\tAssert(!IsA(node, SubLink));",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": null,
          "new_api": "expression_tree_walker",
          "old_text": null,
          "new_text": "expression_tree_walker(node, find_minmax_aggs_walker,\n\t\t\t\t\t\t\t\t  (void *) context)",
          "old_line_content": " *\t\tGiven a MIN/MAX aggregate, try to find an index it can be optimized",
          "new_line_content": "\treturn expression_tree_walker(node, find_minmax_aggs_walker,",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": null,
          "new_api": "find_minmax_aggs_walker",
          "old_text": null,
          "new_text": "find_minmax_aggs_walker((Node *) tlist, &aggs_list)",
          "old_line_content": "\ttotal_cost = 0;",
          "new_line_content": "\tif (find_minmax_aggs_walker((Node *) tlist, &aggs_list))",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": null,
          "new_api": "SS_make_initplan_from_plan",
          "old_text": null,
          "new_text": "SS_make_initplan_from_plan(&subroot, plan,\n\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) tle->expr),\n\t\t\t\t\t\t\t\t\t\t\t -1)",
          "old_line_content": " * Replace original aggregate calls with subplan output Params",
          "new_line_content": "\tinfo->param = SS_make_initplan_from_plan(&subroot, plan,",
          "content_same": false
        },
        {
          "line": 525,
          "old_api": null,
          "new_api": "exprType",
          "old_text": null,
          "new_text": "exprType((Node *) tle->expr)",
          "old_line_content": " */",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) tle->expr),",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": null,
          "new_api": "find_minmax_aggs_walker",
          "old_text": null,
          "new_text": "find_minmax_aggs_walker(parse->havingQual, &aggs_list)",
          "old_line_content": "\t{",
          "new_line_content": "\tif (find_minmax_aggs_walker(parse->havingQual, &aggs_list))",
          "content_same": false
        },
        {
          "line": 148,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(l)",
          "old_line_content": "",
          "new_line_content": "\t\tMinMaxAggInfo *info = (MinMaxAggInfo *) lfirst(l);",
          "content_same": false
        },
        {
          "line": 150,
          "old_api": null,
          "new_api": "build_minmax_path",
          "old_text": null,
          "new_text": "build_minmax_path(root, rel, info)",
          "old_line_content": "\t * Make the cost comparison.",
          "new_line_content": "\t\tif (!build_minmax_path(root, rel, info))",
          "content_same": false
        },
        {
          "line": 541,
          "old_api": null,
          "new_api": "linitial",
          "old_text": null,
          "new_text": "linitial(aggref->args)",
          "old_line_content": "\t\t\tif (info->aggfnoid == aggref->aggfnoid &&",
          "new_line_content": "\t\tExpr\t   *curTarget = linitial(aggref->args);",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(l, *context)",
          "old_line_content": "\t\t\t\treturn (Node *) info->param;",
          "new_line_content": "\t\tforeach(l, *context)",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": null,
          "new_api": "list_length",
          "old_text": null,
          "new_text": "list_length(aggs_list)",
          "old_line_content": "\t\treturn NULL;\t\t\t/* too expensive */",
          "new_line_content": "\tcost_agg(&agg_p, root, AGG_PLAIN, list_length(aggs_list),",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(l, rel->indexlist)",
          "old_line_content": "\t\tList\t   *restrictclauses;",
          "new_line_content": "\tforeach(l, rel->indexlist)",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(l)",
          "old_line_content": "\t\tCost\t\tnew_cost;",
          "new_line_content": "\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(l);",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"failed to re-find aggregate info record\")",
          "old_line_content": "",
          "new_line_content": "\t\telog(ERROR, \"failed to re-find aggregate info record\");",
          "content_same": false
        },
        {
          "line": 553,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(node, SubLink)",
          "old_line_content": " * Get the OID of the sort operator, if any, associated with an aggregate.",
          "new_line_content": "\tAssert(!IsA(node, SubLink));",
          "content_same": false
        },
        {
          "line": 554,
          "old_api": null,
          "new_api": "expression_tree_mutator",
          "old_text": null,
          "new_text": "expression_tree_mutator(node, replace_aggs_with_params_mutator,\n\t\t\t\t\t\t\t\t   (void *) context)",
          "old_line_content": " * Returns InvalidOid if there is no such operator.",
          "new_line_content": "\treturn expression_tree_mutator(node, replace_aggs_with_params_mutator,",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "match_index_to_operand",
          "old_text": null,
          "new_text": "match_index_to_operand((Node *) info->target, indexcol, index)",
          "old_line_content": "/*",
          "new_line_content": "\tif (!match_index_to_operand((Node *) info->target, indexcol, index))",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": null,
          "new_api": "replace_aggs_with_params_mutator",
          "old_text": null,
          "new_text": "replace_aggs_with_params_mutator((Node *) tlist,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &aggs_list)",
          "old_line_content": "\t * Generate the output plan --- basically just a Result",
          "new_line_content": "\ttlist = (List *) replace_aggs_with_params_mutator((Node *) tlist,",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": null,
          "new_api": "SearchSysCache",
          "old_text": null,
          "new_text": "SearchSysCache(AGGFNOID,\n\t\t\t\t\t\t\t  ObjectIdGetDatum(aggfnoid),\n\t\t\t\t\t\t\t  0, 0, 0)",
          "old_line_content": "\taggsortop = aggform->aggsortop;",
          "new_line_content": "\taggTuple = SearchSysCache(AGGFNOID,",
          "content_same": false
        },
        {
          "line": 316,
          "old_api": null,
          "new_api": "match_agg_to_index_col",
          "old_text": null,
          "new_text": "match_agg_to_index_col(info, index, indexcol)",
          "old_line_content": "",
          "new_line_content": "\t\t\tindexscandir = match_agg_to_index_col(info, index, indexcol);",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": null,
          "new_api": "HeapTupleIsValid",
          "old_text": null,
          "new_text": "HeapTupleIsValid(aggTuple)",
          "old_line_content": "\treturn aggsortop;",
          "new_line_content": "\tif (!HeapTupleIsValid(aggTuple))",
          "content_same": false
        },
        {
          "line": 317,
          "old_api": null,
          "new_api": "ScanDirectionIsNoMovement",
          "old_text": null,
          "new_text": "ScanDirectionIsNoMovement(indexscandir)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tif (!ScanDirectionIsNoMovement(indexscandir))",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "GETSTRUCT",
          "old_text": null,
          "new_text": "GETSTRUCT(aggTuple)",
          "old_line_content": "",
          "new_line_content": "\taggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);",
          "content_same": false
        },
        {
          "line": 191,
          "old_api": null,
          "new_api": "make_result",
          "old_text": null,
          "new_text": "make_result(tlist, hqual, NULL)",
          "old_line_content": "",
          "new_line_content": "\tplan = (Plan *) make_result(tlist, hqual, NULL);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "ReleaseSysCache",
          "old_text": null,
          "new_text": "ReleaseSysCache(aggTuple)",
          "old_line_content": "",
          "new_line_content": "\tReleaseSysCache(aggTuple);",
          "content_same": false
        },
        {
          "line": 194,
          "old_api": null,
          "new_api": "cost_qual_eval",
          "old_text": null,
          "new_text": "cost_qual_eval(&tlist_cost, tlist)",
          "old_line_content": "",
          "new_line_content": "\tcost_qual_eval(&tlist_cost, tlist);",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "ScanDirectionIsNoMovement",
          "old_text": null,
          "new_text": "ScanDirectionIsNoMovement(indexscandir)",
          "old_line_content": "\t\t * index columns.  Since we'll need the restrictclauses list anyway to",
          "new_line_content": "\t\tif (ScanDirectionIsNoMovement(indexscandir))",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&subroot, root, sizeof(PlannerInfo))",
          "old_line_content": "\tsubparse->into = NULL;",
          "new_line_content": "\tmemcpy(&subroot, root, sizeof(PlannerInfo));",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": null,
          "new_api": "copyObject",
          "old_text": null,
          "new_text": "copyObject(root->parse)",
          "old_line_content": "\tsubparse->hasAggs = false;",
          "new_line_content": "\tsubroot.parse = subparse = (Query *) copyObject(root->parse);",
          "content_same": false
        },
        {
          "line": 330,
          "old_api": null,
          "new_api": "group_clauses_by_indexkey",
          "old_text": null,
          "new_text": "group_clauses_by_indexkey(index,\n\t\t\t\t\t\t\t\t\t\t\t\tindex->rel->baserestrictinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNIL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tSAOP_FORBID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&found_clause)",
          "old_line_content": "",
          "new_line_content": "\t\trestrictclauses = group_clauses_by_indexkey(index,",
          "content_same": false
        },
        {
          "line": 337,
          "old_api": null,
          "new_api": "list_length",
          "old_text": null,
          "new_text": "list_length(restrictclauses)",
          "old_line_content": "",
          "new_line_content": "\t\tif (list_length(restrictclauses) < indexcol)",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "copyObject",
          "old_text": null,
          "new_text": "copyObject(info->target)",
          "old_line_content": "\t/* set up the appropriate ORDER BY entry */",
          "new_line_content": "\ttle = makeTargetEntry(copyObject(info->target),",
          "content_same": false
        },
        {
          "line": 341,
          "old_api": null,
          "new_api": "list_nth",
          "old_text": null,
          "new_text": "list_nth(restrictclauses, prevcol)",
          "old_line_content": "\t\t\t\tint\t\t\tstrategy;",
          "new_line_content": "\t\t\tList\t   *rinfos = (List *) list_nth(restrictclauses, prevcol);",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": null,
          "new_api": "list_make1",
          "old_text": null,
          "new_text": "list_make1(tle)",
          "old_line_content": "\tsortcl->nulls_first = info->nulls_first;",
          "new_line_content": "\tsubparse->targetList = list_make1(tle);",
          "content_same": false
        },
        {
          "line": 472,
          "old_api": null,
          "new_api": "makeNode",
          "old_text": null,
          "new_text": "makeNode(SortClause)",
          "old_line_content": "\t/* set up LIMIT 1 */",
          "new_line_content": "\tsortcl = makeNode(SortClause);",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": null,
          "new_api": "assignSortGroupRef",
          "old_text": null,
          "new_text": "assignSortGroupRef(tle, subparse->targetList)",
          "old_line_content": "\tsubparse->limitOffset = NULL;",
          "new_line_content": "\tsortcl->tleSortGroupRef = assignSortGroupRef(tle, subparse->targetList);",
          "content_same": false
        },
        {
          "line": 90,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(parse->rowMarks == NIL)",
          "old_line_content": "",
          "new_line_content": "\tAssert(parse->rowMarks == NIL);\t\t/* nor if FOR UPDATE */",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(ll)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t index->opfamily[prevcol]);",
          "new_line_content": "\t\t\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(ll);",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "list_make1",
          "old_text": null,
          "new_text": "list_make1(sortcl)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t  false, false /* not by val */ );",
          "new_line_content": "\tsubparse->sortClause = list_make1(sortcl);",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "is_opclause",
          "old_text": null,
          "new_text": "is_opclause(rinfo->clause)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tAssert(is_opclause(rinfo->clause));",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(node, Aggref)",
          "old_line_content": "\t\tListCell   *l;",
          "new_line_content": "\tif (IsA(node, Aggref))",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "get_op_opfamily_strategy",
          "old_text": null,
          "new_text": "get_op_opfamily_strategy(((OpExpr *) rinfo->clause)->opno,\n\t\t\t\t\t\t\t\t\t\t\t index->opfamily[prevcol])",
          "old_line_content": "\t\t\t\tbreak;\t\t\t/* none are Equal for this index col */",
          "new_line_content": "\t\t\t\t\tget_op_opfamily_strategy(((OpExpr *) rinfo->clause)->opno,",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": null,
          "new_api": "makeConst",
          "old_text": null,
          "new_text": "makeConst(INT8OID, sizeof(int64),\n\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(1),\n\t\t\t\t\t\t\t\t\t\t\t  false, false /* not by val */ )",
          "old_line_content": "\t * basic indexscan, but we have to convert it to a Plan and attach a LIMIT",
          "new_line_content": "\tsubparse->limitCount = (Node *) makeConst(INT8OID, sizeof(int64),",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "Int64GetDatum",
          "old_text": null,
          "new_text": "Int64GetDatum(1)",
          "old_line_content": "\t * node above it.",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(1),",
          "content_same": false
        },
        {
          "line": 232,
          "old_api": null,
          "new_api": "list_length",
          "old_text": null,
          "new_text": "list_length(aggref->args)",
          "old_line_content": "\t\t\treturn true;\t\t/* not a MIN/MAX aggregate */",
          "new_line_content": "\t\tif (list_length(aggref->args) != 1)",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": null,
          "new_api": "fetch_agg_sort_op",
          "old_text": null,
          "new_text": "fetch_agg_sort_op(aggref->aggfnoid)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\taggsortop = fetch_agg_sort_op(aggref->aggfnoid);",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": null,
          "new_api": "create_index_path",
          "old_text": null,
          "new_text": "create_index_path(root, index,\n\t\t\t\t\t\t\t\t\t restrictclauses,\n\t\t\t\t\t\t\t\t\t NIL,\n\t\t\t\t\t\t\t\t\t indexscandir,\n\t\t\t\t\t\t\t\t\t NULL)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tnew_path = create_index_path(root, index,",
          "content_same": false
        },
        {
          "line": 112,
          "old_api": null,
          "new_api": "list_length",
          "old_text": null,
          "new_text": "list_length(jtnode->fromlist)",
          "old_line_content": "\t\treturn NULL;",
          "new_line_content": "\t\tif (list_length(jtnode->fromlist) != 1)",
          "content_same": false
        },
        {
          "line": 114,
          "old_api": null,
          "new_api": "linitial",
          "old_text": null,
          "new_text": "linitial(jtnode->fromlist)",
          "old_line_content": "\tif (rte->rtekind != RTE_RELATION || rte->inh)",
          "new_line_content": "\t\tjtnode = linitial(jtnode->fromlist);",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": null,
          "new_api": "linitial",
          "old_text": null,
          "new_text": "linitial(aggref->args)",
          "old_line_content": "\t\t\t\treturn false;",
          "new_line_content": "\t\tcurTarget = linitial(aggref->args);",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(l, *context)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tforeach(l, *context)",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": null,
          "new_api": "create_plan",
          "old_text": null,
          "new_text": "create_plan(&subroot, (Path *) info->path)",
          "old_line_content": "\telse",
          "new_line_content": "\tplan = create_plan(&subroot, (Path *) info->path);",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": null,
          "new_api": "rt_fetch",
          "old_text": null,
          "new_text": "rt_fetch(rtr->rtindex, parse->rtable)",
          "old_line_content": "\t * Since this optimization is not applicable all that often, we want to",
          "new_line_content": "\trte = rt_fetch(rtr->rtindex, parse->rtable);",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "equal",
          "old_text": null,
          "new_text": "equal(info->target, curTarget)",
          "old_line_content": "\t\tinfo->aggsortop = aggsortop;",
          "new_line_content": "\t\t\t\tequal(info->target, curTarget))",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": null,
          "new_api": "find_base_rel",
          "old_text": null,
          "new_text": "find_base_rel(root, rtr->rtindex)",
          "old_line_content": "\t * to find all the aggregates and verify that each of them is a MIN/MAX",
          "new_line_content": "\trel = find_base_rel(root, rtr->rtindex);",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(sizeof(MinMaxAggInfo))",
          "old_line_content": "",
          "new_line_content": "\t\tinfo = (MinMaxAggInfo *) palloc0(sizeof(MinMaxAggInfo));",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 259,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(node, SubLink)",
          "new_text": null,
          "old_line_content": "\tAssert(!IsA(node, SubLink));",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 260,
          "old_api": "expression_tree_walker",
          "new_api": null,
          "old_text": "expression_tree_walker(node, find_minmax_aggs_walker,\n\t\t\t\t\t\t\t\t  (void *) context)",
          "new_text": null,
          "old_line_content": "\treturn expression_tree_walker(node, find_minmax_aggs_walker,",
          "new_line_content": "\t\t * We need not recurse into the argument, since it can't contain any",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "find_minmax_aggs_walker",
          "new_api": null,
          "old_text": "find_minmax_aggs_walker((Node *) tlist, &aggs_list)",
          "new_text": null,
          "old_line_content": "\tif (find_minmax_aggs_walker((Node *) tlist, &aggs_list))",
          "new_line_content": "\t * If that succeeds, we have enough info to compare costs against the",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "SS_make_initplan_from_plan",
          "new_api": null,
          "old_text": "SS_make_initplan_from_plan(&subroot, plan,\n\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) tle->expr),\n\t\t\t\t\t\t\t\t\t\t\t -1)",
          "new_text": null,
          "old_line_content": "\tinfo->param = SS_make_initplan_from_plan(&subroot, plan,",
          "new_line_content": "\t\t\t\t\t\t\t   subparse->limitCount,",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": "exprType",
          "new_api": null,
          "old_text": "exprType((Node *) tle->expr)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t exprType((Node *) tle->expr),",
          "new_line_content": "\t\t\t\t\t\t\t   0, 1);",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": "find_minmax_aggs_walker",
          "new_api": null,
          "old_text": "find_minmax_aggs_walker(parse->havingQual, &aggs_list)",
          "new_text": null,
          "old_line_content": "\tif (find_minmax_aggs_walker(parse->havingQual, &aggs_list))",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(l)",
          "new_text": null,
          "old_line_content": "\t\tMinMaxAggInfo *info = (MinMaxAggInfo *) lfirst(l);",
          "new_line_content": "\t\treturn NULL;",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": "build_minmax_path",
          "new_api": null,
          "old_text": "build_minmax_path(root, rel, info)",
          "new_text": null,
          "old_line_content": "\t\tif (!build_minmax_path(root, rel, info))",
          "new_line_content": "\t/* Pass 2: see if each one is optimizable */",
          "content_same": false
        },
        {
          "line": 531,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(node, Aggref)",
          "new_text": null,
          "old_line_content": "\tif (IsA(node, Aggref))",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 535,
          "old_api": "linitial",
          "new_api": null,
          "old_text": "linitial(aggref->args)",
          "new_text": null,
          "old_line_content": "\t\tExpr\t   *curTarget = linitial(aggref->args);",
          "new_line_content": "\tif (node == NULL)",
          "content_same": false
        },
        {
          "line": 539,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(l)",
          "new_text": null,
          "old_line_content": "\t\t\tMinMaxAggInfo *info = (MinMaxAggInfo *) lfirst(l);",
          "new_line_content": "\t\tAggref\t   *aggref = (Aggref *) node;",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "list_length",
          "new_api": null,
          "old_text": "list_length(aggs_list)",
          "new_text": null,
          "old_line_content": "\tcost_agg(&agg_p, root, AGG_PLAIN, list_length(aggs_list),",
          "new_line_content": "\t * Make the cost comparison.",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": "foreach",
          "new_api": null,
          "old_text": "foreach(l, rel->indexlist)",
          "new_text": null,
          "old_line_content": "\tforeach(l, rel->indexlist)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 542,
          "old_api": "equal",
          "new_api": null,
          "old_text": "equal(info->target, curTarget)",
          "new_text": null,
          "old_line_content": "\t\t\t\tequal(info->target, curTarget))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(l)",
          "new_text": null,
          "old_line_content": "\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(l);",
          "new_line_content": "\tCost\t\tbest_cost = 0;",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(node, SubLink)",
          "new_text": null,
          "old_line_content": "\tAssert(!IsA(node, SubLink));",
          "new_line_content": "\t\t\tif (info->aggfnoid == aggref->aggfnoid &&",
          "content_same": false
        },
        {
          "line": 420,
          "old_api": "match_index_to_operand",
          "new_api": null,
          "old_text": "match_index_to_operand((Node *) info->target, indexcol, index)",
          "new_text": null,
          "old_line_content": "\tif (!match_index_to_operand((Node *) info->target, indexcol, index))",
          "new_line_content": "\telse if (info->aggsortop == index->revsortop[indexcol])",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(l)",
          "new_text": null,
          "old_line_content": "\t\tmake_agg_subplan(root, (MinMaxAggInfo *) lfirst(l));",
          "new_line_content": "\t * OK, we are going to generate an optimized plan.",
          "content_same": false
        },
        {
          "line": 179,
          "old_api": "replace_aggs_with_params_mutator",
          "new_api": null,
          "old_text": "replace_aggs_with_params_mutator(parse->havingQual,\n\t\t\t\t\t\t\t\t\t\t\t &aggs_list)",
          "new_text": null,
          "old_line_content": "\thqual = replace_aggs_with_params_mutator(parse->havingQual,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": "SearchSysCache",
          "new_api": null,
          "old_text": "SearchSysCache(AGGFNOID,\n\t\t\t\t\t\t\t  ObjectIdGetDatum(aggfnoid),\n\t\t\t\t\t\t\t  0, 0, 0)",
          "new_text": null,
          "old_line_content": "\taggTuple = SearchSysCache(AGGFNOID,",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 565,
          "old_api": "ObjectIdGetDatum",
          "new_api": null,
          "old_text": "ObjectIdGetDatum(aggfnoid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  ObjectIdGetDatum(aggfnoid),",
          "new_line_content": "\tHeapTuple\taggTuple;",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": "match_agg_to_index_col",
          "new_api": null,
          "old_text": "match_agg_to_index_col(info, index, indexcol)",
          "new_text": null,
          "old_line_content": "\t\t\tindexscandir = match_agg_to_index_col(info, index, indexcol);",
          "new_line_content": "\t\t * Look for a match to one of the index columns.  (In a stupidly",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "HeapTupleIsValid",
          "new_api": null,
          "old_text": "HeapTupleIsValid(aggTuple)",
          "new_text": null,
          "old_line_content": "\tif (!HeapTupleIsValid(aggTuple))",
          "new_line_content": "\tOid\t\t\taggsortop;",
          "content_same": false
        },
        {
          "line": 311,
          "old_api": "ScanDirectionIsNoMovement",
          "new_api": null,
          "old_text": "ScanDirectionIsNoMovement(indexscandir)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!ScanDirectionIsNoMovement(indexscandir))",
          "new_line_content": "\t\t * designed index, there could be multiple matches, but we only care",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "GETSTRUCT",
          "new_api": null,
          "old_text": "GETSTRUCT(aggTuple)",
          "new_text": null,
          "old_line_content": "\taggform = (Form_pg_aggregate) GETSTRUCT(aggTuple);",
          "new_line_content": "\t/* fetch aggregate entry from pg_aggregate */",
          "content_same": false
        },
        {
          "line": 314,
          "old_api": "ScanDirectionIsNoMovement",
          "new_api": null,
          "old_text": "ScanDirectionIsNoMovement(indexscandir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsNoMovement(indexscandir))",
          "new_line_content": "\t\tfor (indexcol = 0; indexcol < index->ncolumns; indexcol++)",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": "cost_qual_eval",
          "new_api": null,
          "old_text": "cost_qual_eval(&tlist_cost, tlist)",
          "new_text": null,
          "old_line_content": "\tcost_qual_eval(&tlist_cost, tlist);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&subroot, root, sizeof(PlannerInfo))",
          "new_text": null,
          "old_line_content": "\tmemcpy(&subroot, root, sizeof(PlannerInfo));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 446,
          "old_api": "copyObject",
          "new_api": null,
          "old_text": "copyObject(root->parse)",
          "new_text": null,
          "old_line_content": "\tsubroot.parse = subparse = (Query *) copyObject(root->parse);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "group_clauses_by_indexkey",
          "new_api": null,
          "old_text": "group_clauses_by_indexkey(index,\n\t\t\t\t\t\t\t\t\t\t\t\tindex->rel->baserestrictinfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNIL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t\t\t\t\t\t\tSAOP_FORBID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&found_clause)",
          "new_text": null,
          "old_line_content": "\t\trestrictclauses = group_clauses_by_indexkey(index,",
          "new_line_content": "\t\t * If the match is not at the first index column, we have to verify",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "list_length",
          "new_api": null,
          "old_text": "list_length(restrictclauses)",
          "new_text": null,
          "old_line_content": "\t\tif (list_length(restrictclauses) < indexcol)",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\tindex->rel->baserestrictinfo,",
          "content_same": false
        },
        {
          "line": 459,
          "old_api": "copyObject",
          "new_api": null,
          "old_text": "copyObject(info->target)",
          "new_text": null,
          "old_line_content": "\ttle = makeTargetEntry(copyObject(info->target),",
          "new_line_content": "\tsubparse->groupClause = NIL;",
          "content_same": false
        },
        {
          "line": 461,
          "old_api": "pstrdup",
          "new_api": null,
          "old_text": "pstrdup(\"agg_target\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t  pstrdup(\"agg_target\"),",
          "new_line_content": "\tsubparse->distinctClause = NIL;",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": "list_nth",
          "new_api": null,
          "old_text": "list_nth(restrictclauses, prevcol)",
          "new_text": null,
          "old_line_content": "\t\t\tList\t   *rinfos = (List *) list_nth(restrictclauses, prevcol);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\t&found_clause);",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "list_make1",
          "new_api": null,
          "old_text": "list_make1(tle)",
          "new_text": null,
          "old_line_content": "\tsubparse->targetList = list_make1(tle);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "makeNode",
          "new_api": null,
          "old_text": "makeNode(SortClause)",
          "new_text": null,
          "old_line_content": "\tsortcl = makeNode(SortClause);",
          "new_line_content": "\t\t\t\t\t\t  1,",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(ll)",
          "new_text": null,
          "old_line_content": "\t\t\t\tRestrictInfo *rinfo = (RestrictInfo *) lfirst(ll);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 470,
          "old_api": "list_make1",
          "new_api": null,
          "old_text": "list_make1(sortcl)",
          "new_text": null,
          "old_line_content": "\tsubparse->sortClause = list_make1(sortcl);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": "is_opclause",
          "new_api": null,
          "old_text": "is_opclause(rinfo->clause)",
          "new_text": null,
          "old_line_content": "\t\t\t\tAssert(is_opclause(rinfo->clause));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 88,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!parse->setOperations)",
          "new_text": null,
          "old_line_content": "\tAssert(!parse->setOperations);\t\t/* shouldn't get here if a setop */",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(node, Aggref)",
          "new_text": null,
          "old_line_content": "\tif (IsA(node, Aggref))",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "get_op_opfamily_strategy",
          "new_api": null,
          "old_text": "get_op_opfamily_strategy(((OpExpr *) rinfo->clause)->opno,\n\t\t\t\t\t\t\t\t\t\t\t index->opfamily[prevcol])",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tget_op_opfamily_strategy(((OpExpr *) rinfo->clause)->opno,",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 474,
          "old_api": "makeConst",
          "new_api": null,
          "old_text": "makeConst(INT8OID, sizeof(int64),\n\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(1),\n\t\t\t\t\t\t\t\t\t\t\t  false, false /* not by val */ )",
          "new_text": null,
          "old_line_content": "\tsubparse->limitCount = (Node *) makeConst(INT8OID, sizeof(int64),",
          "new_line_content": "\tsortcl->sortop = info->aggsortop;",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": "Int64GetDatum",
          "new_api": null,
          "old_text": "Int64GetDatum(1)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t  Int64GetDatum(1),",
          "new_line_content": "\tsortcl->nulls_first = info->nulls_first;",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(aggref->agglevelsup == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(aggref->agglevelsup == 0);",
          "new_line_content": "\t\tAggref\t   *aggref = (Aggref *) node;",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": "list_length",
          "new_api": null,
          "old_text": "list_length(aggref->args)",
          "new_text": null,
          "old_line_content": "\t\tif (list_length(aggref->args) != 1)",
          "new_line_content": "\t\tOid\t\t\taggsortop;",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": "fetch_agg_sort_op",
          "new_api": null,
          "old_text": "fetch_agg_sort_op(aggref->aggfnoid)",
          "new_text": null,
          "old_line_content": "\t\taggsortop = fetch_agg_sort_op(aggref->aggfnoid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": "create_index_path",
          "new_api": null,
          "old_text": "create_index_path(root, index,\n\t\t\t\t\t\t\t\t\t restrictclauses,\n\t\t\t\t\t\t\t\t\t NIL,\n\t\t\t\t\t\t\t\t\t indexscandir,\n\t\t\t\t\t\t\t\t\t NULL)",
          "new_text": null,
          "old_line_content": "\t\tnew_path = create_index_path(root, index,",
          "new_line_content": "\t\tif (prevcol < indexcol)",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(parse->jointree, FromExpr)",
          "new_text": null,
          "old_line_content": "\tAssert(parse->jointree != NULL && IsA(parse->jointree, FromExpr));",
          "new_line_content": "\t * levels of FromExpr.",
          "content_same": false
        },
        {
          "line": 108,
          "old_api": "list_length",
          "new_api": null,
          "old_text": "list_length(parse->jointree->fromlist)",
          "new_text": null,
          "old_line_content": "\tif (list_length(parse->jointree->fromlist) != 1)",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": "foreach",
          "new_api": null,
          "old_text": "foreach(l, *context)",
          "new_text": null,
          "old_line_content": "\t\tforeach(l, *context)",
          "new_line_content": "\t\t\treturn true;\t\t/* not a MIN/MAX aggregate */",
          "content_same": false
        },
        {
          "line": 111,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(rtr, RangeTblRef)",
          "new_text": null,
          "old_line_content": "\tif (!IsA(rtr, RangeTblRef))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(l)",
          "new_text": null,
          "old_line_content": "\t\t\tinfo = (MinMaxAggInfo *) lfirst(l);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 113,
          "old_api": "rt_fetch",
          "new_api": null,
          "old_text": "rt_fetch(rtr->rtindex, parse->rtable)",
          "new_text": null,
          "old_line_content": "\trte = rt_fetch(rtr->rtindex, parse->rtable);",
          "new_line_content": "\t\t\treturn NULL;",
          "content_same": false
        },
        {
          "line": 242,
          "old_api": "equal",
          "new_api": null,
          "old_text": "equal(info->target, curTarget)",
          "new_text": null,
          "old_line_content": "\t\t\t\tequal(info->target, curTarget))",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "create_plan",
          "new_api": null,
          "old_text": "create_plan(&subroot, (Path *) info->path)",
          "new_text": null,
          "old_line_content": "\tplan = create_plan(&subroot, (Path *) info->path);",
          "new_line_content": "\t * fraction of NULLs isn't high enough to change the decision.",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "copyObject",
          "new_api": null,
          "old_text": "copyObject(subparse->targetList)",
          "new_text": null,
          "old_line_content": "\tplan->targetlist = copyObject(subparse->targetList);",
          "new_line_content": "\t * The NOT NULL qual has to go on the actual indexscan; create_plan might",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(plan, Result)",
          "new_text": null,
          "old_line_content": "\tif (IsA(plan, Result))",
          "new_line_content": "\t * quals.",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "copyObject",
          "new_api": null,
          "old_text": "copyObject(info->target)",
          "new_text": null,
          "old_line_content": "\tntest->arg = copyObject(info->target);",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 251,
          "old_api": "lappend",
          "new_api": null,
          "old_text": "lappend(*context, info)",
          "new_text": null,
          "old_line_content": "\t\t*context = lappend(*context, info);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(indexscandir)",
          "new_text": null,
          "old_line_content": "\t\t\tif (ScanDirectionIsForward(indexscandir))",
          "new_line_content": "\t\t * Keep if first or if cheaper than previous best.",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 61,
      "total_deletions": 61,
      "total_api_changes": 138
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 15,
        "api_related_lines": 138,
        "non_api_lines": 7,
        "non_api_line_numbers": [
          73,
          106,
          11,
          105,
          109,
          115,
          118
        ]
      }
    },
    "api_calls_before": 86,
    "api_calls_after": 85,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 7,
      "total_diff_lines": 48
    }
  }
}