{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1879175b18211962984e6ff0f3cba344c386b11c",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1879175b18211962984e6ff0f3cba344c386b11c/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1879175b18211962984e6ff0f3cba344c386b11c/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1879175b18211962984e6ff0f3cba344c386b11c/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1010,
          "old_api": "typeLen",
          "new_api": "ExecEvalExpr",
          "old_text": "typeLen(resultType)",
          "new_text": "ExecEvalExpr((Node *) newexpr, NULL,\n\t\t\t\t\t\t\t\t\t\t &const_is_null, &isDone)",
          "old_line_content": "\t\t\t\treturn (Node *) makeConst(result_typeid, typeLen(resultType),",
          "new_line_content": "\t\t\t\tconst_val = ExecEvalExpr((Node *) newexpr, NULL,",
          "content_same": false
        },
        {
          "line": 1012,
          "old_api": "typeByVal",
          "new_api": "Assert",
          "old_text": "typeByVal(resultType)",
          "new_text": "Assert(isDone)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t  typeByVal(resultType),",
          "new_line_content": "\t\t\t\tAssert(isDone);\t/* if this isn't set, we blew it... */",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "DatumGetInt32",
          "new_api": "lfirst",
          "old_text": "DatumGetInt32(const_input->constvalue)",
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\t\telse if (DatumGetInt32(const_input->constvalue))",
          "new_line_content": "\t\t\t\t\tif (! IsA(lfirst(arg), Const))",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "lfirst",
          "new_api": "MAKEBOOLCONST",
          "old_text": "lfirst(newargs)",
          "new_text": "MAKEBOOLCONST(true, false)",
          "old_line_content": "\t\t\t\t\treturn (Node *) lfirst(newargs);",
          "new_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(true, false);",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": "make_orclause",
          "new_api": "MAKEBOOLCONST",
          "old_text": "make_orclause(newargs)",
          "new_text": "MAKEBOOLCONST(false, true)",
          "old_line_content": "\t\t\t\treturn (Node *) make_orclause(newargs);",
          "new_line_content": "\t\t\t\t\tnewargs = lappend(newargs, MAKEBOOLCONST(false, true));",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "DatumGetInt32",
          "new_api": "lfirst",
          "old_text": "DatumGetInt32(const_input->constvalue)",
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\t\telse if (! DatumGetInt32(const_input->constvalue))",
          "new_line_content": "\t\t\t\t\tif (! IsA(lfirst(arg), Const))",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "lfirst",
          "new_api": "MAKEBOOLCONST",
          "old_text": "lfirst(newargs)",
          "new_text": "MAKEBOOLCONST(false, false)",
          "old_line_content": "\t\t\t\t\treturn (Node *) lfirst(newargs);",
          "new_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(false, false);",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": "make_andclause",
          "new_api": "MAKEBOOLCONST",
          "old_text": "make_andclause(newargs)",
          "new_text": "MAKEBOOLCONST(false, true)",
          "old_line_content": "\t\t\t\treturn (Node *) make_andclause(newargs);",
          "new_line_content": "\t\t\t\t\tnewargs = lappend(newargs, MAKEBOOLCONST(false, true));",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "length",
          "new_api": "MAKEBOOLCONST",
          "old_text": "length(args)",
          "new_text": "MAKEBOOLCONST(true, false)",
          "old_line_content": "\t\t\t\tAssert(length(args) == 1);",
          "new_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(true, false);",
          "content_same": false
        },
        {
          "line": 1122,
          "old_api": "DatumGetInt32",
          "new_api": "length",
          "old_text": "DatumGetInt32(const_input->constvalue)",
          "new_text": "length(args)",
          "old_line_content": "\t\t\t\treturn MAKEBOOLCONST(! DatumGetInt32(const_input->constvalue),",
          "new_line_content": "\t\t\t\tAssert(length(args) == 1);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": "IsA",
          "new_api": "makeNode",
          "old_text": "IsA(node, CaseExpr)",
          "new_text": "makeNode(RelabelType)",
          "old_line_content": "\tif (IsA(node, CaseExpr))",
          "new_line_content": "\t\t\tRelabelType *newrelabel = makeNode(RelabelType);",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": "walker",
          "new_api": "expression_tree_walker",
          "old_text": "walker(((Iter *) node)->iterexpr, context)",
          "new_text": "expression_tree_walker((Node *) expr->args,\n\t\t\t\t\t\t\t\t\t\t   walker, context)",
          "old_line_content": "\t\t\treturn walker(((Iter *) node)->iterexpr, context);",
          "new_line_content": "\t\t\t\tif (expression_tree_walker((Node *) expr->args,",
          "content_same": false
        },
        {
          "line": 1416,
          "old_api": "expression_tree_walker",
          "new_api": "walker",
          "old_text": "expression_tree_walker((Node *) aref->reflowerindexpr,\n\t\t\t\t\t\t\t\t\t\t   walker, context)",
          "new_text": "walker(((Iter *) node)->iterexpr, context)",
          "old_line_content": "\t\t\t\tif (expression_tree_walker((Node *) aref->reflowerindexpr,",
          "new_line_content": "\t\t\treturn walker(((Iter *) node)->iterexpr, context);",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "IsA",
          "new_api": "walker",
          "old_text": "IsA(when, CaseWhen)",
          "new_text": "walker(((RelabelType *) node)->arg, context)",
          "old_line_content": "\t\t\t\t\tAssert(IsA(when, CaseWhen));",
          "new_line_content": "\t\t\treturn walker(((RelabelType *) node)->arg, context);",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "walker",
          "new_api": "lfirst",
          "old_text": "walker(caseexpr->arg, context)",
          "new_text": "lfirst(temp)",
          "old_line_content": "\t\t\t\tif (walker(caseexpr->arg, context))",
          "new_line_content": "\t\t\t\t\tCaseWhen   *when = (CaseWhen *) lfirst(temp);",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": "lfirst",
          "new_api": "walker",
          "old_text": "lfirst(temp)",
          "new_text": "walker((Node *) sublink->lefthand, context)",
          "old_line_content": "\t\t\t\tif (walker((Node *) lfirst(temp), context))",
          "new_line_content": "\t\t\t\t\treturn walker((Node *) sublink->lefthand, context);",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "nodeTag",
          "new_api": "lfirst",
          "old_text": "nodeTag(node)",
          "new_text": "lfirst(temp)",
          "old_line_content": "\t\t\t\t nodeTag(node));",
          "new_line_content": "\t\t\t\tif (walker((Node *) lfirst(temp), context))",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": "CHECKFLATCOPY",
          "new_api": "FLATCOPY",
          "old_text": "CHECKFLATCOPY(newsubplan, expr->oper, SubPlan)",
          "new_text": "FLATCOPY(newnode, expr, Expr)",
          "old_line_content": "\t\t\t\t\tCHECKFLATCOPY(newsubplan, expr->oper, SubPlan);",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, expr, Expr);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1043,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\t\t/* otherwise, we can drop the constant-false input */",
          "new_line_content": "\t\t\t\t\t\tnewargs = lappend(newargs, lfirst(arg));",
          "content_same": false
        },
        {
          "line": 1046,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\t * We could return TRUE before falling out of the loop,",
          "new_line_content": "\t\t\t\t\tconst_input = (Const *) lfirst(arg);",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": null,
          "new_api": "DatumGetInt32",
          "old_text": null,
          "new_text": "DatumGetInt32(const_input->constvalue)",
          "old_line_content": "\t\t\t\t * We'd need to check all the inputs for non-removability.",
          "new_line_content": "\t\t\t\t\telse if (DatumGetInt32(const_input->constvalue))",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": null,
          "new_api": "nodeTag",
          "old_text": null,
          "new_text": "nodeTag(node)",
          "old_line_content": "\t\tcase T_Expr:",
          "new_line_content": "\tswitch (nodeTag(node))",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": null,
          "new_api": "copyObject",
          "old_text": null,
          "new_text": "copyObject(node)",
          "old_line_content": "\t\t\t\tif (expr->opType == SUBPLAN_EXPR)",
          "new_line_content": "\t\t\treturn (Node *) copyObject(node);",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": null,
          "new_api": "MAKEBOOLCONST",
          "old_text": null,
          "new_text": "MAKEBOOLCONST(false, false)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(false, false);",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "lnext",
          "old_text": null,
          "new_text": "lnext(newargs)",
          "old_line_content": "\t\t\t\t * AND arguments are handled as follows:",
          "new_line_content": "\t\t\t\tif (lnext(newargs) == NIL)",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(newargs)",
          "old_line_content": "\t\t\t\t *\tnon constant: keep",
          "new_line_content": "\t\t\t\t\treturn (Node *) lfirst(newargs);",
          "content_same": false
        },
        {
          "line": 1070,
          "old_api": null,
          "new_api": "make_orclause",
          "old_text": null,
          "new_text": "make_orclause(newargs)",
          "old_line_content": "\t\t\t\t *\tFALSE: force result to FALSE",
          "new_line_content": "\t\t\t\treturn (Node *) make_orclause(newargs);",
          "content_same": false
        },
        {
          "line": 1590,
          "old_api": null,
          "new_api": "CHECKFLATCOPY",
          "old_text": null,
          "new_text": "CHECKFLATCOPY(newsubplan, expr->oper, SubPlan)",
          "old_line_content": "\t\t\t\t\t/* but not the subplan itself, which is referenced as-is */",
          "new_line_content": "\t\t\t\t\tCHECKFLATCOPY(newsubplan, expr->oper, SubPlan);",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": null,
          "new_api": "CHECKFLATCOPY",
          "old_text": null,
          "new_text": "CHECKFLATCOPY(newsubplan->sublink, oldsublink, SubLink)",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\tCHECKFLATCOPY(newsubplan->sublink, oldsublink, SubLink);",
          "content_same": false
        },
        {
          "line": 1595,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->args, expr->args, List *)",
          "old_line_content": "\t\t\t\t\t * linking to original oper node (OK?)",
          "new_line_content": "\t\t\t\t\tMUTATE(newnode->args, expr->args, List *);",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\t\t/* otherwise, we can drop the constant-true input */",
          "new_line_content": "\t\t\t\t\t\tnewargs = lappend(newargs, lfirst(arg));",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->args, expr->args, List *)",
          "old_line_content": "\t\t\t\tAggref   *newnode;",
          "new_line_content": "\t\t\t\t\tMUTATE(newnode->args, expr->args, List *);",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\t * We could return FALSE before falling out of the loop,",
          "new_line_content": "\t\t\t\t\tconst_input = (Const *) lfirst(arg);",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "DatumGetInt32",
          "old_text": null,
          "new_text": "DatumGetInt32(const_input->constvalue)",
          "old_line_content": "\t\t\t\t * We'd need to check all the inputs for non-removability.",
          "new_line_content": "\t\t\t\t\telse if (! DatumGetInt32(const_input->constvalue))",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, aggref, Aggref)",
          "old_line_content": "\t\t\t\tIter   *newnode;",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, aggref, Aggref);",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->target, aggref->target, Node *)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tMUTATE(newnode->target, aggref->target, Node *);",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, iter, Iter)",
          "old_line_content": "\t\t\t\tArrayRef   *newnode;",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, iter, Iter);",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->iterexpr, iter->iterexpr, Node *)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tMUTATE(newnode->iterexpr, iter->iterexpr, Node *);",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": null,
          "new_api": "lnext",
          "old_text": null,
          "new_text": "lnext(newargs)",
          "old_line_content": "\t\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\tif (lnext(newargs) == NIL)",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": null,
          "new_api": "make_andclause",
          "old_text": null,
          "new_text": "make_andclause(newargs)",
          "old_line_content": "\t\t\t\tif (const_input->constisnull)",
          "new_line_content": "\t\t\t\treturn (Node *) make_andclause(newargs);",
          "content_same": false
        },
        {
          "line": 1123,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(args)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t false);",
          "new_line_content": "\t\t\t\tif (! IsA(lfirst(args), Const))",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, arrayref, ArrayRef)",
          "old_line_content": "\t\t\t\t\t   Node *);",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, arrayref, ArrayRef);",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(args)",
          "old_line_content": "\t\t\t\t/*",
          "new_line_content": "\t\t\t\tconst_input = (Const *) lfirst(args);",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->refupperindexpr, arrayref->refupperindexpr,\n\t\t\t\t\t   List *)",
          "old_line_content": "\t\t\t\treturn (Node *) newnode;",
          "new_line_content": "\t\t\t\tMUTATE(newnode->refupperindexpr, arrayref->refupperindexpr,",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->reflowerindexpr, arrayref->reflowerindexpr,\n\t\t\t\t\t   List *)",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\t\tMUTATE(newnode->reflowerindexpr, arrayref->reflowerindexpr,",
          "content_same": false
        },
        {
          "line": 1128,
          "old_api": null,
          "new_api": "MAKEBOOLCONST",
          "old_text": null,
          "new_text": "MAKEBOOLCONST(false, true)",
          "old_line_content": "\t\t\t\t * with it.  The arglist simplification above was wasted",
          "new_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(false, true);",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->refexpr, arrayref->refexpr,\n\t\t\t\t\t   Node *)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tMUTATE(newnode->refexpr, arrayref->refexpr,",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": null,
          "new_api": "DatumGetInt32",
          "old_text": null,
          "new_text": "DatumGetInt32(const_input->constvalue)",
          "old_line_content": "\t\t\t\t */",
          "new_line_content": "\t\t\t\treturn MAKEBOOLCONST(! DatumGetInt32(const_input->constvalue),",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->refassgnexpr, arrayref->refassgnexpr,\n\t\t\t\t\t   Node *)",
          "old_line_content": "\t\t\t\tRelabelType *newnode;",
          "new_line_content": "\t\t\t\tMUTATE(newnode->refassgnexpr, arrayref->refassgnexpr,",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, relabel, RelabelType)",
          "old_line_content": "\t\t\t\tCaseExpr   *newnode;",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, relabel, RelabelType);",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"eval_const_expressions: unexpected opType %d\",\n\t\t\t\t\t (int) expr->opType)",
          "old_line_content": "\t\t * and return a replacement Expr node using the",
          "new_line_content": "\t\t\t\telog(ERROR, \"eval_const_expressions: unexpected opType %d\",",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->arg, relabel->arg, Node *)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tMUTATE(newnode->arg, relabel->arg, Node *);",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, caseexpr, CaseExpr)",
          "old_line_content": "\t\tcase T_CaseWhen:",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, caseexpr, CaseExpr);",
          "content_same": false
        },
        {
          "line": 1663,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->args, caseexpr->args, List *)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tMUTATE(newnode->args, caseexpr->args, List *);",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->arg, caseexpr->arg, Node *)",
          "old_line_content": "\t\t\t\tCaseWhen   *newnode;",
          "new_line_content": "\t\t\t\tMUTATE(newnode->arg, caseexpr->arg, Node *);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "makeNode",
          "old_text": null,
          "new_text": "makeNode(Expr)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tnewexpr = makeNode(Expr);",
          "content_same": false
        },
        {
          "line": 1666,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->defresult, caseexpr->defresult, Node *)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tMUTATE(newnode->defresult, caseexpr->defresult, Node *);",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(node, RelabelType)",
          "old_line_content": "\t\t * keep it to show that?  At present I don't think so.",
          "new_line_content": "\tif (IsA(node, RelabelType))",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, casewhen, CaseWhen)",
          "old_line_content": "\t\t\t\t/* A \"bare\" SubLink (note we will not come here if we found",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, casewhen, CaseWhen);",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->expr, casewhen->expr, Node *)",
          "old_line_content": "\t\t\t\t * a SUBPLAN_EXPR node above it).  Transform the lefthand side,",
          "new_line_content": "\t\t\t\tMUTATE(newnode->expr, casewhen->expr, Node *);",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->result, casewhen->result, Node *)",
          "old_line_content": "\t\t\t\t * but not the oper list nor the subquery.",
          "new_line_content": "\t\t\t\tMUTATE(newnode->result, casewhen->result, Node *);",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "eval_const_expressions_mutator",
          "old_text": null,
          "new_text": "eval_const_expressions_mutator(relabel->arg, context)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\targ = eval_const_expressions_mutator(relabel->arg, context);",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(arg, Const)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tif (arg && IsA(arg, Const))",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, sublink, SubLink)",
          "old_line_content": "\t\t\t\t * per se, so just invoke it on each list element.",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, sublink, SubLink);",
          "content_same": false
        },
        {
          "line": 1691,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->lefthand, sublink->lefthand, List *)",
          "old_line_content": "\t\t\t\t * NOTE: this would fail badly on a list with integer elements!",
          "new_line_content": "\t\t\t\tMUTATE(newnode->lefthand, sublink->lefthand, List *);",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(node, CaseExpr)",
          "old_line_content": "\t\t * simplify the entire CASE to that alternative's expression.",
          "new_line_content": "\tif (IsA(node, CaseExpr))",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(temp, (List *) node)",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\t\tforeach(temp, (List *) node)",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": null,
          "new_api": "lappend",
          "old_text": null,
          "new_text": "lappend(resultlist,\n\t\t\t\t\t\t\t\t\t\t mutator((Node *) lfirst(temp),\n\t\t\t\t\t\t\t\t\t\t\t\t context))",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\t\tresultlist = lappend(resultlist,",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(temp)",
          "old_line_content": "\t\t\t\t/* We mutate the expression, but not the resdom, by default. */",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t mutator((Node *) lfirst(temp),",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "FLATCOPY",
          "old_text": null,
          "new_text": "FLATCOPY(newnode, targetentry, TargetEntry)",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\t\tFLATCOPY(newnode, targetentry, TargetEntry);",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": null,
          "new_api": "MUTATE",
          "old_text": null,
          "new_text": "MUTATE(newnode->expr, targetentry->expr, Node *)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tMUTATE(newnode->expr, targetentry->expr, Node *);",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(arg, caseexpr->args)",
          "old_line_content": "\t\t\tif (casewhen->expr == NULL ||",
          "new_line_content": "\t\tforeach(arg, caseexpr->args)",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"expression_tree_mutator: Unexpected node type %d\",\n\t\t\t\t nodeTag(node))",
          "old_line_content": "",
          "new_line_content": "\t\t\telog(ERROR, \"expression_tree_mutator: Unexpected node type %d\",",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": null,
          "new_api": "nodeTag",
          "old_text": null,
          "new_text": "nodeTag(node)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t nodeTag(node));",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(arg)",
          "old_line_content": "\t\t\t\tcontinue;",
          "new_line_content": "\t\t\t\texpression_tree_mutator((Node *) lfirst(arg),",
          "content_same": false
        },
        {
          "line": 1218,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(casewhen, CaseWhen)",
          "old_line_content": "\t\t\tif (const_input->constisnull ||",
          "new_line_content": "\t\t\tAssert(IsA(casewhen, CaseWhen));",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(casewhen->expr, Const)",
          "old_line_content": "\t\t\t\tcontinue;\t\t/* drop alternative with FALSE condition */",
          "new_line_content": "\t\t\t\t! IsA(casewhen->expr, Const))",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": null,
          "new_api": "lappend",
          "old_text": null,
          "new_text": "lappend(newargs, casewhen)",
          "old_line_content": "\t\t\t * Found a TRUE condition.  If it's the first (un-dropped)",
          "new_line_content": "\t\t\t\tnewargs = lappend(newargs, casewhen);",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": null,
          "new_api": "DatumGetInt32",
          "old_text": null,
          "new_text": "DatumGetInt32(const_input->constvalue)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\t\t! DatumGetInt32(const_input->constvalue))",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": null,
          "new_api": "lappend",
          "old_text": null,
          "new_text": "lappend(newargs, casewhen)",
          "old_line_content": "\t\tif (newargs == NIL)",
          "new_line_content": "\t\t\tnewargs = lappend(newargs, casewhen);",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "eval_const_expressions_mutator",
          "old_text": null,
          "new_text": "eval_const_expressions_mutator(caseexpr->defresult,\n\t\t\t\t\t\t\t\t\t\t\t\t   context)",
          "old_line_content": "\t\tnewcase->arg = NULL;",
          "new_line_content": "\t\tdefresult = eval_const_expressions_mutator(caseexpr->defresult,",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "makeNode",
          "old_text": null,
          "new_text": "makeNode(CaseExpr)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tnewcase = makeNode(CaseExpr);",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(node, Iter)",
          "old_line_content": "\t\t * Is that the right thing?",
          "new_line_content": "\tif (IsA(node, Iter))",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": null,
          "new_api": "is_funcclause",
          "old_text": null,
          "new_text": "is_funcclause(iter->iterexpr)",
          "old_line_content": "\t\t\tnewfunc->opType = func->opType;",
          "new_line_content": "\t\tif (is_funcclause(iter->iterexpr))",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "expression_tree_mutator",
          "old_text": null,
          "new_text": "expression_tree_mutator((Node *) func->args,\n\t\t\t\t\t\t\t\t\t\teval_const_expressions_mutator,\n\t\t\t\t\t\t\t\t\t\t(void *) context)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\texpression_tree_mutator((Node *) func->args,",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": null,
          "new_api": "makeNode",
          "old_text": null,
          "new_text": "makeNode(Iter)",
          "old_line_content": "\t * expression_tree_mutator, which will copy the node unchanged",
          "new_line_content": "\t\t\tnewiter = makeNode(Iter);",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": null,
          "new_api": "expression_tree_mutator",
          "old_text": null,
          "new_text": "expression_tree_mutator(node, eval_const_expressions_mutator,\n\t\t\t\t\t\t\t\t   (void *) context)",
          "old_line_content": " * understood how to recurse through an expression node tree.  That was",
          "new_line_content": "\treturn expression_tree_mutator(node, eval_const_expressions_mutator,",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": null,
          "new_api": "nodeTag",
          "old_text": null,
          "new_text": "nodeTag(node)",
          "old_line_content": "\t\tcase T_Expr:",
          "new_line_content": "\tswitch (nodeTag(node))",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker((Node *) ((SubPlan *) expr->oper)->sublink,\n\t\t\t\t\t\t\t   context)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\tif (walker((Node *) ((SubPlan *) expr->oper)->sublink,",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(((Aggref *) node)->target, context)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t   walker, context))",
          "new_line_content": "\t\t\treturn walker(((Aggref *) node)->target, context);",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": null,
          "new_api": "expression_tree_walker",
          "old_text": null,
          "new_text": "expression_tree_walker((Node *) aref->refupperindexpr,\n\t\t\t\t\t\t\t\t\t\t   walker, context)",
          "old_line_content": "\t\t\t\t\treturn true;",
          "new_line_content": "\t\t\t\tif (expression_tree_walker((Node *) aref->refupperindexpr,",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": null,
          "new_api": "expression_tree_walker",
          "old_text": null,
          "new_text": "expression_tree_walker((Node *) aref->reflowerindexpr,\n\t\t\t\t\t\t\t\t\t\t   walker, context)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tif (expression_tree_walker((Node *) aref->reflowerindexpr,",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(aref->refexpr, context)",
          "old_line_content": "\t\tcase T_CaseExpr:",
          "new_line_content": "\t\t\t\tif (walker(aref->refexpr, context))",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(aref->refassgnexpr, context)",
          "old_line_content": "\t\t\t\tCaseExpr   *caseexpr = (CaseExpr *) node;",
          "new_line_content": "\t\t\t\tif (walker(aref->refassgnexpr, context))",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(temp, caseexpr->args)",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\tforeach(temp, caseexpr->args)",
          "content_same": false
        },
        {
          "line": 1443,
          "old_api": null,
          "new_api": "IsA",
          "old_text": null,
          "new_text": "IsA(when, CaseWhen)",
          "old_line_content": "\t\t\t\t\treturn true;",
          "new_line_content": "\t\t\t\t\tAssert(IsA(when, CaseWhen));",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(when->result, context)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\tif (walker(when->result, context))",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(caseexpr->arg, context)",
          "old_line_content": "\t\t\t\tSubLink   *sublink = (SubLink *) node;",
          "new_line_content": "\t\t\t\tif (walker(caseexpr->arg, context))",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(caseexpr->defresult, context)",
          "old_line_content": "\t\t\t\t/* If the SubLink has already been processed by subselect.c,",
          "new_line_content": "\t\t\t\tif (walker(caseexpr->defresult, context))",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker((Node *) sublink->oper, context)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\treturn walker((Node *) sublink->oper, context);",
          "content_same": false
        },
        {
          "line": 1472,
          "old_api": null,
          "new_api": "foreach",
          "old_text": null,
          "new_text": "foreach(temp, (List *) node)",
          "old_line_content": "\t\tdefault:",
          "new_line_content": "\t\t\tforeach(temp, (List *) node)",
          "content_same": false
        },
        {
          "line": 1479,
          "old_api": null,
          "new_api": "walker",
          "old_text": null,
          "new_text": "walker(((TargetEntry *) node)->expr, context)",
          "old_line_content": "",
          "new_line_content": "\t\t\treturn walker(((TargetEntry *) node)->expr, context);",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"expression_tree_walker: Unexpected node type %d\",\n\t\t\t\t nodeTag(node))",
          "old_line_content": " * expression_tree_mutator() is designed to support routines that make a",
          "new_line_content": "\t\t\telog(ERROR, \"expression_tree_walker: Unexpected node type %d\",",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "nodeTag",
          "old_text": null,
          "new_text": "nodeTag(node)",
          "old_line_content": " * modified copy of an expression tree, with some nodes being added,",
          "new_line_content": "\t\t\t\t nodeTag(node));",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": null,
          "new_api": "makeNode",
          "old_text": null,
          "new_text": "makeNode(Expr)",
          "old_line_content": "\t\t\t\t * ExecEvalExpr() code used in this situation will use",
          "new_line_content": "\t\t\t\tnewexpr = makeNode(Expr);",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(newexpr)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t  false, false);",
          "new_line_content": "\t\t\t\tpfree(newexpr);",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": null,
          "new_api": "typeidType",
          "old_text": null,
          "new_text": "typeidType(result_typeid)",
          "old_line_content": "\t\t\t\t/*",
          "new_line_content": "\t\t\t\tresultType = typeidType(result_typeid);",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "typeLen",
          "old_text": null,
          "new_text": "typeLen(resultType)",
          "old_line_content": "\t\t\t\t * OR arguments are handled as follows:",
          "new_line_content": "\t\t\t\treturn (Node *) makeConst(result_typeid, typeLen(resultType),",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": null,
          "new_api": "typeByVal",
          "old_text": null,
          "new_text": "typeByVal(resultType)",
          "old_line_content": "\t\t\t\t *  FALSE: drop (does not affect result)",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t  typeByVal(resultType),",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1033,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (! IsA(lfirst(arg), Const))",
          "new_line_content": "\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tnewargs = lappend(newargs, lfirst(arg));",
          "new_line_content": "\t\t\t\tList\t   *arg;",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tconst_input = (Const *) lfirst(arg);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "nodeTag",
          "new_api": null,
          "old_text": "nodeTag(node)",
          "new_text": null,
          "old_line_content": "\tswitch (nodeTag(node))",
          "new_line_content": "\t  (newnode) = makeNode(nodetype), \\",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(true, false)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(true, false);",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(false, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tnewargs = lappend(newargs, MAKEBOOLCONST(false, true));",
          "new_line_content": "\t\t\t\t * We could return TRUE before falling out of the loop,",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "copyObject",
          "new_api": null,
          "old_text": "copyObject(node)",
          "new_text": null,
          "old_line_content": "\t\t\treturn (Node *) copyObject(node);",
          "new_line_content": "\t\treturn NULL;",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(false, false)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(false, false);",
          "new_line_content": "\t\t\t\t * We'd need to check all the inputs for non-removability.",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": "lnext",
          "new_api": null,
          "old_text": "lnext(newargs)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (lnext(newargs) == NIL)",
          "new_line_content": "\t\t\t\tif (forceTrue)",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, expr, Expr)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, expr, Expr);",
          "new_line_content": "\t\tcase T_Param:",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": "CHECKFLATCOPY",
          "new_api": null,
          "old_text": "CHECKFLATCOPY(newsubplan->sublink, oldsublink, SubLink)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tCHECKFLATCOPY(newsubplan->sublink, oldsublink, SubLink);",
          "new_line_content": "\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->args, expr->args, List *)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tMUTATE(newnode->args, expr->args, List *);",
          "new_line_content": "\t\t\t\t\tSubPlan\t   *newsubplan;",
          "content_same": false
        },
        {
          "line": 1589,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newsubplan->sublink->oper, oldsublink->oper, List*)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tMUTATE(newsubplan->sublink->oper, oldsublink->oper, List*);",
          "new_line_content": "\t\t\t\t\t/* flat-copy the oper node, which is a SubPlan */",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (! IsA(lfirst(arg), Const))",
          "new_line_content": "\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tnewargs = lappend(newargs, lfirst(arg));",
          "new_line_content": "\t\t\t\tList\t   *arg;",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tconst_input = (Const *) lfirst(arg);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, aggref, Aggref)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, aggref, Aggref);",
          "new_line_content": "\t\t\t\treturn (Node *) newnode;",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->target, aggref->target, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->target, aggref->target, Node *);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(false, false)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(false, false);",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(false, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tnewargs = lappend(newargs, MAKEBOOLCONST(false, true));",
          "new_line_content": "\t\t\t\t * We could return FALSE before falling out of the loop,",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, iter, Iter)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, iter, Iter);",
          "new_line_content": "\t\t\t\treturn (Node *) newnode;",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(true, false)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(true, false);",
          "new_line_content": "\t\t\t\t * We'd need to check all the inputs for non-removability.",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->iterexpr, iter->iterexpr, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->iterexpr, iter->iterexpr, Node *);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "lnext",
          "new_api": null,
          "old_text": "lnext(newargs)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (lnext(newargs) == NIL)",
          "new_line_content": "\t\t\t\tif (forceFalse)",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(args)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (! IsA(lfirst(args), Const))",
          "new_line_content": "\t\t\t\t/* If only one nonconst-or-NULL input, it's the result */",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, arrayref, ArrayRef)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, arrayref, ArrayRef);",
          "new_line_content": "\t\t\t\treturn (Node *) newnode;",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->refupperindexpr, arrayref->refupperindexpr,\n\t\t\t\t\t   List *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->refupperindexpr, arrayref->refupperindexpr,",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->reflowerindexpr, arrayref->reflowerindexpr,\n\t\t\t\t\t   List *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->reflowerindexpr, arrayref->reflowerindexpr,",
          "new_line_content": "\t\tcase T_ArrayRef:",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": "MAKEBOOLCONST",
          "new_api": null,
          "old_text": "MAKEBOOLCONST(false, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn MAKEBOOLCONST(false, true);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->refexpr, arrayref->refexpr,\n\t\t\t\t\t   Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->refexpr, arrayref->refexpr,",
          "new_line_content": "\t\t\t\tArrayRef   *arrayref = (ArrayRef *) node;",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->refassgnexpr, arrayref->refassgnexpr,\n\t\t\t\t\t   Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->refassgnexpr, arrayref->refassgnexpr,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, relabel, RelabelType)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, relabel, RelabelType);",
          "new_line_content": "\t\t\t\treturn (Node *) newnode;",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"eval_const_expressions: unexpected opType %d\",\n\t\t\t\t\t (int) expr->opType)",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(ERROR, \"eval_const_expressions: unexpected opType %d\",",
          "new_line_content": "\t\t\t\t/*",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->arg, relabel->arg, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->arg, relabel->arg, Node *);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, caseexpr, CaseExpr)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, caseexpr, CaseExpr);",
          "new_line_content": "\t\t\t\treturn (Node *) newnode;",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->args, caseexpr->args, List *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->args, caseexpr->args, List *);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->arg, caseexpr->arg, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->arg, caseexpr->arg, Node *);",
          "new_line_content": "\t\tcase T_CaseExpr:",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->defresult, caseexpr->defresult, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->defresult, caseexpr->defresult, Node *);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": "makeNode",
          "new_api": null,
          "old_text": "makeNode(Expr)",
          "new_text": null,
          "old_line_content": "\t\tnewexpr = makeNode(Expr);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(node, RelabelType)",
          "new_text": null,
          "old_line_content": "\tif (IsA(node, RelabelType))",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, casewhen, CaseWhen)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, casewhen, CaseWhen);",
          "new_line_content": "\t\t\t\treturn (Node *) newnode;",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->expr, casewhen->expr, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->expr, casewhen->expr, Node *);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1669,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->result, casewhen->result, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->result, casewhen->result, Node *);",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1166,
          "old_api": "eval_const_expressions_mutator",
          "new_api": null,
          "old_text": "eval_const_expressions_mutator(relabel->arg, context)",
          "new_text": null,
          "old_line_content": "\t\targ = eval_const_expressions_mutator(relabel->arg, context);",
          "new_line_content": "\t\t * the Const node.  Otherwise keep the RelabelType node.",
          "content_same": false
        },
        {
          "line": 1167,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(arg, Const)",
          "new_text": null,
          "old_line_content": "\t\tif (arg && IsA(arg, Const))",
          "new_line_content": "\t\t *",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, sublink, SubLink)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, sublink, SubLink);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->lefthand, sublink->lefthand, List *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->lefthand, sublink->lefthand, List *);",
          "new_line_content": "\t\t\t\t/* A \"bare\" SubLink (note we will not come here if we found",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "makeNode",
          "new_api": null,
          "old_text": "makeNode(RelabelType)",
          "new_text": null,
          "old_line_content": "\t\t\tRelabelType *newrelabel = makeNode(RelabelType);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": "foreach",
          "new_api": null,
          "old_text": "foreach(temp, (List *) node)",
          "new_text": null,
          "old_line_content": "\t\t\t\tforeach(temp, (List *) node)",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "lappend",
          "new_api": null,
          "old_text": "lappend(resultlist,\n\t\t\t\t\t\t\t\t\t\t mutator((Node *) lfirst(temp),\n\t\t\t\t\t\t\t\t\t\t\t\t context))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tresultlist = lappend(resultlist,",
          "new_line_content": "\t\t\t\t * per se, so just invoke it on each list element.",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(temp)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t mutator((Node *) lfirst(temp),",
          "new_line_content": "\t\t\t\t * NOTE: this would fail badly on a list with integer elements!",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "FLATCOPY",
          "new_api": null,
          "old_text": "FLATCOPY(newnode, targetentry, TargetEntry)",
          "new_text": null,
          "old_line_content": "\t\t\t\tFLATCOPY(newnode, targetentry, TargetEntry);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": "MUTATE",
          "new_api": null,
          "old_text": "MUTATE(newnode->expr, targetentry->expr, Node *)",
          "new_text": null,
          "old_line_content": "\t\t\t\tMUTATE(newnode->expr, targetentry->expr, Node *);",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": "foreach",
          "new_api": null,
          "old_text": "foreach(arg, caseexpr->args)",
          "new_text": null,
          "old_line_content": "\t\tforeach(arg, caseexpr->args)",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"expression_tree_mutator: Unexpected node type %d\",\n\t\t\t\t nodeTag(node))",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"expression_tree_mutator: Unexpected node type %d\",",
          "new_line_content": "\t\t\t\tTargetEntry   *newnode;",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": "nodeTag",
          "new_api": null,
          "old_text": "nodeTag(node)",
          "new_text": null,
          "old_line_content": "\t\t\t\t nodeTag(node));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1207,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(arg)",
          "new_text": null,
          "old_line_content": "\t\t\t\texpression_tree_mutator((Node *) lfirst(arg),",
          "new_line_content": "\t\tNode\t   *defresult;",
          "content_same": false
        },
        {
          "line": 1210,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(casewhen, CaseWhen)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(IsA(casewhen, CaseWhen));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1212,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(casewhen->expr, Const)",
          "new_text": null,
          "old_line_content": "\t\t\t\t! IsA(casewhen->expr, Const))",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "lappend",
          "new_api": null,
          "old_text": "lappend(newargs, casewhen)",
          "new_text": null,
          "old_line_content": "\t\t\t\tnewargs = lappend(newargs, casewhen);",
          "new_line_content": "\t\t\tCaseWhen   *casewhen = (CaseWhen *)",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": "DatumGetInt32",
          "new_api": null,
          "old_text": "DatumGetInt32(const_input->constvalue)",
          "new_text": null,
          "old_line_content": "\t\t\t\t! DatumGetInt32(const_input->constvalue))",
          "new_line_content": "\t\t\tif (casewhen->expr == NULL ||",
          "content_same": false
        },
        {
          "line": 1230,
          "old_api": "lappend",
          "new_api": null,
          "old_text": "lappend(newargs, casewhen)",
          "new_text": null,
          "old_line_content": "\t\t\tnewargs = lappend(newargs, casewhen);",
          "new_line_content": "\t\t\t * Found a TRUE condition.  If it's the first (un-dropped)",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "eval_const_expressions_mutator",
          "new_api": null,
          "old_text": "eval_const_expressions_mutator(caseexpr->defresult,\n\t\t\t\t\t\t\t\t\t\t\t\t   context)",
          "new_text": null,
          "old_line_content": "\t\tdefresult = eval_const_expressions_mutator(caseexpr->defresult,",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "makeNode",
          "new_api": null,
          "old_text": "makeNode(CaseExpr)",
          "new_text": null,
          "old_line_content": "\t\tnewcase = makeNode(CaseExpr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "IsA",
          "new_api": null,
          "old_text": "IsA(node, Iter)",
          "new_text": null,
          "old_line_content": "\tif (IsA(node, Iter))",
          "new_line_content": "\t\t/* Otherwise we need a new CASE node */",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "is_funcclause",
          "new_api": null,
          "old_text": "is_funcclause(iter->iterexpr)",
          "new_text": null,
          "old_line_content": "\t\tif (is_funcclause(iter->iterexpr))",
          "new_line_content": "\t\t * We must not try to eliminate the function, but we",
          "content_same": false
        },
        {
          "line": 1266,
          "old_api": "makeNode",
          "new_api": null,
          "old_text": "makeNode(Expr)",
          "new_text": null,
          "old_line_content": "\t\t\tnewfunc = makeNode(Expr);",
          "new_line_content": "\t\tIter\t   *iter = (Iter *) node;",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "expression_tree_mutator",
          "new_api": null,
          "old_text": "expression_tree_mutator((Node *) func->args,\n\t\t\t\t\t\t\t\t\t\teval_const_expressions_mutator,\n\t\t\t\t\t\t\t\t\t\t(void *) context)",
          "new_text": null,
          "old_line_content": "\t\t\t\texpression_tree_mutator((Node *) func->args,",
          "new_line_content": "\t\t\tExpr   *newfunc;",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": "expression_tree_mutator",
          "new_api": null,
          "old_text": "expression_tree_mutator(node, eval_const_expressions_mutator,\n\t\t\t\t\t\t\t\t   (void *) context)",
          "new_text": null,
          "old_line_content": "\treturn expression_tree_mutator(node, eval_const_expressions_mutator,",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": "nodeTag",
          "new_api": null,
          "old_text": "nodeTag(node)",
          "new_text": null,
          "old_line_content": "\tswitch (nodeTag(node))",
          "new_line_content": "\t * and so we need only recurse into any sub-nodes it has.",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker((Node *) ((SubPlan *) expr->oper)->sublink,\n\t\t\t\t\t\t\t   context)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (walker((Node *) ((SubPlan *) expr->oper)->sublink,",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": "expression_tree_walker",
          "new_api": null,
          "old_text": "expression_tree_walker((Node *) expr->args,\n\t\t\t\t\t\t\t\t\t\t   walker, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (expression_tree_walker((Node *) expr->args,",
          "new_line_content": "\t\t\t\tif (expr->opType == SUBPLAN_EXPR)",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(((Aggref *) node)->target, context)",
          "new_text": null,
          "old_line_content": "\t\t\treturn walker(((Aggref *) node)->target, context);",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": "expression_tree_walker",
          "new_api": null,
          "old_text": "expression_tree_walker((Node *) aref->refupperindexpr,\n\t\t\t\t\t\t\t\t\t\t   walker, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (expression_tree_walker((Node *) aref->refupperindexpr,",
          "new_line_content": "\t\tcase T_Aggref:",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(aref->refexpr, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (walker(aref->refexpr, context))",
          "new_line_content": "\t\t\t\t/* recurse directly for upper/lower array index lists */",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(aref->refassgnexpr, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (walker(aref->refassgnexpr, context))",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   walker, context))",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(((RelabelType *) node)->arg, context)",
          "new_text": null,
          "old_line_content": "\t\t\treturn walker(((RelabelType *) node)->arg, context);",
          "new_line_content": "\t\t\t\t/* walker must see the refexpr and refassgnexpr, however */",
          "content_same": false
        },
        {
          "line": 1432,
          "old_api": "foreach",
          "new_api": null,
          "old_text": "foreach(temp, caseexpr->args)",
          "new_text": null,
          "old_line_content": "\t\t\t\tforeach(temp, caseexpr->args)",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(temp)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tCaseWhen   *when = (CaseWhen *) lfirst(temp);",
          "new_line_content": "\t\tcase T_RelabelType:",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(when->expr, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (walker(when->expr, context))",
          "new_line_content": "\t\tcase T_CaseExpr:",
          "content_same": false
        },
        {
          "line": 1438,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(when->result, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (walker(when->result, context))",
          "new_line_content": "\t\t\t\tCaseExpr   *caseexpr = (CaseExpr *) node;",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker((Node *) sublink->lefthand, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn walker((Node *) sublink->lefthand, context);",
          "new_line_content": "\t\t\t\tSubLink   *sublink = (SubLink *) node;",
          "content_same": false
        },
        {
          "line": 1460,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker((Node *) sublink->oper, context)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treturn walker((Node *) sublink->oper, context);",
          "new_line_content": "\t\t\t\t/* If the SubLink has already been processed by subselect.c,",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "foreach",
          "new_api": null,
          "old_text": "foreach(temp, (List *) node)",
          "new_text": null,
          "old_line_content": "\t\t\tforeach(temp, (List *) node)",
          "new_line_content": "\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "walker",
          "new_api": null,
          "old_text": "walker(((TargetEntry *) node)->expr, context)",
          "new_text": null,
          "old_line_content": "\t\t\treturn walker(((TargetEntry *) node)->expr, context);",
          "new_line_content": "\t\tcase T_List:",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"expression_tree_walker: Unexpected node type %d\",\n\t\t\t\t nodeTag(node))",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"expression_tree_walker: Unexpected node type %d\",",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "ExecEvalExpr",
          "new_api": null,
          "old_text": "ExecEvalExpr((Node *) expr, NULL,\n\t\t\t\t\t\t\t\t\t\t &const_is_null, &isDone)",
          "new_text": null,
          "old_line_content": "\t\t\t\tconst_val = ExecEvalExpr((Node *) expr, NULL,",
          "new_line_content": "\t\t\t\t/*",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(isDone)",
          "new_text": null,
          "old_line_content": "\t\t\t\tAssert(isDone);\t/* if this isn't set, we blew it... */",
          "new_line_content": "\t\t\t\t * ExecEvalExpr() code used in this situation will use",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "typeidType",
          "new_api": null,
          "old_text": "typeidType(result_typeid)",
          "new_text": null,
          "old_line_content": "\t\t\t\tresultType = typeidType(result_typeid);",
          "new_line_content": "\t\t\t\t */",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 18,
      "total_additions": 91,
      "total_deletions": 89,
      "total_api_changes": 198
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 13,
        "api_related_lines": 198,
        "non_api_lines": 9,
        "non_api_line_numbers": [
          994,
          995,
          996,
          997,
          999,
          1000,
          1001,
          1002,
          11
        ]
      }
    },
    "api_calls_before": 240,
    "api_calls_after": 242,
    "diff_info": {
      "added_lines": 13,
      "removed_lines": 5,
      "total_diff_lines": 45
    }
  }
}