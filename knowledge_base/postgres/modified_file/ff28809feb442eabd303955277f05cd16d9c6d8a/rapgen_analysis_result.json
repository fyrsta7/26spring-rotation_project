{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ff28809feb442eabd303955277f05cd16d9c6d8a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ff28809feb442eabd303955277f05cd16d9c6d8a/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ff28809feb442eabd303955277f05cd16d9c6d8a/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ff28809feb442eabd303955277f05cd16d9c6d8a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 971,
          "old_api": "has_seq_scans",
          "new_api": "expand_table",
          "old_text": "has_seq_scans(hashp)",
          "new_text": "expand_table(hashp)",
          "old_line_content": "\t\t\t!has_seq_scans(hashp))",
          "new_line_content": "\t\t\t(void) expand_table(hashp);",
          "content_same": false
        },
        {
          "line": 1027,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockAcquire",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockAcquire(&(hctl->freeList[freelist_idx].mutex))",
          "old_line_content": "\t\t\t\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\t\t\t\tSpinLockAcquire(&(hctl->freeList[freelist_idx].mutex));",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockRelease",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\t\t\t\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\t\t\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "ereport",
          "new_api": "errcode",
          "old_text": "ereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of shared memory\")))",
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\t\t\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "errcode",
          "new_api": "errmsg",
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": "errmsg(\"out of shared memory\")",
          "old_line_content": "\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\t\t\t\t\t\t\t errmsg(\"out of shared memory\")));",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "ereport",
          "new_api": "errcode",
          "old_text": "ereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")))",
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\t\t\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "errcode",
          "new_api": "errmsg",
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": "errmsg(\"out of memory\")",
          "old_line_content": "\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\t\t\t\t\t\t\t errmsg(\"out of memory\")));",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockAcquire",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockAcquire(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\t\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\t\tSpinLockAcquire(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1280,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockRelease",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\t\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockRelease",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": "elog",
          "new_api": "has_seq_scans",
          "old_text": "elog(ERROR, \"cannot freeze shared hashtable \\\"%s\\\"\", hashp->tabname)",
          "new_text": "has_seq_scans(hashp)",
          "old_line_content": "\t\telog(ERROR, \"cannot freeze shared hashtable \\\"%s\\\"\", hashp->tabname);",
          "new_line_content": "\tif (!hashp->frozen && has_seq_scans(hashp))",
          "content_same": false
        },
        {
          "line": 1502,
          "old_api": "has_seq_scans",
          "new_api": "elog",
          "old_text": "has_seq_scans(hashp)",
          "new_text": "elog(ERROR, \"cannot freeze hashtable \\\"%s\\\" because it has active scans\",\n\t\t\t hashp->tabname)",
          "old_line_content": "\tif (!hashp->frozen && has_seq_scans(hashp))",
          "new_line_content": "\t\telog(ERROR, \"cannot freeze hashtable \\\"%s\\\" because it has active scans\",",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "memcpy",
          "new_api": "MemSet",
          "old_text": "memcpy(p, old_p, old_dirsize)",
          "new_text": "MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize)",
          "old_line_content": "\t\tmemcpy(p, old_p, old_dirsize);",
          "new_line_content": "\t\tMemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": "Assert",
          "new_api": "pfree",
          "old_text": "Assert(hashp->alloc == DynaHashAlloc)",
          "new_text": "pfree(old_p)",
          "old_line_content": "\t\tAssert(hashp->alloc == DynaHashAlloc);",
          "new_line_content": "\t\tpfree(old_p);",
          "content_same": false
        },
        {
          "line": 1702,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockAcquire",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockAcquire(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\tSpinLockAcquire(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "IS_PARTITIONED",
          "new_api": "SpinLockRelease",
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\tif (IS_PARTITIONED(hctl))",
          "new_line_content": "\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 1152,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"cannot update in frozen hashtable \\\"%s\\\"\",\n\t\t\t hashp->tabname)",
          "old_line_content": "\tif (hashp->frozen)",
          "new_line_content": "\t\telog(ERROR, \"cannot update in frozen hashtable \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "\t\t\t\t/* if partitioned, must lock to touch nentries and freeList */",
          "new_line_content": "\t\t\t\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": null,
          "new_api": "MOD",
          "old_text": null,
          "new_text": "MOD(new_bucket, hashp->ssize)",
          "old_line_content": "\tnew_segnum = new_bucket >> hashp->sshift;",
          "new_line_content": "\tnew_segndx = MOD(new_bucket, hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1030,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(hctl->freeList[freelist_idx].nentries > 0)",
          "old_line_content": "\t\t\t\t/* delete the record from the appropriate nentries counter. */",
          "new_line_content": "\t\t\t\tAssert(hctl->freeList[freelist_idx].nentries > 0);",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": null,
          "new_api": "dir_realloc",
          "old_text": null,
          "new_text": "dir_realloc(hashp)",
          "old_line_content": "\t\tif (new_segnum >= hctl->dsize)",
          "new_line_content": "\t\t\tif (!dir_realloc(hashp))",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "calc_bucket",
          "old_text": null,
          "new_text": "calc_bucket(hctl, existingElement->hashvalue)",
          "old_line_content": "\t */",
          "new_line_content": "\tbucket = calc_bucket(hctl, existingElement->hashvalue);",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": null,
          "new_api": "seg_alloc",
          "old_text": null,
          "new_text": "seg_alloc(hashp)",
          "old_line_content": "\t\t\t\treturn false;",
          "new_line_content": "\t\tif (!(hashp->dir[new_segnum] = seg_alloc(hashp)))",
          "content_same": false
        },
        {
          "line": 1163,
          "old_api": null,
          "new_api": "MOD",
          "old_text": null,
          "new_text": "MOD(bucket, hashp->ssize)",
          "old_line_content": "\tsegment_num = bucket >> hashp->sshift;",
          "new_line_content": "\tsegment_ndx = MOD(bucket, hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"too many active hash_seq_search scans, cannot start one on \\\"%s\\\"\",\n\t\t\t hashp->tabname)",
          "old_line_content": "\tif (num_seq_scans >= MAX_SEQ_SCANS)",
          "new_line_content": "\t\telog(ERROR, \"too many active hash_seq_search scans, cannot start one on \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(curElem)",
          "old_line_content": "\t\t\t++status->curBucket;",
          "new_line_content": "\t\treturn (void *) ELEMENTKEY(curElem);",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": null,
          "new_api": "element_alloc",
          "old_text": null,
          "new_text": "element_alloc(hashp, hctl->nelem_alloc, freelist_idx)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tif (!element_alloc(hashp, hctl->nelem_alloc, freelist_idx))",
          "content_same": false
        },
        {
          "line": 1807,
          "old_api": null,
          "new_api": "GetCurrentTransactionNestLevel",
          "old_text": null,
          "new_text": "GetCurrentTransactionNestLevel()",
          "old_line_content": "\tseq_scan_tables[num_seq_scans] = hashp;",
          "new_line_content": "\tseq_scan_level[num_seq_scans] = GetCurrentTransactionNestLevel();",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": null,
          "new_api": "hash_corrupted",
          "old_text": null,
          "new_text": "hash_corrupted(hashp)",
          "old_line_content": "\tif (segp == NULL)",
          "new_line_content": "\t\thash_corrupted(hashp);",
          "content_same": false
        },
        {
          "line": 1682,
          "old_api": null,
          "new_api": "MAXALIGN",
          "old_text": null,
          "new_text": "MAXALIGN(hctl->entrysize)",
          "old_line_content": "\t/* Each element has a HASHELEMENT header plus user data. */",
          "new_line_content": "\telementSize = MAXALIGN(sizeof(HASHELEMENT)) + MAXALIGN(hctl->entrysize);",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (!IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1685,
          "old_api": null,
          "new_api": "alloc",
          "old_text": null,
          "new_text": "hashp->alloc(nelem * elementSize)",
          "old_line_content": "\tCurrentDynaHashCxt = hashp->hcxt;",
          "new_line_content": "\tfirstElement = (HASHELEMENT *) hashp->alloc(nelem * elementSize);",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\t\t\t\t */",
          "new_line_content": "\t\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "hash_seq_term",
          "old_text": null,
          "new_text": "hash_seq_term(status)",
          "old_line_content": "\t{",
          "new_line_content": "\t\thash_seq_term(status);",
          "content_same": false
        },
        {
          "line": 1309,
          "old_api": null,
          "new_api": "SpinLockAcquire",
          "old_text": null,
          "new_text": "SpinLockAcquire(&(hctl->freeList[borrow_from_idx].mutex))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tSpinLockAcquire(&(hctl->freeList[borrow_from_idx].mutex));",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(hashp->alloc != DynaHashAlloc)",
          "old_line_content": "\t\t\t/* ENTER_NULL does not work with palloc-based allocator */",
          "new_line_content": "\t\t\tAssert(hashp->alloc != DynaHashAlloc);",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"hash_update_hash_key argument is not in hashtable \\\"%s\\\"\",\n\t\t\t hashp->tabname)",
          "old_line_content": "\tif (currBucket == NULL)",
          "new_line_content": "\t\telog(ERROR, \"hash_update_hash_key argument is not in hashtable \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": null,
          "new_api": "MOD",
          "old_text": null,
          "new_text": "MOD(curBucket, ssize)",
          "old_line_content": "\tsegment_num = curBucket >> hashp->sshift;",
          "new_line_content": "\tsegment_ndx = MOD(curBucket, ssize);",
          "content_same": false
        },
        {
          "line": 1315,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex))",
          "old_line_content": "\t\t\t\t\thctl->freeList[borrow_from_idx].freeList = newElement->link;",
          "new_line_content": "\t\t\t\t\tSpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex));",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\t\t\tif (currBucket != NULL)",
          "new_line_content": "\t\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "\t/* if partitioned, must lock to touch freeList */",
          "new_line_content": "\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"no hash_seq_search scan for hash table \\\"%s\\\"\",\n\t\t hashp->tabname)",
          "old_line_content": "\t}",
          "new_line_content": "\telog(ERROR, \"no hash_seq_search scan for hash table \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": null,
          "new_api": "hash",
          "old_text": null,
          "new_text": "hashp->hash(newKeyPtr, hashp->keysize)",
          "old_line_content": "\t */",
          "new_line_content": "\tnewhashvalue = hashp->hash(newKeyPtr, hashp->keysize);",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"cannot insert into frozen hashtable \\\"%s\\\"\",\n\t\t\t\t\t hashp->tabname)",
          "old_line_content": "\t\t\tif (hashp->frozen)",
          "new_line_content": "\t\t\t\telog(ERROR, \"cannot insert into frozen hashtable \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 1193,
          "old_api": null,
          "new_api": "calc_bucket",
          "old_text": null,
          "new_text": "calc_bucket(hctl, newhashvalue)",
          "old_line_content": "",
          "new_line_content": "\tnewbucket = calc_bucket(hctl, newhashvalue);",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "MOD",
          "old_text": null,
          "new_text": "MOD(old_bucket, hashp->ssize)",
          "old_line_content": "\told_segnum = old_bucket >> hashp->sshift;",
          "new_line_content": "\told_segndx = MOD(old_bucket, hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "get_hash_entry",
          "old_text": null,
          "new_text": "get_hash_entry(hashp, freelist_idx)",
          "old_line_content": "",
          "new_line_content": "\t\t\tcurrBucket = get_hash_entry(hashp, freelist_idx);",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": null,
          "new_api": "MOD",
          "old_text": null,
          "new_text": "MOD(newbucket, hashp->ssize)",
          "old_line_content": "\tsegment_num = newbucket >> hashp->sshift;",
          "new_line_content": "\tsegment_ndx = MOD(newbucket, hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "",
          "new_line_content": "\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1318,
          "old_api": null,
          "new_api": "SpinLockAcquire",
          "old_text": null,
          "new_text": "SpinLockAcquire(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\t\t\t\t\t/* careful: count the new element in its proper freelist */",
          "new_line_content": "\t\t\t\t\tSpinLockAcquire(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "old_line_content": "\t\t\t\t\thctl->freeList[freelist_idx].nentries++;",
          "new_line_content": "\t\t\t\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tSpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex));",
          "content_same": false
        },
        {
          "line": 1201,
          "old_api": null,
          "new_api": "hash_corrupted",
          "old_text": null,
          "new_text": "hash_corrupted(hashp)",
          "old_line_content": "\tif (segp == NULL)",
          "new_line_content": "\t\thash_corrupted(hashp);",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": null,
          "new_api": "hash_seq_term",
          "old_text": null,
          "new_text": "hash_seq_term(status)",
          "old_line_content": "\t\t\tstatus->curBucket = curBucket;",
          "new_line_content": "\t\t\thash_seq_term(status);",
          "content_same": false
        },
        {
          "line": 1075,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of shared memory\")))",
          "old_line_content": "\t\t\t\tif (hashp->isshared)",
          "new_line_content": "\t\t\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 1591,
          "old_api": null,
          "new_api": "calc_bucket",
          "old_text": null,
          "new_text": "calc_bucket(hctl, currElement->hashvalue)",
          "old_line_content": "\t\tnextElement = currElement->link;",
          "new_line_content": "\t\tif ((long) calc_bucket(hctl, currElement->hashvalue) == old_bucket)",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")))",
          "old_line_content": "\t\t\t\telse",
          "new_line_content": "\t\t\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 1337,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "",
          "new_line_content": "\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(PANIC, \"hash table \\\"%s\\\" corrupted\", hashp->tabname)",
          "old_line_content": "\tif (hashp->isshared)",
          "new_line_content": "\t\telog(PANIC, \"hash table \\\"%s\\\" corrupted\", hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(FATAL, \"hash table \\\"%s\\\" corrupted\", hashp->tabname)",
          "old_line_content": "\telse",
          "new_line_content": "\t\telog(FATAL, \"hash table \\\"%s\\\" corrupted\", hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\t\tif (currBucket->hashvalue == newhashvalue &&",
          "new_line_content": "\t\t\tmatch(ELEMENTKEY(currBucket), newKeyPtr, keysize) == 0)",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(curElem)",
          "old_line_content": "\tstatus->curBucket = curBucket;",
          "new_line_content": "\treturn (void *) ELEMENTKEY(curElem);",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\t\t\tcurrBucket->hashvalue = hashvalue;",
          "new_line_content": "\t\t\thashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": null,
          "new_api": "deregister_seq_scan",
          "old_text": null,
          "new_text": "deregister_seq_scan(status->hashp)",
          "old_line_content": "\tif (!status->hashp->frozen)",
          "new_line_content": "\t\tderegister_seq_scan(status->hashp);",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(WARNING, \"leaked hash_seq_search scan for hash table %p\",\n\t\t\t\t seq_scan_tables[i])",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\telog(WARNING, \"leaked hash_seq_search scan for hash table %p\",",
          "content_same": false
        },
        {
          "line": 970,
          "old_api": null,
          "new_api": "has_seq_scans",
          "old_text": null,
          "new_text": "has_seq_scans(hashp)",
          "old_line_content": "\t\t\thctl->freeList[0].nentries > (long) (hctl->max_bucket + 1) &&",
          "new_line_content": "\t\t\t!has_seq_scans(hashp))",
          "content_same": false
        },
        {
          "line": 1099,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "",
          "new_line_content": "\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": null,
          "new_api": "pg_ceil_log2_32",
          "old_text": null,
          "new_text": "pg_ceil_log2_32(num)",
          "old_line_content": "#if SIZEOF_LONG < 8",
          "new_line_content": "\treturn pg_ceil_log2_32(num);",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hashp->hctl)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (IS_PARTITIONED(hashp->hctl))",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"unrecognized hash action code: %d\", (int) action)",
          "old_line_content": "",
          "new_line_content": "\telog(ERROR, \"unrecognized hash action code: %d\", (int) action);",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": null,
          "new_api": "pg_ceil_log2_64",
          "old_text": null,
          "new_text": "pg_ceil_log2_64(num)",
          "old_line_content": "#else",
          "new_line_content": "\treturn pg_ceil_log2_64(num);",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "calc_bucket",
          "old_text": null,
          "new_text": "calc_bucket(hctl, hashvalue)",
          "old_line_content": "\t */",
          "new_line_content": "\tbucket = calc_bucket(hctl, hashvalue);",
          "content_same": false
        },
        {
          "line": 980,
          "old_api": null,
          "new_api": "MOD",
          "old_text": null,
          "new_text": "MOD(bucket, hashp->ssize)",
          "old_line_content": "\tsegment_num = bucket >> hashp->sshift;",
          "new_line_content": "\tsegment_ndx = MOD(bucket, hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": null,
          "new_api": "my_log2",
          "old_text": null,
          "new_text": "my_log2(num)",
          "old_line_content": "\t/* my_log2's internal range check is sufficient */",
          "new_line_content": "\treturn 1L << my_log2(num);",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": null,
          "new_api": "hash_corrupted",
          "old_text": null,
          "new_text": "hash_corrupted(hashp)",
          "old_line_content": "\tif (segp == NULL)",
          "new_line_content": "\t\thash_corrupted(hashp);",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"cannot freeze shared hashtable \\\"%s\\\"\", hashp->tabname)",
          "old_line_content": "\tif (hashp->isshared)",
          "new_line_content": "\t\telog(ERROR, \"cannot freeze shared hashtable \\\"%s\\\"\", hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": null,
          "new_api": "alloc",
          "old_text": null,
          "new_text": "hashp->alloc((Size) new_dirsize)",
          "old_line_content": "\tCurrentDynaHashCxt = hashp->hcxt;",
          "new_line_content": "\tp = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": null,
          "new_api": "my_log2",
          "old_text": null,
          "new_text": "my_log2(num)",
          "old_line_content": "\t\tnum = INT_MAX / 2;",
          "new_line_content": "\treturn 1 << my_log2(num);",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(p, old_p, old_dirsize)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tmemcpy(p, old_p, old_dirsize);",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\tcurrBucket->hashvalue = newhashvalue;",
          "new_line_content": "\thashp->keycopy(ELEMENTKEY(currBucket), newKeyPtr, keysize);",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(WARNING, \"leaked hash_seq_search scan for hash table %p\",\n\t\t\t\t\t seq_scan_tables[i])",
          "old_line_content": "\t\t\tif (isCommit)",
          "new_line_content": "\t\t\t\telog(WARNING, \"leaked hash_seq_search scan for hash table %p\",",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(hashp->alloc == DynaHashAlloc)",
          "old_line_content": "\t\t/* XXX assume the allocator is palloc, so we know how to free */",
          "new_line_content": "\t\tAssert(hashp->alloc == DynaHashAlloc);",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\t\tif (currBucket->hashvalue == hashvalue &&",
          "new_line_content": "\t\t\tmatch(ELEMENTKEY(currBucket), keyPtr, keysize) == 0)",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "ELEMENT_FROM_KEY",
          "old_text": null,
          "new_text": "ELEMENT_FROM_KEY(existingEntry)",
          "old_line_content": "{",
          "new_line_content": "\tHASHELEMENT *existingElement = ELEMENT_FROM_KEY(existingEntry);",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": null,
          "new_api": "register_seq_scan",
          "old_text": null,
          "new_text": "register_seq_scan(hashp)",
          "old_line_content": "\tif (!hashp->frozen)",
          "new_line_content": "\t\tregister_seq_scan(hashp);",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "\t\t/* if partitioned, must lock to touch nentries and freeList */",
          "new_line_content": "\t\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": null,
          "new_api": "alloc",
          "old_text": null,
          "new_text": "hashp->alloc(sizeof(HASHBUCKET) * hashp->ssize)",
          "old_line_content": "\tCurrentDynaHashCxt = hashp->hcxt;",
          "new_line_content": "\tsegp = (HASHSEGMENT) hashp->alloc(sizeof(HASHBUCKET) * hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1530,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "",
          "new_line_content": "\tAssert(!IS_PARTITIONED(hctl));",
          "content_same": false
        },
        {
          "line": 1019,
          "old_api": null,
          "new_api": "ELEMENTKEY",
          "old_text": null,
          "new_text": "ELEMENTKEY(currBucket)",
          "old_line_content": "\t\t\tif (currBucket != NULL)",
          "new_line_content": "\t\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "content_same": false
        },
        {
          "line": 1660,
          "old_api": null,
          "new_api": "MemSet",
          "old_text": null,
          "new_text": "MemSet(segp, 0, sizeof(HASHBUCKET) * hashp->ssize)",
          "old_line_content": "",
          "new_line_content": "\tMemSet(segp, 0, sizeof(HASHBUCKET) * hashp->ssize);",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "IS_PARTITIONED",
          "old_text": null,
          "new_text": "IS_PARTITIONED(hctl)",
          "old_line_content": "",
          "new_line_content": "\t\tif (IS_PARTITIONED(hctl))",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 1272,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\t\tSpinLockAcquire(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1153,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"cannot update in frozen hashtable \\\"%s\\\"\",\n\t\t\t hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"cannot update in frozen hashtable \\\"%s\\\"\",",
          "new_line_content": "\t\t\t hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "MOD",
          "new_api": null,
          "old_text": "MOD(new_bucket, hashp->ssize)",
          "new_text": null,
          "old_line_content": "\tnew_segndx = MOD(new_bucket, hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&(hctl->freeList[freelist_idx].mutex))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tSpinLockAcquire(&(hctl->freeList[freelist_idx].mutex));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(hctl->freeList[freelist_idx].nentries > 0)",
          "new_text": null,
          "old_line_content": "\t\t\t\tAssert(hctl->freeList[freelist_idx].nentries > 0);",
          "new_line_content": "\t\t\t\thctl->freeList[freelist_idx].nentries--;",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "dir_realloc",
          "new_api": null,
          "old_text": "dir_realloc(hashp)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!dir_realloc(hashp))",
          "new_line_content": "\t\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 1161,
          "old_api": "calc_bucket",
          "new_api": null,
          "old_text": "calc_bucket(hctl, existingElement->hashvalue)",
          "new_text": null,
          "old_line_content": "\tbucket = calc_bucket(hctl, existingElement->hashvalue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "seg_alloc",
          "new_api": null,
          "old_text": "seg_alloc(hashp)",
          "new_text": null,
          "old_line_content": "\t\tif (!(hashp->dir[new_segnum] = seg_alloc(hashp)))",
          "new_line_content": "\t\t\treturn false;",
          "content_same": false
        },
        {
          "line": 1164,
          "old_api": "MOD",
          "new_api": null,
          "old_text": "MOD(bucket, hashp->ssize)",
          "new_text": null,
          "old_line_content": "\tsegment_ndx = MOD(bucket, hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"too many active hash_seq_search scans, cannot start one on \\\"%s\\\"\",\n\t\t\t hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"too many active hash_seq_search scans, cannot start one on \\\"%s\\\"\",",
          "new_line_content": "\t\t\t hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(curElem)",
          "new_text": null,
          "old_line_content": "\t\treturn (void *) ELEMENTKEY(curElem);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "element_alloc",
          "new_api": null,
          "old_text": "element_alloc(hashp, hctl->nelem_alloc, freelist_idx)",
          "new_text": null,
          "old_line_content": "\t\tif (!element_alloc(hashp, hctl->nelem_alloc, freelist_idx))",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "GetCurrentTransactionNestLevel",
          "new_api": null,
          "old_text": "GetCurrentTransactionNestLevel()",
          "new_text": null,
          "old_line_content": "\tseq_scan_level[num_seq_scans] = GetCurrentTransactionNestLevel();",
          "new_line_content": "\tnum_seq_scans++;",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "hash_corrupted",
          "new_api": null,
          "old_text": "hash_corrupted(hashp)",
          "new_text": null,
          "old_line_content": "\t\thash_corrupted(hashp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": "MAXALIGN",
          "new_api": null,
          "old_text": "MAXALIGN(hctl->entrysize)",
          "new_text": null,
          "old_line_content": "\telementSize = MAXALIGN(sizeof(HASHELEMENT)) + MAXALIGN(hctl->entrysize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "IS_PARTITIONED",
          "new_api": null,
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!IS_PARTITIONED(hctl))",
          "new_line_content": "\t\t\t\treturn NULL;\t/* out of memory */",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": "alloc",
          "new_api": null,
          "old_text": "hashp->alloc(nelem * elementSize)",
          "new_text": null,
          "old_line_content": "\tfirstElement = (HASHELEMENT *) hashp->alloc(nelem * elementSize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": "hash_seq_term",
          "new_api": null,
          "old_text": "hash_seq_term(status)",
          "new_text": null,
          "old_line_content": "\t\thash_seq_term(status);",
          "new_line_content": "\t\treturn NULL;\t\t\t/* search is done */",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&(hctl->freeList[borrow_from_idx].mutex))",
          "new_text": null,
          "old_line_content": "\t\t\t\tSpinLockAcquire(&(hctl->freeList[borrow_from_idx].mutex));",
          "new_line_content": "\t\t\t\tnewElement = hctl->freeList[borrow_from_idx].freeList;",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(hashp->alloc != DynaHashAlloc)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(hashp->alloc != DynaHashAlloc);",
          "new_line_content": "\t\t\t/* FALL THRU */",
          "content_same": false
        },
        {
          "line": 1183,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"hash_update_hash_key argument is not in hashtable \\\"%s\\\"\",\n\t\t\t hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"hash_update_hash_key argument is not in hashtable \\\"%s\\\"\",",
          "new_line_content": "\t\t\t hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": "MOD",
          "new_api": null,
          "old_text": "MOD(curBucket, ssize)",
          "new_text": null,
          "old_line_content": "\tsegment_ndx = MOD(curBucket, ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1316,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tSpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"no hash_seq_search scan for hash table \\\"%s\\\"\",\n\t\t hashp->tabname)",
          "new_text": null,
          "old_line_content": "\telog(ERROR, \"no hash_seq_search scan for hash table \\\"%s\\\"\",",
          "new_line_content": "\t\t hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockAcquire(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "hash",
          "new_api": null,
          "old_text": "hashp->hash(newKeyPtr, hashp->keysize)",
          "new_text": null,
          "old_line_content": "\tnewhashvalue = hashp->hash(newKeyPtr, hashp->keysize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"cannot insert into frozen hashtable \\\"%s\\\"\",\n\t\t\t\t\t hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(ERROR, \"cannot insert into frozen hashtable \\\"%s\\\"\",",
          "new_line_content": "\t\t\t\t\t hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "calc_bucket",
          "new_api": null,
          "old_text": "calc_bucket(hctl, newhashvalue)",
          "new_text": null,
          "old_line_content": "\tnewbucket = calc_bucket(hctl, newhashvalue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "MOD",
          "new_api": null,
          "old_text": "MOD(old_bucket, hashp->ssize)",
          "new_text": null,
          "old_line_content": "\told_segndx = MOD(old_bucket, hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1068,
          "old_api": "get_hash_entry",
          "new_api": null,
          "old_text": "get_hash_entry(hashp, freelist_idx)",
          "new_text": null,
          "old_line_content": "\t\t\tcurrBucket = get_hash_entry(hashp, freelist_idx);",
          "new_line_content": "\t\t\tif (currBucket == NULL)",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "MOD",
          "new_api": null,
          "old_text": "MOD(newbucket, hashp->ssize)",
          "new_text": null,
          "old_line_content": "\tsegment_ndx = MOD(newbucket, hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tSpinLockAcquire(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "\t\t\t\t\thctl->freeList[freelist_idx].nentries++;",
          "content_same": false
        },
        {
          "line": 1321,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex))",
          "new_text": null,
          "old_line_content": "\t\t\t\tSpinLockRelease(&(hctl->freeList[borrow_from_idx].mutex));",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1202,
          "old_api": "hash_corrupted",
          "new_api": null,
          "old_text": "hash_corrupted(hashp)",
          "new_text": null,
          "old_line_content": "\t\thash_corrupted(hashp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": "hash_seq_term",
          "new_api": null,
          "old_text": "hash_seq_term(status)",
          "new_text": null,
          "old_line_content": "\t\t\thash_seq_term(status);",
          "new_line_content": "\t\t\treturn NULL;\t\t/* search is done */",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"out of shared memory\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t errmsg(\"out of shared memory\")));",
          "new_line_content": "\t\t\t\telse",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": "calc_bucket",
          "new_api": null,
          "old_text": "calc_bucket(hctl, currElement->hashvalue)",
          "new_text": null,
          "old_line_content": "\t\tif ((long) calc_bucket(hctl, currElement->hashvalue) == old_bucket)",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"out of memory\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t errmsg(\"out of memory\")));",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&hctl->freeList[freelist_idx].mutex)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockRelease(&hctl->freeList[freelist_idx].mutex);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(PANIC, \"hash table \\\"%s\\\" corrupted\", hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\telog(PANIC, \"hash table \\\"%s\\\" corrupted\", hashp->tabname);",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(FATAL, \"hash table \\\"%s\\\" corrupted\", hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\telog(FATAL, \"hash table \\\"%s\\\" corrupted\", hashp->tabname);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\tmatch(ELEMENTKEY(currBucket), newKeyPtr, keysize) == 0)",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1474,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(curElem)",
          "new_text": null,
          "old_line_content": "\treturn (void *) ELEMENTKEY(curElem);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1091,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\thashp->keycopy(ELEMENTKEY(currBucket), keyPtr, keysize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "deregister_seq_scan",
          "new_api": null,
          "old_text": "deregister_seq_scan(status->hashp)",
          "new_text": null,
          "old_line_content": "\t\tderegister_seq_scan(status->hashp);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(WARNING, \"leaked hash_seq_search scan for hash table %p\",\n\t\t\t\t seq_scan_tables[i])",
          "new_text": null,
          "old_line_content": "\t\t\telog(WARNING, \"leaked hash_seq_search scan for hash table %p\",",
          "new_line_content": "\t\t\t\t seq_scan_tables[i]);",
          "content_same": false
        },
        {
          "line": 1100,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": "pg_ceil_log2_32",
          "new_api": null,
          "old_text": "pg_ceil_log2_32(num)",
          "new_text": null,
          "old_line_content": "\treturn pg_ceil_log2_32(num);",
          "new_line_content": "#else",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "IS_PARTITIONED",
          "new_api": null,
          "old_text": "IS_PARTITIONED(hashp->hctl)",
          "new_text": null,
          "old_line_content": "\tif (IS_PARTITIONED(hashp->hctl))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"unrecognized hash action code: %d\", (int) action)",
          "new_text": null,
          "old_line_content": "\telog(ERROR, \"unrecognized hash action code: %d\", (int) action);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "pg_ceil_log2_64",
          "new_api": null,
          "old_text": "pg_ceil_log2_64(num)",
          "new_text": null,
          "old_line_content": "\treturn pg_ceil_log2_64(num);",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 972,
          "old_api": "expand_table",
          "new_api": null,
          "old_text": "expand_table(hashp)",
          "new_text": null,
          "old_line_content": "\t\t\t(void) expand_table(hashp);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": "calc_bucket",
          "new_api": null,
          "old_text": "calc_bucket(hctl, hashvalue)",
          "new_text": null,
          "old_line_content": "\tbucket = calc_bucket(hctl, hashvalue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": "MOD",
          "new_api": null,
          "old_text": "MOD(bucket, hashp->ssize)",
          "new_text": null,
          "old_line_content": "\tsegment_ndx = MOD(bucket, hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1752,
          "old_api": "my_log2",
          "new_api": null,
          "old_text": "my_log2(num)",
          "new_text": null,
          "old_line_content": "\treturn 1L << my_log2(num);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "hash_corrupted",
          "new_api": null,
          "old_text": "hash_corrupted(hashp)",
          "new_text": null,
          "old_line_content": "\t\thash_corrupted(hashp);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1630,
          "old_api": "alloc",
          "new_api": null,
          "old_text": "hashp->alloc((Size) new_dirsize)",
          "new_text": null,
          "old_line_content": "\tp = (HASHSEGMENT *) hashp->alloc((Size) new_dirsize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1503,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"cannot freeze hashtable \\\"%s\\\" because it has active scans\",\n\t\t\t hashp->tabname)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"cannot freeze hashtable \\\"%s\\\" because it has active scans\",",
          "new_line_content": "\t\t\t hashp->tabname);",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "my_log2",
          "new_api": null,
          "old_text": "my_log2(num)",
          "new_text": null,
          "old_line_content": "\treturn 1 << my_log2(num);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\thashp->keycopy(ELEMENTKEY(currBucket), newKeyPtr, keysize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": "MemSet",
          "new_api": null,
          "old_text": "MemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize)",
          "new_text": null,
          "old_line_content": "\t\tMemSet(((char *) p) + old_dirsize, 0, new_dirsize - old_dirsize);",
          "new_line_content": "\t\thashp->dir = p;",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(WARNING, \"leaked hash_seq_search scan for hash table %p\",\n\t\t\t\t\t seq_scan_tables[i])",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(WARNING, \"leaked hash_seq_search scan for hash table %p\",",
          "new_line_content": "\t\t\t\t\t seq_scan_tables[i]);",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\tmatch(ELEMENTKEY(currBucket), keyPtr, keysize) == 0)",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(old_p)",
          "new_text": null,
          "old_line_content": "\t\tpfree(old_p);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "ELEMENT_FROM_KEY",
          "new_api": null,
          "old_text": "ELEMENT_FROM_KEY(existingEntry)",
          "new_text": null,
          "old_line_content": "\tHASHELEMENT *existingElement = ELEMENT_FROM_KEY(existingEntry);",
          "new_line_content": "\tHASHHDR    *hctl = hashp->hctl;",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "register_seq_scan",
          "new_api": null,
          "old_text": "register_seq_scan(hashp)",
          "new_text": null,
          "old_line_content": "\t\tregister_seq_scan(hashp);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": "alloc",
          "new_api": null,
          "old_text": "hashp->alloc(sizeof(HASHBUCKET) * hashp->ssize)",
          "new_text": null,
          "old_line_content": "\tsegp = (HASHSEGMENT) hashp->alloc(sizeof(HASHBUCKET) * hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": "IS_PARTITIONED",
          "new_api": null,
          "old_text": "IS_PARTITIONED(hctl)",
          "new_text": null,
          "old_line_content": "\tAssert(!IS_PARTITIONED(hctl));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "ELEMENTKEY",
          "new_api": null,
          "old_text": "ELEMENTKEY(currBucket)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn (void *) ELEMENTKEY(currBucket);",
          "new_line_content": "\t\t\treturn NULL;",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": "MemSet",
          "new_api": null,
          "old_text": "MemSet(segp, 0, sizeof(HASHBUCKET) * hashp->ssize)",
          "new_text": null,
          "old_line_content": "\tMemSet(segp, 0, sizeof(HASHBUCKET) * hashp->ssize);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 16,
      "total_additions": 76,
      "total_deletions": 76,
      "total_api_changes": 168
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 5,
        "api_related_lines": 168,
        "non_api_lines": 4,
        "non_api_line_numbers": [
          968,
          969,
          966,
          967
        ]
      }
    },
    "api_calls_before": 170,
    "api_calls_after": 170,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 4,
      "total_diff_lines": 20
    }
  }
}