{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/2f39106a209e647d7b1895331fca115f9bb6ec8d",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/2f39106a209e647d7b1895331fca115f9bb6ec8d/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/2f39106a209e647d7b1895331fca115f9bb6ec8d/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/2f39106a209e647d7b1895331fca115f9bb6ec8d/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 677,
          "old_api": "TransactionIdIsValid",
          "new_api": "ExpireOldKnownAssignedTransactionIds",
          "old_text": "TransactionIdIsValid(running->oldestRunningXid)",
          "new_text": "ExpireOldKnownAssignedTransactionIds(running->oldestRunningXid)",
          "old_line_content": "\tAssert(TransactionIdIsValid(running->oldestRunningXid));",
          "new_line_content": "\tExpireOldKnownAssignedTransactionIds(running->oldestRunningXid);",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "qsort",
          "new_api": "KnownAssignedXidsAdd",
          "old_text": "qsort(xids, nxids, sizeof(TransactionId), xidComparator)",
          "new_text": "KnownAssignedXidsAdd(xids[i], xids[i], true)",
          "old_line_content": "\t\tqsort(xids, nxids, sizeof(TransactionId), xidComparator);",
          "new_line_content": "\t\t\tKnownAssignedXidsAdd(xids[i], xids[i], true);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": "TransactionIdAdvance",
          "new_api": "TransactionIdRetreat",
          "old_text": "TransactionIdAdvance(latestObservedXid)",
          "new_text": "TransactionIdRetreat(latestObservedXid)",
          "old_line_content": "\tTransactionIdAdvance(latestObservedXid);",
          "new_line_content": "\tTransactionIdRetreat(latestObservedXid);\t/* = running->nextXid - 1 */",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": "TransactionIdPrecedes",
          "new_api": "LWLockRelease",
          "old_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,\n\t\t\t\t\t\t\t  running->latestCompletedXid)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 894,
          "old_api": "TransactionIdIsValid",
          "new_api": "trace_recovery",
          "old_text": "TransactionIdIsValid(ShmemVariableCache->nextXid)",
          "new_text": "trace_recovery(DEBUG1)",
          "old_line_content": "\tAssert(TransactionIdIsValid(ShmemVariableCache->nextXid));",
          "new_line_content": "\t\telog(trace_recovery(DEBUG1),",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "RecoveryInProgress",
          "new_api": "errmsg",
          "old_text": "RecoveryInProgress()",
          "new_text": "errmsg(\"out of memory\")",
          "old_line_content": "\t\tint\t\t\tmaxxids = RecoveryInProgress() ? TOTAL_MAX_CACHED_SUBXIDS : arrayP->maxProcs;",
          "new_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "content_same": false
        },
        {
          "line": 1058,
          "old_api": "LWLockAcquire",
          "new_api": "TransactionIdPrecedes",
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid, xid)",
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid, xid))",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": "TransactionIdIsValid",
          "new_api": "TransactionIdEquals",
          "old_text": "TransactionIdIsValid(pxid)",
          "new_text": "TransactionIdEquals(pxid, xid)",
          "old_line_content": "\t\tif (!TransactionIdIsValid(pxid))",
          "new_line_content": "\t\tif (TransactionIdEquals(pxid, xid))",
          "content_same": false
        },
        {
          "line": 1190,
          "old_api": "SubTransGetTopmostTransaction",
          "new_api": "TransactionIdEquals",
          "old_text": "SubTransGetTopmostTransaction(xid)",
          "new_text": "TransactionIdEquals(xids[i], topxid)",
          "old_line_content": "\ttopxid = SubTransGetTopmostTransaction(xid);",
          "new_line_content": "\t\t\tif (TransactionIdEquals(xids[i], topxid))",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "TransactionIdIsValid",
          "new_api": "TransactionIdEquals",
          "old_text": "TransactionIdIsValid(pxid)",
          "new_text": "TransactionIdEquals(pxid, xid)",
          "old_line_content": "\t\tif (!TransactionIdIsValid(pxid))",
          "new_line_content": "\t\tif (TransactionIdEquals(pxid, xid))",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "RecoveryInProgress",
          "new_api": "KnownAssignedXidsGetOldestXmin",
          "old_text": "RecoveryInProgress()",
          "new_text": "KnownAssignedXidsGetOldestXmin()",
          "old_line_content": "\tif (RecoveryInProgress())",
          "new_line_content": "\t\tTransactionId kaxmin = KnownAssignedXidsGetOldestXmin();",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": "errcode",
          "new_api": "ereport",
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "old_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 1543,
          "old_api": "errmsg",
          "new_api": "errcode",
          "old_text": "errmsg(\"out of memory\")",
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "new_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": "Assert",
          "new_api": "errmsg",
          "old_text": "Assert(snapshot->subxip == NULL)",
          "new_text": "errmsg(\"out of memory\")",
          "old_line_content": "\t\tAssert(snapshot->subxip == NULL);",
          "new_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "TransactionIdIsNormal",
          "new_api": "RecoveryInProgress",
          "old_text": "TransactionIdIsNormal(xmax)",
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\tAssert(TransactionIdIsNormal(xmax));",
          "new_line_content": "\tsnapshot->takenDuringRecovery = RecoveryInProgress();",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "TransactionIdPrecedesOrEquals",
          "new_api": "LWLockRelease",
          "old_text": "TransactionIdPrecedesOrEquals(xid, xmin)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\tTransactionIdPrecedesOrEquals(xid, xmin))",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": "GET_VXID_FROM_PGPROC",
          "new_api": "LWLockRelease",
          "old_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "VirtualTransactionIdIsValid",
          "new_api": "VirtualTransactionIdEquals",
          "old_text": "VirtualTransactionIdIsValid(vxid)",
          "new_text": "VirtualTransactionIdEquals(vxid, vxids[i])",
          "old_line_content": "\t\tif (pgxact->delayChkpt && VirtualTransactionIdIsValid(vxid))",
          "new_line_content": "\t\t\t\tif (VirtualTransactionIdEquals(vxid, vxids[i]))",
          "content_same": false
        },
        {
          "line": 2521,
          "old_api": "TransactionIdIsValid",
          "new_api": "VirtualTransactionIdIsValid",
          "old_text": "TransactionIdIsValid(limitXmin)",
          "new_text": "VirtualTransactionIdIsValid(vxid)",
          "old_line_content": "\t\t\tif (!TransactionIdIsValid(limitXmin) ||",
          "new_line_content": "\t\t\t\tif (VirtualTransactionIdIsValid(vxid))",
          "content_same": false
        },
        {
          "line": 2527,
          "old_api": "VirtualTransactionIdIsValid",
          "new_api": "LWLockRelease",
          "old_text": "VirtualTransactionIdIsValid(vxid)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\t\tif (VirtualTransactionIdIsValid(vxid))",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "TransactionIdIsValid",
          "new_api": "VirtualTransactionIdIsValid",
          "old_text": "TransactionIdIsValid(limitXmin)",
          "new_text": "VirtualTransactionIdIsValid(vxid)",
          "old_line_content": "\t\t\tif (!TransactionIdIsValid(limitXmin) ||",
          "new_line_content": "\t\t\t\tif (VirtualTransactionIdIsValid(vxid))",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": "VirtualTransactionIdIsValid",
          "new_api": "LWLockRelease",
          "old_text": "VirtualTransactionIdIsValid(vxid)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\t\tif (VirtualTransactionIdIsValid(vxid))",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2672,
          "old_api": "SendProcSignal",
          "new_api": "LWLockRelease",
          "old_text": "SendProcSignal(pid, sigmode, vxid.backendId)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\t\t(void) SendProcSignal(pid, sigmode, vxid.backendId);",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2978,
          "old_api": "LWLockAcquire",
          "new_api": "LWLockRelease",
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 3075,
          "old_api": "XidCacheRemove",
          "new_api": "elog",
          "old_text": "XidCacheRemove(j)",
          "new_text": "elog(WARNING, \"did not find subXID %u in MyProc\", xid)",
          "old_line_content": "\t\t\tXidCacheRemove(j);",
          "new_line_content": "\t\telog(WARNING, \"did not find subXID %u in MyProc\", xid);",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": "KnownAssignedXidsCompress",
          "new_api": "LWLockRelease",
          "old_text": "KnownAssignedXidsCompress(true)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\tKnownAssignedXidsCompress(true);",
          "new_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 3525,
          "old_api": "LWLockRelease",
          "new_api": "elog",
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": "elog(ERROR, \"too many KnownAssignedXids\")",
          "old_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t\telog(ERROR, \"too many KnownAssignedXids\");",
          "content_same": false
        },
        {
          "line": 3715,
          "old_api": "KnownAssignedXidsRemove",
          "new_api": "KnownAssignedXidsCompress",
          "old_text": "KnownAssignedXidsRemove(xid)",
          "new_text": "KnownAssignedXidsCompress(false)",
          "old_line_content": "\t\tKnownAssignedXidsRemove(xid);",
          "new_line_content": "\tKnownAssignedXidsCompress(false);",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": "LWLockAcquire",
          "new_api": "LWLockRelease",
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2069,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(CurrentRunningXacts->nextXid)",
          "old_line_content": "\tCurrentRunningXacts->subxcnt = subcount;",
          "new_line_content": "\tAssert(TransactionIdIsValid(CurrentRunningXacts->nextXid));",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(CurrentRunningXacts->oldestRunningXid)",
          "old_line_content": "\tCurrentRunningXacts->subxid_overflow = suboverflowed;",
          "new_line_content": "\tAssert(TransactionIdIsValid(CurrentRunningXacts->oldestRunningXid));",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(CurrentRunningXacts->latestCompletedXid)",
          "old_line_content": "\tCurrentRunningXacts->nextXid = ShmemVariableCache->nextXid;",
          "new_line_content": "\tAssert(TransactionIdIsNormal(CurrentRunningXacts->latestCompletedXid));",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "GetOldestActiveTransactionId(void)",
          "new_line_content": "\tAssert(!RecoveryInProgress());",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(XidGenLock, LW_SHARED)",
          "old_line_content": "\t * Read nextXid, as the upper bound of what's still active.",
          "new_line_content": "\tLWLockAcquire(XidGenLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(XidGenLock)",
          "old_line_content": "\t * Reading a TransactionId is atomic, but we must grab the lock to make",
          "new_line_content": "\tLWLockRelease(XidGenLock);",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\toldestRunningXid = ShmemVariableCache->nextXid;",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2126,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "new_line_content": "\t\tif (!TransactionIdIsNormal(xid))",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, oldestRunningXid)",
          "old_line_content": "\t\t/* Fetch xid just once - see GetNewTransactionId */",
          "new_line_content": "\t\tif (TransactionIdPrecedes(xid, oldestRunningXid))",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "TransactionId",
          "new_line_content": "\tbool\t\trecovery_in_progress = RecoveryInProgress();",
          "content_same": false
        },
        {
          "line": 2167,
          "old_api": null,
          "new_api": "LWLockHeldByMe",
          "old_text": null,
          "new_text": "LWLockHeldByMe(ProcArrayLock)",
          "old_line_content": "{",
          "new_line_content": "\tAssert(LWLockHeldByMe(ProcArrayLock));",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(XidGenLock, LW_SHARED)",
          "old_line_content": "\t * running. If no transaction with xid were running concurrently a new xid",
          "new_line_content": "\tLWLockAcquire(XidGenLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(procArray->replication_slot_xmin)",
          "old_line_content": "\t * If there's already a slot pegging the xmin horizon, we can start with",
          "new_line_content": "\tif (TransactionIdIsValid(procArray->replication_slot_xmin) &&",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(procArray->replication_slot_xmin,\n\t\t\t\t\t\t\t  oldestSafeXid)",
          "old_line_content": "\t * that value, it's guaranteed to be safe since it's computed by this",
          "new_line_content": "\t\tTransactionIdPrecedes(procArray->replication_slot_xmin,",
          "content_same": false
        },
        {
          "line": 2224,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "new_line_content": "\t\t\tif (!TransactionIdIsNormal(xid))",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, oldestSafeXid)",
          "old_line_content": "\t\t\t/* Fetch xid just once - see GetNewTransactionId */",
          "new_line_content": "\t\t\tif (TransactionIdPrecedes(xid, oldestSafeXid))",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(XidGenLock)",
          "old_line_content": "",
          "new_line_content": "\tLWLockRelease(XidGenLock);",
          "content_same": false
        },
        {
          "line": 2265,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(VirtualTransactionId) * arrayP->maxProcs)",
          "old_line_content": "\tProcArrayStruct *arrayP = procArray;",
          "new_line_content": "\t\tpalloc(sizeof(VirtualTransactionId) * arrayP->maxProcs);",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\tint\t\t\tindex;",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "GET_VXID_FROM_PGPROC",
          "old_text": null,
          "new_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "old_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "new_line_content": "\t\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": null,
          "new_api": "VirtualTransactionIdIsValid",
          "old_text": null,
          "new_text": "VirtualTransactionIdIsValid(vxid)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (VirtualTransactionIdIsValid(vxid))",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "HaveVirtualXIDsDelayingChkpt(VirtualTransactionId *vxids, int nvxids)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": null,
          "new_api": "GET_VXID_FROM_PGPROC",
          "old_text": null,
          "new_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": null,
          "new_api": "VirtualTransactionIdIsValid",
          "old_text": null,
          "new_text": "VirtualTransactionIdIsValid(vxid)",
          "old_line_content": "\t\tvolatile PGPROC *proc = &allProcs[pgprocno];",
          "new_line_content": "\t\tif (pgxact->delayChkpt && VirtualTransactionIdIsValid(vxid))",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "{",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": null,
          "new_api": "BackendPidGetProcWithLock",
          "old_text": null,
          "new_text": "BackendPidGetProcWithLock(pid)",
          "old_line_content": "",
          "new_line_content": "\tresult = BackendPidGetProcWithLock(pid);",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\treturn NULL;",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\tProcArrayStruct *arrayP = procArray;",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "BackendPidGetProc",
          "old_text": null,
          "new_text": "BackendPidGetProc(pid)",
          "old_line_content": " *",
          "new_line_content": "\treturn (BackendPidGetProc(pid) != NULL);",
          "content_same": false
        },
        {
          "line": 2487,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(VirtualTransactionId) * arrayP->maxProcs)",
          "old_line_content": "\tProcArrayStruct *arrayP = procArray;",
          "new_line_content": "\t\tpalloc(sizeof(VirtualTransactionId) * arrayP->maxProcs);",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\tint\t\t\tindex;",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2508,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(pxmin)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (excludeXmin0 && !TransactionIdIsValid(pxmin))",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(limitXmin)",
          "old_line_content": "\t\t\t\tcontinue;",
          "new_line_content": "\t\t\tif (!TransactionIdIsValid(limitXmin) ||",
          "content_same": false
        },
        {
          "line": 2516,
          "old_api": null,
          "new_api": "TransactionIdPrecedesOrEquals",
          "old_text": null,
          "new_text": "TransactionIdPrecedesOrEquals(pxmin, limitXmin)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tTransactionIdPrecedesOrEquals(pxmin, limitXmin))",
          "content_same": false
        },
        {
          "line": 2520,
          "old_api": null,
          "new_api": "GET_VXID_FROM_PGPROC",
          "old_text": null,
          "new_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "content_same": false
        },
        {
          "line": 2579,
          "old_api": null,
          "new_api": "malloc",
          "old_text": null,
          "new_text": "malloc(sizeof(VirtualTransactionId) * (arrayP->maxProcs + 1))",
          "old_line_content": "\t * malloc it permanently to avoid repeated palloc/pfree overhead. Allow",
          "new_line_content": "\t\t\tmalloc(sizeof(VirtualTransactionId) * (arrayP->maxProcs + 1));",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "old_line_content": "\t */",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\tif (vxids == NULL)",
          "new_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"out of memory\")",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "content_same": false
        },
        {
          "line": 2586,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\t\tif (vxids == NULL)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 545,
          "old_api": null,
          "new_api": "pg_atomic_exchange_u32",
          "old_text": null,
          "new_text": "pg_atomic_exchange_u32(&procglobal->procArrayGroupFirst,\n\t\t\t\t\t\t\t\t\t INVALID_PGPROCNO)",
          "old_line_content": "\twhile (true)",
          "new_line_content": "\tnextidx = pg_atomic_exchange_u32(&procglobal->procArrayGroupFirst,",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(dbOid)",
          "old_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "new_line_content": "\t\tif (!OidIsValid(dbOid) ||",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": null,
          "new_api": "ProcArrayEndTransactionInternal",
          "old_text": null,
          "new_text": "ProcArrayEndTransactionInternal(proc, pgxact, proc->procArrayGroupMemberXid)",
          "old_line_content": "\t/* Walk the list and clear all XIDs. */",
          "new_line_content": "\t\tProcArrayEndTransactionInternal(proc, pgxact, proc->procArrayGroupMemberXid);",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": null,
          "new_api": "pg_atomic_read_u32",
          "old_text": null,
          "new_text": "pg_atomic_read_u32(&proc->procArrayGroupNext)",
          "old_line_content": "\t\tPGPROC\t   *proc = &allProcs[nextidx];",
          "new_line_content": "\t\tnextidx = pg_atomic_read_u32(&proc->procArrayGroupNext);",
          "content_same": false
        },
        {
          "line": 564,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(limitXmin)",
          "old_line_content": "\t\t\t * no snapshot currently. We hold a Share lock to avoid contention",
          "new_line_content": "\t\t\tif (!TransactionIdIsValid(limitXmin) ||",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": null,
          "new_api": "TransactionIdFollows",
          "old_text": null,
          "new_text": "TransactionIdFollows(pxmin, limitXmin)",
          "old_line_content": "\t\t\t * with users taking snapshots.  That is not a problem because the",
          "new_line_content": "\t\t\t\t(TransactionIdIsValid(pxmin) && !TransactionIdFollows(pxmin, limitXmin)))",
          "content_same": false
        },
        {
          "line": 2617,
          "old_api": null,
          "new_api": "GET_VXID_FROM_PGPROC",
          "old_text": null,
          "new_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "pg_atomic_read_u32",
          "old_text": null,
          "new_text": "pg_atomic_read_u32(&proc->procArrayGroupNext)",
          "old_line_content": "\t * holding the lock.",
          "new_line_content": "\t\twakeidx = pg_atomic_read_u32(&proc->procArrayGroupNext);",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "pg_atomic_write_u32",
          "old_text": null,
          "new_text": "pg_atomic_write_u32(&proc->procArrayGroupNext, INVALID_PGPROCNO)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tpg_atomic_write_u32(&proc->procArrayGroupNext, INVALID_PGPROCNO);",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "pg_write_barrier",
          "old_text": null,
          "new_text": "pg_write_barrier()",
          "old_line_content": "\t\tPGPROC\t   *proc = &allProcs[wakeidx];",
          "new_line_content": "\t\tpg_write_barrier();",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": null,
          "new_api": "PGSemaphoreUnlock",
          "old_text": null,
          "new_text": "PGSemaphoreUnlock(proc->sem)",
          "old_line_content": "\t\t/* ensure all previous writes are visible before follower continues. */",
          "new_line_content": "\t\t\tPGSemaphoreUnlock(proc->sem);",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "CancelVirtualTransaction(VirtualTransactionId vxid, ProcSignalReason sigmode)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": null,
          "new_api": "GET_VXID_FROM_PGPROC",
          "old_text": null,
          "new_text": "GET_VXID_FROM_PGPROC(procvxid, *proc)",
          "old_line_content": "\tfor (index = 0; index < arrayP->numProcs; index++)",
          "new_line_content": "\t\tGET_VXID_FROM_PGPROC(procvxid, *proc);",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": null,
          "new_api": "SendProcSignal",
          "old_text": null,
          "new_text": "SendProcSignal(pid, sigmode, vxid.backendId)",
          "old_line_content": "\t\t\tif (pid != 0)",
          "new_line_content": "\t\t\t\t(void) SendProcSignal(pid, sigmode, vxid.backendId);",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(standbyState == STANDBY_INITIALIZED)",
          "old_line_content": " * so we can ensure it's initialized gaplessly up to the point where necessary",
          "new_line_content": "\tAssert(standbyState == STANDBY_INITIALIZED);",
          "content_same": false
        },
        {
          "line": 634,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(initializedUptoXID)",
          "old_line_content": " * while in recovery.",
          "new_line_content": "\tAssert(TransactionIdIsNormal(initializedUptoXID));",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "TransactionIdRetreat",
          "old_text": null,
          "new_text": "TransactionIdRetreat(latestObservedXid)",
          "old_line_content": "\t * we set latestObservedXid to the xid SUBTRANS has been initialized up",
          "new_line_content": "\tTransactionIdRetreat(latestObservedXid);",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "old_line_content": "{",
          "new_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(running->nextXid)",
          "old_line_content": "\tTransactionId *xids;",
          "new_line_content": "\tAssert(TransactionIdIsValid(running->nextXid));",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(running->oldestRunningXid)",
          "old_line_content": "\tint\t\t\tnxids;",
          "new_line_content": "\tAssert(TransactionIdIsValid(running->oldestRunningXid));",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(running->latestCompletedXid)",
          "old_line_content": "\tTransactionId nextXid;",
          "new_line_content": "\tAssert(TransactionIdIsNormal(running->latestCompletedXid));",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "StandbyReleaseOldLocks",
          "old_text": null,
          "new_text": "StandbyReleaseOldLocks(running->oldestRunningXid)",
          "old_line_content": "\t */",
          "new_line_content": "\tStandbyReleaseOldLocks(running->oldestRunningXid);",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "CountDBBackends(Oid databaseid)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2756,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(databaseid)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tif (!OidIsValid(databaseid) ||",
          "content_same": false
        },
        {
          "line": 713,
          "old_api": null,
          "new_api": "KnownAssignedXidsReset",
          "old_text": null,
          "new_text": "KnownAssignedXidsReset()",
          "old_line_content": "\t\tif (!running->subxid_overflow || running->xcnt == 0)",
          "new_line_content": "\t\t\tKnownAssignedXidsReset();",
          "content_same": false
        },
        {
          "line": 2761,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\tcontinue;\t\t\t/* do not count prepared xacts */",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(standbySnapshotPendingXmin,\n\t\t\t\t\t\t\t\t\t  running->oldestRunningXid)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tif (TransactionIdPrecedes(standbySnapshotPendingXmin,",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG1)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\t\telog(trace_recovery(DEBUG1),",
          "content_same": false
        },
        {
          "line": 726,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG1)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\telog(trace_recovery(DEBUG1),",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "CountDBConnections(Oid databaseid)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 735,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(standbyState == STANDBY_INITIALIZED)",
          "old_line_content": "\t\t\t\t\t standbySnapshotPendingXmin,",
          "new_line_content": "\tAssert(standbyState == STANDBY_INITIALIZED);",
          "content_same": false
        },
        {
          "line": 2788,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(databaseid)",
          "old_line_content": "\t\tvolatile PGPROC *proc = &allProcs[pgprocno];",
          "new_line_content": "\t\tif (!OidIsValid(databaseid) ||",
          "content_same": false
        },
        {
          "line": 2793,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\tcontinue;\t\t\t/* do not count background workers */",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "\t * with that.",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "{",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(TransactionId) * (running->xcnt + running->subxcnt))",
          "old_line_content": "\t */",
          "new_line_content": "\txids = palloc(sizeof(TransactionId) * (running->xcnt + running->subxcnt));",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": null,
          "new_api": "GET_VXID_FROM_PGPROC",
          "old_text": null,
          "new_text": "GET_VXID_FROM_PGPROC(procvxid, *proc)",
          "old_line_content": "\t\tvolatile PGPROC *proc = &allProcs[pgprocno];",
          "new_line_content": "\t\t\tGET_VXID_FROM_PGPROC(procvxid, *proc);",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": null,
          "new_api": "TransactionIdDidAbort",
          "old_text": null,
          "new_text": "TransactionIdDidAbort(xid)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tif (TransactionIdDidCommit(xid) || TransactionIdDidAbort(xid))",
          "content_same": false
        },
        {
          "line": 2830,
          "old_api": null,
          "new_api": "SendProcSignal",
          "old_text": null,
          "new_text": "SendProcSignal(pid, sigmode, procvxid.backendId)",
          "old_line_content": "\t\t\tif (pid != 0)",
          "new_line_content": "\t\t\t\t(void) SendProcSignal(pid, sigmode, procvxid.backendId);",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\t\t */",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"KnownAssignedXids is not empty\")",
          "old_line_content": "",
          "new_line_content": "\t\t\telog(ERROR, \"KnownAssignedXids is not empty\");",
          "content_same": false
        },
        {
          "line": 799,
          "old_api": null,
          "new_api": "qsort",
          "old_text": null,
          "new_text": "qsort(xids, nxids, sizeof(TransactionId), xidComparator)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tqsort(xids, nxids, sizeof(TransactionId), xidComparator);",
          "content_same": false
        },
        {
          "line": 2848,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "CountUserBackends(Oid roleid)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 807,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG3)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tKnownAssignedXidsDisplay(trace_recovery(DEBUG3));",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(xids)",
          "old_line_content": "\t\tfor (i = 0; i < nxids; i++)",
          "new_line_content": "\tpfree(xids);",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\tif (proc->isBackgroundWorker)",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(latestObservedXid)",
          "old_line_content": "\t * subtrans from thereon, up to nextXid - 1.",
          "new_line_content": "\tAssert(TransactionIdIsNormal(latestObservedXid));",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(latestObservedXid)",
          "old_line_content": "\t *",
          "new_line_content": "\tTransactionIdAdvance(latestObservedXid);",
          "content_same": false
        },
        {
          "line": 824,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(latestObservedXid, running->nextXid)",
          "old_line_content": "\t * We need to duplicate parts of RecordKnownAssignedTransactionId() here,",
          "new_line_content": "\twhile (TransactionIdPrecedes(latestObservedXid, running->nextXid))",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": null,
          "new_api": "ExtendSUBTRANS",
          "old_text": null,
          "new_text": "ExtendSUBTRANS(latestObservedXid)",
          "old_line_content": "\t * haven't gone through RecordKnownAssignedTransactionId().",
          "new_line_content": "\t\tExtendSUBTRANS(latestObservedXid);",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(latestObservedXid)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tTransactionIdAdvance(latestObservedXid);",
          "content_same": false
        },
        {
          "line": 2907,
          "old_api": null,
          "new_api": "CHECK_FOR_INTERRUPTS",
          "old_text": null,
          "new_text": "CHECK_FOR_INTERRUPTS()",
          "old_line_content": "\tfor (tries = 0; tries < 50; tries++)",
          "new_line_content": "\t\tCHECK_FOR_INTERRUPTS();",
          "content_same": false
        },
        {
          "line": 2911,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\t\tint\t\t\tindex;",
          "new_line_content": "\t\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 864,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,\n\t\t\t\t\t\t\t  running->latestCompletedXid)",
          "old_line_content": "",
          "new_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(ShmemVariableCache->latestCompletedXid)",
          "old_line_content": "\t * the value from the snapshot, so check before we use the incoming value.",
          "new_line_content": "\tAssert(TransactionIdIsNormal(ShmemVariableCache->latestCompletedXid));",
          "content_same": false
        },
        {
          "line": 880,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(nextXid)",
          "old_line_content": "\t *",
          "new_line_content": "\tTransactionIdAdvance(nextXid);",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "TransactionIdFollows",
          "old_text": null,
          "new_text": "TransactionIdFollows(nextXid, ShmemVariableCache->nextXid)",
          "old_line_content": "\t * We don't expect anyone else to modify nextXid, hence we don't need to",
          "new_line_content": "\tif (TransactionIdFollows(nextXid, ShmemVariableCache->nextXid))",
          "content_same": false
        },
        {
          "line": 883,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(XidGenLock, LW_EXCLUSIVE)",
          "old_line_content": "\t * it, though.",
          "new_line_content": "\t\tLWLockAcquire(XidGenLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 885,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(XidGenLock)",
          "old_line_content": "\tnextXid = latestObservedXid;",
          "new_line_content": "\t\tLWLockRelease(XidGenLock);",
          "content_same": false
        },
        {
          "line": 888,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(ShmemVariableCache->nextXid)",
          "old_line_content": "\t{",
          "new_line_content": "\tAssert(TransactionIdIsValid(ShmemVariableCache->nextXid));",
          "content_same": false
        },
        {
          "line": 2937,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t\t\tif ((pgxact->vacuumFlags & PROC_IS_AUTOVACUUM) &&",
          "new_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG3)",
          "old_line_content": "\t\tShmemVariableCache->nextXid = nextXid;",
          "new_line_content": "\tKnownAssignedXidsDisplay(trace_recovery(DEBUG3));",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG1)",
          "old_line_content": "\t}",
          "new_line_content": "\t\telog(trace_recovery(DEBUG1), \"recovery snapshots are now enabled\");",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": null,
          "new_api": "kill",
          "old_text": null,
          "new_text": "kill(autovac_pids[index], SIGTERM)",
          "old_line_content": "\t\t * Send SIGTERM to any conflicting autovacuums before sleeping. We",
          "new_line_content": "\t\t\t(void) kill(autovac_pids[index], SIGTERM);\t/* ignore any error */",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": null,
          "new_api": "pg_usleep",
          "old_text": null,
          "new_text": "pg_usleep(100 * 1000L)",
          "old_line_content": "\t\t * block kill() inside the kernel...",
          "new_line_content": "\t\tpg_usleep(100 * 1000L); /* 100ms */",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "old_line_content": "ProcArrayApplyXidAssignment(TransactionId topxid,",
          "new_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": null,
          "new_api": "TransactionIdLatest",
          "old_text": null,
          "new_text": "TransactionIdLatest(topxid, nsubxids, subxids)",
          "old_line_content": "{",
          "new_line_content": "\tmax_xid = TransactionIdLatest(topxid, nsubxids, subxids);",
          "content_same": false
        },
        {
          "line": 2969,
          "old_api": null,
          "new_api": "LWLockHeldByMe",
          "old_text": null,
          "new_text": "LWLockHeldByMe(ProcArrayLock)",
          "old_line_content": " * replication slots.",
          "new_line_content": "\tAssert(!already_locked || LWLockHeldByMe(ProcArrayLock));",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "RecordKnownAssignedTransactionIds",
          "old_text": null,
          "new_text": "RecordKnownAssignedTransactionIds(max_xid)",
          "old_line_content": "\t *",
          "new_line_content": "\tRecordKnownAssignedTransactionIds(max_xid);",
          "content_same": false
        },
        {
          "line": 2972,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "ProcArraySetReplicationSlotXmin(TransactionId xmin, TransactionId catalog_xmin,",
          "new_line_content": "\t\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": null,
          "new_api": "SubTransSetParent",
          "old_text": null,
          "new_text": "SubTransSetParent(subxids[i], topxid)",
          "old_line_content": "\t * As a result we are able to refer directly to the top-level",
          "new_line_content": "\t\tSubTransSetParent(subxids[i], topxid);",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": " * data that's older than those limits.",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "\tif (standbyState == STANDBY_INITIALIZED)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\tif (xmin != NULL)",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 952,
          "old_api": null,
          "new_api": "KnownAssignedXidsRemoveTree",
          "old_text": null,
          "new_text": "KnownAssignedXidsRemoveTree(InvalidTransactionId, nsubxids, subxids)",
          "old_line_content": "\t */",
          "new_line_content": "\tKnownAssignedXidsRemoveTree(InvalidTransactionId, nsubxids, subxids);",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(procArray->lastOverflowedXid, max_xid)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (TransactionIdPrecedes(procArray->lastOverflowedXid, max_xid))",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t/*",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 3025,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xid)",
          "old_line_content": "\t\t\t\t\t\t  int nxids, const TransactionId *xids,",
          "new_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "content_same": false
        },
        {
          "line": 3034,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "\t * We must hold ProcArrayLock exclusively in order to remove transactions",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": null,
          "new_api": "TransactionIdEquals",
          "old_text": null,
          "new_text": "TransactionIdEquals(MyProc->subxids.xids[j], anxid)",
          "old_line_content": "\tfor (i = nxids - 1; i >= 0; i--)",
          "new_line_content": "\t\t\tif (TransactionIdEquals(MyProc->subxids.xids[j], anxid))",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": null,
          "new_api": "XidCacheRemove",
          "old_text": null,
          "new_text": "XidCacheRemove(j)",
          "old_line_content": "\t\tTransactionId anxid = xids[i];",
          "new_line_content": "\t\t\t\tXidCacheRemove(j);",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, RecentXmin)",
          "old_line_content": "\t/*",
          "new_line_content": "\tif (TransactionIdPrecedes(xid, RecentXmin))",
          "content_same": false
        },
        {
          "line": 1007,
          "old_api": null,
          "new_api": "xc_by_recent_xmin_inc",
          "old_text": null,
          "new_text": "xc_by_recent_xmin_inc()",
          "old_line_content": "\t * possibly still be running.  (Note: in particular, this guarantees that",
          "new_line_content": "\t\txc_by_recent_xmin_inc();",
          "content_same": false
        },
        {
          "line": 3062,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(WARNING, \"did not find subXID %u in MyProc\", anxid)",
          "old_line_content": "\t\t * overflowed. However it's also possible for this routine to be",
          "new_line_content": "\t\t\telog(WARNING, \"did not find subXID %u in MyProc\", anxid);",
          "content_same": false
        },
        {
          "line": 1016,
          "old_api": null,
          "new_api": "TransactionIdIsKnownCompleted",
          "old_text": null,
          "new_text": "TransactionIdIsKnownCompleted(xid)",
          "old_line_content": "",
          "new_line_content": "\tif (TransactionIdIsKnownCompleted(xid))",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": null,
          "new_api": "xc_by_known_xact_inc",
          "old_text": null,
          "new_text": "xc_by_known_xact_inc()",
          "old_line_content": "\t * We may have just checked the status of this transaction, so if it is",
          "new_line_content": "\t\txc_by_known_xact_inc();",
          "content_same": false
        },
        {
          "line": 3067,
          "old_api": null,
          "new_api": "TransactionIdEquals",
          "old_text": null,
          "new_text": "TransactionIdEquals(MyProc->subxids.xids[j], xid)",
          "old_line_content": "\t\tif (j < 0 && !MyPgXact->overflowed)",
          "new_line_content": "\t\tif (TransactionIdEquals(MyProc->subxids.xids[j], xid))",
          "content_same": false
        },
        {
          "line": 3069,
          "old_api": null,
          "new_api": "XidCacheRemove",
          "old_text": null,
          "new_text": "XidCacheRemove(j)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tXidCacheRemove(j);",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "TransactionIdIsCurrentTransactionId",
          "old_text": null,
          "new_text": "TransactionIdIsCurrentTransactionId(xid)",
          "old_line_content": "\t}",
          "new_line_content": "\tif (TransactionIdIsCurrentTransactionId(xid))",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": null,
          "new_api": "xc_by_my_xact_inc",
          "old_text": null,
          "new_text": "xc_by_my_xact_inc()",
          "old_line_content": "\t/*",
          "new_line_content": "\t\txc_by_my_xact_inc();",
          "content_same": false
        },
        {
          "line": 3078,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,\n\t\t\t\t\t\t\t  latestXid)",
          "old_line_content": "\t}",
          "new_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,",
          "content_same": false
        },
        {
          "line": 3082,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1043,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\t{",
          "new_line_content": "\t\tint\t\t\tmaxxids = RecoveryInProgress() ? TOTAL_MAX_CACHED_SUBXIDS : arrayP->maxProcs;",
          "content_same": false
        },
        {
          "line": 1045,
          "old_api": null,
          "new_api": "malloc",
          "old_text": null,
          "new_text": "malloc(maxxids * sizeof(TransactionId))",
          "old_line_content": "\t\t * In hot standby mode, reserve enough space to hold all xids in the",
          "new_line_content": "\t\txids = (TransactionId *) malloc(maxxids * sizeof(TransactionId));",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": null,
          "new_api": "fprintf",
          "old_text": null,
          "new_text": "fprintf(stderr,\n\t\t\t\"XidCache: xmin: %ld, known: %ld, myxact: %ld, latest: %ld, mainxid: %ld, childxid: %ld, knownassigned: %ld, nooflo: %ld, slow: %ld\\n\",\n\t\t\txc_by_recent_xmin,\n\t\t\txc_by_known_xact,\n\t\t\txc_by_my_xact,\n\t\t\txc_by_latest_xid,\n\t\t\txc_by_main_xid,\n\t\t\txc_by_child_xid,\n\t\t\txc_by_known_assigned,\n\t\t\txc_no_overflow,\n\t\t\txc_slow_answer)",
          "old_line_content": "/*",
          "new_line_content": "\tfprintf(stderr,",
          "content_same": false
        },
        {
          "line": 1047,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "old_line_content": "\t\t * the bigger array, but we don't bother to shrink it.",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 1048,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\t\tif (xids == NULL)",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1061,
          "old_api": null,
          "new_api": "xc_by_latest_xid_inc",
          "old_text": null,
          "new_text": "xc_by_latest_xid_inc()",
          "old_line_content": "\t * Now that we have the lock, we can check latestCompletedXid; if the",
          "new_line_content": "\t\txc_by_latest_xid_inc();",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(pxid)",
          "old_line_content": "\t\tif (proc == MyProc)",
          "new_line_content": "\t\tif (!TransactionIdIsValid(pxid))",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "",
          "new_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1089,
          "old_api": null,
          "new_api": "xc_by_main_xid_inc",
          "old_text": null,
          "new_text": "xc_by_main_xid_inc()",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\txc_by_main_xid_inc();",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, pxid)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (TransactionIdPrecedes(xid, pxid))",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "TransactionIdEquals",
          "old_text": null,
          "new_text": "TransactionIdEquals(cxid, xid)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\tif (TransactionIdEquals(cxid, xid))",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "xc_by_child_xid_inc",
          "old_text": null,
          "new_text": "xc_by_child_xid_inc()",
          "old_line_content": "\t\t\t/* Fetch xid just once - see GetNewTransactionId */",
          "new_line_content": "\t\t\t\txc_by_child_xid_inc();",
          "content_same": false
        },
        {
          "line": 3177,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "old_line_content": " *",
          "new_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xid)",
          "old_line_content": " * Called during recovery in analogy with and in place of GetNewTransactionId()",
          "new_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\t}",
          "new_line_content": "\tif (RecoveryInProgress())",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(latestObservedXid)",
          "old_line_content": " */",
          "new_line_content": "\tAssert(TransactionIdIsValid(latestObservedXid));",
          "content_same": false
        },
        {
          "line": 3181,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG4)",
          "old_line_content": "RecordKnownAssignedTransactionIds(TransactionId xid)",
          "new_line_content": "\telog(trace_recovery(DEBUG4), \"record known xact %u latestObservedXid %u\",",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(nxids == 0)",
          "old_line_content": "\t * Step 3: in hot standby mode, check the known-assigned-xids list.  XIDs",
          "new_line_content": "\t\tAssert(nxids == 0);",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "KnownAssignedXidExists",
          "old_text": null,
          "new_text": "KnownAssignedXidExists(xid)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tif (KnownAssignedXidExists(xid))",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": null,
          "new_api": "xc_by_known_assigned_inc",
          "old_text": null,
          "new_text": "xc_by_known_assigned_inc()",
          "old_line_content": "\t\t/* none of the PGXACT entries should have XIDs in hot standby mode */",
          "new_line_content": "\t\t\txc_by_known_assigned_inc();",
          "content_same": false
        },
        {
          "line": 3189,
          "old_api": null,
          "new_api": "TransactionIdFollows",
          "old_text": null,
          "new_text": "TransactionIdFollows(xid, latestObservedXid)",
          "old_line_content": "",
          "new_line_content": "\tif (TransactionIdFollows(xid, latestObservedXid))",
          "content_same": false
        },
        {
          "line": 1150,
          "old_api": null,
          "new_api": "TransactionIdPrecedesOrEquals",
          "old_text": null,
          "new_text": "TransactionIdPrecedesOrEquals(xid, procArray->lastOverflowedXid)",
          "old_line_content": "\t\t * If the KnownAssignedXids overflowed, we have to check pg_subtrans",
          "new_line_content": "\t\tif (TransactionIdPrecedesOrEquals(xid, procArray->lastOverflowedXid))",
          "content_same": false
        },
        {
          "line": 1151,
          "old_api": null,
          "new_api": "KnownAssignedXidsGet",
          "old_text": null,
          "new_text": "KnownAssignedXidsGet(xids, xid)",
          "old_line_content": "\t\t * too.  Fetch all xids from KnownAssignedXids that are lower than",
          "new_line_content": "\t\t\tnxids = KnownAssignedXidsGet(xids, xid);",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t * there's no help for it.",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 3203,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(next_expected_xid, xid)",
          "old_line_content": "\t\t *",
          "new_line_content": "\t\twhile (TransactionIdPrecedes(next_expected_xid, xid))",
          "content_same": false
        },
        {
          "line": 3205,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(next_expected_xid)",
          "old_line_content": "\t\t * immediately start assigning subtransactions to their toplevel",
          "new_line_content": "\t\t\tTransactionIdAdvance(next_expected_xid);",
          "content_same": false
        },
        {
          "line": 3206,
          "old_api": null,
          "new_api": "ExtendSUBTRANS",
          "old_text": null,
          "new_text": "ExtendSUBTRANS(next_expected_xid)",
          "old_line_content": "\t\t * transactions.",
          "new_line_content": "\t\t\tExtendSUBTRANS(next_expected_xid);",
          "content_same": false
        },
        {
          "line": 3208,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(next_expected_xid == xid)",
          "old_line_content": "\t\tnext_expected_xid = latestObservedXid;",
          "new_line_content": "\t\tAssert(next_expected_xid == xid);",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "xc_no_overflow_inc",
          "old_text": null,
          "new_text": "xc_no_overflow_inc()",
          "old_line_content": "\t/*",
          "new_line_content": "\t\txc_no_overflow_inc();",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": null,
          "new_api": "xc_slow_answer_inc",
          "old_text": null,
          "new_text": "xc_slow_answer_inc()",
          "old_line_content": "\t *",
          "new_line_content": "\txc_slow_answer_inc();",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": null,
          "new_api": "TransactionIdDidAbort",
          "old_text": null,
          "new_text": "TransactionIdDidAbort(xid)",
          "old_line_content": "\t * in xids[], or it's not running.  If it's an already-failed",
          "new_line_content": "\tif (TransactionIdDidAbort(xid))",
          "content_same": false
        },
        {
          "line": 3224,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(next_expected_xid)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tTransactionIdAdvance(next_expected_xid);",
          "content_same": false
        },
        {
          "line": 3225,
          "old_api": null,
          "new_api": "KnownAssignedXidsAdd",
          "old_text": null,
          "new_text": "KnownAssignedXidsAdd(next_expected_xid, xid, false)",
          "old_line_content": "",
          "new_line_content": "\t\tKnownAssignedXidsAdd(next_expected_xid, xid, false);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": null,
          "new_api": "SubTransGetTopmostTransaction",
          "old_text": null,
          "new_text": "SubTransGetTopmostTransaction(xid)",
          "old_line_content": "",
          "new_line_content": "\ttopxid = SubTransGetTopmostTransaction(xid);",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(topxid)",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert(TransactionIdIsValid(topxid));",
          "content_same": false
        },
        {
          "line": 1186,
          "old_api": null,
          "new_api": "TransactionIdEquals",
          "old_text": null,
          "new_text": "TransactionIdEquals(topxid, xid)",
          "old_line_content": "\t * It isn't aborted, so check whether the transaction tree it belongs to",
          "new_line_content": "\tif (!TransactionIdEquals(topxid, xid))",
          "content_same": false
        },
        {
          "line": 3234,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(next_expected_xid)",
          "old_line_content": "\t\t * Now we can advance latestObservedXid",
          "new_line_content": "\t\tTransactionIdAdvance(next_expected_xid);",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(XidGenLock, LW_EXCLUSIVE)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tLWLockAcquire(XidGenLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3237,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(XidGenLock)",
          "old_line_content": "",
          "new_line_content": "\t\tLWLockRelease(XidGenLock);",
          "content_same": false
        },
        {
          "line": 3251,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "old_line_content": " * Called during recovery in analogy with and in place of ProcArrayEndTransaction()",
          "new_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "content_same": false
        },
        {
          "line": 3256,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "{",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": null,
          "new_api": "KnownAssignedXidsRemoveTree",
          "old_text": null,
          "new_text": "KnownAssignedXidsRemoveTree(xid, nsubxids, subxids)",
          "old_line_content": "",
          "new_line_content": "\tKnownAssignedXidsRemoveTree(xid, nsubxids, subxids);",
          "content_same": false
        },
        {
          "line": 3261,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,\n\t\t\t\t\t\t\t  max_xid)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, RecentXmin)",
          "old_line_content": "\tint\t\t\ti;",
          "new_line_content": "\tif (TransactionIdPrecedes(xid, RecentXmin))",
          "content_same": false
        },
        {
          "line": 3265,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\t * Don't bother checking a transaction older than RecentXmin; it could not",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": " * ExpireAllKnownAssignedTransactionIds",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": null,
          "new_api": "KnownAssignedXidsRemovePreceding",
          "old_text": null,
          "new_text": "KnownAssignedXidsRemovePreceding(InvalidTransactionId)",
          "old_line_content": " *\t\tRemove all entries in KnownAssignedXids",
          "new_line_content": "\tKnownAssignedXidsRemovePreceding(InvalidTransactionId);",
          "content_same": false
        },
        {
          "line": 3277,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": " */",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1232,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(pxid)",
          "old_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "new_line_content": "\t\tif (!TransactionIdIsValid(pxid))",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": " * ExpireOldKnownAssignedTransactionIds",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3288,
          "old_api": null,
          "new_api": "KnownAssignedXidsRemovePreceding",
          "old_text": null,
          "new_text": "KnownAssignedXidsRemovePreceding(xid)",
          "old_line_content": " *\t\tRemove KnownAssignedXids entries preceding the given XID",
          "new_line_content": "\tKnownAssignedXidsRemovePreceding(xid);",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": " */",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1245,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1324,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\t * relation has been passed in, backends in all databases have to be",
          "new_line_content": "\tAssert(allDbs || !RecoveryInProgress());",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\t */",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(result)",
          "old_line_content": "\t * We initialize the MIN() calculation with latestCompletedXid + 1. This",
          "new_line_content": "\tAssert(TransactionIdIsNormal(result));",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(result)",
          "old_line_content": "\t * is a lower bound for the XIDs that might appear in the ProcArray later,",
          "new_line_content": "\tTransactionIdAdvance(result);",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\t\tproc->databaseId == 0)\t/* always include WalSender */",
          "new_line_content": "\t\t\tif (TransactionIdIsNormal(xid) &&",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, result)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\tTransactionIdPrecedes(xid, result))",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\t\t *",
          "new_line_content": "\t\t\tif (TransactionIdIsNormal(xid) &&",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, result)",
          "old_line_content": "\t\t\t * We must check both Xid and Xmin because a transaction might",
          "new_line_content": "\t\t\t\tTransactionIdPrecedes(xid, result))",
          "content_same": false
        },
        {
          "line": 1377,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\t}",
          "new_line_content": "\tif (RecoveryInProgress())",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1387,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(kaxmin)",
          "old_line_content": "\t\t * than the main procarray.",
          "new_line_content": "\t\tif (TransactionIdIsNormal(kaxmin) &&",
          "content_same": false
        },
        {
          "line": 1388,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(kaxmin, result)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\tTransactionIdPrecedes(kaxmin, result))",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1413,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(result)",
          "old_line_content": "\t\t * vacuum_defer_cleanup_age isn't large enough to cause wraparound ---",
          "new_line_content": "\t\tif (!TransactionIdIsNormal(result))",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "TransactionIdPrecedesOrEquals",
          "old_text": null,
          "new_text": "TransactionIdPrecedesOrEquals(from_xid, to_xid)",
          "old_line_content": "\tTransactionId next_xid;",
          "new_line_content": "\tAssert(TransactionIdPrecedesOrEquals(from_xid, to_xid));",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(replication_slot_xmin)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tTransactionIdIsValid(replication_slot_xmin) &&",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(replication_slot_xmin, result)",
          "old_line_content": "",
          "new_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_xmin, result))",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(next_xid, to_xid)",
          "old_line_content": "\tif (to_xid >= from_xid)",
          "new_line_content": "\t\twhile (TransactionIdPrecedes(next_xid, to_xid))",
          "content_same": false
        },
        {
          "line": 3478,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(next_xid)",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tTransactionIdAdvance(next_xid);",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "RelationIsAccessibleInLogicalDecoding",
          "old_text": null,
          "new_text": "RelationIsAccessibleInLogicalDecoding(rel)",
          "old_line_content": "\t * check whether we need to back up further to make logical decoding",
          "new_line_content": "\t\t RelationIsAccessibleInLogicalDecoding(rel)) &&",
          "content_same": false
        },
        {
          "line": 1434,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(replication_slot_catalog_xmin)",
          "old_line_content": "\t * possible. We need to do so if we're computing the global limit (rel =",
          "new_line_content": "\t\tTransactionIdIsValid(replication_slot_catalog_xmin) &&",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(replication_slot_catalog_xmin, result)",
          "old_line_content": "\t * NULL) or if the passed relation is a catalog relation of some kind.",
          "new_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_catalog_xmin, result))",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(head >= 0 && head <= pArray->maxKnownAssignedXids)",
          "old_line_content": "\t * Since only the startup process modifies the head/tail pointers, we",
          "new_line_content": "\tAssert(head >= 0 && head <= pArray->maxKnownAssignedXids);",
          "content_same": false
        },
        {
          "line": 3490,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(tail >= 0 && tail < pArray->maxKnownAssignedXids)",
          "old_line_content": "\t * don't need a lock to read them here.",
          "new_line_content": "\tAssert(tail >= 0 && tail < pArray->maxKnownAssignedXids);",
          "content_same": false
        },
        {
          "line": 3498,
          "old_api": null,
          "new_api": "TransactionIdFollowsOrEquals",
          "old_text": null,
          "new_text": "TransactionIdFollowsOrEquals(KnownAssignedXids[head - 1], from_xid)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\tTransactionIdFollowsOrEquals(KnownAssignedXids[head - 1], from_xid))",
          "content_same": false
        },
        {
          "line": 3500,
          "old_api": null,
          "new_api": "KnownAssignedXidsDisplay",
          "old_text": null,
          "new_text": "KnownAssignedXidsDisplay(LOG)",
          "old_line_content": "\t * if the last existing element is marked invalid, it must still have a",
          "new_line_content": "\t\tKnownAssignedXidsDisplay(LOG);",
          "content_same": false
        },
        {
          "line": 3501,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"out-of-order XID insertion in KnownAssignedXids\")",
          "old_line_content": "\t * correctly sequenced XID value.",
          "new_line_content": "\t\telog(ERROR, \"out-of-order XID insertion in KnownAssignedXids\");",
          "content_same": false
        },
        {
          "line": 3511,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "\t * If our xids won't fit in the remaining space, compress out free space",
          "new_line_content": "\t\t\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 3513,
          "old_api": null,
          "new_api": "KnownAssignedXidsCompress",
          "old_text": null,
          "new_text": "KnownAssignedXidsCompress(true)",
          "old_line_content": "\tif (head + nxids > pArray->maxKnownAssignedXids)",
          "new_line_content": "\t\tKnownAssignedXidsCompress(true);",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(next_xid)",
          "old_line_content": "\t/* Now we can insert the xids into the space starting at head */",
          "new_line_content": "\t\tTransactionIdAdvance(next_xid);",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": null,
          "new_api": "SpinLockAcquire",
          "old_text": null,
          "new_text": "SpinLockAcquire(&pArray->known_assigned_xids_lck)",
          "old_line_content": "\t * spinlock.",
          "new_line_content": "\t\tSpinLockAcquire(&pArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&pArray->known_assigned_xids_lck)",
          "old_line_content": "\tif (exclusive_lock)",
          "new_line_content": "\t\tSpinLockRelease(&pArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(snapshot != NULL)",
          "old_line_content": "\tint\t\t\tcount = 0;",
          "new_line_content": "\tAssert(snapshot != NULL);",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": null,
          "new_api": "GetMaxSnapshotXidCount",
          "old_text": null,
          "new_text": "GetMaxSnapshotXidCount()",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tmalloc(GetMaxSnapshotXidCount() * sizeof(TransactionId));",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "old_line_content": "\t\t * First call for this snapshot. Snapshot is same size whether or not",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\t\t * we are in recovery, see later comments.",
          "new_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"out of memory\")",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(snapshot->subxip == NULL)",
          "old_line_content": "\t\tsnapshot->xip = (TransactionId *)",
          "new_line_content": "\t\tAssert(snapshot->subxip == NULL);",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": null,
          "new_api": "GetMaxSnapshotSubxidCount",
          "old_text": null,
          "new_text": "GetMaxSnapshotSubxidCount()",
          "old_line_content": "\t\tif (snapshot->xip == NULL)",
          "new_line_content": "\t\t\tmalloc(GetMaxSnapshotSubxidCount() * sizeof(TransactionId));",
          "content_same": false
        },
        {
          "line": 3589,
          "old_api": null,
          "new_api": "SpinLockAcquire",
          "old_text": null,
          "new_text": "SpinLockAcquire(&pArray->known_assigned_xids_lck)",
          "old_line_content": "\t\ttail = pArray->tailKnownAssignedXids;",
          "new_line_content": "\t\tSpinLockAcquire(&pArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 3592,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&pArray->known_assigned_xids_lck)",
          "old_line_content": "\telse",
          "new_line_content": "\t\tSpinLockRelease(&pArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\t}",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xmax)",
          "old_line_content": "\t * going to set MyPgXact->xmin.",
          "new_line_content": "\tAssert(TransactionIdIsNormal(xmax));",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": null,
          "new_api": "TransactionIdAdvance",
          "old_text": null,
          "new_text": "TransactionIdAdvance(xmax)",
          "old_line_content": "\t */",
          "new_line_content": "\tTransactionIdAdvance(xmax);",
          "content_same": false
        },
        {
          "line": 3614,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, mid_xid)",
          "old_line_content": "",
          "new_line_content": "\t\telse if (TransactionIdPrecedes(xid, mid_xid))",
          "content_same": false
        },
        {
          "line": 3631,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(pArray->numKnownAssignedXids >= 0)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(pArray->numKnownAssignedXids >= 0);",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\t\t/* Ignore procs running LAZY VACUUM */",
          "new_line_content": "\t\t\tif (TransactionIdIsNormal(xid) &&",
          "content_same": false
        },
        {
          "line": 1594,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(xid, globalxmin)",
          "old_line_content": "\t\t\tif (pgxact->vacuumFlags & PROC_IN_VACUUM)",
          "new_line_content": "\t\t\t\tNormalTransactionIdPrecedes(xid, globalxmin))",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\tif (!TransactionIdIsNormal(xid)",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(xid, xmax)",
          "old_line_content": "\t\t\t * If the transaction has no XID assigned, we can skip it; it",
          "new_line_content": "\t\t\t\t|| !NormalTransactionIdPrecedes(xid, xmax))",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(xid, xmin)",
          "old_line_content": "\t\t\t\tcontinue;",
          "new_line_content": "\t\t\tif (NormalTransactionIdPrecedes(xid, xmin))",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xid)",
          "old_line_content": " *",
          "new_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "content_same": false
        },
        {
          "line": 3668,
          "old_api": null,
          "new_api": "KnownAssignedXidsSearch",
          "old_text": null,
          "new_text": "KnownAssignedXidsSearch(xid, false)",
          "old_line_content": " */",
          "new_line_content": "\treturn KnownAssignedXidsSearch(xid, false);",
          "content_same": false
        },
        {
          "line": 3679,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xid)",
          "old_line_content": " *",
          "new_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG4)",
          "old_line_content": " */",
          "new_line_content": "\telog(trace_recovery(DEBUG4), \"remove KnownAssignedXid %u\", xid);",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": null,
          "new_api": "KnownAssignedXidsSearch",
          "old_text": null,
          "new_text": "KnownAssignedXidsSearch(xid, true)",
          "old_line_content": "\t * removed again when the top-level xact commits or aborts.",
          "new_line_content": "\t(void) KnownAssignedXidsSearch(xid, true);",
          "content_same": false
        },
        {
          "line": 1649,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(snapshot->subxip + subcount,\n\t\t\t\t\t\t\t   (void *) proc->subxids.xids,\n\t\t\t\t\t\t\t   nxids * sizeof(TransactionId))",
          "old_line_content": "\t\t\t\t\tint\t\t\tnxids = pgxact->nxids;",
          "new_line_content": "\t\t\t\t\t\tmemcpy(snapshot->subxip + subcount,",
          "content_same": false
        },
        {
          "line": 3708,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xid)",
          "old_line_content": "static void",
          "new_line_content": "\tif (TransactionIdIsValid(xid))",
          "content_same": false
        },
        {
          "line": 3709,
          "old_api": null,
          "new_api": "KnownAssignedXidsRemove",
          "old_text": null,
          "new_text": "KnownAssignedXidsRemove(xid)",
          "old_line_content": "KnownAssignedXidsRemoveTree(TransactionId xid, int nsubxids,",
          "new_line_content": "\t\tKnownAssignedXidsRemove(xid);",
          "content_same": false
        },
        {
          "line": 3712,
          "old_api": null,
          "new_api": "KnownAssignedXidsRemove",
          "old_text": null,
          "new_text": "KnownAssignedXidsRemove(subxids[i])",
          "old_line_content": "\tint\t\t\ti;",
          "new_line_content": "\t\tKnownAssignedXidsRemove(subxids[i]);",
          "content_same": false
        },
        {
          "line": 3734,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(removeXid)",
          "old_line_content": "\tvolatile ProcArrayStruct *pArray = procArray;",
          "new_line_content": "\tif (!TransactionIdIsValid(removeXid))",
          "content_same": false
        },
        {
          "line": 3736,
          "old_api": null,
          "new_api": "trace_recovery",
          "old_text": null,
          "new_text": "trace_recovery(DEBUG4)",
          "old_line_content": "\tint\t\t\thead,",
          "new_line_content": "\t\telog(trace_recovery(DEBUG4), \"removing all KnownAssignedXids\");",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "KnownAssignedXidsGetAndSetXmin",
          "old_text": null,
          "new_text": "KnownAssignedXidsGetAndSetXmin(snapshot->subxip, &xmin,\n\t\t\t\t\t\t\t\t\t\t\t\t  xmax)",
          "old_line_content": "\t\t * Note: It is possible for recovery to end before we finish taking",
          "new_line_content": "\t\tsubcount = KnownAssignedXidsGetAndSetXmin(snapshot->subxip, &xmin,",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": null,
          "new_api": "TransactionIdPrecedesOrEquals",
          "old_text": null,
          "new_text": "TransactionIdPrecedesOrEquals(xmin, procArray->lastOverflowedXid)",
          "old_line_content": "\t\t * those newly added transaction ids would be filtered away, so we",
          "new_line_content": "\t\tif (TransactionIdPrecedesOrEquals(xmin, procArray->lastOverflowedXid))",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(MyPgXact->xmin)",
          "old_line_content": "",
          "new_line_content": "\tif (!TransactionIdIsValid(MyPgXact->xmin))",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\treplication_slot_xmin = procArray->replication_slot_xmin;",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": null,
          "new_api": "TransactionIdFollowsOrEquals",
          "old_text": null,
          "new_text": "TransactionIdFollowsOrEquals(knownXid, removeXid)",
          "old_line_content": "\tfor (i = tail; i < head; i++)",
          "new_line_content": "\t\t\tif (TransactionIdFollowsOrEquals(knownXid, removeXid))",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xmin, globalxmin)",
          "old_line_content": "",
          "new_line_content": "\tif (TransactionIdPrecedes(xmin, globalxmin))",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": null,
          "new_api": "StandbyTransactionIdIsPrepared",
          "old_text": null,
          "new_text": "StandbyTransactionIdIsPrepared(knownXid)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tif (!StandbyTransactionIdIsPrepared(knownXid))",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(RecentGlobalXmin)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (!TransactionIdIsNormal(RecentGlobalXmin))",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(replication_slot_xmin)",
          "old_line_content": "\t/* Update global variables too */",
          "new_line_content": "\tif (TransactionIdIsValid(replication_slot_xmin) &&",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(replication_slot_xmin, RecentGlobalXmin)",
          "old_line_content": "\tRecentGlobalXmin = globalxmin - vacuum_defer_cleanup_age;",
          "new_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_xmin, RecentGlobalXmin))",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(pArray->numKnownAssignedXids >= 0)",
          "old_line_content": "\t\t\t\tcount++;",
          "new_line_content": "\tAssert(pArray->numKnownAssignedXids >= 0);",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(replication_slot_catalog_xmin)",
          "old_line_content": "\tRecentGlobalDataXmin = RecentGlobalXmin;",
          "new_line_content": "\tif (TransactionIdIsNormal(replication_slot_catalog_xmin) &&",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": null,
          "new_api": "NormalTransactionIdPrecedes",
          "old_text": null,
          "new_text": "NormalTransactionIdPrecedes(replication_slot_catalog_xmin, RecentGlobalXmin)",
          "old_line_content": "",
          "new_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_catalog_xmin, RecentGlobalXmin))",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": null,
          "new_api": "GetCurrentCommandId",
          "old_text": null,
          "new_text": "GetCurrentCommandId(false)",
          "old_line_content": "\tsnapshot->xmin = xmin;",
          "new_line_content": "\tsnapshot->curcid = GetCurrentCommandId(false);",
          "content_same": false
        },
        {
          "line": 3791,
          "old_api": null,
          "new_api": "KnownAssignedXidsCompress",
          "old_text": null,
          "new_text": "KnownAssignedXidsCompress(false)",
          "old_line_content": "\telse",
          "new_line_content": "\tKnownAssignedXidsCompress(false);",
          "content_same": false
        },
        {
          "line": 3808,
          "old_api": null,
          "new_api": "KnownAssignedXidsGetAndSetXmin",
          "old_text": null,
          "new_text": "KnownAssignedXidsGetAndSetXmin(xarray, &xtmp, xmax)",
          "old_line_content": " */",
          "new_line_content": "\treturn KnownAssignedXidsGetAndSetXmin(xarray, &xtmp, xmax);",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": null,
          "new_api": "GetXLogInsertRecPtr",
          "old_text": null,
          "new_text": "GetXLogInsertRecPtr()",
          "old_line_content": "\t{",
          "new_line_content": "\t\tsnapshot->lsn = GetXLogInsertRecPtr();",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "GetSnapshotCurrentTimestamp",
          "old_text": null,
          "new_text": "GetSnapshotCurrentTimestamp()",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tsnapshot->whenTaken = GetSnapshotCurrentTimestamp();",
          "content_same": false
        },
        {
          "line": 1771,
          "old_api": null,
          "new_api": "MaintainOldSnapshotTimeMapping",
          "old_text": null,
          "new_text": "MaintainOldSnapshotTimeMapping(snapshot->whenTaken, xmin)",
          "old_line_content": "\t\t * Capture the current time and WAL stream location in case this",
          "new_line_content": "\t\tMaintainOldSnapshotTimeMapping(snapshot->whenTaken, xmin);",
          "content_same": false
        },
        {
          "line": 3835,
          "old_api": null,
          "new_api": "SpinLockAcquire",
          "old_text": null,
          "new_text": "SpinLockAcquire(&procArray->known_assigned_xids_lck)",
          "old_line_content": "\t * cannot enter and then leave the array while we hold ProcArrayLock.  We",
          "new_line_content": "\tSpinLockAcquire(&procArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 3838,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&procArray->known_assigned_xids_lck)",
          "old_line_content": "\t *",
          "new_line_content": "\tSpinLockRelease(&procArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xmin)",
          "old_line_content": "\t\t\t\t\t\t\t VirtualTransactionId *sourcevxid)",
          "new_line_content": "\tAssert(TransactionIdIsNormal(xmin));",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 3852,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(knownXid, *xmin)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tTransactionIdPrecedes(knownXid, *xmin))",
          "content_same": false
        },
        {
          "line": 3859,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xmax)",
          "old_line_content": "\t\t\t\t*xmin = knownXid;",
          "new_line_content": "\t\t\tif (TransactionIdIsValid(xmax) &&",
          "content_same": false
        },
        {
          "line": 3860,
          "old_api": null,
          "new_api": "TransactionIdFollowsOrEquals",
          "old_text": null,
          "new_text": "TransactionIdFollowsOrEquals(knownXid, xmax)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tTransactionIdFollowsOrEquals(knownXid, xmax))",
          "content_same": false
        },
        {
          "line": 1832,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\t\tif (!TransactionIdIsNormal(xid) ||",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "TransactionIdPrecedesOrEquals",
          "old_text": null,
          "new_text": "TransactionIdPrecedesOrEquals(xid, xmin)",
          "old_line_content": "",
          "new_line_content": "\t\t\t!TransactionIdPrecedesOrEquals(xid, xmin))",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": null,
          "new_api": "SpinLockAcquire",
          "old_text": null,
          "new_text": "SpinLockAcquire(&procArray->known_assigned_xids_lck)",
          "old_line_content": "\t\t\t\ttail;",
          "new_line_content": "\tSpinLockAcquire(&procArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 3888,
          "old_api": null,
          "new_api": "SpinLockRelease",
          "old_text": null,
          "new_text": "SpinLockRelease(&procArray->known_assigned_xids_lck)",
          "old_line_content": "\t/*",
          "new_line_content": "\tSpinLockRelease(&procArray->known_assigned_xids_lck);",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(ProcArrayLock)",
          "old_line_content": "\t\tMyPgXact->xmin = TransactionXmin = xmin;",
          "new_line_content": "\tLWLockRelease(ProcArrayLock);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xmin)",
          "old_line_content": "ProcArrayInstallRestoredXmin(TransactionId xmin, PGPROC *proc)",
          "new_line_content": "\tAssert(TransactionIdIsNormal(xmin));",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(proc != NULL)",
          "old_line_content": "{",
          "new_line_content": "\tAssert(proc != NULL);",
          "content_same": false
        },
        {
          "line": 1873,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\tvolatile PGXACT *pgxact;",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 3924,
          "old_api": null,
          "new_api": "initStringInfo",
          "old_text": null,
          "new_text": "initStringInfo(&buf)",
          "old_line_content": "\t\t\t\ti;",
          "new_line_content": "\tinitStringInfo(&buf);",
          "content_same": false
        },
        {
          "line": 3931,
          "old_api": null,
          "new_api": "appendStringInfo",
          "old_text": null,
          "new_text": "appendStringInfo(&buf, \"[%d]=%u \", i, KnownAssignedXids[i])",
          "old_line_content": "",
          "new_line_content": "\t\t\tappendStringInfo(&buf, \"[%d]=%u \", i, KnownAssignedXids[i]);",
          "content_same": false
        },
        {
          "line": 1885,
          "old_api": null,
          "new_api": "TransactionIdIsNormal",
          "old_text": null,
          "new_text": "TransactionIdIsNormal(xid)",
          "old_line_content": "\t * no later than the one we're installing, so that the system-wide xmin",
          "new_line_content": "\t\tTransactionIdIsNormal(xid) &&",
          "content_same": false
        },
        {
          "line": 1886,
          "old_api": null,
          "new_api": "TransactionIdPrecedesOrEquals",
          "old_text": null,
          "new_text": "TransactionIdPrecedesOrEquals(xid, xmin)",
          "old_line_content": "\t * can't go backwards.  Also, make sure it's running in the same database,",
          "new_line_content": "\t\tTransactionIdPrecedesOrEquals(xid, xmin))",
          "content_same": false
        },
        {
          "line": 3935,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(trace_level, \"%d KnownAssignedXids (num=%d tail=%d head=%d) %s\",\n\t\t nxids,\n\t\t pArray->numKnownAssignedXids,\n\t\t pArray->tailKnownAssignedXids,\n\t\t pArray->headKnownAssignedXids,\n\t\t buf.data)",
          "old_line_content": "\t\t{",
          "new_line_content": "\telog(trace_level, \"%d KnownAssignedXids (num=%d tail=%d head=%d) %s\",",
          "content_same": false
        },
        {
          "line": 3942,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(buf.data)",
          "old_line_content": "\t\t nxids,",
          "new_line_content": "\tpfree(buf.data);",
          "content_same": false
        },
        {
          "line": 3955,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "old_line_content": "static void",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": null,
          "new_api": "RecoveryInProgress",
          "old_text": null,
          "new_text": "RecoveryInProgress()",
          "old_line_content": "\tTransactionId *xids;",
          "new_line_content": "\tAssert(!RecoveryInProgress());",
          "content_same": false
        },
        {
          "line": 1955,
          "old_api": null,
          "new_api": "malloc",
          "old_text": null,
          "new_text": "malloc(TOTAL_MAX_CACHED_SUBXIDS * sizeof(TransactionId))",
          "old_line_content": "\tif (CurrentRunningXacts->xids == NULL)",
          "new_line_content": "\t\t\tmalloc(TOTAL_MAX_CACHED_SUBXIDS * sizeof(TransactionId));",
          "content_same": false
        },
        {
          "line": 1957,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 1958,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "old_line_content": "\t\t * First call",
          "new_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "content_same": false
        },
        {
          "line": 1959,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"out of memory\")",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "old_line_content": "\tsuboverflowed = false;",
          "new_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(XidGenLock, LW_SHARED)",
          "old_line_content": "",
          "new_line_content": "\tLWLockAcquire(XidGenLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(xid)",
          "old_line_content": "\t\txid = pgxact->xid;",
          "new_line_content": "\t\tif (!TransactionIdIsValid(xid))",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "TransactionIdPrecedes",
          "old_text": null,
          "new_text": "TransactionIdPrecedes(xid, oldestRunningXid)",
          "old_line_content": "",
          "new_line_content": "\t\tif (TransactionIdPrecedes(xid, oldestRunningXid))",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&xids[count], (void *) proc->subxids.xids,\n\t\t\t\t\t   nxids * sizeof(TransactionId))",
          "old_line_content": "\t\t\t * Save subtransaction XIDs. Other backends can't add or remove",
          "new_line_content": "\t\t\t\tmemcpy(&xids[count], (void *) proc->subxids.xids,",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2075,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(CurrentRunningXacts->nextXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(CurrentRunningXacts->nextXid));",
          "new_line_content": "\treturn CurrentRunningXacts;",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(CurrentRunningXacts->oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(CurrentRunningXacts->oldestRunningXid));",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(CurrentRunningXacts->latestCompletedXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(CurrentRunningXacts->latestCompletedXid));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\tAssert(!RecoveryInProgress());",
          "new_line_content": "\t * sure that all XIDs < nextXid are already present in the proc array (or",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(XidGenLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(XidGenLock, LW_SHARED);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(XidGenLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(XidGenLock);",
          "new_line_content": "\tfor (index = 0; index < arrayP->numProcs; index++)",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\tif (!TransactionIdIsNormal(xid))",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdPrecedes(xid, oldestRunningXid))",
          "new_line_content": "\t\t * smaller than oldestRunningXid",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * GetOldestSafeDecodingTransactionId -- lowest xid not affected by vacuum",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\tbool\t\trecovery_in_progress = RecoveryInProgress();",
          "new_line_content": "\t * running. If no transaction with xid were running concurrently a new xid",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "LWLockHeldByMe",
          "new_api": null,
          "old_text": "LWLockHeldByMe(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tAssert(LWLockHeldByMe(ProcArrayLock));",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(XidGenLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(XidGenLock, LW_SHARED);",
          "new_line_content": "\t * routine initially and has been enforced since.  We can always use the",
          "content_same": false
        },
        {
          "line": 2199,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(procArray->replication_slot_catalog_xmin)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdIsValid(procArray->replication_slot_catalog_xmin) &&",
          "new_line_content": "\t * If we're not in recovery, we walk over the procarray and collect the",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(procArray->replication_slot_catalog_xmin,\n\t\t\t\t\t\t\t  oldestSafeXid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdPrecedes(procArray->replication_slot_catalog_xmin,",
          "new_line_content": "\t * lowest xid. Since we're called with ProcArrayLock held and have",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!TransactionIdIsNormal(xid))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, oldestSafeXid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdPrecedes(xid, oldestSafeXid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(XidGenLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(XidGenLock);",
          "new_line_content": " * GetVirtualXIDsDelayingChkpt -- Get the VXIDs of transactions that are",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(VirtualTransactionId) * arrayP->maxProcs)",
          "new_text": null,
          "old_line_content": "\t\tpalloc(sizeof(VirtualTransactionId) * arrayP->maxProcs);",
          "new_line_content": "\t\tint\t\t\tpgprocno = arrayP->pgprocnos[index];",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "VirtualTransactionIdIsValid",
          "new_api": null,
          "old_text": "VirtualTransactionIdIsValid(vxid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (VirtualTransactionIdIsValid(vxid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "GET_VXID_FROM_PGPROC",
          "new_api": null,
          "old_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "new_text": null,
          "old_line_content": "\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "new_line_content": "\t\t\tfor (i = 0; i < nvxids; i++)",
          "content_same": false
        },
        {
          "line": 2330,
          "old_api": "VirtualTransactionIdEquals",
          "new_api": null,
          "old_text": "VirtualTransactionIdEquals(vxid, vxids[i])",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (VirtualTransactionIdEquals(vxid, vxids[i]))",
          "new_line_content": "\t\t\tif (result)",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * BackendPidGetProc -- get a backend's PGPROC given its PID",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\treturn result;",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": "BackendPidGetProcWithLock",
          "new_api": null,
          "old_text": "BackendPidGetProcWithLock(pid)",
          "new_text": null,
          "old_line_content": "\tresult = BackendPidGetProcWithLock(pid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * BackendPidGetProcWithLock -- get a backend's PGPROC given its PID",
          "content_same": false
        },
        {
          "line": 2423,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 2438,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * IsBackendPid -- is a given pid a running backend",
          "content_same": false
        },
        {
          "line": 2451,
          "old_api": "BackendPidGetProc",
          "new_api": null,
          "old_text": "BackendPidGetProc(pid)",
          "new_text": null,
          "old_line_content": "\treturn (BackendPidGetProc(pid) != NULL);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(VirtualTransactionId) * arrayP->maxProcs)",
          "new_text": null,
          "old_line_content": "\t\tpalloc(sizeof(VirtualTransactionId) * arrayP->maxProcs);",
          "new_line_content": "\t\tint\t\t\tpgprocno = arrayP->pgprocnos[index];",
          "content_same": false
        },
        {
          "line": 2495,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 2514,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(pxmin)",
          "new_text": null,
          "old_line_content": "\t\t\tif (excludeXmin0 && !TransactionIdIsValid(pxmin))",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": "TransactionIdPrecedesOrEquals",
          "new_api": null,
          "old_text": "TransactionIdPrecedesOrEquals(pxmin, limitXmin)",
          "new_text": null,
          "old_line_content": "\t\t\t\tTransactionIdPrecedesOrEquals(pxmin, limitXmin))",
          "new_line_content": "\t\t\t\t\tvxids[count++] = vxid;",
          "content_same": false
        },
        {
          "line": 2526,
          "old_api": "GET_VXID_FROM_PGPROC",
          "new_api": null,
          "old_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "new_text": null,
          "old_line_content": "\t\t\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2533,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": "malloc",
          "new_api": null,
          "old_text": "malloc(sizeof(VirtualTransactionId) * (arrayP->maxProcs + 1))",
          "new_text": null,
          "old_line_content": "\t\t\tmalloc(sizeof(VirtualTransactionId) * (arrayP->maxProcs + 1));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\tfor (index = 0; index < arrayP->numProcs; index++)",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"out of memory\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2592,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 547,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&procglobal->procArrayGroupFirst)",
          "new_text": null,
          "old_line_content": "\t\tnextidx = pg_atomic_read_u32(&procglobal->procArrayGroupFirst);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 548,
          "old_api": "pg_atomic_compare_exchange_u32",
          "new_api": null,
          "old_text": "pg_atomic_compare_exchange_u32(&procglobal->procArrayGroupFirst,\n\t\t\t\t\t\t\t\t\t\t   &nextidx,\n\t\t\t\t\t\t\t\t\t\t   INVALID_PGPROCNO)",
          "new_text": null,
          "old_line_content": "\t\tif (pg_atomic_compare_exchange_u32(&procglobal->procArrayGroupFirst,",
          "new_line_content": "\t/* Remember head of list so we can perform wakeups after dropping lock. */",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(dbOid)",
          "new_text": null,
          "old_line_content": "\t\tif (!OidIsValid(dbOid) ||",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "ProcArrayEndTransactionInternal",
          "new_api": null,
          "old_text": "ProcArrayEndTransactionInternal(proc, pgxact, proc->procArrayGroupMemberXid)",
          "new_text": null,
          "old_line_content": "\t\tProcArrayEndTransactionInternal(proc, pgxact, proc->procArrayGroupMemberXid);",
          "new_line_content": "\t/* We're done with the lock now. */",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&proc->procArrayGroupNext)",
          "new_text": null,
          "old_line_content": "\t\tnextidx = pg_atomic_read_u32(&proc->procArrayGroupNext);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 570,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t * up are probably much slower than the simple memory writes we did while",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": "TransactionIdFollows",
          "new_api": null,
          "old_text": "TransactionIdFollows(pxmin, limitXmin)",
          "new_text": null,
          "old_line_content": "\t\t\t\t(TransactionIdIsValid(pxmin) && !TransactionIdFollows(pxmin, limitXmin)))",
          "new_line_content": "\t\t\t\t\tvxids[count++] = vxid;",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": "GET_VXID_FROM_PGPROC",
          "new_api": null,
          "old_text": "GET_VXID_FROM_PGPROC(vxid, *proc)",
          "new_text": null,
          "old_line_content": "\t\t\t\tGET_VXID_FROM_PGPROC(vxid, *proc);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\treturn vxids;",
          "content_same": false
        },
        {
          "line": 583,
          "old_api": "pg_atomic_read_u32",
          "new_api": null,
          "old_text": "pg_atomic_read_u32(&proc->procArrayGroupNext)",
          "new_text": null,
          "old_line_content": "\t\twakeidx = pg_atomic_read_u32(&proc->procArrayGroupNext);",
          "new_line_content": "\t\tproc->procArrayGroupMember = false;",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "pg_atomic_write_u32",
          "new_api": null,
          "old_text": "pg_atomic_write_u32(&proc->procArrayGroupNext, INVALID_PGPROCNO)",
          "new_text": null,
          "old_line_content": "\t\tpg_atomic_write_u32(&proc->procArrayGroupNext, INVALID_PGPROCNO);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": "pg_write_barrier",
          "new_api": null,
          "old_text": "pg_write_barrier()",
          "new_text": null,
          "old_line_content": "\t\tpg_write_barrier();",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "PGSemaphoreUnlock",
          "new_api": null,
          "old_text": "PGSemaphoreUnlock(proc->sem)",
          "new_text": null,
          "old_line_content": "\t\t\tPGSemaphoreUnlock(proc->sem);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tVirtualTransactionId procvxid;",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": "GET_VXID_FROM_PGPROC",
          "new_api": null,
          "old_text": "GET_VXID_FROM_PGPROC(procvxid, *proc)",
          "new_text": null,
          "old_line_content": "\t\tGET_VXID_FROM_PGPROC(procvxid, *proc);",
          "new_line_content": "\t\t\tpid = proc->pid;",
          "content_same": false
        },
        {
          "line": 2678,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * MinimumActiveBackends --- count backends (other than myself) that are",
          "content_same": false
        },
        {
          "line": 639,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(standbyState == STANDBY_INITIALIZED)",
          "new_text": null,
          "old_line_content": "\tAssert(standbyState == STANDBY_INITIALIZED);",
          "new_line_content": "\t * RecordKnownAssignedTransactionIds, and when we get consistent in",
          "content_same": false
        },
        {
          "line": 640,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(initializedUptoXID)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(initializedUptoXID));",
          "new_line_content": "\t * ProcArrayApplyRecoveryInfo().",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": "TransactionIdRetreat",
          "new_api": null,
          "old_text": "TransactionIdRetreat(latestObservedXid)",
          "new_text": null,
          "old_line_content": "\tTransactionIdRetreat(latestObservedXid);",
          "new_line_content": " * Takes us through 3 states: Initialized, Pending and Ready.",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "new_text": null,
          "old_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "new_line_content": "\t * Remove stale transactions, if any.",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(running->nextXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(running->nextXid));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(running->latestCompletedXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(running->latestCompletedXid));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "ExpireOldKnownAssignedTransactionIds",
          "new_api": null,
          "old_text": "ExpireOldKnownAssignedTransactionIds(running->oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\tExpireOldKnownAssignedTransactionIds(running->oldestRunningXid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "StandbyReleaseOldLocks",
          "new_api": null,
          "old_text": "StandbyReleaseOldLocks(running->oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\tStandbyReleaseOldLocks(running->oldestRunningXid);",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(databaseid)",
          "new_text": null,
          "old_line_content": "\t\tif (!OidIsValid(databaseid) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 719,
          "old_api": "KnownAssignedXidsReset",
          "new_api": null,
          "old_text": "KnownAssignedXidsReset()",
          "new_text": null,
          "old_line_content": "\t\t\tKnownAssignedXidsReset();",
          "new_line_content": "\t\t\t\t\t\t\t\t\t  running->oldestRunningXid))",
          "content_same": false
        },
        {
          "line": 2767,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * CountDBConnections --- counts database backends ignoring any background",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(standbySnapshotPendingXmin,\n\t\t\t\t\t\t\t\t\t  running->oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdPrecedes(standbySnapshotPendingXmin,",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG1)",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(trace_recovery(DEBUG1),",
          "new_line_content": "\t\t\t\t\t \"until oldest active xid on standby is at least %u (now %u)\",",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG1)",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(trace_recovery(DEBUG1),",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 2783,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 741,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(standbyState == STANDBY_INITIALIZED)",
          "new_text": null,
          "old_line_content": "\tAssert(standbyState == STANDBY_INITIALIZED);",
          "new_line_content": "\t * with that.",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(databaseid)",
          "new_text": null,
          "old_line_content": "\t\tif (!OidIsValid(databaseid) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2799,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * CancelDBBackends --- cancel backends that are using specified database",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "\t * Some of the new xids are top-level xids and some are subtransactions.",
          "content_same": false
        },
        {
          "line": 2815,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(TransactionId) * (running->xcnt + running->subxcnt))",
          "new_text": null,
          "old_line_content": "\txids = palloc(sizeof(TransactionId) * (running->xcnt + running->subxcnt));",
          "new_line_content": "\tfor (i = 0; i < running->xcnt + running->subxcnt; i++)",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": "GET_VXID_FROM_PGPROC",
          "new_api": null,
          "old_text": "GET_VXID_FROM_PGPROC(procvxid, *proc)",
          "new_text": null,
          "old_line_content": "\t\t\tGET_VXID_FROM_PGPROC(procvxid, *proc);",
          "new_line_content": "\t\t\t\t/*",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "TransactionIdDidAbort",
          "new_api": null,
          "old_text": "TransactionIdDidAbort(xid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdDidCommit(xid) || TransactionIdDidAbort(xid))",
          "new_line_content": "\tif (nxids > 0)",
          "content_same": false
        },
        {
          "line": 2836,
          "old_api": "SendProcSignal",
          "new_api": null,
          "old_text": "SendProcSignal(pid, sigmode, procvxid.backendId)",
          "new_text": null,
          "old_line_content": "\t\t\t\t(void) SendProcSignal(pid, sigmode, procvxid.backendId);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2841,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "int",
          "content_same": false
        },
        {
          "line": 797,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t * KnownAssignedXids.",
          "content_same": false
        },
        {
          "line": 798,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"KnownAssignedXids is not empty\")",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"KnownAssignedXids is not empty\");",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": "KnownAssignedXidsAdd",
          "new_api": null,
          "old_text": "KnownAssignedXidsAdd(xids[i], xids[i], true)",
          "new_text": null,
          "old_line_content": "\t\t\tKnownAssignedXidsAdd(xids[i], xids[i], true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG3)",
          "new_text": null,
          "old_line_content": "\t\tKnownAssignedXidsDisplay(trace_recovery(DEBUG3));",
          "new_line_content": "\t * latestObservedXid is at least set to the point where SUBTRANS was",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(xids)",
          "new_text": null,
          "old_line_content": "\tpfree(xids);",
          "new_line_content": "\t * subtrans from thereon, up to nextXid - 1.",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * CountOtherDBBackends -- check for other backends running in the given DB",
          "content_same": false
        },
        {
          "line": 828,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(latestObservedXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(latestObservedXid));",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(latestObservedXid, running->nextXid)",
          "new_text": null,
          "old_line_content": "\twhile (TransactionIdPrecedes(latestObservedXid, running->nextXid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "ExtendSUBTRANS",
          "new_api": null,
          "old_text": "ExtendSUBTRANS(latestObservedXid)",
          "new_text": null,
          "old_line_content": "\t\tExtendSUBTRANS(latestObservedXid);",
          "new_line_content": "\t * Now we've got the running xids we need to set the global values that",
          "content_same": false
        },
        {
          "line": 833,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(latestObservedXid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdAdvance(latestObservedXid);",
          "new_line_content": "\t * are used to track snapshots as they evolve further.",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "TransactionIdRetreat",
          "new_api": null,
          "old_text": "TransactionIdRetreat(latestObservedXid)",
          "new_text": null,
          "old_line_content": "\tTransactionIdRetreat(latestObservedXid);\t/* = running->nextXid - 1 */",
          "new_line_content": "\t * - latestCompletedXid which will be the xmax for snapshots",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": "CHECK_FOR_INTERRUPTS",
          "new_api": null,
          "old_text": "CHECK_FOR_INTERRUPTS()",
          "new_text": null,
          "old_line_content": "\t\tCHECK_FOR_INTERRUPTS();",
          "new_line_content": "\t\tfor (index = 0; index < arrayP->numProcs; index++)",
          "content_same": false
        },
        {
          "line": 2917,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\t\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(ShmemVariableCache->latestCompletedXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(ShmemVariableCache->latestCompletedXid));",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t * hold a lock while examining it.  We still acquire the lock to modify",
          "content_same": false
        },
        {
          "line": 886,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(nextXid)",
          "new_text": null,
          "old_line_content": "\tTransactionIdAdvance(nextXid);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "TransactionIdFollows",
          "new_api": null,
          "old_text": "TransactionIdFollows(nextXid, ShmemVariableCache->nextXid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdFollows(nextXid, ShmemVariableCache->nextXid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(XidGenLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\t\tLWLockAcquire(XidGenLock, LW_EXCLUSIVE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(XidGenLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(XidGenLock);",
          "new_line_content": "\tif (standbyState == STANDBY_SNAPSHOT_READY)",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t * Send SIGTERM to any conflicting autovacuums before sleeping. We",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG3)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsDisplay(trace_recovery(DEBUG3));",
          "new_line_content": "\t\t\t \"until oldest active xid on standby is at least %u (now %u)\",",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG1)",
          "new_text": null,
          "old_line_content": "\t\telog(trace_recovery(DEBUG1), \"recovery snapshots are now enabled\");",
          "new_line_content": "\t\t\t running->oldestRunningXid);",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG1)",
          "new_text": null,
          "old_line_content": "\t\telog(trace_recovery(DEBUG1),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": "kill",
          "new_api": null,
          "old_text": "kill(autovac_pids[index], SIGTERM)",
          "new_text": null,
          "old_line_content": "\t\t\t(void) kill(autovac_pids[index], SIGTERM);\t/* ignore any error */",
          "new_line_content": "\treturn true;\t\t\t\t/* timed out, still conflicts */",
          "content_same": false
        },
        {
          "line": 2958,
          "old_api": "pg_usleep",
          "new_api": null,
          "old_text": "pg_usleep(100 * 1000L)",
          "new_text": null,
          "old_line_content": "\t\tpg_usleep(100 * 1000L); /* 100ms */",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "new_text": null,
          "old_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": "TransactionIdLatest",
          "new_api": null,
          "old_text": "TransactionIdLatest(topxid, nsubxids, subxids)",
          "new_text": null,
          "old_line_content": "\tmax_xid = TransactionIdLatest(topxid, nsubxids, subxids);",
          "new_line_content": "\t * unobserved xids to fit into known-assigned-xids. That shouldn't happen",
          "content_same": false
        },
        {
          "line": 2975,
          "old_api": "LWLockHeldByMe",
          "new_api": null,
          "old_text": "LWLockHeldByMe(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tAssert(!already_locked || LWLockHeldByMe(ProcArrayLock));",
          "new_line_content": "\tprocArray->replication_slot_catalog_xmin = catalog_xmin;",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": "RecordKnownAssignedTransactionIds",
          "new_api": null,
          "old_text": "RecordKnownAssignedTransactionIds(max_xid)",
          "new_text": null,
          "old_line_content": "\tRecordKnownAssignedTransactionIds(max_xid);",
          "new_line_content": "\t * subtransaction commit is not marked in clog until commit processing, so",
          "content_same": false
        },
        {
          "line": 2984,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * Return the current slot xmin limits. That's useful to be able to remove",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "SubTransSetParent",
          "new_api": null,
          "old_text": "SubTransSetParent(subxids[i], topxid)",
          "new_text": null,
          "old_line_content": "\t\tSubTransSetParent(subxids[i], topxid);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\t*catalog_xmin = procArray->replication_slot_catalog_xmin;",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3005,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\tMyProc->subxids.xids[i] = MyProc->subxids.xids[MyPgXact->nxids - 1]; \\",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "KnownAssignedXidsRemoveTree",
          "new_api": null,
          "old_text": "KnownAssignedXidsRemoveTree(InvalidTransactionId, nsubxids, subxids)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsRemoveTree(InvalidTransactionId, nsubxids, subxids);",
          "new_line_content": "\t\tprocArray->lastOverflowedXid = max_xid;",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(procArray->lastOverflowedXid, max_xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(procArray->lastOverflowedXid, max_xid))",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * Aside from some shortcuts such as checking RecentXmin and our own Xid,",
          "content_same": false
        },
        {
          "line": 3031,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "new_line_content": "\t * to abort subtransactions, but pending closer analysis we'd best be",
          "content_same": false
        },
        {
          "line": 3040,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3053,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(MyProc->subxids.xids[j], anxid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdEquals(MyProc->subxids.xids[j], anxid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3055,
          "old_api": "XidCacheRemove",
          "new_api": null,
          "old_text": "XidCacheRemove(j)",
          "new_text": null,
          "old_line_content": "\t\t\t\tXidCacheRemove(j);",
          "new_line_content": "\t\t * Ordinarily we should have found it, unless the cache has",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, RecentXmin)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(xid, RecentXmin))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1013,
          "old_api": "xc_by_recent_xmin_inc",
          "new_api": null,
          "old_text": "xc_by_recent_xmin_inc()",
          "new_text": null,
          "old_line_content": "\t\txc_by_recent_xmin_inc();",
          "new_line_content": "\t * already known to be completed, we can fall out without any access to",
          "content_same": false
        },
        {
          "line": 3068,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(WARNING, \"did not find subXID %u in MyProc\", anxid)",
          "new_text": null,
          "old_line_content": "\t\t\telog(WARNING, \"did not find subXID %u in MyProc\", anxid);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1022,
          "old_api": "TransactionIdIsKnownCompleted",
          "new_api": null,
          "old_text": "TransactionIdIsKnownCompleted(xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdIsKnownCompleted(xid))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "xc_by_known_xact_inc",
          "new_api": null,
          "old_text": "xc_by_known_xact_inc()",
          "new_text": null,
          "old_line_content": "\t\txc_by_known_xact_inc();",
          "new_line_content": "\t * any access to shared memory.",
          "content_same": false
        },
        {
          "line": 3073,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(MyProc->subxids.xids[j], xid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdEquals(MyProc->subxids.xids[j], xid))",
          "new_line_content": "\t/* Ordinarily we should have found it, unless the cache has overflowed */",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "TransactionIdIsCurrentTransactionId",
          "new_api": null,
          "old_text": "TransactionIdIsCurrentTransactionId(xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdIsCurrentTransactionId(xid))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(WARNING, \"did not find subXID %u in MyProc\", xid)",
          "new_text": null,
          "old_line_content": "\t\telog(WARNING, \"did not find subXID %u in MyProc\", xid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "xc_by_my_xact_inc",
          "new_api": null,
          "old_text": "xc_by_my_xact_inc()",
          "new_text": null,
          "old_line_content": "\t\txc_by_my_xact_inc();",
          "new_line_content": "\t * malloc it permanently to avoid repeated palloc/pfree overhead.",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,\n\t\t\t\t\t\t\t  latestXid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3088,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * Print stats about effectiveness of XID cache",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "malloc",
          "new_api": null,
          "old_text": "malloc(maxxids * sizeof(TransactionId))",
          "new_text": null,
          "old_line_content": "\t\txids = (TransactionId *) malloc(maxxids * sizeof(TransactionId));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3099,
          "old_api": "fprintf",
          "new_api": null,
          "old_text": "fprintf(stderr,\n\t\t\t\"XidCache: xmin: %ld, known: %ld, myxact: %ld, latest: %ld, mainxid: %ld, childxid: %ld, knownassigned: %ld, nooflo: %ld, slow: %ld\\n\",\n\t\t\txc_by_recent_xmin,\n\t\t\txc_by_known_xact,\n\t\t\txc_by_my_xact,\n\t\t\txc_by_latest_xid,\n\t\t\txc_by_main_xid,\n\t\t\txc_by_child_xid,\n\t\t\txc_by_known_assigned,\n\t\t\txc_no_overflow,\n\t\t\txc_slow_answer)",
          "new_text": null,
          "old_line_content": "\tfprintf(stderr,",
          "new_line_content": "\t\t\txc_by_main_xid,",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"out of memory\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "new_line_content": "\t * Now that we have the lock, we can check latestCompletedXid; if the",
          "content_same": false
        },
        {
          "line": 1064,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid, xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid, xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1066,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\tfor (i = 0; i < arrayP->numProcs; i++)",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": "xc_by_latest_xid_inc",
          "new_api": null,
          "old_text": "xc_by_latest_xid_inc()",
          "new_text": null,
          "old_line_content": "\t\txc_by_latest_xid_inc();",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(pxid, xid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdEquals(pxid, xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1094,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t * We can ignore main Xids that are younger than the target Xid, since",
          "content_same": false
        },
        {
          "line": 1095,
          "old_api": "xc_by_main_xid_inc",
          "new_api": null,
          "old_text": "xc_by_main_xid_inc()",
          "new_text": null,
          "old_line_content": "\t\t\txc_by_main_xid_inc();",
          "new_line_content": "\t\t * the target could not possibly be their child.",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, pxid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdPrecedes(xid, pxid))",
          "new_line_content": "\t\tfor (j = pgxact->nxids - 1; j >= 0; j--)",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(cxid, xid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdEquals(cxid, xid))",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\t\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": "xc_by_child_xid_inc",
          "new_api": null,
          "old_text": "xc_by_child_xid_inc()",
          "new_text": null,
          "old_line_content": "\t\t\t\txc_by_child_xid_inc();",
          "new_line_content": "\t\t * Save the main Xid for step 4.  We only need to remember main Xids",
          "content_same": false
        },
        {
          "line": 3183,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "new_text": null,
          "old_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1137,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\tif (RecoveryInProgress())",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3185,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(latestObservedXid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(latestObservedXid));",
          "new_line_content": "\t * When a newly observed xid arrives, it is frequently the case that it is",
          "content_same": false
        },
        {
          "line": 3187,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG4)",
          "new_text": null,
          "old_line_content": "\telog(trace_recovery(DEBUG4), \"record known xact %u latestObservedXid %u\",",
          "new_line_content": "\t * intervening xids as running also.",
          "content_same": false
        },
        {
          "line": 1140,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(nxids == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(nxids == 0);",
          "new_line_content": "\t\t\treturn true;",
          "content_same": false
        },
        {
          "line": 1142,
          "old_api": "KnownAssignedXidExists",
          "new_api": null,
          "old_text": "KnownAssignedXidExists(xid)",
          "new_text": null,
          "old_line_content": "\t\tif (KnownAssignedXidExists(xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1144,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t * If the KnownAssignedXids overflowed, we have to check pg_subtrans",
          "content_same": false
        },
        {
          "line": 1145,
          "old_api": "xc_by_known_assigned_inc",
          "new_api": null,
          "old_text": "xc_by_known_assigned_inc()",
          "new_text": null,
          "old_line_content": "\t\t\txc_by_known_assigned_inc();",
          "new_line_content": "\t\t * too.  Fetch all xids from KnownAssignedXids that are lower than",
          "content_same": false
        },
        {
          "line": 3195,
          "old_api": "TransactionIdFollows",
          "new_api": null,
          "old_text": "TransactionIdFollows(xid, latestObservedXid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdFollows(xid, latestObservedXid))",
          "new_line_content": "\t\t * operation using individual extend steps. Note that we do not need",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "TransactionIdPrecedesOrEquals",
          "new_api": null,
          "old_text": "TransactionIdPrecedesOrEquals(xid, procArray->lastOverflowedXid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdPrecedesOrEquals(xid, procArray->lastOverflowedXid))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1157,
          "old_api": "KnownAssignedXidsGet",
          "new_api": null,
          "old_text": "KnownAssignedXidsGet(xids, xid)",
          "new_text": null,
          "old_line_content": "\t\t\tnxids = KnownAssignedXidsGet(xids, xid);",
          "new_line_content": "\t * If none of the relevant caches overflowed, we know the Xid is not",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\tif (nxids == 0)",
          "content_same": false
        },
        {
          "line": 3209,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(next_expected_xid, xid)",
          "new_text": null,
          "old_line_content": "\t\twhile (TransactionIdPrecedes(next_expected_xid, xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3211,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(next_expected_xid)",
          "new_text": null,
          "old_line_content": "\t\t\tTransactionIdAdvance(next_expected_xid);",
          "new_line_content": "\t\t * If the KnownAssignedXids machinery isn't up yet, there's nothing",
          "content_same": false
        },
        {
          "line": 3212,
          "old_api": "ExtendSUBTRANS",
          "new_api": null,
          "old_text": "ExtendSUBTRANS(next_expected_xid)",
          "new_text": null,
          "old_line_content": "\t\t\tExtendSUBTRANS(next_expected_xid);",
          "new_line_content": "\t\t * more to do since we don't track assigned xids yet.",
          "content_same": false
        },
        {
          "line": 3214,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(next_expected_xid == xid)",
          "new_text": null,
          "old_line_content": "\t\tAssert(next_expected_xid == xid);",
          "new_line_content": "\t\tif (standbyState <= STANDBY_INITIALIZED)",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "xc_no_overflow_inc",
          "new_api": null,
          "old_text": "xc_no_overflow_inc()",
          "new_text": null,
          "old_line_content": "\t\txc_no_overflow_inc();",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "xc_slow_answer_inc",
          "new_api": null,
          "old_text": "xc_slow_answer_inc()",
          "new_text": null,
          "old_line_content": "\txc_slow_answer_inc();",
          "new_line_content": "\t * It isn't aborted, so check whether the transaction tree it belongs to",
          "content_same": false
        },
        {
          "line": 1182,
          "old_api": "TransactionIdDidAbort",
          "new_api": null,
          "old_text": "TransactionIdDidAbort(xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdDidAbort(xid))",
          "new_line_content": "\t * held ProcArrayLock).",
          "content_same": false
        },
        {
          "line": 3230,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(next_expected_xid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdAdvance(next_expected_xid);",
          "new_line_content": "\t\tlatestObservedXid = xid;",
          "content_same": false
        },
        {
          "line": 3231,
          "old_api": "KnownAssignedXidsAdd",
          "new_api": null,
          "old_text": "KnownAssignedXidsAdd(next_expected_xid, xid, false)",
          "new_text": null,
          "old_line_content": "\t\tKnownAssignedXidsAdd(next_expected_xid, xid, false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1191,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(topxid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(topxid));",
          "new_line_content": "\t\t\t\treturn true;",
          "content_same": false
        },
        {
          "line": 1192,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(topxid, xid)",
          "new_text": null,
          "old_line_content": "\tif (!TransactionIdEquals(topxid, xid))",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 3240,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(next_expected_xid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdAdvance(next_expected_xid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(XidGenLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\t\tLWLockAcquire(XidGenLock, LW_EXCLUSIVE);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(XidGenLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(XidGenLock);",
          "new_line_content": " *\t\tRemove the given XIDs from KnownAssignedXids.",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(xids[i], topxid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdEquals(xids[i], topxid))",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 3257,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(standbyState >= STANDBY_INITIALIZED)",
          "new_text": null,
          "old_line_content": "\tAssert(standbyState >= STANDBY_INITIALIZED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3262,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "\t\t\t\t\t\t\t  max_xid))",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": "KnownAssignedXidsRemoveTree",
          "new_api": null,
          "old_text": "KnownAssignedXidsRemoveTree(xid, nsubxids, subxids)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsRemoveTree(xid, nsubxids, subxids);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3267,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,\n\t\t\t\t\t\t\t  max_xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(ShmemVariableCache->latestCompletedXid,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, RecentXmin)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(xid, RecentXmin))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": " * ExpireOldKnownAssignedTransactionIds",
          "content_same": false
        },
        {
          "line": 3282,
          "old_api": "KnownAssignedXidsRemovePreceding",
          "new_api": null,
          "old_text": "KnownAssignedXidsRemovePreceding(InvalidTransactionId)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsRemovePreceding(InvalidTransactionId);",
          "new_line_content": " *\t\tRemove KnownAssignedXids entries preceding the given XID",
          "content_same": false
        },
        {
          "line": 3283,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1244,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(pxid, xid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdEquals(pxid, xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3294,
          "old_api": "KnownAssignedXidsRemovePreceding",
          "new_api": null,
          "old_text": "KnownAssignedXidsRemovePreceding(xid)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsRemovePreceding(xid);",
          "new_line_content": " * Private module functions to manipulate KnownAssignedXids",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 1251,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\tAssert(allDbs || !RecoveryInProgress());",
          "new_line_content": "\t * is a lower bound for the XIDs that might appear in the ProcArray later,",
          "content_same": false
        },
        {
          "line": 1332,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t * additions.",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(result)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(result));",
          "new_line_content": "\t\tvolatile PGPROC *proc = &allProcs[pgprocno];",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(result)",
          "new_text": null,
          "old_line_content": "\tTransactionIdAdvance(result);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 1361,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdIsNormal(xid) &&",
          "new_line_content": "\t\t\t *",
          "content_same": false
        },
        {
          "line": 1362,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, result)",
          "new_text": null,
          "old_line_content": "\t\t\t\tTransactionIdPrecedes(xid, result))",
          "new_line_content": "\t\t\t * We must check both Xid and Xmin because a transaction might",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdIsNormal(xid) &&",
          "new_line_content": "\t/* fetch into volatile var while ProcArrayLock is held */",
          "content_same": false
        },
        {
          "line": 1374,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, result)",
          "new_text": null,
          "old_line_content": "\t\t\t\tTransactionIdPrecedes(xid, result))",
          "new_line_content": "\treplication_slot_xmin = procArray->replication_slot_xmin;",
          "content_same": false
        },
        {
          "line": 1389,
          "old_api": "KnownAssignedXidsGetOldestXmin",
          "new_api": null,
          "old_text": "KnownAssignedXidsGetOldestXmin()",
          "new_text": null,
          "old_line_content": "\t\tTransactionId kaxmin = KnownAssignedXidsGetOldestXmin();",
          "new_line_content": "\t\t\tresult = kaxmin;",
          "content_same": false
        },
        {
          "line": 1391,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(kaxmin)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdIsNormal(kaxmin) &&",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(kaxmin, result)",
          "new_text": null,
          "old_line_content": "\t\t\tTransactionIdPrecedes(kaxmin, result))",
          "new_line_content": "\t\t * No other information needed, so release the lock immediately.",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t\t * vacuum_defer_cleanup_age provides some additional \"slop\" for the",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(result)",
          "new_text": null,
          "old_line_content": "\t\tif (!TransactionIdIsNormal(result))",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "TransactionIdPrecedesOrEquals",
          "new_api": null,
          "old_text": "TransactionIdPrecedesOrEquals(from_xid, to_xid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdPrecedesOrEquals(from_xid, to_xid));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 1427,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(replication_slot_xmin)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdIsValid(replication_slot_xmin) &&",
          "new_line_content": "\t * check whether we need to back up further to make logical decoding",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(replication_slot_xmin, result)",
          "new_text": null,
          "old_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_xmin, result))",
          "new_line_content": "\t * possible. We need to do so if we're computing the global limit (rel =",
          "content_same": false
        },
        {
          "line": 3481,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(next_xid, to_xid)",
          "new_text": null,
          "old_line_content": "\t\twhile (TransactionIdPrecedes(next_xid, to_xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3484,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(next_xid)",
          "new_text": null,
          "old_line_content": "\t\t\tTransactionIdAdvance(next_xid);",
          "new_line_content": "\t * don't need a lock to read them here.",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": "RelationIsAccessibleInLogicalDecoding",
          "new_api": null,
          "old_text": "RelationIsAccessibleInLogicalDecoding(rel)",
          "new_text": null,
          "old_line_content": "\t\t RelationIsAccessibleInLogicalDecoding(rel)) &&",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(replication_slot_catalog_xmin)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdIsValid(replication_slot_catalog_xmin) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(replication_slot_catalog_xmin, result)",
          "new_text": null,
          "old_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_catalog_xmin, result))",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3495,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(head >= 0 && head <= pArray->maxKnownAssignedXids)",
          "new_text": null,
          "old_line_content": "\tAssert(head >= 0 && head <= pArray->maxKnownAssignedXids);",
          "new_line_content": "\t * correctly sequenced XID value.",
          "content_same": false
        },
        {
          "line": 3496,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(tail >= 0 && tail < pArray->maxKnownAssignedXids)",
          "new_text": null,
          "old_line_content": "\tAssert(tail >= 0 && tail < pArray->maxKnownAssignedXids);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3504,
          "old_api": "TransactionIdFollowsOrEquals",
          "new_api": null,
          "old_text": "TransactionIdFollowsOrEquals(KnownAssignedXids[head - 1], from_xid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdFollowsOrEquals(KnownAssignedXids[head - 1], from_xid))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 3506,
          "old_api": "KnownAssignedXidsDisplay",
          "new_api": null,
          "old_text": "KnownAssignedXidsDisplay(LOG)",
          "new_text": null,
          "old_line_content": "\t\tKnownAssignedXidsDisplay(LOG);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3507,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"out-of-order XID insertion in KnownAssignedXids\")",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"out-of-order XID insertion in KnownAssignedXids\");",
          "new_line_content": "\tif (head + nxids > pArray->maxKnownAssignedXids)",
          "content_same": false
        },
        {
          "line": 3517,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockAcquire(ProcArrayLock, LW_EXCLUSIVE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"too many KnownAssignedXids\")",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"too many KnownAssignedXids\");",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(next_xid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdAdvance(next_xid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3560,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&pArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockAcquire(&pArray->known_assigned_xids_lck);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&pArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockRelease(&pArray->known_assigned_xids_lck);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(snapshot != NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(snapshot != NULL);",
          "new_line_content": "\t * more subxip storage than is probably needed.",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "GetMaxSnapshotXidCount",
          "new_api": null,
          "old_text": "GetMaxSnapshotXidCount()",
          "new_text": null,
          "old_line_content": "\t\t\tmalloc(GetMaxSnapshotXidCount() * sizeof(TransactionId));",
          "new_line_content": "\t\tsnapshot->subxip = (TransactionId *)",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\tif (snapshot->subxip == NULL)",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": "GetMaxSnapshotSubxidCount",
          "new_api": null,
          "old_text": "GetMaxSnapshotSubxidCount()",
          "new_text": null,
          "old_line_content": "\t\t\tmalloc(GetMaxSnapshotSubxidCount() * sizeof(TransactionId));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3595,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&pArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockAcquire(&pArray->known_assigned_xids_lck);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t * It is sufficient to get shared lock on ProcArrayLock, even if we are",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\t * going to set MyPgXact->xmin.",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"out of memory\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3598,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&pArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\t\tSpinLockRelease(&pArray->known_assigned_xids_lck);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 1557,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1562,
          "old_api": "TransactionIdAdvance",
          "new_api": null,
          "old_text": "TransactionIdAdvance(xmax)",
          "new_text": null,
          "old_line_content": "\tTransactionIdAdvance(xmax);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\tsnapshot->takenDuringRecovery = RecoveryInProgress();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3620,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, mid_xid)",
          "new_text": null,
          "old_line_content": "\t\telse if (TransactionIdPrecedes(xid, mid_xid))",
          "new_line_content": "\tif (result_index < 0)",
          "content_same": false
        },
        {
          "line": 3637,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(pArray->numKnownAssignedXids >= 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(pArray->numKnownAssignedXids >= 0);",
          "new_line_content": "\t\tif (result_index == tail)",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdIsNormal(xid) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(xid, globalxmin)",
          "new_text": null,
          "old_line_content": "\t\t\t\tNormalTransactionIdPrecedes(xid, globalxmin))",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 1612,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!TransactionIdIsNormal(xid)",
          "new_line_content": "\t\t\t * must include them in xmin.",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(xid, xmax)",
          "new_text": null,
          "old_line_content": "\t\t\t\t|| !NormalTransactionIdPrecedes(xid, xmax))",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 1620,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(xid, xmin)",
          "new_text": null,
          "old_line_content": "\t\t\tif (NormalTransactionIdPrecedes(xid, xmin))",
          "new_line_content": "\t\t\tsnapshot->xip[count++] = xid;",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "new_line_content": " * Remove the specified XID from KnownAssignedXids[].",
          "content_same": false
        },
        {
          "line": 3674,
          "old_api": "KnownAssignedXidsSearch",
          "new_api": null,
          "old_text": "KnownAssignedXidsSearch(xid, false)",
          "new_text": null,
          "old_line_content": "\treturn KnownAssignedXidsSearch(xid, false);",
          "new_line_content": " * Caller must hold ProcArrayLock in exclusive mode.",
          "content_same": false
        },
        {
          "line": 3685,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "new_line_content": "\t * present.  We intentionally remove subxact IDs while processing",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG4)",
          "new_text": null,
          "old_line_content": "\telog(trace_recovery(DEBUG4), \"remove KnownAssignedXid %u\", xid);",
          "new_line_content": "\t * removed again when the top-level xact commits or aborts.",
          "content_same": false
        },
        {
          "line": 3699,
          "old_api": "KnownAssignedXidsSearch",
          "new_api": null,
          "old_text": "KnownAssignedXidsSearch(xid, true)",
          "new_text": null,
          "old_line_content": "\t(void) KnownAssignedXidsSearch(xid, true);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 1655,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(snapshot->subxip + subcount,\n\t\t\t\t\t\t\t   (void *) proc->subxids.xids,\n\t\t\t\t\t\t\t   nxids * sizeof(TransactionId))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tmemcpy(snapshot->subxip + subcount,",
          "new_line_content": "\t\t\t}",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdIsValid(xid))",
          "new_line_content": "\t/* Opportunistically compress the array */",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": "KnownAssignedXidsRemove",
          "new_api": null,
          "old_text": "KnownAssignedXidsRemove(subxids[i])",
          "new_text": null,
          "old_line_content": "\t\tKnownAssignedXidsRemove(subxids[i]);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3721,
          "old_api": "KnownAssignedXidsCompress",
          "new_api": null,
          "old_text": "KnownAssignedXidsCompress(false)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsCompress(false);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 3740,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(removeXid)",
          "new_text": null,
          "old_line_content": "\tif (!TransactionIdIsValid(removeXid))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1695,
          "old_api": "KnownAssignedXidsGetAndSetXmin",
          "new_api": null,
          "old_text": "KnownAssignedXidsGetAndSetXmin(snapshot->subxip, &xmin,\n\t\t\t\t\t\t\t\t\t\t\t\t  xmax)",
          "new_text": null,
          "old_line_content": "\t\tsubcount = KnownAssignedXidsGetAndSetXmin(snapshot->subxip, &xmin,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": "TransactionIdPrecedesOrEquals",
          "new_api": null,
          "old_text": "TransactionIdPrecedesOrEquals(xmin, procArray->lastOverflowedXid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdPrecedesOrEquals(xmin, procArray->lastOverflowedXid))",
          "new_line_content": "\treplication_slot_xmin = procArray->replication_slot_xmin;",
          "content_same": false
        },
        {
          "line": 3748,
          "old_api": "trace_recovery",
          "new_api": null,
          "old_text": "trace_recovery(DEBUG4)",
          "new_text": null,
          "old_line_content": "\telog(trace_recovery(DEBUG4), \"prune KnownAssignedXids to %u\", removeXid);",
          "new_line_content": "\ttail = pArray->tailKnownAssignedXids;",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(MyPgXact->xmin)",
          "new_text": null,
          "old_line_content": "\tif (!TransactionIdIsValid(MyPgXact->xmin))",
          "new_line_content": "\t * Update globalxmin to include actual process xids.  This is a slightly",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3763,
          "old_api": "TransactionIdFollowsOrEquals",
          "new_api": null,
          "old_text": "TransactionIdFollowsOrEquals(knownXid, removeXid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdFollowsOrEquals(knownXid, removeXid))",
          "new_line_content": "\t\t\t\tcount++;",
          "content_same": false
        },
        {
          "line": 1717,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xmin, globalxmin)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdPrecedes(xmin, globalxmin))",
          "new_line_content": "\t\tRecentGlobalXmin = FirstNormalTransactionId;",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "StandbyTransactionIdIsPrepared",
          "new_api": null,
          "old_text": "StandbyTransactionIdIsPrepared(knownXid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!StandbyTransactionIdIsPrepared(knownXid))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(RecentGlobalXmin)",
          "new_text": null,
          "old_line_content": "\tif (!TransactionIdIsNormal(RecentGlobalXmin))",
          "new_line_content": "\t\tRecentGlobalXmin = replication_slot_xmin;",
          "content_same": false
        },
        {
          "line": 1726,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(replication_slot_xmin)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdIsValid(replication_slot_xmin) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(replication_slot_xmin, RecentGlobalXmin)",
          "new_text": null,
          "old_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_xmin, RecentGlobalXmin))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 3775,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(pArray->numKnownAssignedXids >= 0)",
          "new_text": null,
          "old_line_content": "\tAssert(pArray->numKnownAssignedXids >= 0);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(replication_slot_catalog_xmin)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdIsNormal(replication_slot_catalog_xmin) &&",
          "new_line_content": "\tsnapshot->xmin = xmin;",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "NormalTransactionIdPrecedes",
          "new_api": null,
          "old_text": "NormalTransactionIdPrecedes(replication_slot_catalog_xmin, RecentGlobalXmin)",
          "new_text": null,
          "old_line_content": "\t\tNormalTransactionIdPrecedes(replication_slot_catalog_xmin, RecentGlobalXmin))",
          "new_line_content": "\tsnapshot->xmax = xmax;",
          "content_same": false
        },
        {
          "line": 1749,
          "old_api": "GetCurrentCommandId",
          "new_api": null,
          "old_text": "GetCurrentCommandId(false)",
          "new_text": null,
          "old_line_content": "\tsnapshot->curcid = GetCurrentCommandId(false);",
          "new_line_content": "\tsnapshot->active_count = 0;",
          "content_same": false
        },
        {
          "line": 3797,
          "old_api": "KnownAssignedXidsCompress",
          "new_api": null,
          "old_text": "KnownAssignedXidsCompress(false)",
          "new_text": null,
          "old_line_content": "\tKnownAssignedXidsCompress(false);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 3814,
          "old_api": "KnownAssignedXidsGetAndSetXmin",
          "new_api": null,
          "old_text": "KnownAssignedXidsGetAndSetXmin(xarray, &xtmp, xmax)",
          "new_text": null,
          "old_line_content": "\treturn KnownAssignedXidsGetAndSetXmin(xarray, &xtmp, xmax);",
          "new_line_content": " *",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "GetXLogInsertRecPtr",
          "new_api": null,
          "old_text": "GetXLogInsertRecPtr()",
          "new_text": null,
          "old_line_content": "\t\tsnapshot->lsn = GetXLogInsertRecPtr();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": "GetSnapshotCurrentTimestamp",
          "new_api": null,
          "old_text": "GetSnapshotCurrentTimestamp()",
          "new_text": null,
          "old_line_content": "\t\tsnapshot->whenTaken = GetSnapshotCurrentTimestamp();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": "MaintainOldSnapshotTimeMapping",
          "new_api": null,
          "old_text": "MaintainOldSnapshotTimeMapping(snapshot->whenTaken, xmin)",
          "new_text": null,
          "old_line_content": "\t\tMaintainOldSnapshotTimeMapping(snapshot->whenTaken, xmin);",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 3841,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&procArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\tSpinLockAcquire(&procArray->known_assigned_xids_lck);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&procArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\tSpinLockRelease(&procArray->known_assigned_xids_lck);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 1801,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xmin)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(xmin));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1806,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t\tvolatile PGXACT *pgxact = &allPgXact[pgprocno];",
          "content_same": false
        },
        {
          "line": 3858,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(knownXid, *xmin)",
          "new_text": null,
          "old_line_content": "\t\t\t\tTransactionIdPrecedes(knownXid, *xmin))",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xmax)",
          "new_text": null,
          "old_line_content": "\t\t\tif (TransactionIdIsValid(xmax) &&",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 3866,
          "old_api": "TransactionIdFollowsOrEquals",
          "new_api": null,
          "old_text": "TransactionIdFollowsOrEquals(knownXid, xmax)",
          "new_text": null,
          "old_line_content": "\t\t\t\tTransactionIdFollowsOrEquals(knownXid, xmax))",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1838,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\tif (!TransactionIdIsNormal(xid) ||",
          "new_line_content": "\t\t * TransactionXmin too.  (Note that because snapmgr.c called",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": "TransactionIdPrecedesOrEquals",
          "new_api": null,
          "old_text": "TransactionIdPrecedesOrEquals(xid, xmin)",
          "new_text": null,
          "old_line_content": "\t\t\t!TransactionIdPrecedesOrEquals(xid, xmin))",
          "new_line_content": "\t\t * GetSnapshotData first, we'll be overwriting a valid xmin here, so",
          "content_same": false
        },
        {
          "line": 3891,
          "old_api": "SpinLockAcquire",
          "new_api": null,
          "old_text": "SpinLockAcquire(&procArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\tSpinLockAcquire(&procArray->known_assigned_xids_lck);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3894,
          "old_api": "SpinLockRelease",
          "new_api": null,
          "old_text": "SpinLockRelease(&procArray->known_assigned_xids_lck)",
          "new_text": null,
          "old_line_content": "\tSpinLockRelease(&procArray->known_assigned_xids_lck);",
          "new_line_content": "\t\t\treturn KnownAssignedXids[i];",
          "content_same": false
        },
        {
          "line": 1854,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * ProcArrayInstallRestoredXmin -- install restored xmin into MyPgXact->xmin",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xmin)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsNormal(xmin));",
          "new_line_content": "\tpgxact = &allPgXact[proc->pgprocno];",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(proc != NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(proc != NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1879,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "\t * no later than the one we're installing, so that the system-wide xmin",
          "content_same": false
        },
        {
          "line": 3930,
          "old_api": "initStringInfo",
          "new_api": null,
          "old_text": "initStringInfo(&buf)",
          "new_text": null,
          "old_line_content": "\tinitStringInfo(&buf);",
          "new_line_content": "\t\t\tnxids++;",
          "content_same": false
        },
        {
          "line": 3937,
          "old_api": "appendStringInfo",
          "new_api": null,
          "old_text": "appendStringInfo(&buf, \"[%d]=%u \", i, KnownAssignedXids[i])",
          "new_text": null,
          "old_line_content": "\t\t\tappendStringInfo(&buf, \"[%d]=%u \", i, KnownAssignedXids[i]);",
          "new_line_content": "\t\t pArray->numKnownAssignedXids,",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": "TransactionIdIsNormal",
          "new_api": null,
          "old_text": "TransactionIdIsNormal(xid)",
          "new_text": null,
          "old_line_content": "\t\tTransactionIdIsNormal(xid) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3941,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(trace_level, \"%d KnownAssignedXids (num=%d tail=%d head=%d) %s\",\n\t\t nxids,\n\t\t pArray->numKnownAssignedXids,\n\t\t pArray->tailKnownAssignedXids,\n\t\t pArray->headKnownAssignedXids,\n\t\t buf.data)",
          "new_text": null,
          "old_line_content": "\telog(trace_level, \"%d KnownAssignedXids (num=%d tail=%d head=%d) %s\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": " * GetRunningTransactionData -- returns information about running transactions.",
          "content_same": false
        },
        {
          "line": 3948,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(buf.data)",
          "new_text": null,
          "old_line_content": "\tpfree(buf.data);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(ProcArrayLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(ProcArrayLock);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1944,
          "old_api": "RecoveryInProgress",
          "new_api": null,
          "old_text": "RecoveryInProgress()",
          "new_text": null,
          "old_line_content": "\tAssert(!RecoveryInProgress());",
          "new_line_content": "\t * more subxip storage than is probably needed.",
          "content_same": false
        },
        {
          "line": 1961,
          "old_api": "malloc",
          "new_api": null,
          "old_text": "malloc(TOTAL_MAX_CACHED_SUBXIDS * sizeof(TransactionId))",
          "new_text": null,
          "old_line_content": "\t\t\tmalloc(TOTAL_MAX_CACHED_SUBXIDS * sizeof(TransactionId));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1963,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1964,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_OUT_OF_MEMORY)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),",
          "new_line_content": "\tcount = subcount = 0;",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"out of memory\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"out of memory\")));",
          "new_line_content": "\tsuboverflowed = false;",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(ProcArrayLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(ProcArrayLock, LW_SHARED);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1978,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(XidGenLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(XidGenLock, LW_SHARED);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\t\tif (!TransactionIdIsValid(xid))",
          "new_line_content": "\t\t * up transaction information held on standbys.",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(xid, oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdPrecedes(xid, oldestRunningXid))",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&xids[count], (void *) proc->subxids.xids,\n\t\t\t\t\t   nxids * sizeof(TransactionId))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(&xids[count], (void *) proc->subxids.xids,",
          "new_line_content": "\t\t\t\t * Top-level XID of a transaction is always less than any of",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 29,
      "total_additions": 308,
      "total_deletions": 309,
      "total_api_changes": 646
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 8,
        "api_related_lines": 646,
        "non_api_lines": 5,
        "non_api_line_numbers": [
          546,
          549,
          550,
          551,
          552
        ]
      }
    },
    "api_calls_before": 441,
    "api_calls_after": 440,
    "diff_info": {
      "added_lines": 2,
      "removed_lines": 8,
      "total_diff_lines": 22
    }
  }
}