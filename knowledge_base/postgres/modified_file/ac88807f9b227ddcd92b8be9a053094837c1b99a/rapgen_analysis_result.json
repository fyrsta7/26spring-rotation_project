{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ac88807f9b227ddcd92b8be9a053094837c1b99a",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ac88807f9b227ddcd92b8be9a053094837c1b99a/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ac88807f9b227ddcd92b8be9a053094837c1b99a/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/ac88807f9b227ddcd92b8be9a053094837c1b99a/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 309,
          "old_api": "tuplehash_insert",
          "new_api": "MemoryContextSwitchTo",
          "old_text": "tuplehash_insert(hashtable->hashtab, key, &found)",
          "new_text": "MemoryContextSwitchTo(hashtable->tempcxt)",
          "old_line_content": "\t\tentry = tuplehash_insert(hashtable->hashtab, key, &found);",
          "new_line_content": "\toldContext = MemoryContextSwitchTo(hashtable->tempcxt);",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 263,
          "old_api": null,
          "new_api": "BuildTupleHashTableExt",
          "old_text": null,
          "new_text": "BuildTupleHashTableExt(parent,\n\t\t\t\t\t\t\t\t  inputDesc,\n\t\t\t\t\t\t\t\t  numCols, keyColIdx,\n\t\t\t\t\t\t\t\t  eqfuncoids,\n\t\t\t\t\t\t\t\t  hashfunctions,\n\t\t\t\t\t\t\t\t  collations,\n\t\t\t\t\t\t\t\t  nbuckets, additionalsize,\n\t\t\t\t\t\t\t\t  tablecxt,\n\t\t\t\t\t\t\t\t  tablecxt,\n\t\t\t\t\t\t\t\t  tempcxt,\n\t\t\t\t\t\t\t\t  use_variable_hash_iv)",
          "old_line_content": "}",
          "new_line_content": "\treturn BuildTupleHashTableExt(parent,",
          "content_same": false
        },
        {
          "line": 284,
          "old_api": null,
          "new_api": "tuplehash_reset",
          "old_text": null,
          "new_text": "tuplehash_reset(hashtable->hashtab)",
          "old_line_content": " * matches.  On return, *isnew is true if the entry is newly created,",
          "new_line_content": "\ttuplehash_reset(hashtable->hashtab);",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": null,
          "new_api": "ExecStoreMinimalTuple",
          "old_text": null,
          "new_text": "ExecStoreMinimalTuple(tuple, slot, false)",
          "old_line_content": "\t\thashkey = (hashkey << 1) | ((hashkey & 0x80000000) ? 1 : 0);",
          "new_line_content": "\t\tExecStoreMinimalTuple(tuple, slot, false);",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(nbuckets > 0)",
          "old_line_content": "",
          "new_line_content": "\tAssert(nbuckets > 0);",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(nbuckets, (long) ((work_mem * 1024L) / entrysize))",
          "old_line_content": "",
          "new_line_content": "\tnbuckets = Min(nbuckets, (long) ((work_mem * 1024L) / entrysize));",
          "content_same": false
        },
        {
          "line": 176,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(metacxt)",
          "old_line_content": "",
          "new_line_content": "\toldcontext = MemoryContextSwitchTo(metacxt);",
          "content_same": false
        },
        {
          "line": 178,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(TupleHashTableData))",
          "old_line_content": "",
          "new_line_content": "\thashtable = (TupleHashTable) palloc(sizeof(TupleHashTableData));",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "slot_getattr",
          "old_text": null,
          "new_text": "slot_getattr(slot, att, &isNull)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tattr = slot_getattr(slot, att, &isNull);",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": null,
          "new_api": "FunctionCall1Coll",
          "old_text": null,
          "new_text": "FunctionCall1Coll(&hashfunctions[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\thashtable->tab_collations[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tattr)",
          "old_line_content": "\t * resulting in near perfect perturbation.",
          "new_line_content": "\t\t\thkey = DatumGetUInt32(FunctionCall1Coll(&hashfunctions[i],",
          "content_same": false
        },
        {
          "line": 320,
          "old_api": null,
          "new_api": "tuplehash_insert",
          "old_text": null,
          "new_text": "tuplehash_insert(hashtable->hashtab, key, &found)",
          "old_line_content": "\t\t\t/* zero caller data */",
          "new_line_content": "\t\tentry = tuplehash_insert(hashtable->hashtab, key, &found);",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": null,
          "new_api": "murmurhash32",
          "old_text": null,
          "new_text": "murmurhash32(hashkey)",
          "old_line_content": "\tTupleTableSlot *slot1;",
          "new_line_content": "\treturn murmurhash32(hashkey);",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": null,
          "new_api": "murmurhash32",
          "old_text": null,
          "new_text": "murmurhash32(ParallelWorkerNumber)",
          "old_line_content": "\telse",
          "new_line_content": "\t\thashtable->hash_iv = murmurhash32(ParallelWorkerNumber);",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": null,
          "new_api": "tuplehash_create",
          "old_text": null,
          "new_text": "tuplehash_create(metacxt, nbuckets, hashtable)",
          "old_line_content": "",
          "new_line_content": "\thashtable->hashtab = tuplehash_create(metacxt, nbuckets, hashtable);",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(hashtable->tablecxt)",
          "old_line_content": "",
          "new_line_content": "\t\t\tMemoryContextSwitchTo(hashtable->tablecxt);",
          "content_same": false
        },
        {
          "line": 335,
          "old_api": null,
          "new_api": "ExecCopySlotMinimalTuple",
          "old_text": null,
          "new_text": "ExecCopySlotMinimalTuple(slot)",
          "old_line_content": "}",
          "new_line_content": "\t\t\tentry->firstTuple = ExecCopySlotMinimalTuple(slot);",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": null,
          "new_api": "CreateTupleDescCopy",
          "old_text": null,
          "new_text": "CreateTupleDescCopy(inputDesc)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\t&TTSOpsMinimalTuple);",
          "new_line_content": "\thashtable->tableslot = MakeSingleTupleTableSlot(CreateTupleDescCopy(inputDesc),",
          "content_same": false
        },
        {
          "line": 340,
          "old_api": null,
          "new_api": "tuplehash_lookup",
          "old_text": null,
          "new_text": "tuplehash_lookup(hashtable->hashtab, key)",
          "old_line_content": " * case of LookupTupleHashEntry, except that it supports cross-type",
          "new_line_content": "\t\tentry = tuplehash_lookup(hashtable->hashtab, key);",
          "content_same": false
        },
        {
          "line": 343,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(oldContext)",
          "old_line_content": " * the input tuple, as well as the equality functions, since these may be",
          "new_line_content": "\tMemoryContextSwitchTo(oldContext);",
          "content_same": false
        },
        {
          "line": 475,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(tuple1 != NULL)",
          "old_line_content": "",
          "new_line_content": "\tAssert(tuple1 != NULL);",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": null,
          "new_api": "ExecStoreMinimalTuple",
          "old_text": null,
          "new_text": "ExecStoreMinimalTuple(tuple1, slot1, false)",
          "old_line_content": "",
          "new_line_content": "\tExecStoreMinimalTuple(tuple1, slot1, false);",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(tuple2 == NULL)",
          "old_line_content": "",
          "new_line_content": "\tAssert(tuple2 == NULL);",
          "content_same": false
        },
        {
          "line": 226,
          "old_api": null,
          "new_api": "ExecBuildGroupingEqual",
          "old_text": null,
          "new_text": "ExecBuildGroupingEqual(inputDesc, inputDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&TTSOpsMinimalTuple, &TTSOpsMinimalTuple,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnumCols,\n\t\t\t\t\t\t\t\t\t\t\t\t\tkeyColIdx, eqfuncoids, collations,\n\t\t\t\t\t\t\t\t\t\t\t\t\tallow_jit ? parent : NULL)",
          "old_line_content": "\t */",
          "new_line_content": "\thashtable->tab_eq_func = ExecBuildGroupingEqual(inputDesc, inputDesc,",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": null,
          "new_api": "ExecQualAndReset",
          "old_text": null,
          "new_text": "ExecQualAndReset(hashtable->cur_eq_func, econtext)",
          "old_line_content": "",
          "new_line_content": "\treturn !ExecQualAndReset(hashtable->cur_eq_func, econtext);",
          "content_same": false
        },
        {
          "line": 238,
          "old_api": null,
          "new_api": "CreateStandaloneExprContext",
          "old_text": null,
          "new_text": "CreateStandaloneExprContext()",
          "old_line_content": " * with ResetTupleHashTable().",
          "new_line_content": "\thashtable->exprcontext = CreateStandaloneExprContext();",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(hashtable->tempcxt)",
          "old_line_content": "",
          "new_line_content": "\toldContext = MemoryContextSwitchTo(hashtable->tempcxt);",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(oldcontext)",
          "old_line_content": "TupleHashTable",
          "new_line_content": "\tMemoryContextSwitchTo(oldcontext);",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": null,
          "new_api": "tuplehash_lookup",
          "old_text": null,
          "new_text": "tuplehash_lookup(hashtable->hashtab, key)",
          "old_line_content": " * format).  LookupTupleHashEntry sets up a dummy TupleHashEntryData with a",
          "new_line_content": "\tentry = tuplehash_lookup(hashtable->hashtab, key);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(oldContext)",
          "old_line_content": " * NULL firstTuple field --- that cues us to look at the inputslot instead.",
          "new_line_content": "\tMemoryContextSwitchTo(oldContext);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 273,
          "old_api": "tuplehash_reset",
          "new_api": null,
          "old_text": "tuplehash_reset(hashtable->hashtab)",
          "new_text": null,
          "old_line_content": "\ttuplehash_reset(hashtable->hashtab);",
          "new_line_content": "\t\t\t\t\t\t\t\t  use_variable_hash_iv);",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": "ExecStoreMinimalTuple",
          "new_api": null,
          "old_text": "ExecStoreMinimalTuple(tuple, slot, false)",
          "new_text": null,
          "old_line_content": "\t\tExecStoreMinimalTuple(tuple, slot, false);",
          "new_line_content": "\t\thashfunctions = hashtable->in_hash_funcs;",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "slot_getattr",
          "new_api": null,
          "old_text": "slot_getattr(slot, att, &isNull)",
          "new_text": null,
          "old_line_content": "\t\tattr = slot_getattr(slot, att, &isNull);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 170,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(nbuckets > 0)",
          "new_text": null,
          "old_line_content": "\tAssert(nbuckets > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 298,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(hashtable->tempcxt)",
          "new_text": null,
          "old_line_content": "\toldContext = MemoryContextSwitchTo(hashtable->tempcxt);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 173,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(nbuckets, (long) ((work_mem * 1024L) / entrysize))",
          "new_text": null,
          "old_line_content": "\tnbuckets = Min(nbuckets, (long) ((work_mem * 1024L) / entrysize));",
          "new_line_content": "\t/* Limit initial table size request to not more than work_mem */",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "FunctionCall1Coll",
          "new_api": null,
          "old_text": "FunctionCall1Coll(&hashfunctions[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\thashtable->tab_collations[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\tattr)",
          "new_text": null,
          "old_line_content": "\t\t\thkey = DatumGetUInt32(FunctionCall1Coll(&hashfunctions[i],",
          "new_line_content": "\t\tbool\t\tisNull;",
          "content_same": false
        },
        {
          "line": 175,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(metacxt)",
          "new_text": null,
          "old_line_content": "\toldcontext = MemoryContextSwitchTo(metacxt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 177,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(TupleHashTableData))",
          "new_text": null,
          "old_line_content": "\thashtable = (TupleHashTable) palloc(sizeof(TupleHashTableData));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "murmurhash32",
          "new_api": null,
          "old_text": "murmurhash32(hashkey)",
          "new_text": null,
          "old_line_content": "\treturn murmurhash32(hashkey);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\tattr));",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(hashtable->tablecxt)",
          "new_text": null,
          "old_line_content": "\t\t\tMemoryContextSwitchTo(hashtable->tablecxt);",
          "new_line_content": "\t\tif (found)",
          "content_same": false
        },
        {
          "line": 324,
          "old_api": "ExecCopySlotMinimalTuple",
          "new_api": null,
          "old_text": "ExecCopySlotMinimalTuple(slot)",
          "new_text": null,
          "old_line_content": "\t\t\tentry->firstTuple = ExecCopySlotMinimalTuple(slot);",
          "new_line_content": "\t\t\t/* found pre-existing entry */",
          "content_same": false
        },
        {
          "line": 200,
          "old_api": "murmurhash32",
          "new_api": null,
          "old_text": "murmurhash32(ParallelWorkerNumber)",
          "new_text": null,
          "old_line_content": "\t\thashtable->hash_iv = murmurhash32(ParallelWorkerNumber);",
          "new_line_content": "\tif (use_variable_hash_iv)",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": "tuplehash_lookup",
          "new_api": null,
          "old_text": "tuplehash_lookup(hashtable->hashtab, key)",
          "new_text": null,
          "old_line_content": "\t\tentry = tuplehash_lookup(hashtable->hashtab, key);",
          "new_line_content": "\t\t\t/* created new entry */",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "tuplehash_create",
          "new_api": null,
          "old_text": "tuplehash_create(metacxt, nbuckets, hashtable)",
          "new_text": null,
          "old_line_content": "\thashtable->hashtab = tuplehash_create(metacxt, nbuckets, hashtable);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 332,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(oldContext)",
          "new_text": null,
          "old_line_content": "\tMemoryContextSwitchTo(oldContext);",
          "new_line_content": "\t\t\tentry->additional = NULL;",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(tuple1 != NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(tuple1 != NULL);",
          "new_line_content": "\tTupleTableSlot *slot1;",
          "content_same": false
        },
        {
          "line": 210,
          "old_api": "CreateTupleDescCopy",
          "new_api": null,
          "old_text": "CreateTupleDescCopy(inputDesc)",
          "new_text": null,
          "old_line_content": "\thashtable->tableslot = MakeSingleTupleTableSlot(CreateTupleDescCopy(inputDesc),",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "ExecStoreMinimalTuple",
          "new_api": null,
          "old_text": "ExecStoreMinimalTuple(tuple1, slot1, false)",
          "new_text": null,
          "old_line_content": "\tExecStoreMinimalTuple(tuple1, slot1, false);",
          "new_line_content": "\tTupleHashTable hashtable = (TupleHashTable) tb->private_data;",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(tuple2 == NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(tuple2 == NULL);",
          "new_line_content": "\tExprContext *econtext = hashtable->exprcontext;",
          "content_same": false
        },
        {
          "line": 215,
          "old_api": "ExecBuildGroupingEqual",
          "new_api": null,
          "old_text": "ExecBuildGroupingEqual(inputDesc, inputDesc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&TTSOpsMinimalTuple, &TTSOpsMinimalTuple,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnumCols,\n\t\t\t\t\t\t\t\t\t\t\t\t\tkeyColIdx, eqfuncoids, collations,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNULL)",
          "new_text": null,
          "old_line_content": "\thashtable->tab_eq_func = ExecBuildGroupingEqual(inputDesc, inputDesc,",
          "new_line_content": "\t * If the old reset interface is used (i.e. BuildTupleHashTable, rather",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "ExecQualAndReset",
          "new_api": null,
          "old_text": "ExecQualAndReset(hashtable->cur_eq_func, econtext)",
          "new_text": null,
          "old_line_content": "\treturn !ExecQualAndReset(hashtable->cur_eq_func, econtext);",
          "new_line_content": "\t * could be supported too, but is not currently required.",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "CreateStandaloneExprContext",
          "new_api": null,
          "old_text": "CreateStandaloneExprContext()",
          "new_text": null,
          "old_line_content": "\thashtable->exprcontext = CreateStandaloneExprContext();",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\t&TTSOpsMinimalTuple, &TTSOpsMinimalTuple,",
          "content_same": false
        },
        {
          "line": 356,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(hashtable->tempcxt)",
          "new_text": null,
          "old_line_content": "\toldContext = MemoryContextSwitchTo(hashtable->tempcxt);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 229,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(oldcontext)",
          "new_text": null,
          "old_line_content": "\tMemoryContextSwitchTo(oldcontext);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\tkeyColIdx, eqfuncoids, collations,",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "tuplehash_lookup",
          "new_api": null,
          "old_text": "tuplehash_lookup(hashtable->hashtab, key)",
          "new_text": null,
          "old_line_content": "\tentry = tuplehash_lookup(hashtable->hashtab, key);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(oldContext)",
          "new_text": null,
          "old_line_content": "\tMemoryContextSwitchTo(oldContext);",
          "new_line_content": "\t/* Need to run the hash functions in short-lived context */",
          "content_same": false
        },
        {
          "line": 252,
          "old_api": "BuildTupleHashTableExt",
          "new_api": null,
          "old_text": "BuildTupleHashTableExt(parent,\n\t\t\t\t\t\t\t\t  inputDesc,\n\t\t\t\t\t\t\t\t  numCols, keyColIdx,\n\t\t\t\t\t\t\t\t  eqfuncoids,\n\t\t\t\t\t\t\t\t  hashfunctions,\n\t\t\t\t\t\t\t\t  collations,\n\t\t\t\t\t\t\t\t  nbuckets, additionalsize,\n\t\t\t\t\t\t\t\t  tablecxt,\n\t\t\t\t\t\t\t\t  tablecxt,\n\t\t\t\t\t\t\t\t  tempcxt,\n\t\t\t\t\t\t\t\t  use_variable_hash_iv)",
          "new_text": null,
          "old_line_content": "\treturn BuildTupleHashTableExt(parent,",
          "new_line_content": "BuildTupleHashTable(PlanState *parent,",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 1,
      "total_additions": 28,
      "total_deletions": 28,
      "total_api_changes": 57
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 57,
        "non_api_lines": 11,
        "non_api_line_numbers": [
          230,
          169,
          214,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223
        ]
      }
    },
    "api_calls_before": 41,
    "api_calls_after": 41,
    "diff_info": {
      "added_lines": 12,
      "removed_lines": 1,
      "total_diff_lines": 38
    }
  }
}