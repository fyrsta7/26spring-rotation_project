{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/473411fc51157e8e825ee865c2822f976e0da5e3",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/473411fc51157e8e825ee865c2822f976e0da5e3/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/473411fc51157e8e825ee865c2822f976e0da5e3/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/473411fc51157e8e825ee865c2822f976e0da5e3/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 751,
          "old_api": "fmgr_info_cxt",
          "new_api": "RegProcedureIsValid",
          "old_text": "fmgr_info_cxt(cmp_proc, orderproc, so->arrayContext)",
          "new_text": "RegProcedureIsValid(cmp_proc)",
          "old_line_content": "\tfmgr_info_cxt(cmp_proc, orderproc, so->arrayContext);",
          "new_line_content": "\tif (!RegProcedureIsValid(cmp_proc))",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "fmgr_info_cxt",
          "new_api": "RegProcedureIsValid",
          "old_text": "fmgr_info_cxt(cmp_proc, *sortprocp, so->arrayContext)",
          "new_text": "RegProcedureIsValid(cmp_proc)",
          "old_line_content": "\tfmgr_info_cxt(cmp_proc, *sortprocp, so->arrayContext);",
          "new_line_content": "\tif (!RegProcedureIsValid(cmp_proc))",
          "content_same": false
        },
        {
          "line": 809,
          "old_api": "OidIsValid",
          "new_api": "Assert",
          "old_text": "OidIsValid(cmp_op)",
          "new_text": "Assert(skey->sk_strategy != BTEqualStrategyNumber)",
          "old_line_content": "\tif (!OidIsValid(cmp_op))",
          "new_line_content": "\tAssert(skey->sk_strategy != BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": "elog",
          "new_api": "OidIsValid",
          "old_text": "elog(ERROR, \"missing operator %d(%u,%u) in opfamily %u\",\n\t\t\t strat, elemtype, elemtype,\n\t\t\t rel->rd_opfamily[skey->sk_attno - 1])",
          "new_text": "OidIsValid(elemtype)",
          "old_line_content": "\t\telog(ERROR, \"missing operator %d(%u,%u) in opfamily %u\",",
          "new_line_content": "\tAssert(OidIsValid(elemtype));",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": "elog",
          "new_api": "OidIsValid",
          "old_text": "elog(ERROR, \"missing oprcode for operator %u\", cmp_op)",
          "new_text": "OidIsValid(cmp_op)",
          "old_line_content": "\t\telog(ERROR, \"missing oprcode for operator %u\", cmp_op);",
          "new_line_content": "\tif (!OidIsValid(cmp_op))",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": "Assert",
          "new_api": "get_opcode",
          "old_text": "Assert(nelems > 0)",
          "new_text": "get_opcode(cmp_op)",
          "old_line_content": "\tAssert(nelems > 0);",
          "new_line_content": "\tcmp_proc = get_opcode(cmp_op);",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "FunctionCall2Coll",
          "new_api": "fmgr_info",
          "old_text": "FunctionCall2Coll(&flinfo,\n\t\t\t\t\t\t\t\t\t\t   skey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t   elems[i],\n\t\t\t\t\t\t\t\t\t\t   result)",
          "new_text": "fmgr_info(cmp_proc, &flinfo)",
          "old_line_content": "\t\tif (DatumGetBool(FunctionCall2Coll(&flinfo,",
          "new_line_content": "\tfmgr_info(cmp_proc, &flinfo);",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "Assert",
          "new_api": "elog",
          "old_text": "Assert(new_nelems <= array->num_elems)",
          "new_text": "elog(ERROR, \"unrecognized StrategyNumber: %d\",\n\t\t\t\t (int) skey->sk_strategy)",
          "old_line_content": "\tAssert(new_nelems <= array->num_elems);",
          "new_line_content": "\t\t\telog(ERROR, \"unrecognized StrategyNumber: %d\",",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": "Assert",
          "new_api": "_bt_check_compare",
          "old_text": "Assert(all_satisfied && continuescan)",
          "new_text": "_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\t  false, false, false,\n\t\t\t\t\t\t\t  &continuescan, &nsktrig)",
          "old_line_content": "\t\t\tAssert(all_satisfied && continuescan);",
          "new_line_content": "\t\tif (_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": "_bt_rewind_nonrequired_arrays",
          "new_api": "Assert",
          "old_text": "_bt_rewind_nonrequired_arrays(scan, dir)",
          "new_text": "Assert(so->keyData[opsktrig].sk_strategy != BTEqualStrategyNumber)",
          "old_line_content": "\t\t\t_bt_rewind_nonrequired_arrays(scan, dir);",
          "new_line_content": "\t\t\tAssert(so->keyData[opsktrig].sk_strategy != BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": "_bt_fix_scankey_strategy",
          "new_api": "elog",
          "old_text": "_bt_fix_scankey_strategy(cur, indoption)",
          "new_text": "elog(ERROR, \"btree index keys must be ordered by attribute\")",
          "old_line_content": "\t\tif (!_bt_fix_scankey_strategy(cur, indoption))",
          "new_line_content": "\t\telog(ERROR, \"btree index keys must be ordered by attribute\");",
          "content_same": false
        },
        {
          "line": 2634,
          "old_api": "_bt_mark_scankey_required",
          "new_api": "_bt_fix_scankey_strategy",
          "old_text": "_bt_mark_scankey_required(outkeys)",
          "new_text": "_bt_fix_scankey_strategy(cur, indoption)",
          "old_line_content": "\t\t\t_bt_mark_scankey_required(outkeys);",
          "new_line_content": "\t\tif (!_bt_fix_scankey_strategy(cur, indoption))",
          "content_same": false
        },
        {
          "line": 2844,
          "old_api": "Assert",
          "new_api": "_bt_mark_scankey_required",
          "old_text": "Assert(j != (BTEqualStrategyNumber - 1))",
          "new_text": "_bt_mark_scankey_required(outkey)",
          "old_line_content": "\t\t\tAssert(j != (BTEqualStrategyNumber - 1));",
          "new_line_content": "\t\t\t\t_bt_mark_scankey_required(outkey);",
          "content_same": false
        },
        {
          "line": 2926,
          "old_api": "Assert",
          "new_api": "_bt_compare_scankey_args",
          "old_text": "Assert(!array || array->num_elems > 0)",
          "new_text": "_bt_compare_scankey_args(scan, cur, cur, xform[j].skey,\n\t\t\t\t\t\t\t\t\t\t array, orderproc, &test_result)",
          "old_line_content": "\t\t\t\t\tAssert(!array || array->num_elems > 0);",
          "new_line_content": "\t\t\tif (_bt_compare_scankey_args(scan, cur, cur, xform[j].skey,",
          "content_same": false
        },
        {
          "line": 3293,
          "old_api": "OidIsValid",
          "new_api": "BTCommuteStrategyNumber",
          "old_text": "OidIsValid(cmp_op)",
          "new_text": "BTCommuteStrategyNumber(strat)",
          "old_line_content": "\tif (OidIsValid(cmp_op))",
          "new_line_content": "\t\tstrat = BTCommuteStrategyNumber(strat);",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "get_opcode",
          "new_api": "get_opfamily_member",
          "old_text": "get_opcode(cmp_op)",
          "new_text": "get_opfamily_member(rel->rd_opfamily[leftarg->sk_attno - 1],\n\t\t\t\t\t\t\t\t lefttype,\n\t\t\t\t\t\t\t\t righttype,\n\t\t\t\t\t\t\t\t strat)",
          "old_line_content": "\t\tRegProcedure cmp_proc = get_opcode(cmp_op);",
          "new_line_content": "\tcmp_op = get_opfamily_member(rel->rd_opfamily[leftarg->sk_attno - 1],",
          "content_same": false
        },
        {
          "line": 3299,
          "old_api": "OidFunctionCall2Coll",
          "new_api": "OidIsValid",
          "old_text": "OidFunctionCall2Coll(cmp_proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\top->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tleftarg->sk_argument,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trightarg->sk_argument)",
          "new_text": "OidIsValid(cmp_op)",
          "old_line_content": "\t\t\t*result = DatumGetBool(OidFunctionCall2Coll(cmp_proc,",
          "new_line_content": "\tif (OidIsValid(cmp_op))",
          "content_same": false
        },
        {
          "line": 3403,
          "old_api": "DatumGetPointer",
          "new_api": "BTCommuteStrategyNumber",
          "old_text": "DatumGetPointer(skey->sk_argument)",
          "new_text": "BTCommuteStrategyNumber(skey->sk_strategy)",
          "old_line_content": "\t\tScanKey\t\tsubkey = (ScanKey) DatumGetPointer(skey->sk_argument);",
          "new_line_content": "\t\tskey->sk_strategy = BTCommuteStrategyNumber(skey->sk_strategy);",
          "content_same": false
        },
        {
          "line": 3516,
          "old_api": "BTreeTupleGetNAtts",
          "new_api": "RelationGetDescr",
          "old_text": "BTreeTupleGetNAtts(tuple, scan->indexRelation)",
          "new_text": "RelationGetDescr(scan->indexRelation)",
          "old_line_content": "\tAssert(BTreeTupleGetNAtts(tuple, scan->indexRelation) == tupnatts);",
          "new_line_content": "\tTupleDesc\ttupdesc = RelationGetDescr(scan->indexRelation);",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "index_getattr",
          "new_api": "_bt_check_rowcompare",
          "old_text": "index_getattr(tuple,\n\t\t\t\t\t\t\t  key->sk_attno,\n\t\t\t\t\t\t\t  tupdesc,\n\t\t\t\t\t\t\t  &isNull)",
          "new_text": "_bt_check_rowcompare(key, tuple, tupnatts, tupdesc, dir,\n\t\t\t\t\t\t\t\t\t continuescan)",
          "old_line_content": "\t\tdatum = index_getattr(tuple,",
          "new_line_content": "\t\t\tif (_bt_check_rowcompare(key, tuple, tupnatts, tupdesc, dir,",
          "content_same": false
        },
        {
          "line": 3985,
          "old_api": "ScanDirectionIsBackward",
          "new_api": "DatumGetPointer",
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": "DatumGetPointer(skey->sk_argument)",
          "old_line_content": "\t\t\t\t\t ScanDirectionIsBackward(dir))",
          "new_line_content": "\t\t\tif (subkey != (ScanKey) DatumGetPointer(skey->sk_argument))",
          "content_same": false
        },
        {
          "line": 3991,
          "old_api": "FunctionCall2Coll",
          "new_api": "ScanDirectionIsBackward",
          "old_text": "FunctionCall2Coll(&subkey->sk_func,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsubkey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdatum,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsubkey->sk_argument)",
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\tcmpresult = DatumGetInt32(FunctionCall2Coll(&subkey->sk_func,",
          "new_line_content": "\t\t\t\t\t ScanDirectionIsBackward(dir))",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": "INVERT_COMPARE_RESULT",
          "new_api": "FunctionCall2Coll",
          "old_text": "INVERT_COMPARE_RESULT(cmpresult)",
          "new_text": "FunctionCall2Coll(&subkey->sk_func,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsubkey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdatum,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsubkey->sk_argument)",
          "old_line_content": "\t\t\tINVERT_COMPARE_RESULT(cmpresult);",
          "new_line_content": "\t\tcmpresult = DatumGetInt32(FunctionCall2Coll(&subkey->sk_func,",
          "content_same": false
        },
        {
          "line": 4110,
          "old_api": "PageGetItem",
          "new_api": "Min",
          "old_text": "PageGetItem(pstate->page,\n\t\t\t\t\t\t\t\t\t PageGetItemId(pstate->page, aheadoffnum))",
          "new_text": "Min((int) pstate->maxoff,\n\t\t\t\t\t\t  (int) pstate->offnum + pstate->targetdistance)",
          "old_line_content": "\tahead = (IndexTuple) PageGetItem(pstate->page,",
          "new_line_content": "\t\taheadoffnum = Min((int) pstate->maxoff,",
          "content_same": false
        },
        {
          "line": 4217,
          "old_api": "_bt_relbuf",
          "new_api": "BufferGetPage",
          "old_text": "_bt_relbuf(scan->indexRelation, buf)",
          "new_text": "BufferGetPage(buf)",
          "old_line_content": "\t\t\t_bt_relbuf(scan->indexRelation, buf);",
          "new_line_content": "\t\tpage = BufferGetPage(buf);",
          "content_same": false
        },
        {
          "line": 4223,
          "old_api": "P_FIRSTDATAKEY",
          "new_api": "_bt_relbuf",
          "old_text": "P_FIRSTDATAKEY(opaque)",
          "new_text": "_bt_relbuf(scan->indexRelation, buf)",
          "old_line_content": "\tminoff = P_FIRSTDATAKEY(opaque);",
          "new_line_content": "\t\t\t_bt_relbuf(scan->indexRelation, buf);",
          "content_same": false
        },
        {
          "line": 4238,
          "old_api": "PageGetItemId",
          "new_api": "Assert",
          "old_text": "PageGetItemId(page, offnum)",
          "new_text": "Assert(itemIndex >= so->currPos.firstItem &&\n\t\t\t   itemIndex <= so->currPos.lastItem)",
          "old_line_content": "\t\t\tItemId\t\tiid = PageGetItemId(page, offnum);",
          "new_line_content": "\t\tAssert(itemIndex >= so->currPos.firstItem &&",
          "content_same": false
        },
        {
          "line": 4245,
          "old_api": "BTreeTupleGetNPosting",
          "new_api": "PageGetItem",
          "old_text": "BTreeTupleGetNPosting(ituple)",
          "new_text": "PageGetItem(page, iid)",
          "old_line_content": "\t\t\t\tint\t\t\tnposting = BTreeTupleGetNPosting(ituple);",
          "new_line_content": "\t\t\tIndexTuple\tituple = (IndexTuple) PageGetItem(page, iid);",
          "content_same": false
        },
        {
          "line": 4539,
          "old_api": "Assert",
          "new_api": "BTreeShmemSize",
          "old_text": "Assert(!found)",
          "new_text": "BTreeShmemSize()",
          "old_line_content": "\t\tAssert(!found);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),",
          "content_same": false
        },
        {
          "line": 4552,
          "old_api": "Assert",
          "new_api": "time",
          "old_text": "Assert(found)",
          "new_text": "time(NULL)",
          "old_line_content": "\t\tAssert(found);",
          "new_line_content": "\t\tbtvacinfo->cycle_ctr = (BTCycleId) time(NULL);",
          "content_same": false
        },
        {
          "line": 4569,
          "old_api": "lengthof",
          "new_api": "offsetof",
          "old_text": "lengthof(tab)",
          "new_text": "offsetof(BTOptions, deduplicate_items)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t  tab, lengthof(tab));",
          "new_line_content": "\t\toffsetof(BTOptions, deduplicate_items)}",
          "content_same": false
        },
        {
          "line": 4827,
          "old_api": "FunctionCall2Coll",
          "new_api": "index_getattr",
          "old_text": "FunctionCall2Coll(&scankey->sk_func,\n\t\t\t\t\t\t\t\t\t\t\tscankey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\tdatum1,\n\t\t\t\t\t\t\t\t\t\t\tdatum2)",
          "new_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "old_line_content": "\t\t\tDatumGetInt32(FunctionCall2Coll(&scankey->sk_func,",
          "new_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "content_same": false
        },
        {
          "line": 4892,
          "old_api": "datum_image_eq",
          "new_api": "TupleDescAttr",
          "old_text": "datum_image_eq(datum1, datum2, att->attbyval, att->attlen)",
          "new_text": "TupleDescAttr(itupdesc, attnum - 1)",
          "old_line_content": "\t\t\t!datum_image_eq(datum1, datum2, att->attbyval, att->attlen))",
          "new_line_content": "\t\tatt = TupleDescAttr(itupdesc, attnum - 1);",
          "content_same": false
        },
        {
          "line": 4934,
          "old_api": "PageGetItemId",
          "new_api": "P_IGNORE",
          "old_text": "PageGetItemId(page, offnum)",
          "new_text": "P_IGNORE(opaque)",
          "old_line_content": "\titup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));",
          "new_line_content": "\tif (P_IGNORE(opaque))",
          "content_same": false
        },
        {
          "line": 4938,
          "old_api": "BTreeTupleIsPosting",
          "new_api": "PageGetMaxOffsetNumber",
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": "PageGetMaxOffsetNumber(page)",
          "old_line_content": "\tif (!heapkeyspace && BTreeTupleIsPosting(itup))",
          "new_line_content": "\t\t   offnum <= PageGetMaxOffsetNumber(page));",
          "content_same": false
        },
        {
          "line": 4959,
          "old_api": "BTreeTupleIsPivot",
          "new_api": "P_FIRSTDATAKEY",
          "old_text": "BTreeTupleIsPivot(itup)",
          "new_text": "P_FIRSTDATAKEY(opaque)",
          "old_line_content": "\t\t\tif (BTreeTupleIsPivot(itup))",
          "new_line_content": "\t\tif (offnum >= P_FIRSTDATAKEY(opaque))",
          "content_same": false
        },
        {
          "line": 5106,
          "old_api": "errcode",
          "new_api": "BTPageGetOpaque",
          "old_text": "errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED)",
          "new_text": "BTPageGetOpaque(page)",
          "old_line_content": "\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "new_line_content": "\topaque = BTPageGetOpaque(page);",
          "content_same": false
        },
        {
          "line": 5107,
          "old_api": "errmsg",
          "new_api": "P_ISLEAF",
          "old_text": "errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel))",
          "new_text": "P_ISLEAF(opaque)",
          "old_line_content": "\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",",
          "new_line_content": "\tif (!P_ISLEAF(opaque))",
          "content_same": false
        },
        {
          "line": 5111,
          "old_api": "BTMaxItemSizeNoHeapTid",
          "new_api": "ereport",
          "old_text": "BTMaxItemSizeNoHeapTid(page)",
          "new_text": "ereport(ERROR,\n\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel)),\n\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap)),\n\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\"),\n\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))))",
          "old_line_content": "\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),",
          "new_line_content": "\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 5112,
          "old_api": "RelationGetRelationName",
          "new_api": "errcode",
          "old_text": "RelationGetRelationName(rel)",
          "new_text": "errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED)",
          "old_line_content": "\t\t\t\t\tRelationGetRelationName(rel)),",
          "new_line_content": "\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "content_same": false
        },
        {
          "line": 5113,
          "old_api": "errdetail",
          "new_api": "errmsg",
          "old_text": "errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap))",
          "new_text": "errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel))",
          "old_line_content": "\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",",
          "new_line_content": "\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 5116,
          "old_api": "RelationGetRelationName",
          "new_api": "BTMaxItemSize",
          "old_text": "RelationGetRelationName(heap)",
          "new_text": "BTMaxItemSize(page)",
          "old_line_content": "\t\t\t\t\t   RelationGetRelationName(heap)),",
          "new_line_content": "\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :",
          "content_same": false
        },
        {
          "line": 5117,
          "old_api": "errhint",
          "new_api": "BTMaxItemSizeNoHeapTid",
          "old_text": "errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\")",
          "new_text": "BTMaxItemSizeNoHeapTid(page)",
          "old_line_content": "\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"",
          "new_line_content": "\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),",
          "content_same": false
        },
        {
          "line": 5120,
          "old_api": "RelationGetRelationName",
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": "RelationGetRelationName(rel)",
          "new_text": "BTreeTupleGetHeapTID(newtup)",
          "old_line_content": "\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))));",
          "new_line_content": "\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 4109,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "",
          "new_line_content": "\tif (ScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 4113,
          "old_api": null,
          "new_api": "Max",
          "old_text": null,
          "new_text": "Max((int) pstate->minoff,\n\t\t\t\t\t\t  (int) pstate->offnum - pstate->targetdistance)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t false, 0, NULL))",
          "new_line_content": "\t\taheadoffnum = Max((int) pstate->minoff,",
          "content_same": false
        },
        {
          "line": 4116,
          "old_api": null,
          "new_api": "PageGetItem",
          "old_text": null,
          "new_text": "PageGetItem(pstate->page,\n\t\t\t\t\t\t\t\t\t PageGetItemId(pstate->page, aheadoffnum))",
          "old_line_content": "\t\t * Success -- instruct _bt_readpage to skip ahead to very next tuple",
          "new_line_content": "\tahead = (IndexTuple) PageGetItem(pstate->page,",
          "content_same": false
        },
        {
          "line": 4117,
          "old_api": null,
          "new_api": "PageGetItemId",
          "old_text": null,
          "new_text": "PageGetItemId(pstate->page, aheadoffnum)",
          "old_line_content": "\t\t * after the one we determined was still before the current array keys",
          "new_line_content": "\t\t\t\t\t\t\t\t\t PageGetItemId(pstate->page, aheadoffnum));",
          "content_same": false
        },
        {
          "line": 4118,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, ahead, tupdesc, tupnatts,\n\t\t\t\t\t\t\t\t\t false, 0, NULL)",
          "old_line_content": "\t\t */",
          "new_line_content": "\tif (_bt_tuple_before_array_skeys(scan, dir, ahead, tupdesc, tupnatts,",
          "content_same": false
        },
        {
          "line": 2075,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t((ScanDirectionIsForward(dir) && result > 0) ||",
          "content_same": false
        },
        {
          "line": 2076,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\t (ScanDirectionIsBackward(dir) && result < 0)))",
          "content_same": false
        },
        {
          "line": 4125,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(all_required_satisfied && all_satisfied)",
          "old_line_content": "\t\t\t * interesting scan keys (all required scan keys plus non-required",
          "new_line_content": "\t\tAssert(all_required_satisfied && all_satisfied);",
          "content_same": false
        },
        {
          "line": 4140,
          "old_api": null,
          "new_api": "Max",
          "old_text": null,
          "new_text": "Max(pstate->targetdistance / 8, 1)",
          "old_line_content": " * told us were killed",
          "new_line_content": "\t\tpstate->targetdistance = Max(pstate->targetdistance / 8, 1);",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": null,
          "new_api": "_bt_advance_array_keys_increment",
          "old_text": null,
          "new_text": "_bt_advance_array_keys_increment(scan, dir)",
          "old_line_content": "\t * Does tuple now satisfy our new qual?  Recheck with _bt_check_compare.",
          "new_line_content": "\tif (beyond_end_advance && !_bt_advance_array_keys_increment(scan, dir))",
          "content_same": false
        },
        {
          "line": 2121,
          "old_api": null,
          "new_api": "_bt_verify_keys_with_arraykeys",
          "old_text": null,
          "new_text": "_bt_verify_keys_with_arraykeys(scan)",
          "old_line_content": "\t * satisfies all required scan keys, but not all nonrequired array keys,",
          "new_line_content": "\tAssert(_bt_verify_keys_with_arraykeys(scan));",
          "content_same": false
        },
        {
          "line": 4188,
          "old_api": null,
          "new_api": "BTScanPosIsValid",
          "old_text": null,
          "new_text": "BTScanPosIsValid(so->currPos)",
          "old_line_content": "\tso->numKilled = 0;",
          "new_line_content": "\tAssert(BTScanPosIsValid(so->currPos));",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(all_required_satisfied)",
          "old_line_content": "\t\t\t!so->scanBehind)",
          "new_line_content": "\t\tAssert(all_required_satisfied);",
          "content_same": false
        },
        {
          "line": 4196,
          "old_api": null,
          "new_api": "BTScanPosIsPinned",
          "old_text": null,
          "new_text": "BTScanPosIsPinned(so->currPos)",
          "old_line_content": "\t\t * LSN.",
          "new_line_content": "\tif (BTScanPosIsPinned(so->currPos))",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(all_satisfied && continuescan)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tAssert(all_satisfied && continuescan);",
          "content_same": false
        },
        {
          "line": 4205,
          "old_api": null,
          "new_api": "_bt_lockbuf",
          "old_text": null,
          "new_text": "_bt_lockbuf(scan->indexRelation, so->currPos.buf, BT_READ)",
          "old_line_content": "\t\tBuffer\t\tbuf;",
          "new_line_content": "\t\t_bt_lockbuf(scan->indexRelation, so->currPos.buf, BT_READ);",
          "content_same": false
        },
        {
          "line": 4207,
          "old_api": null,
          "new_api": "BufferGetPage",
          "old_text": null,
          "new_text": "BufferGetPage(so->currPos.buf)",
          "old_line_content": "\t\tdroppedpin = true;",
          "new_line_content": "\t\tpage = BufferGetPage(so->currPos.buf);",
          "content_same": false
        },
        {
          "line": 4215,
          "old_api": null,
          "new_api": "_bt_getbuf",
          "old_text": null,
          "new_text": "_bt_getbuf(scan->indexRelation, so->currPos.currPage, BT_READ)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tbuf = _bt_getbuf(scan->indexRelation, so->currPos.currPage, BT_READ);",
          "content_same": false
        },
        {
          "line": 4218,
          "old_api": null,
          "new_api": "BufferGetLSNAtomic",
          "old_text": null,
          "new_text": "BufferGetLSNAtomic(buf)",
          "old_line_content": "\t\t\treturn;",
          "new_line_content": "\t\tif (BufferGetLSNAtomic(buf) == so->currPos.lsn)",
          "content_same": false
        },
        {
          "line": 2178,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(!continuescan)",
          "old_line_content": "",
          "new_line_content": "\t\tif (unlikely(!continuescan))",
          "content_same": false
        },
        {
          "line": 4228,
          "old_api": null,
          "new_api": "BTPageGetOpaque",
          "old_text": null,
          "new_text": "BTPageGetOpaque(page)",
          "old_line_content": "\t\tint\t\t\titemIndex = so->killedItems[i];",
          "new_line_content": "\topaque = BTPageGetOpaque(page);",
          "content_same": false
        },
        {
          "line": 4229,
          "old_api": null,
          "new_api": "P_FIRSTDATAKEY",
          "old_text": null,
          "new_text": "P_FIRSTDATAKEY(opaque)",
          "old_line_content": "\t\tBTScanPosItem *kitem = &so->currPos.items[itemIndex];",
          "new_line_content": "\tminoff = P_FIRSTDATAKEY(opaque);",
          "content_same": false
        },
        {
          "line": 2182,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(sktrig_required)",
          "old_line_content": "\t\t\t * recursing.  We'll consume a small, fixed amount of stack space.",
          "new_line_content": "\t\t\tAssert(sktrig_required);",
          "content_same": false
        },
        {
          "line": 2183,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->keyData[nsktrig].sk_strategy != BTEqualStrategyNumber)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tAssert(so->keyData[nsktrig].sk_strategy != BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 4230,
          "old_api": null,
          "new_api": "PageGetMaxOffsetNumber",
          "old_text": null,
          "new_text": "PageGetMaxOffsetNumber(page)",
          "old_line_content": "\t\tOffsetNumber offnum = kitem->indexOffset;",
          "new_line_content": "\tmaxoff = PageGetMaxOffsetNumber(page);",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!beyond_end_advance)",
          "old_line_content": "\t\t\t/* This tuple doesn't satisfy the inequality */",
          "new_line_content": "\t\t\tAssert(!beyond_end_advance);",
          "content_same": false
        },
        {
          "line": 2193,
          "old_api": null,
          "new_api": "_bt_advance_array_keys",
          "old_text": null,
          "new_text": "_bt_advance_array_keys(scan, pstate, tuple, tupnatts,\n\t\t\t\t\t\t\t\t\t\t\t   tupdesc, nsktrig, true)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tsatisfied = _bt_advance_array_keys(scan, pstate, tuple, tupnatts,",
          "content_same": false
        },
        {
          "line": 4244,
          "old_api": null,
          "new_api": "PageGetItemId",
          "old_text": null,
          "new_text": "PageGetItemId(page, offnum)",
          "old_line_content": "\t\t\t\tint\t\t\tpi = i + 1;",
          "new_line_content": "\t\t\tItemId\t\tiid = PageGetItemId(page, offnum);",
          "content_same": false
        },
        {
          "line": 2197,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!satisfied)",
          "old_line_content": "\t\t *",
          "new_line_content": "\t\t\tAssert(!satisfied);",
          "content_same": false
        },
        {
          "line": 4248,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(ituple)",
          "old_line_content": "\t\t\t\t/*",
          "new_line_content": "\t\t\tif (BTreeTupleIsPosting(ituple))",
          "content_same": false
        },
        {
          "line": 4251,
          "old_api": null,
          "new_api": "BTreeTupleGetNPosting",
          "old_text": null,
          "new_text": "BTreeTupleGetNPosting(ituple)",
          "old_line_content": "\t\t\t\t * group of TIDs that originally came from a posting list",
          "new_line_content": "\t\t\t\tint\t\t\tnposting = BTreeTupleGetNPosting(ituple);",
          "content_same": false
        },
        {
          "line": 4270,
          "old_api": null,
          "new_api": "BTreeTupleGetPostingN",
          "old_text": null,
          "new_text": "BTreeTupleGetPostingN(ituple, j)",
          "old_line_content": "\t\t\t\t\t * kitem must have matching offnum when heap TIDs match,",
          "new_line_content": "\t\t\t\t\tItemPointer item = BTreeTupleGetPostingN(ituple, j);",
          "content_same": false
        },
        {
          "line": 4272,
          "old_api": null,
          "new_api": "ItemPointerEquals",
          "old_text": null,
          "new_text": "ItemPointerEquals(item, &kitem->heapTid)",
          "old_line_content": "\t\t\t\t\t * have been concurrently modified",
          "new_line_content": "\t\t\t\t\tif (!ItemPointerEquals(item, &kitem->heapTid))",
          "content_same": false
        },
        {
          "line": 4280,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(kitem->indexOffset == offnum || !droppedpin)",
          "old_line_content": "\t\t\t\t\t * will prevent us from considering the posting list tuple",
          "new_line_content": "\t\t\t\t\tAssert(kitem->indexOffset == offnum || !droppedpin);",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts,\n\t\t\t\t\t\t\t\t\t\tfalse, 0, NULL)",
          "old_line_content": "\t * sibling page when the page's finaltup satisfies all required scan keys",
          "new_line_content": "\tAssert(_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts,",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,\n\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup, rel),\n\t\t\t\t\t\t\t\t\t false, 0, &so->scanBehind)",
          "old_line_content": "\t * When we encounter a truncated finaltup high key attribute, we're",
          "new_line_content": "\t\t_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "BTreeTupleGetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleGetNAtts(pstate->finaltup, rel)",
          "old_line_content": "\t * optimistic about the chances of its corresponding required scan key",
          "new_line_content": "\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup, rel),",
          "content_same": false
        },
        {
          "line": 4312,
          "old_api": null,
          "new_api": "ItemPointerEquals",
          "old_text": null,
          "new_text": "ItemPointerEquals(&ituple->t_tid, &kitem->heapTid)",
          "old_line_content": "\t\t\t * it's possible that multiple processes attempt to do this",
          "new_line_content": "\t\t\telse if (ItemPointerEquals(&ituple->t_tid, &kitem->heapTid))",
          "content_same": false
        },
        {
          "line": 4323,
          "old_api": null,
          "new_api": "ItemIdIsDead",
          "old_text": null,
          "new_text": "ItemIdIsDead(iid)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\tif (killtuple && !ItemIdIsDead(iid))",
          "content_same": false
        },
        {
          "line": 4326,
          "old_api": null,
          "new_api": "ItemIdMarkDead",
          "old_text": null,
          "new_text": "ItemIdMarkDead(iid)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tItemIdMarkDead(iid);",
          "content_same": false
        },
        {
          "line": 4330,
          "old_api": null,
          "new_api": "OffsetNumberNext",
          "old_text": null,
          "new_text": "OffsetNumberNext(offnum)",
          "old_line_content": "\t *",
          "new_line_content": "\t\t\toffnum = OffsetNumberNext(offnum);",
          "content_same": false
        },
        {
          "line": 4344,
          "old_api": null,
          "new_api": "MarkBufferDirtyHint",
          "old_text": null,
          "new_text": "MarkBufferDirtyHint(so->currPos.buf, true)",
          "old_line_content": "",
          "new_line_content": "\t\tMarkBufferDirtyHint(so->currPos.buf, true);",
          "content_same": false
        },
        {
          "line": 4347,
          "old_api": null,
          "new_api": "_bt_unlockbuf",
          "old_text": null,
          "new_text": "_bt_unlockbuf(scan->indexRelation, so->currPos.buf)",
          "old_line_content": " * assignment of \"vacuum cycle IDs\" to currently-active btree vacuuming",
          "new_line_content": "\t_bt_unlockbuf(scan->indexRelation, so->currPos.buf);",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": null,
          "new_api": "BTreeTupleGetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleGetNAtts(pstate->finaltup, rel)",
          "old_line_content": "\t\t * We're checking finaltup (which is usually not caller's tuple), so",
          "new_line_content": "\t\tint\t\t\tnfinaltupatts = BTreeTupleGetNAtts(pstate->finaltup, rel);",
          "content_same": false
        },
        {
          "line": 4399,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(BtreeVacuumLock, LW_SHARED)",
          "old_line_content": "\t\tif (vac->relid.relId == rel->rd_lockInfo.lockRelId.relId &&",
          "new_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_SHARED);",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!so->scanBehind)",
          "old_line_content": "\t\t\t\t\t\t  &continuescanflip, &opsktrig);",
          "new_line_content": "\t\tAssert(!so->scanBehind);",
          "content_same": false
        },
        {
          "line": 4413,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": " *",
          "new_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": null,
          "new_api": "_bt_check_compare",
          "old_text": null,
          "new_text": "_bt_check_compare(scan, flipped,\n\t\t\t\t\t\t  pstate->finaltup, nfinaltupatts, tupdesc,\n\t\t\t\t\t\t  false, false, false,\n\t\t\t\t\t\t  &continuescanflip, &opsktrig)",
          "old_line_content": "\t\t * If we ended up here due to the all_required_satisfied criteria,",
          "new_line_content": "\t\t_bt_check_compare(scan, flipped,",
          "content_same": false
        },
        {
          "line": 4433,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "old_line_content": "\tresult = ++(btvacinfo->cycle_ctr);",
          "new_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(all_required_satisfied != oppodir_inequality_sktrig)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(all_required_satisfied != oppodir_inequality_sktrig);",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(!continuescanflip &&\n\t\t\t\t\t ((all_required_satisfied && opsktrig > sktrig) ||\n\t\t\t\t\t  (oppodir_inequality_sktrig && opsktrig >= sktrig)))",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\tif (unlikely(!continuescanflip &&",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "_bt_rewind_nonrequired_arrays",
          "old_text": null,
          "new_text": "_bt_rewind_nonrequired_arrays(scan, dir)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\t\t_bt_rewind_nonrequired_arrays(scan, dir);",
          "content_same": false
        },
        {
          "line": 4456,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": "\t/* OK, add an entry */",
          "new_line_content": "\t\t\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 4457,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",\n\t\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "\tif (btvacinfo->num_vacuums >= btvacinfo->max_vacuums)",
          "new_line_content": "\t\t\telog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 4458,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 4465,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": "\tbtvacinfo->num_vacuums++;",
          "new_line_content": "\t\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 4466,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"out of btvacinfo slots\")",
          "old_line_content": "",
          "new_line_content": "\t\telog(ERROR, \"out of btvacinfo slots\");",
          "content_same": false
        },
        {
          "line": 4473,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": " *",
          "new_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(ScanDirectionIsForward(dir));",
          "content_same": false
        },
        {
          "line": 4488,
          "old_api": null,
          "new_api": "LWLockAcquire",
          "old_text": null,
          "new_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "old_line_content": "",
          "new_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "content_same": false
        },
        {
          "line": 2447,
          "old_api": null,
          "new_api": "_bt_parallel_primscan_schedule",
          "old_text": null,
          "new_text": "_bt_parallel_primscan_schedule(scan, pstate->prev_scan_page)",
          "old_line_content": "",
          "new_line_content": "\t\t_bt_parallel_primscan_schedule(scan, pstate->prev_scan_page);",
          "content_same": false
        },
        {
          "line": 4505,
          "old_api": null,
          "new_api": "LWLockRelease",
          "old_text": null,
          "new_text": "LWLockRelease(BtreeVacuumLock)",
          "old_line_content": "void",
          "new_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "content_same": false
        },
        {
          "line": 4514,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(arg)",
          "old_line_content": "Size",
          "new_line_content": "\t_bt_end_vacuum((Relation) DatumGetPointer(arg));",
          "content_same": false
        },
        {
          "line": 4525,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(BTVacInfo, vacuums)",
          "old_line_content": " * BTreeShmemInit --- initialize this module's shared memory",
          "new_line_content": "\tsize = offsetof(BTVacInfo, vacuums);",
          "content_same": false
        },
        {
          "line": 4526,
          "old_api": null,
          "new_api": "mul_size",
          "old_text": null,
          "new_text": "mul_size(MaxBackends, sizeof(BTOneVacInfo))",
          "old_line_content": " */",
          "new_line_content": "\tsize = add_size(size, mul_size(MaxBackends, sizeof(BTOneVacInfo)));",
          "content_same": false
        },
        {
          "line": 4538,
          "old_api": null,
          "new_api": "ShmemInitStruct",
          "old_text": null,
          "new_text": "ShmemInitStruct(\"BTree Vacuum State\",\n\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),\n\t\t\t\t\t\t\t\t\t\t\t  &found)",
          "old_line_content": "\t\t/* Initialize shared memory area */",
          "new_line_content": "\tbtvacinfo = (BTVacInfo *) ShmemInitStruct(\"BTree Vacuum State\",",
          "content_same": false
        },
        {
          "line": 4545,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!found)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tAssert(!found);",
          "content_same": false
        },
        {
          "line": 4558,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(found)",
          "old_line_content": "\tstatic const relopt_parse_elt tab[] = {",
          "new_line_content": "\t\tAssert(found);",
          "content_same": false
        },
        {
          "line": 4565,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(BTOptions, fillfactor)",
          "old_line_content": "",
          "new_line_content": "\t\t{\"fillfactor\", RELOPT_TYPE_INT, offsetof(BTOptions, fillfactor)},",
          "content_same": false
        },
        {
          "line": 4567,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(BTOptions, vacuum_cleanup_index_scale_factor)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t  RELOPT_KIND_BTREE,",
          "new_line_content": "\t\toffsetof(BTOptions, vacuum_cleanup_index_scale_factor)},",
          "content_same": false
        },
        {
          "line": 4572,
          "old_api": null,
          "new_api": "build_reloptions",
          "old_text": null,
          "new_text": "build_reloptions(reloptions, validate,\n\t\t\t\t\t\t\t\t\t  RELOPT_KIND_BTREE,\n\t\t\t\t\t\t\t\t\t  sizeof(BTOptions),\n\t\t\t\t\t\t\t\t\t  tab, lengthof(tab))",
          "old_line_content": "/*",
          "new_line_content": "\treturn (bytea *) build_reloptions(reloptions, validate,",
          "content_same": false
        },
        {
          "line": 4575,
          "old_api": null,
          "new_api": "lengthof",
          "old_text": null,
          "new_text": "lengthof(tab)",
          "old_line_content": " * This is optional, but handling AMPROP_RETURNABLE here saves opening the rel",
          "new_line_content": "\t\t\t\t\t\t\t\t\t  tab, lengthof(tab));",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->numArrayKeys)",
          "old_line_content": "\tso->qual_ok = true;",
          "new_line_content": "\t\tAssert(so->numArrayKeys);",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": null,
          "new_api": "_bt_verify_keys_with_arraykeys",
          "old_text": null,
          "new_text": "_bt_verify_keys_with_arraykeys(scan)",
          "old_line_content": "\tso->numberOfKeys = 0;",
          "new_line_content": "\t\tAssert(_bt_verify_keys_with_arraykeys(scan));",
          "content_same": false
        },
        {
          "line": 2601,
          "old_api": null,
          "new_api": "_bt_preprocess_array_keys",
          "old_text": null,
          "new_text": "_bt_preprocess_array_keys(scan)",
          "old_line_content": "",
          "new_line_content": "\tarrayKeyData = _bt_preprocess_array_keys(scan);",
          "content_same": false
        },
        {
          "line": 4659,
          "old_api": null,
          "new_api": "RelationGetDescr",
          "old_text": null,
          "new_text": "RelationGetDescr(rel)",
          "old_line_content": "\tSize\t\tnewsize;",
          "new_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "content_same": false
        },
        {
          "line": 4660,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "",
          "new_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(so->arrayContext,\n\t\t\t\t\t\t\t\t\t\tnumberOfKeys * sizeof(int))",
          "old_line_content": "\toutkeys = so->keyData;",
          "new_line_content": "\t\tkeyDataMap = MemoryContextAlloc(so->arrayContext,",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(outkey->sk_strategy != InvalidStrategy)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(outkey->sk_strategy != InvalidStrategy);",
          "content_same": false
        },
        {
          "line": 4671,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(firstright)",
          "old_line_content": "\t/* Force truncation to be ineffective for testing purposes */",
          "new_line_content": "\tAssert(!BTreeTupleIsPivot(lastleft) && !BTreeTupleIsPivot(firstright));",
          "content_same": false
        },
        {
          "line": 4674,
          "old_api": null,
          "new_api": "_bt_keep_natts",
          "old_text": null,
          "new_text": "_bt_keep_natts(rel, lastleft, firstright, itup_key)",
          "old_line_content": "",
          "new_line_content": "\tkeepnatts = _bt_keep_natts(rel, lastleft, firstright, itup_key);",
          "content_same": false
        },
        {
          "line": 581,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(last_equal_output_ikey < output_ikey)",
          "old_line_content": "\t\t * not all input keys become output keys.  Take care of it now.",
          "new_line_content": "\t\tAssert(last_equal_output_ikey < output_ikey);",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(last_equal_output_ikey < input_ikey)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tAssert(last_equal_output_ikey < input_ikey);",
          "content_same": false
        },
        {
          "line": 4681,
          "old_api": null,
          "new_api": "index_truncate_tuple",
          "old_text": null,
          "new_text": "index_truncate_tuple(itupdesc, firstright,\n\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts))",
          "old_line_content": "\t\t * index_truncate_tuple() just returns a straight copy of firstright",
          "new_line_content": "\tpivot = index_truncate_tuple(itupdesc, firstright,",
          "content_same": false
        },
        {
          "line": 4682,
          "old_api": null,
          "new_api": "Min",
          "old_text": null,
          "new_text": "Min(keepnatts, nkeyatts)",
          "old_line_content": "\t\t * when it has no attributes to truncate.  When that happens, we may",
          "new_line_content": "\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts));",
          "content_same": false
        },
        {
          "line": 2636,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(outkeys, cur, sizeof(ScanKeyData))",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tmemcpy(outkeys, cur, sizeof(ScanKeyData));",
          "content_same": false
        },
        {
          "line": 4684,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(pivot)",
          "old_line_content": "\t\t */",
          "new_line_content": "\tif (BTreeTupleIsPosting(pivot))",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": null,
          "new_api": "_bt_mark_scankey_required",
          "old_text": null,
          "new_text": "_bt_mark_scankey_required(outkeys)",
          "old_line_content": "\t\t\t * that's not nearly as important when there's only one scan key)",
          "new_line_content": "\t\t\t_bt_mark_scankey_required(outkeys);",
          "content_same": false
        },
        {
          "line": 4691,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\tAssert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1);",
          "content_same": false
        },
        {
          "line": 4692,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfAttributes(rel)",
          "old_line_content": "\t * If there is a distinguishing key attribute within pivot tuple, we're",
          "new_line_content": "\t\tAssert(IndexRelationGetNumberOfAttributes(rel) == nkeyatts);",
          "content_same": false
        },
        {
          "line": 4694,
          "old_api": null,
          "new_api": "BTreeTupleGetPostingOffset",
          "old_text": null,
          "new_text": "BTreeTupleGetPostingOffset(firstright)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tpivot->t_info |= MAXALIGN(BTreeTupleGetPostingOffset(firstright));",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur->sk_flags & SK_SEARCHARRAY)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\t\t\tAssert(cur->sk_flags & SK_SEARCHARRAY);",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur->sk_strategy != BTEqualStrategyNumber ||\n\t\t\t\t   (so->arrayKeys[0].scan_key == 0 &&\n\t\t\t\t\tOidIsValid(so->orderProcs[0].fn_oid)))",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tAssert(cur->sk_strategy != BTEqualStrategyNumber ||",
          "content_same": false
        },
        {
          "line": 2651,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(so->orderProcs[0].fn_oid)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\t\t\t\tOidIsValid(so->orderProcs[0].fn_oid)));",
          "content_same": false
        },
        {
          "line": 4703,
          "old_api": null,
          "new_api": "BTreeTupleSetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleSetNAtts(pivot, keepnatts, false)",
          "old_line_content": "\t * key attribute value in firstright distinguishes the right side of the",
          "new_line_content": "\t\tBTreeTupleSetNAtts(pivot, keepnatts, false);",
          "content_same": false
        },
        {
          "line": 608,
          "old_api": null,
          "new_api": "_bt_setup_array_cmp",
          "old_text": null,
          "new_text": "_bt_setup_array_cmp(scan, outkey, elemtype,\n\t\t\t\t\t\t\t\t&so->orderProcs[output_ikey], NULL)",
          "old_line_content": "\t\t * Reorder existing array scan key so->orderProcs[] entries.",
          "new_line_content": "\t\t\t_bt_setup_array_cmp(scan, outkey, elemtype,",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(xform, 0, sizeof(xform))",
          "old_line_content": "\t */",
          "new_line_content": "\tmemset(xform, 0, sizeof(xform));",
          "content_same": false
        },
        {
          "line": 4720,
          "old_api": null,
          "new_api": "MAXALIGN",
          "old_text": null,
          "new_text": "MAXALIGN(sizeof(ItemPointerData))",
          "old_line_content": "\t/*",
          "new_line_content": "\tnewsize = MAXALIGN(IndexTupleSize(pivot)) + MAXALIGN(sizeof(ItemPointerData));",
          "content_same": false
        },
        {
          "line": 4721,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(newsize)",
          "old_line_content": "\t * Store all of firstright's key attribute values plus a tiebreaker heap",
          "new_line_content": "\ttidpivot = palloc0(newsize);",
          "content_same": false
        },
        {
          "line": 4722,
          "old_api": null,
          "new_api": "IndexTupleSize",
          "old_text": null,
          "new_text": "IndexTupleSize(pivot)",
          "old_line_content": "\t * TID value in enlarged pivot tuple",
          "new_line_content": "\tmemcpy(tidpivot, pivot, MAXALIGN(IndexTupleSize(pivot)));",
          "content_same": false
        },
        {
          "line": 628,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->num_elems > 0)",
          "old_line_content": "\t\t\t\tfound = true;",
          "new_line_content": "\t\t\tAssert(array->num_elems > 0);",
          "content_same": false
        },
        {
          "line": 4724,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(pivot)",
          "old_line_content": "\ttidpivot->t_info &= ~INDEX_SIZE_MASK;",
          "new_line_content": "\tpfree(pivot);",
          "content_same": false
        },
        {
          "line": 2682,
          "old_api": null,
          "new_api": "_bt_fix_scankey_strategy",
          "old_text": null,
          "new_text": "_bt_fix_scankey_strategy(cur, indoption)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tif (!_bt_fix_scankey_strategy(cur, indoption))",
          "content_same": false
        },
        {
          "line": 4732,
          "old_api": null,
          "new_api": "BTreeTupleSetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleSetNAtts(tidpivot, nkeyatts, true)",
          "old_line_content": "\t * example in cases where no truncation takes place -- use lastleft's heap",
          "new_line_content": "\tBTreeTupleSetNAtts(tidpivot, nkeyatts, true);",
          "content_same": false
        },
        {
          "line": 4733,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(tidpivot)",
          "old_line_content": "\t * TID.  (This is also the closest value to negative infinity that's",
          "new_line_content": "\tpivotheaptid = BTreeTupleGetHeapTID(tidpivot);",
          "content_same": false
        },
        {
          "line": 4742,
          "old_api": null,
          "new_api": "BTreeTupleGetMaxHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "old_line_content": "\t * be inserted into the parent page in the second phase of a page split be",
          "new_line_content": "\tItemPointerCopy(BTreeTupleGetMaxHeapTID(lastleft), pivotheaptid);",
          "content_same": false
        },
        {
          "line": 652,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(array, array + 1,\n\t\t\t\t\t\t\tsizeof(BTArrayKeyInfo) *\n\t\t\t\t\t\t\t(so->numArrayKeys - arrayidx))",
          "old_line_content": "\t\t\t\t\t * just shifted forward to the offset at arrayidx, which",
          "new_line_content": "\t\t\t\t\tmemmove(array, array + 1,",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"btree index keys must be ordered by attribute\")",
          "old_line_content": "\t\t\t *",
          "new_line_content": "\t\t\t\telog(ERROR, \"btree index keys must be ordered by attribute\");",
          "content_same": false
        },
        {
          "line": 4755,
          "old_api": null,
          "new_api": "BTreeTupleGetMaxHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "old_line_content": "#else",
          "new_line_content": "\tAssert(ItemPointerCompare(BTreeTupleGetMaxHeapTID(lastleft),",
          "content_same": false
        },
        {
          "line": 4756,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "content_same": false
        },
        {
          "line": 4757,
          "old_api": null,
          "new_api": "ItemPointerCompare",
          "old_text": null,
          "new_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft))",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 4758,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(lastleft)",
          "old_line_content": "\t * Those invariants aren't guaranteed to hold for lastleft + firstright",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft)) >= 0);",
          "content_same": false
        },
        {
          "line": 4759,
          "old_api": null,
          "new_api": "ItemPointerCompare",
          "old_text": null,
          "new_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "old_line_content": "\t * heap TID attribute values when they're considered here only because",
          "new_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 4760,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "\t * DEBUG_NO_TRUNCATE is defined (a heap TID is probably not actually",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(found)",
          "old_line_content": "\t * the next primitive index scan.  The underlying structure is protected",
          "new_line_content": "\t\tAssert(found);",
          "content_same": false
        },
        {
          "line": 4773,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "\t */",
          "new_line_content": "\tItemPointerCopy(BTreeTupleGetHeapTID(firstright), pivotheaptid);",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->scan_key == eq_in_ikey)",
          "old_line_content": "\t\t\t\t\tScanKey\t\tchk = xform[j].skey;",
          "new_line_content": "\t\t\t\t\tAssert(array->scan_key == eq_in_ikey);",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(orderproc->fn_oid)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tAssert(OidIsValid(orderproc->fn_oid));",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg_internal(\"number of array scan keys left by preprocessing (%d) exceeds the maximum allowed by parallel btree index scans (%d)\",\n\t\t\t\t\t\t\t\t so->numArrayKeys, INDEX_MAX_KEYS)))",
          "old_line_content": "/*",
          "new_line_content": "\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "errcode",
          "old_text": null,
          "new_text": "errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED)",
          "old_line_content": " * _bt_setup_array_cmp() -- Set up array comparison functions",
          "new_line_content": "\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": null,
          "new_api": "errmsg_internal",
          "old_text": null,
          "new_text": "errmsg_internal(\"number of array scan keys left by preprocessing (%d) exceeds the maximum allowed by parallel btree index scans (%d)\",\n\t\t\t\t\t\t\t\t so->numArrayKeys, INDEX_MAX_KEYS)",
          "old_line_content": " *",
          "new_line_content": "\t\t\t\t errmsg_internal(\"number of array scan keys left by preprocessing (%d) exceeds the maximum allowed by parallel btree index scans (%d)\",",
          "content_same": false
        },
        {
          "line": 4780,
          "old_api": null,
          "new_api": "ItemPointerSetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerSetOffsetNumber(pivotheaptid,\n\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)))",
          "old_line_content": "\treturn tidpivot;",
          "new_line_content": "\tItemPointerSetOffsetNumber(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 4781,
          "old_api": null,
          "new_api": "ItemPointerGetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerGetOffsetNumber(pivotheaptid)",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)));",
          "content_same": false
        },
        {
          "line": 4782,
          "old_api": null,
          "new_api": "ItemPointerCompare",
          "old_text": null,
          "new_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "old_line_content": "",
          "new_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "content_same": false
        },
        {
          "line": 4783,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(firstright)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "_bt_compare_scankey_args",
          "old_text": null,
          "new_text": "_bt_compare_scankey_args(scan, chk, eq, chk,\n\t\t\t\t\t\t\t\t\t\t\t\t array, orderproc,\n\t\t\t\t\t\t\t\t\t\t\t\t &test_result)",
          "old_line_content": "\t\t\t\t\t\t\t/* keys proven mutually contradictory */",
          "new_line_content": "\t\t\t\t\tif (_bt_compare_scankey_args(scan, chk, eq, chk,",
          "content_same": false
        },
        {
          "line": 4804,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t * _bt_compare() treats truncated key attributes as having the value minus",
          "new_line_content": "\tint\t\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 4805,
          "old_api": null,
          "new_api": "RelationGetDescr",
          "old_text": null,
          "new_text": "RelationGetDescr(rel)",
          "old_line_content": "\t * infinity, which would break searches within !heapkeyspace indexes.  We",
          "new_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "content_same": false
        },
        {
          "line": 2758,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!array || array->num_elems > 0)",
          "old_line_content": "\t\t\t\t/* track number of attrs for which we have \"=\" keys */",
          "new_line_content": "\t\t\t\t\t\tAssert(!array || array->num_elems > 0);",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(skey->sk_strategy == BTEqualStrategyNumber)",
          "old_line_content": "\t */",
          "new_line_content": "\tAssert(skey->sk_strategy == BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 722,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(elemtype)",
          "old_line_content": "\tif (elemtype == opcintype)",
          "new_line_content": "\tAssert(OidIsValid(elemtype));",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": null,
          "new_api": "_bt_compare_scankey_args",
          "old_text": null,
          "new_text": "_bt_compare_scankey_args(scan, le, lt, le, NULL, NULL,\n\t\t\t\t\t\t\t\t\t\t\t &test_result)",
          "old_line_content": "\t\t\t\t\t\txform[BTLessStrategyNumber - 1].skey = NULL;",
          "new_line_content": "\t\t\t\tif (_bt_compare_scankey_args(scan, le, lt, le, NULL, NULL,",
          "content_same": false
        },
        {
          "line": 4826,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "old_line_content": "\t\tif (!isNull1 &&",
          "new_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "index_getprocinfo",
          "old_text": null,
          "new_text": "index_getprocinfo(rel, skey->sk_attno, BTORDER_PROC)",
          "old_line_content": "",
          "new_line_content": "\t\t*orderproc = *index_getprocinfo(rel, skey->sk_attno, BTORDER_PROC);",
          "content_same": false
        },
        {
          "line": 4833,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(&scankey->sk_func,\n\t\t\t\t\t\t\t\t\t\t\tscankey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\tdatum1,\n\t\t\t\t\t\t\t\t\t\t\tdatum2)",
          "old_line_content": "\t\tkeepnatts++;",
          "new_line_content": "\t\t\tDatumGetInt32(FunctionCall2Coll(&scankey->sk_func,",
          "content_same": false
        },
        {
          "line": 2792,
          "old_api": null,
          "new_api": "_bt_compare_scankey_args",
          "old_text": null,
          "new_text": "_bt_compare_scankey_args(scan, ge, gt, ge, NULL, NULL,\n\t\t\t\t\t\t\t\t\t\t\t &test_result)",
          "old_line_content": "\t\t\t\t\t\txform[BTGreaterStrategyNumber - 1].skey = NULL;",
          "new_line_content": "\t\t\t\tif (_bt_compare_scankey_args(scan, ge, gt, ge, NULL, NULL,",
          "content_same": false
        },
        {
          "line": 749,
          "old_api": null,
          "new_api": "get_opfamily_proc",
          "old_text": null,
          "new_text": "get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t opcintype, elemtype, BTORDER_PROC)",
          "old_line_content": "",
          "new_line_content": "\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],",
          "content_same": false
        },
        {
          "line": 4846,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!itup_key->allequalimage ||\n\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright))",
          "old_line_content": "/*",
          "new_line_content": "\tAssert(!itup_key->allequalimage ||",
          "content_same": false
        },
        {
          "line": 4847,
          "old_api": null,
          "new_api": "_bt_keep_natts_fast",
          "old_text": null,
          "new_text": "_bt_keep_natts_fast(rel, lastleft, firstright)",
          "old_line_content": " * _bt_keep_natts_fast - fast bitwise variant of _bt_keep_natts.",
          "new_line_content": "\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright));",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",\n\t\t\t BTORDER_PROC, opcintype, elemtype, skey->sk_attno,\n\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "",
          "new_line_content": "\t\telog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 754,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\tif (!sortprocp)",
          "new_line_content": "\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": null,
          "new_api": "fmgr_info_cxt",
          "old_text": null,
          "new_text": "fmgr_info_cxt(cmp_proc, orderproc, so->arrayContext)",
          "old_line_content": "\t/*",
          "new_line_content": "\tfmgr_info_cxt(cmp_proc, orderproc, so->arrayContext);",
          "content_same": false
        },
        {
          "line": 2813,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(outkey, xform[j].skey, sizeof(ScanKeyData))",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\tmemcpy(outkey, xform[j].skey, sizeof(ScanKeyData));",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": null,
          "new_api": "_bt_mark_scankey_required",
          "old_text": null,
          "new_text": "_bt_mark_scankey_required(outkey)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t\t\t\t_bt_mark_scankey_required(outkey);",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": null,
          "new_api": "get_opfamily_proc",
          "old_text": null,
          "new_text": "get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t elemtype, elemtype, BTORDER_PROC)",
          "old_line_content": "",
          "new_line_content": "\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",\n\t\t\t BTORDER_PROC, elemtype, elemtype,\n\t\t\t skey->sk_attno, RelationGetRelationName(rel))",
          "old_line_content": "}",
          "new_line_content": "\t\telog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t skey->sk_attno, RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "fmgr_info_cxt",
          "old_text": null,
          "new_text": "fmgr_info_cxt(cmp_proc, *sortprocp, so->arrayContext)",
          "old_line_content": " * scan and skey identify the index column, whose opfamily determines the",
          "new_line_content": "\tfmgr_info_cxt(cmp_proc, *sortprocp, so->arrayContext);",
          "content_same": false
        },
        {
          "line": 2829,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(xform, 0, sizeof(xform))",
          "old_line_content": "\t\t/* if row comparison, push it directly to the output array */",
          "new_line_content": "\t\t\tmemset(xform, 0, sizeof(xform));",
          "content_same": false
        },
        {
          "line": 4877,
          "old_api": null,
          "new_api": "RelationGetDescr",
          "old_text": null,
          "new_text": "RelationGetDescr(rel)",
          "old_line_content": "\t{",
          "new_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "content_same": false
        },
        {
          "line": 4878,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t\tDatum\t\tdatum1,",
          "new_line_content": "\tint\t\t\tkeysz = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 2840,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(outkey, cur, sizeof(ScanKeyData))",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\tmemcpy(outkey, cur, sizeof(ScanKeyData));",
          "content_same": false
        },
        {
          "line": 4890,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "old_line_content": "",
          "new_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "content_same": false
        },
        {
          "line": 4891,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "old_line_content": "\t\tif (!isNull1 &&",
          "new_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "content_same": false
        },
        {
          "line": 2850,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(j != (BTEqualStrategyNumber - 1))",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\tAssert(j != (BTEqualStrategyNumber - 1));",
          "content_same": false
        },
        {
          "line": 4898,
          "old_api": null,
          "new_api": "datum_image_eq",
          "old_text": null,
          "new_text": "datum_image_eq(datum1, datum2, att->attbyval, att->attlen)",
          "old_line_content": "\treturn keepnatts;",
          "new_line_content": "\t\t\t!datum_image_eq(datum1, datum2, att->attbyval, att->attlen))",
          "content_same": false
        },
        {
          "line": 811,
          "old_api": null,
          "new_api": "get_opfamily_member",
          "old_text": null,
          "new_text": "get_opfamily_member(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t elemtype,\n\t\t\t\t\t\t\t\t elemtype,\n\t\t\t\t\t\t\t\t strat)",
          "old_line_content": "\t\t\t strat, elemtype, elemtype,",
          "new_line_content": "\tcmp_op = get_opfamily_member(rel->rd_opfamily[skey->sk_attno - 1],",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(arrayKeyData)",
          "old_line_content": "\t\t\t(cur->sk_flags & SK_SEARCHARRAY))",
          "new_line_content": "\t\t\tAssert(arrayKeyData);",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur->sk_flags & SK_SEARCHARRAY)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tAssert(cur->sk_flags & SK_SEARCHARRAY);",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"missing operator %d(%u,%u) in opfamily %u\",\n\t\t\t strat, elemtype, elemtype,\n\t\t\t rel->rd_opfamily[skey->sk_attno - 1])",
          "old_line_content": "",
          "new_line_content": "\t\telog(ERROR, \"missing operator %d(%u,%u) in opfamily %u\",",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": null,
          "new_api": "RegProcedureIsValid",
          "old_text": null,
          "new_text": "RegProcedureIsValid(cmp_proc)",
          "old_line_content": "\tresult = elems[0];",
          "new_line_content": "\tif (!RegProcedureIsValid(cmp_proc))",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"missing oprcode for operator %u\", cmp_op)",
          "old_line_content": "\tfor (i = 1; i < nelems; i++)",
          "new_line_content": "\t\telog(ERROR, \"missing oprcode for operator %u\", cmp_op);",
          "content_same": false
        },
        {
          "line": 2869,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(arrayKeyData)",
          "old_line_content": "\t\t * operator strategy before now?",
          "new_line_content": "\t\t\tAssert(arrayKeyData);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(nelems > 0)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t   elems[i],",
          "new_line_content": "\tAssert(nelems > 0);",
          "content_same": false
        },
        {
          "line": 4924,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfAttributes(rel)",
          "old_line_content": "\t/*",
          "new_line_content": "\tint16\t\tnatts = IndexRelationGetNumberOfAttributes(rel);",
          "content_same": false
        },
        {
          "line": 829,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(&flinfo,\n\t\t\t\t\t\t\t\t\t\t   skey->sk_collation,\n\t\t\t\t\t\t\t\t\t\t   elems[i],\n\t\t\t\t\t\t\t\t\t\t   result)",
          "old_line_content": "",
          "new_line_content": "\t\tif (DatumGetBool(FunctionCall2Coll(&flinfo,",
          "content_same": false
        },
        {
          "line": 4925,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t * We cannot reliably test a deleted or half-dead page, since they have",
          "new_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "content_same": false
        },
        {
          "line": 4926,
          "old_api": null,
          "new_api": "BTPageGetOpaque",
          "old_text": null,
          "new_text": "BTPageGetOpaque(page)",
          "old_line_content": "\t * dummy high keys",
          "new_line_content": "\tBTPageOpaque opaque = BTPageGetOpaque(page);",
          "content_same": false
        },
        {
          "line": 4937,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(offnum >= FirstOffsetNumber &&\n\t\t   offnum <= PageGetMaxOffsetNumber(page))",
          "old_line_content": "\t/* !heapkeyspace indexes do not support deduplication */",
          "new_line_content": "\tAssert(offnum >= FirstOffsetNumber &&",
          "content_same": false
        },
        {
          "line": 4940,
          "old_api": null,
          "new_api": "PageGetItemId",
          "old_text": null,
          "new_text": "PageGetItemId(page, offnum)",
          "old_line_content": "",
          "new_line_content": "\titup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));",
          "content_same": false
        },
        {
          "line": 4941,
          "old_api": null,
          "new_api": "BTreeTupleGetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleGetNAtts(itup, rel)",
          "old_line_content": "\t/* Posting list tuples should never have \"pivot heap TID\" bit set */",
          "new_line_content": "\ttupnatts = BTreeTupleGetNAtts(itup, rel);",
          "content_same": false
        },
        {
          "line": 4944,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "\t\t BT_PIVOT_HEAP_TID_ATTR) != 0)",
          "new_line_content": "\tif (!heapkeyspace && BTreeTupleIsPosting(itup))",
          "content_same": false
        },
        {
          "line": 4949,
          "old_api": null,
          "new_api": "ItemPointerGetOffsetNumberNoCheck",
          "old_text": null,
          "new_text": "ItemPointerGetOffsetNumberNoCheck(&itup->t_tid)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\t\t(ItemPointerGetOffsetNumberNoCheck(&itup->t_tid) &",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->scan_key == i)",
          "old_line_content": "\t\t\t\t\torderproc = so->orderProcs + xform[j].ikey;",
          "new_line_content": "\t\t\t\t\tAssert(array->scan_key == i);",
          "content_same": false
        },
        {
          "line": 2904,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(orderproc->fn_oid)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tAssert(OidIsValid(orderproc->fn_oid));",
          "content_same": false
        },
        {
          "line": 4954,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tif (natts != nkeyatts && BTreeTupleIsPosting(itup))",
          "content_same": false
        },
        {
          "line": 4957,
          "old_api": null,
          "new_api": "P_ISLEAF",
          "old_text": null,
          "new_text": "P_ISLEAF(opaque)",
          "old_line_content": "\t\t\t * tuple",
          "new_line_content": "\tif (P_ISLEAF(opaque))",
          "content_same": false
        },
        {
          "line": 862,
          "old_api": null,
          "new_api": "qsort_arg",
          "old_text": null,
          "new_text": "qsort_arg(elems, nelems, sizeof(Datum),\n\t\t\t  _bt_compare_array_elements, &cxt)",
          "old_line_content": "}",
          "new_line_content": "\tqsort_arg(elems, nelems, sizeof(Datum),",
          "content_same": false
        },
        {
          "line": 2911,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->scan_key == xform[j].ikey)",
          "old_line_content": "\t\t\t\t * arbitrarily pass only one of the arrays.  That won't",
          "new_line_content": "\t\t\t\t\tAssert(array->scan_key == xform[j].ikey);",
          "content_same": false
        },
        {
          "line": 2912,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(orderproc->fn_oid)",
          "old_line_content": "\t\t\t\t * matter, since _bt_compare_scankey_args is aware that two",
          "new_line_content": "\t\t\t\t\tAssert(OidIsValid(orderproc->fn_oid));",
          "content_same": false
        },
        {
          "line": 866,
          "old_api": null,
          "new_api": "qunique_arg",
          "old_text": null,
          "new_text": "qunique_arg(elems, nelems, sizeof(Datum),\n\t\t\t\t\t   _bt_compare_array_elements, &cxt)",
          "old_line_content": " *",
          "new_line_content": "\treturn qunique_arg(elems, nelems, sizeof(Datum),",
          "content_same": false
        },
        {
          "line": 4965,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(itup)",
          "old_line_content": "\t\t\t * inferred, even with a posting list tuple, because only pivot",
          "new_line_content": "\t\t\tif (BTreeTupleIsPivot(itup))",
          "content_same": false
        },
        {
          "line": 2932,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!array || array->num_elems > 0)",
          "old_line_content": "\t\t\t\t\t\t!(xform[j].skey->sk_flags & SK_SEARCHARRAY))",
          "new_line_content": "\t\t\t\t\tAssert(!array || array->num_elems > 0);",
          "content_same": false
        },
        {
          "line": 4982,
          "old_api": null,
          "new_api": "P_RIGHTMOST",
          "old_text": null,
          "new_text": "P_RIGHTMOST(opaque)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tAssert(!P_RIGHTMOST(opaque));",
          "content_same": false
        },
        {
          "line": 2940,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!array || array->scan_key == i)",
          "old_line_content": "\t\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\tAssert(!array || array->scan_key == i);",
          "content_same": false
        },
        {
          "line": 4997,
          "old_api": null,
          "new_api": "P_FIRSTDATAKEY",
          "old_text": null,
          "new_text": "P_FIRSTDATAKEY(opaque)",
          "old_line_content": "\t\t\t * are a particular kind of pivot tuple.",
          "new_line_content": "\t\tif (offnum == P_FIRSTDATAKEY(opaque))",
          "content_same": false
        },
        {
          "line": 2954,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(j == (BTEqualStrategyNumber - 1))",
          "old_line_content": "\t\t\t\telse if (j == (BTEqualStrategyNumber - 1))",
          "new_line_content": "\t\t\t\t\t\tAssert(j == (BTEqualStrategyNumber - 1));",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(skey->sk_strategy == BTEqualStrategyNumber)",
          "old_line_content": "",
          "new_line_content": "\tAssert(skey->sk_strategy == BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 908,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(nextelemtype)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\tAssert(OidIsValid(origelemtype) && OidIsValid(nextelemtype));",
          "content_same": false
        },
        {
          "line": 2955,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(xform[j].skey->sk_flags & SK_SEARCHARRAY)",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\tAssert(xform[j].skey->sk_flags & SK_SEARCHARRAY);",
          "content_same": false
        },
        {
          "line": 2956,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(xform[j].ikey == array->scan_key)",
          "old_line_content": "\t\t\t\t\t/* key == a && key == b, but a != b */",
          "new_line_content": "\t\t\t\t\t\tAssert(xform[j].ikey == array->scan_key);",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!(cur->sk_flags & SK_SEARCHARRAY))",
          "old_line_content": "\t\t\t\t\tso->qual_ok = false;",
          "new_line_content": "\t\t\t\t\t\tAssert(!(cur->sk_flags & SK_SEARCHARRAY));",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": null,
          "new_api": "get_opfamily_proc",
          "old_text": null,
          "new_text": "get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t\t origelemtype, nextelemtype, BTORDER_PROC)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "RegProcedureIsValid",
          "old_text": null,
          "new_text": "RegProcedureIsValid(cmp_proc)",
          "old_line_content": "\t\t/* We have all we need to determine redundancy/contradictoriness */",
          "new_line_content": "\t\tif (!RegProcedureIsValid(cmp_proc))",
          "content_same": false
        },
        {
          "line": 5021,
          "old_api": null,
          "new_api": "ItemPointerGetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerGetOffsetNumber(&(itup->t_tid))",
          "old_line_content": "\t\t\t * key attributes.  Note that tupnatts will only have been",
          "new_line_content": "\t\t\t\tItemPointerGetOffsetNumber(&(itup->t_tid)) == P_HIKEY;",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": null,
          "new_api": "fmgr_info_cxt",
          "old_text": null,
          "new_text": "fmgr_info_cxt(cmp_proc, mergeproc, so->arrayContext)",
          "old_line_content": "",
          "new_line_content": "\t\tfmgr_info_cxt(cmp_proc, mergeproc, so->arrayContext);",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(outkey, xform[j].skey, sizeof(ScanKeyData))",
          "old_line_content": "\t\t\t\txform[j].ikey = i;",
          "new_line_content": "\t\t\t\tmemcpy(outkey, xform[j].skey, sizeof(ScanKeyData));",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": null,
          "new_api": "_bt_mark_scankey_required",
          "old_text": null,
          "new_text": "_bt_mark_scankey_required(outkey)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\t\t_bt_mark_scankey_required(outkey);",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": null,
          "new_api": "_bt_compare_array_elements",
          "old_text": null,
          "new_text": "_bt_compare_array_elements(oelem, nelem, &cxt)",
          "old_line_content": "\t\t\tj++;",
          "new_line_content": "\t\tint\t\t\tres = _bt_compare_array_elements(oelem, nelem, &cxt);",
          "content_same": false
        },
        {
          "line": 5039,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(heapkeyspace)",
          "old_line_content": "\t */",
          "new_line_content": "\tAssert(heapkeyspace);",
          "content_same": false
        },
        {
          "line": 5046,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(itup)",
          "old_line_content": "",
          "new_line_content": "\tif (!BTreeTupleIsPivot(itup))",
          "content_same": false
        },
        {
          "line": 5050,
          "old_api": null,
          "new_api": "BTreeTupleIsPosting",
          "old_text": null,
          "new_text": "BTreeTupleIsPosting(itup)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (BTreeTupleIsPosting(itup))",
          "content_same": false
        },
        {
          "line": 3003,
          "old_api": null,
          "new_api": "_bt_preprocess_array_keys_final",
          "old_text": null,
          "new_text": "_bt_preprocess_array_keys_final(scan, keyDataMap)",
          "old_line_content": "/*",
          "new_line_content": "\t\t_bt_preprocess_array_keys_final(scan, keyDataMap);",
          "content_same": false
        },
        {
          "line": 5057,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(itup)",
          "old_line_content": "\t * represent that there is a value present for a key attribute that",
          "new_line_content": "\tif (BTreeTupleGetHeapTID(itup) != NULL && tupnatts != nkeyatts)",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\tif (((cur->sk_flags & SK_BT_REQFWD) && ScanDirectionIsForward(dir)) ||",
          "content_same": false
        },
        {
          "line": 3036,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t\tfirst_elem_dir = array->num_elems - 1;",
          "new_line_content": "\t\t\t((cur->sk_flags & SK_BT_REQBKWD) && ScanDirectionIsBackward(dir)))",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->num_elems > 0)",
          "old_line_content": "\t\t   skey->sk_strategy != BTEqualStrategyNumber);",
          "new_line_content": "\tAssert(array->num_elems > 0);",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!(arraysk->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)))",
          "old_line_content": "",
          "new_line_content": "\tAssert(!(arraysk->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)));",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert((arraysk->sk_flags & SK_SEARCHARRAY) &&\n\t\t   arraysk->sk_strategy == BTEqualStrategyNumber)",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert((arraysk->sk_flags & SK_SEARCHARRAY) &&",
          "content_same": false
        },
        {
          "line": 3039,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t\treturn false;",
          "new_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!(skey->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)))",
          "old_line_content": "\t * datum of opclass input type for the index's attribute (on-disk type).",
          "new_line_content": "\tAssert(!(skey->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)));",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!(skey->sk_flags & SK_SEARCHARRAY) ||\n\t\t   skey->sk_strategy != BTEqualStrategyNumber)",
          "old_line_content": "\t * We can reuse the array's ORDER proc whenever the non-array scan key's",
          "new_line_content": "\tAssert(!(skey->sk_flags & SK_SEARCHARRAY) ||",
          "content_same": false
        },
        {
          "line": 5088,
          "old_api": null,
          "new_api": "IndexTupleSize",
          "old_text": null,
          "new_text": "IndexTupleSize(newtup)",
          "old_line_content": "\t/*",
          "new_line_content": "\titemsz = MAXALIGN(IndexTupleSize(newtup));",
          "content_same": false
        },
        {
          "line": 5091,
          "old_api": null,
          "new_api": "BTMaxItemSize",
          "old_text": null,
          "new_text": "BTMaxItemSize(page)",
          "old_line_content": "\t * which case a slightly higher limit applies.",
          "new_line_content": "\tif (itemsz <= BTMaxItemSize(page))",
          "content_same": false
        },
        {
          "line": 3048,
          "old_api": null,
          "new_api": "_bt_verify_keys_with_arraykeys",
          "old_text": null,
          "new_text": "_bt_verify_keys_with_arraykeys(scan)",
          "old_line_content": " */",
          "new_line_content": "\treturn _bt_verify_keys_with_arraykeys(scan);",
          "content_same": false
        },
        {
          "line": 5099,
          "old_api": null,
          "new_api": "BTMaxItemSizeNoHeapTid",
          "old_text": null,
          "new_text": "BTMaxItemSizeNoHeapTid(page)",
          "old_line_content": "\t */",
          "new_line_content": "\tif (!needheaptidspace && itemsz <= BTMaxItemSizeNoHeapTid(page))",
          "content_same": false
        },
        {
          "line": 5108,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",\n\t\t\t itemsz, RelationGetRelationName(rel))",
          "old_line_content": "\t\t\t\t\titemsz,",
          "new_line_content": "\t\telog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",",
          "content_same": false
        },
        {
          "line": 5109,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,",
          "new_line_content": "\t\t\t itemsz, RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 5118,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"",
          "new_line_content": "\t\t\t\t\tRelationGetRelationName(rel)),",
          "content_same": false
        },
        {
          "line": 5119,
          "old_api": null,
          "new_api": "errdetail",
          "old_text": null,
          "new_text": "errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap))",
          "old_line_content": "\t\t\t\t\t \"or use full text indexing.\"),",
          "new_line_content": "\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",",
          "content_same": false
        },
        {
          "line": 5121,
          "old_api": null,
          "new_api": "BTreeTupleGetHeapTID",
          "old_text": null,
          "new_text": "BTreeTupleGetHeapTID(newtup)",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "get_opfamily_proc",
          "old_text": null,
          "new_text": "get_opfamily_proc(rel->rd_opfamily[arraysk->sk_attno - 1],\n\t\t\t\t\t\t\t\t\t skey->sk_subtype, arraysk_elemtype,\n\t\t\t\t\t\t\t\t\t BTORDER_PROC)",
          "old_line_content": "\t\t\t*qual_ok = false;\t/* suppress compiler warnings */",
          "new_line_content": "\t\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[arraysk->sk_attno - 1],",
          "content_same": false
        },
        {
          "line": 5122,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(heap)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t   RelationGetRelationName(heap)),",
          "content_same": false
        },
        {
          "line": 5123,
          "old_api": null,
          "new_api": "errhint",
          "old_text": null,
          "new_text": "errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\")",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": null,
          "new_api": "RegProcedureIsValid",
          "old_text": null,
          "new_text": "RegProcedureIsValid(cmp_proc)",
          "old_line_content": "",
          "new_line_content": "\t\tif (!RegProcedureIsValid(cmp_proc))",
          "content_same": false
        },
        {
          "line": 5126,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": " * We use each attribute's BTEQUALIMAGE_PROC opclass procedure.  If any",
          "new_line_content": "\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))));",
          "content_same": false
        },
        {
          "line": 1038,
          "old_api": null,
          "new_api": "fmgr_info",
          "old_text": null,
          "new_text": "fmgr_info(cmp_proc, orderprocp)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t   arraysk, &cmpresult);",
          "new_line_content": "\t\tfmgr_info(cmp_proc, orderprocp);",
          "content_same": false
        },
        {
          "line": 1041,
          "old_api": null,
          "new_api": "_bt_binsrch_array_skey",
          "old_text": null,
          "new_text": "_bt_binsrch_array_skey(orderprocp, false,\n\t\t\t\t\t\t\t\t\t   NoMovementScanDirection,\n\t\t\t\t\t\t\t\t\t   skey->sk_argument, false, array,\n\t\t\t\t\t\t\t\t\t   arraysk, &cmpresult)",
          "old_line_content": "\t{",
          "new_line_content": "\tmatchelem = _bt_binsrch_array_skey(orderprocp, false,",
          "content_same": false
        },
        {
          "line": 5145,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfAttributes(rel)",
          "old_line_content": "\t\tOid\t\t\topfamily = rel->rd_opfamily[i];",
          "new_line_content": "\tif (IndexRelationGetNumberOfAttributes(rel) !=",
          "content_same": false
        },
        {
          "line": 5146,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "\t\tOid\t\t\topcintype = rel->rd_opcintype[i];",
          "new_line_content": "\t\tIndexRelationGetNumberOfKeyAttributes(rel))",
          "content_same": false
        },
        {
          "line": 5149,
          "old_api": null,
          "new_api": "IndexRelationGetNumberOfKeyAttributes",
          "old_text": null,
          "new_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "old_line_content": "",
          "new_line_content": "\tfor (int i = 0; i < IndexRelationGetNumberOfKeyAttributes(rel); i++)",
          "content_same": false
        },
        {
          "line": 5156,
          "old_api": null,
          "new_api": "get_opfamily_proc",
          "old_text": null,
          "new_text": "get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tequalimageproc = get_opfamily_proc(opfamily, opcintype, opcintype,",
          "content_same": false
        },
        {
          "line": 5163,
          "old_api": null,
          "new_api": "OidIsValid",
          "old_text": null,
          "new_text": "OidIsValid(equalimageproc)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (!OidIsValid(equalimageproc) ||",
          "content_same": false
        },
        {
          "line": 5164,
          "old_api": null,
          "new_api": "OidFunctionCall1Coll",
          "old_text": null,
          "new_text": "OidFunctionCall1Coll(equalimageproc, collation,\n\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t!DatumGetBool(OidFunctionCall1Coll(equalimageproc, collation,",
          "content_same": false
        },
        {
          "line": 5165,
          "old_api": null,
          "new_api": "ObjectIdGetDatum",
          "old_text": null,
          "new_text": "ObjectIdGetDatum(opcintype)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))))",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": null,
          "new_api": "memmove",
          "old_text": null,
          "new_text": "memmove(array->elem_values, array->elem_values + matchelem,\n\t\t\t\t\tsizeof(Datum) * new_nelems)",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\tmemmove(array->elem_values, array->elem_values + matchelem,",
          "content_same": false
        },
        {
          "line": 5175,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "",
          "new_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",",
          "content_same": false
        },
        {
          "line": 5176,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "\treturn allequalimage;",
          "new_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 5178,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "old_line_content": "",
          "new_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",",
          "content_same": false
        },
        {
          "line": 5179,
          "old_api": null,
          "new_api": "RelationGetRelationName",
          "old_text": null,
          "new_text": "RelationGetRelationName(rel)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(new_nelems >= 0)",
          "old_line_content": "\treturn true;",
          "new_line_content": "\tAssert(new_nelems >= 0);",
          "content_same": false
        },
        {
          "line": 1088,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(new_nelems <= array->num_elems)",
          "old_line_content": "}",
          "new_line_content": "\tAssert(new_nelems <= array->num_elems);",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(cxt->sortproc,\n\t\t\t\t\t\t\t\t\t\t\t  cxt->collation,\n\t\t\t\t\t\t\t\t\t\t\t  da, db)",
          "old_line_content": "}",
          "new_line_content": "\tcompare = DatumGetInt32(FunctionCall2Coll(cxt->sortproc,",
          "content_same": false
        },
        {
          "line": 3158,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(leftarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL))",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tAssert(leftarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL));",
          "content_same": false
        },
        {
          "line": 1111,
          "old_api": null,
          "new_api": "INVERT_COMPARE_RESULT",
          "old_text": null,
          "new_text": "INVERT_COMPARE_RESULT(compare)",
          "old_line_content": " *",
          "new_line_content": "\t\tINVERT_COMPARE_RESULT(compare);",
          "content_same": false
        },
        {
          "line": 3165,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(rightarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL))",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tAssert(rightarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL));",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "BTCommuteStrategyNumber",
          "old_text": null,
          "new_text": "BTCommuteStrategyNumber(strat)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\tstrat = BTCommuteStrategyNumber(strat);",
          "content_same": false
        },
        {
          "line": 1138,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur->sk_strategy == BTEqualStrategyNumber)",
          "old_line_content": "\t\telse if (cur->sk_flags & SK_BT_NULLS_FIRST)",
          "new_line_content": "\tAssert(cur->sk_strategy == BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 3198,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"unrecognized StrategyNumber: %d\", (int) strat)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\telog(ERROR, \"unrecognized StrategyNumber: %d\", (int) strat);",
          "content_same": false
        },
        {
          "line": 1162,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(orderproc, cur->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t tupdatum, arrdatum)",
          "old_line_content": "\t\t *",
          "new_line_content": "\t\tresult = DatumGetInt32(FunctionCall2Coll(orderproc, cur->sk_collation,",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": null,
          "new_api": "INVERT_COMPARE_RESULT",
          "old_text": null,
          "new_text": "INVERT_COMPARE_RESULT(result)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\tINVERT_COMPARE_RESULT(result);",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": null,
          "new_api": "_bt_compare_array_scankey_args",
          "old_text": null,
          "new_text": "_bt_compare_array_scankey_args(scan, leftarg, rightarg,\n\t\t\t\t\t\t\t\t\t\t\t\t  orderproc, array, result)",
          "old_line_content": "\t\t/* FALL THRU */",
          "new_line_content": "\t\t\treturn _bt_compare_array_scankey_args(scan, leftarg, rightarg,",
          "content_same": false
        },
        {
          "line": 3241,
          "old_api": null,
          "new_api": "_bt_compare_array_scankey_args",
          "old_text": null,
          "new_text": "_bt_compare_array_scankey_args(scan, rightarg, leftarg,\n\t\t\t\t\t\t\t\t\t\t\t\t  orderproc, array, result)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\t\treturn _bt_compare_array_scankey_args(scan, rightarg, leftarg,",
          "content_same": false
        },
        {
          "line": 3250,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(leftarg->sk_attno == rightarg->sk_attno)",
          "old_line_content": "\t * support the convention that sk_subtype == InvalidOid means the opclass",
          "new_line_content": "\tAssert(leftarg->sk_attno == rightarg->sk_attno);",
          "content_same": false
        },
        {
          "line": 1215,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur->sk_strategy == BTEqualStrategyNumber)",
          "old_line_content": "",
          "new_line_content": "\tAssert(cur->sk_strategy == BTEqualStrategyNumber);",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "ScanDirectionIsNoMovement",
          "old_text": null,
          "new_text": "ScanDirectionIsNoMovement(dir)",
          "old_line_content": "\t\t * (plus all prior elements relative to the current scan direction)",
          "new_line_content": "\t\tAssert(!ScanDirectionIsNoMovement(dir));",
          "content_same": false
        },
        {
          "line": 1220,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur->sk_flags & SK_BT_REQFWD)",
          "old_line_content": "\t\t * cannot possibly be at or ahead of the corresponding tuple value.",
          "new_line_content": "\t\tAssert(cur->sk_flags & SK_BT_REQFWD);",
          "content_same": false
        },
        {
          "line": 3275,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(&op->sk_func,\n\t\t\t\t\t\t\t\t\t\t\t\t op->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t leftarg->sk_argument,\n\t\t\t\t\t\t\t\t\t\t\t\t rightarg->sk_argument)",
          "old_line_content": "",
          "new_line_content": "\t\t*result = DatumGetBool(FunctionCall2Coll(&op->sk_func,",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 1249,
          "old_api": null,
          "new_api": "_bt_compare_array_skey",
          "old_text": null,
          "new_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\t\t\tarrdatum, cur)",
          "old_line_content": "\t\t\t\t\t*set_elem_result = result;",
          "new_line_content": "\t\t\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "content_same": false
        },
        {
          "line": 3301,
          "old_api": null,
          "new_api": "get_opcode",
          "old_text": null,
          "new_text": "get_opcode(cmp_op)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\t\tleftarg->sk_argument,",
          "new_line_content": "\t\tRegProcedure cmp_proc = get_opcode(cmp_op);",
          "content_same": false
        },
        {
          "line": 3303,
          "old_api": null,
          "new_api": "RegProcedureIsValid",
          "old_text": null,
          "new_text": "RegProcedureIsValid(cmp_proc)",
          "old_line_content": "\t\t\treturn true;",
          "new_line_content": "\t\tif (RegProcedureIsValid(cmp_proc))",
          "content_same": false
        },
        {
          "line": 3305,
          "old_api": null,
          "new_api": "OidFunctionCall2Coll",
          "old_text": null,
          "new_text": "OidFunctionCall2Coll(cmp_proc,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\top->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tleftarg->sk_argument,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trightarg->sk_argument)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t*result = DatumGetBool(OidFunctionCall2Coll(cmp_proc,",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": null,
          "new_api": "_bt_compare_array_skey",
          "old_text": null,
          "new_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\t\t\tarrdatum, cur)",
          "old_line_content": "\t\t\t\t\t*set_elem_result = result;",
          "new_line_content": "\t\t\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "content_same": false
        },
        {
          "line": 1304,
          "old_api": null,
          "new_api": "_bt_compare_array_skey",
          "old_text": null,
          "new_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\tarrdatum, cur)",
          "old_line_content": "\t\t\t * It's safe to quit as soon as we see an equal array element.",
          "new_line_content": "\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!(skey->sk_flags & SK_ROW_HEADER))",
          "old_line_content": "\t\tif (skey->sk_flags & SK_SEARCHNULL)",
          "new_line_content": "\t\tAssert(!(skey->sk_flags & SK_ROW_HEADER));",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": null,
          "new_api": "_bt_compare_array_skey",
          "old_text": null,
          "new_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\tarray->elem_values[low_elem], cur)",
          "old_line_content": "}",
          "new_line_content": "\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->numArrayKeys)",
          "old_line_content": "\t\tScanKey\t\tskey = &so->keyData[curArrayKey->scan_key];",
          "new_line_content": "\tAssert(so->numArrayKeys);",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->qual_ok)",
          "old_line_content": "",
          "new_line_content": "\tAssert(so->qual_ok);",
          "content_same": false
        },
        {
          "line": 1357,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(curArrayKey->num_elems > 0)",
          "old_line_content": "\t\t\tcurArrayKey->cur_elem = 0;",
          "new_line_content": "\t\tAssert(curArrayKey->num_elems > 0);",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(skey->sk_flags & SK_SEARCHARRAY)",
          "old_line_content": "\t\tskey->sk_argument = curArrayKey->elem_values[curArrayKey->cur_elem];",
          "new_line_content": "\t\tAssert(skey->sk_flags & SK_SEARCHARRAY);",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\tso->scanBehind = false;",
          "new_line_content": "\t\tif (ScanDirectionIsBackward(dir))",
          "content_same": false
        },
        {
          "line": 3409,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(skey->sk_argument)",
          "old_line_content": "\t\t\tif ((addflags & SK_BT_DESC) && !(subkey->sk_flags & SK_BT_DESC))",
          "new_line_content": "\t\tScanKey\t\tsubkey = (ScanKey) DatumGetPointer(skey->sk_argument);",
          "content_same": false
        },
        {
          "line": 3413,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subkey->sk_flags & SK_ROW_MEMBER)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\tAssert(subkey->sk_flags & SK_ROW_MEMBER);",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": null,
          "new_api": "BTCommuteStrategyNumber",
          "old_text": null,
          "new_text": "BTCommuteStrategyNumber(subkey->sk_strategy)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tsubkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tif (ScanDirectionIsForward(dir) && ++cur_elem >= num_elems)",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\tcurArrayKey->cur_elem = cur_elem;",
          "new_line_content": "\t\telse if (ScanDirectionIsBackward(dir) && --cur_elem < 0)",
          "content_same": false
        },
        {
          "line": 3461,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"unrecognized StrategyNumber: %d\",\n\t\t\t\t (int) skey->sk_strategy)",
          "old_line_content": "\tskey->sk_flags |= addflags;",
          "new_line_content": "\t\t\telog(ERROR, \"unrecognized StrategyNumber: %d\",",
          "content_same": false
        },
        {
          "line": 3471,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(skey->sk_argument)",
          "old_line_content": "\t\tsubkey->sk_flags |= addflags;",
          "new_line_content": "\t\tScanKey\t\tsubkey = (ScanKey) DatumGetPointer(skey->sk_argument);",
          "content_same": false
        },
        {
          "line": 3474,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subkey->sk_flags & SK_ROW_MEMBER)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(subkey->sk_flags & SK_ROW_MEMBER);",
          "content_same": false
        },
        {
          "line": 3475,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subkey->sk_attno == skey->sk_attno)",
          "old_line_content": "/*",
          "new_line_content": "\t\tAssert(subkey->sk_attno == skey->sk_attno);",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": null,
          "new_api": "_bt_start_array_keys",
          "old_text": null,
          "new_text": "_bt_start_array_keys(scan, -dir)",
          "old_line_content": " * _bt_rewind_nonrequired_arrays() -- Rewind non-required arrays",
          "new_line_content": "\t_bt_start_array_keys(scan, -dir);",
          "content_same": false
        },
        {
          "line": 3476,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subkey->sk_strategy == skey->sk_strategy)",
          "old_line_content": " * Test whether an indextuple satisfies all the scankey conditions.",
          "new_line_content": "\t\tAssert(subkey->sk_strategy == skey->sk_strategy);",
          "content_same": false
        },
        {
          "line": 3522,
          "old_api": null,
          "new_api": "BTreeTupleGetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleGetNAtts(tuple, scan->indexRelation)",
          "old_line_content": "#ifdef USE_ASSERT_CHECKING",
          "new_line_content": "\tAssert(BTreeTupleGetNAtts(tuple, scan->indexRelation) == tupnatts);",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": null,
          "new_api": "_bt_check_compare",
          "old_text": null,
          "new_text": "_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\tarrayKeys, pstate->prechecked, pstate->firstmatch,\n\t\t\t\t\t\t\t&pstate->continuescan, &ikey)",
          "old_line_content": "\t{",
          "new_line_content": "\tres = _bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,",
          "content_same": false
        },
        {
          "line": 1484,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->scan_key == ikey)",
          "old_line_content": "\t\t\tfirst_elem_dir = 0;",
          "new_line_content": "\t\tAssert(array->scan_key == ikey);",
          "content_same": false
        },
        {
          "line": 3536,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!so->scanBehind && !pstate->prechecked && !pstate->firstmatch)",
          "old_line_content": "\t\tbool\t\tdcontinuescan;",
          "new_line_content": "\t\tAssert(!so->scanBehind && !pstate->prechecked && !pstate->firstmatch);",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 3537,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t tupnatts, false, 0, NULL)",
          "old_line_content": "\t\tint\t\t\tdikey = 0;",
          "new_line_content": "\t\tAssert(!_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,",
          "content_same": false
        },
        {
          "line": 3549,
          "old_api": null,
          "new_api": "_bt_check_compare",
          "old_text": null,
          "new_text": "_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\t\t\t\tfalse, false, false,\n\t\t\t\t\t\t\t\t\t\t&dcontinuescan, &dikey)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(res == _bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,",
          "content_same": false
        },
        {
          "line": 3552,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(pstate->continuescan == dcontinuescan)",
          "old_line_content": "\t * there are no equality strategy array scan keys.  Otherwise we can only",
          "new_line_content": "\t\tAssert(pstate->continuescan == dcontinuescan);",
          "content_same": false
        },
        {
          "line": 3573,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts, true,\n\t\t\t\t\t\t\t\t\t ikey, NULL)",
          "old_line_content": "\t\t * strategy keys, actually).",
          "new_line_content": "\tif (_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts, true,",
          "content_same": false
        },
        {
          "line": 3587,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!so->scanBehind ||\n\t\t\t   so->keyData[ikey].sk_strategy == BTEqualStrategyNumber)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t false, 0, NULL))",
          "new_line_content": "\t\tAssert(!so->scanBehind ||",
          "content_same": false
        },
        {
          "line": 3589,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(so->scanBehind)",
          "old_line_content": "\t\t\t/* Cut our losses -- start a new primitive index scan now */",
          "new_line_content": "\t\tif (unlikely(so->scanBehind) && pstate->finaltup &&",
          "content_same": false
        },
        {
          "line": 3590,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,\n\t\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscan->indexRelation),\n\t\t\t\t\t\t\t\t\t\t false, 0, NULL)",
          "old_line_content": "\t\t\tpstate->continuescan = false;",
          "new_line_content": "\t\t\t_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,",
          "content_same": false
        },
        {
          "line": 3591,
          "old_api": null,
          "new_api": "BTreeTupleGetNAtts",
          "old_text": null,
          "new_text": "BTreeTupleGetNAtts(pstate->finaltup,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscan->indexRelation)",
          "old_line_content": "\t\t\tso->needPrimScan = true;",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup,",
          "content_same": false
        },
        {
          "line": 1551,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->numArrayKeys)",
          "old_line_content": "\t\t*scanBehind = false;",
          "new_line_content": "\tAssert(so->numArrayKeys);",
          "content_same": false
        },
        {
          "line": 1552,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->numberOfKeys)",
          "old_line_content": "",
          "new_line_content": "\tAssert(so->numberOfKeys);",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(sktrig == 0 || readpagetup)",
          "old_line_content": "\tfor (int ikey = sktrig; ikey < so->numberOfKeys; ikey++)",
          "new_line_content": "\tAssert(sktrig == 0 || readpagetup);",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!readpagetup || scanBehind == NULL)",
          "old_line_content": "\t{",
          "new_line_content": "\tAssert(!readpagetup || scanBehind == NULL);",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!readpagetup || ikey == sktrig)",
          "old_line_content": "\t\t * _bt_advance_array_keys caller requires that we track *scanBehind",
          "new_line_content": "\t\tAssert(!readpagetup || ikey == sktrig);",
          "content_same": false
        },
        {
          "line": 3623,
          "old_api": null,
          "new_api": "_bt_checkkeys_look_ahead",
          "old_text": null,
          "new_text": "_bt_checkkeys_look_ahead(scan, pstate, tupnatts, tupdesc)",
          "old_line_content": "\t\t\t\t * just after the tuple we successfully \"looked ahead\" to).",
          "new_line_content": "\t\t\t\t_bt_checkkeys_look_ahead(scan, pstate, tupnatts, tupdesc);",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!readpagetup)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tAssert(!readpagetup);",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!readpagetup)",
          "old_line_content": "\t\t\t * that a truncated attribute might have affected our answer).",
          "new_line_content": "\t\t\tAssert(!readpagetup);",
          "content_same": false
        },
        {
          "line": 3644,
          "old_api": null,
          "new_api": "_bt_advance_array_keys",
          "old_text": null,
          "new_text": "_bt_advance_array_keys(scan, pstate, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\t\t  ikey, true)",
          "old_line_content": " *",
          "new_line_content": "\treturn _bt_advance_array_keys(scan, pstate, tuple, tupnatts, tupdesc,",
          "content_same": false
        },
        {
          "line": 1621,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\ttupdatum = index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull);",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": null,
          "new_api": "_bt_compare_array_skey",
          "old_text": null,
          "new_text": "_bt_compare_array_skey(&so->orderProcs[ikey],\n\t\t\t\t\t\t\t\t\t\ttupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\tcur->sk_argument, cur)",
          "old_line_content": "\t\t * scan's arrays just yet?",
          "new_line_content": "\t\tresult = _bt_compare_array_skey(&so->orderProcs[ikey],",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t * scan's arrays?  (Must be if we get here during a readpagetup call.)",
          "new_line_content": "\t\tif ((ScanDirectionIsForward(dir) && result < 0) ||",
          "content_same": false
        },
        {
          "line": 1632,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\t(ScanDirectionIsBackward(dir) && result > 0))",
          "content_same": false
        },
        {
          "line": 1641,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(result != 0)",
          "old_line_content": "\t\t *",
          "new_line_content": "\t\t\tAssert(result != 0);",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(result == 0)",
          "old_line_content": "}",
          "new_line_content": "\t\tAssert(result == 0);",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!readpagetup)",
          "old_line_content": " * _bt_start_prim_scan() -- start scheduled primitive index scan?",
          "new_line_content": "\tAssert(!readpagetup);",
          "content_same": false
        },
        {
          "line": 3708,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "",
          "new_line_content": "\t\tif (((key->sk_flags & SK_BT_REQFWD) && ScanDirectionIsForward(dir)) ||",
          "content_same": false
        },
        {
          "line": 3709,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\t((key->sk_flags & SK_BT_REQBKWD) && ScanDirectionIsBackward(dir)))",
          "content_same": false
        },
        {
          "line": 3711,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t * for the last item on the page, then we know the keys required for",
          "new_line_content": "\t\telse if (((key->sk_flags & SK_BT_REQFWD) && ScanDirectionIsBackward(dir)) ||",
          "content_same": false
        },
        {
          "line": 3712,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t * the current direction scan should be matched.  Otherwise, the",
          "new_line_content": "\t\t\t\t ((key->sk_flags & SK_BT_REQBKWD) && ScanDirectionIsForward(dir)))",
          "content_same": false
        },
        {
          "line": 1673,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(so->numArrayKeys)",
          "old_line_content": "\t * Array keys are advanced within _bt_checkkeys when the scan reaches the",
          "new_line_content": "\tAssert(so->numArrayKeys);",
          "content_same": false
        },
        {
          "line": 3744,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(tuple)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tAssert(BTreeTupleIsPivot(tuple));",
          "content_same": false
        },
        {
          "line": 3757,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(tuple,\n\t\t\t\t\t\t\t  key->sk_attno,\n\t\t\t\t\t\t\t  tupdesc,\n\t\t\t\t\t\t\t  &isNull)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tdatum = index_getattr(tuple,",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": null,
          "new_api": "_bt_verify_arrays_bt_first",
          "old_text": null,
          "new_text": "_bt_verify_arrays_bt_first(scan, dir)",
          "old_line_content": "\t\treturn true;",
          "new_line_content": "\t\tAssert(_bt_verify_arrays_bt_first(scan, dir));",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(key->sk_flags & SK_SEARCHNOTNULL)",
          "old_line_content": "\t\t\t * Tuple fails this qual.  If it's a required qual for the current",
          "new_line_content": "\t\t\t\tAssert(key->sk_flags & SK_SEARCHNOTNULL);",
          "content_same": false
        },
        {
          "line": 1725,
          "old_api": null,
          "new_api": "_bt_parallel_done",
          "old_text": null,
          "new_text": "_bt_parallel_done(scan)",
          "old_line_content": " * _bt_advance_array_keys() -- Advance array elements using a tuple",
          "new_line_content": "\t\t_bt_parallel_done(scan);",
          "content_same": false
        },
        {
          "line": 3808,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t\t\t * Since NULLs are sorted after non-NULLs, we know we have",
          "new_line_content": "\t\t\t\t\tScanDirectionIsBackward(dir))",
          "content_same": false
        },
        {
          "line": 3826,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t\t\tScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 3844,
          "old_api": null,
          "new_api": "FunctionCall2Coll",
          "old_text": null,
          "new_text": "FunctionCall2Coll(&key->sk_func, key->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\tdatum, key->sk_argument)",
          "old_line_content": "\t\t\t * pass, either.",
          "new_line_content": "\t\t\t!DatumGetBool(FunctionCall2Coll(&key->sk_func, key->sk_collation,",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": null,
          "new_api": "_bt_tuple_before_array_skeys",
          "old_text": null,
          "new_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t tupnatts, false, 0, NULL)",
          "old_line_content": "\t\t * Required scan key wasn't satisfied, so required arrays will have to",
          "new_line_content": "\t\tAssert(!_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,",
          "content_same": false
        },
        {
          "line": 3869,
          "old_api": null,
          "new_api": "_bt_advance_array_keys",
          "old_text": null,
          "new_text": "_bt_advance_array_keys(scan, NULL, tuple, tupnatts,\n\t\t\t\t\t\t\t\t\t\t\t  tupdesc, *ikey, false)",
          "old_line_content": "\t\t\treturn false;",
          "new_line_content": "\t\t\t\treturn _bt_advance_array_keys(scan, NULL, tuple, tupnatts,",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!pstate->prechecked)",
          "old_line_content": "\t\tpstate->rechecks = 0;",
          "new_line_content": "\t\tAssert(!pstate->prechecked);",
          "content_same": false
        },
        {
          "line": 1833,
          "old_api": null,
          "new_api": "_bt_verify_keys_with_arraykeys",
          "old_text": null,
          "new_text": "_bt_verify_keys_with_arraykeys(scan)",
          "old_line_content": "\t\tDatum\t\ttupdatum;",
          "new_line_content": "\tAssert(_bt_verify_keys_with_arraykeys(scan));",
          "content_same": false
        },
        {
          "line": 3896,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(skey->sk_argument)",
          "old_line_content": "",
          "new_line_content": "\tScanKey\t\tsubkey = (ScanKey) DatumGetPointer(skey->sk_argument);",
          "content_same": false
        },
        {
          "line": 1852,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(array->scan_key == ikey)",
          "old_line_content": "\t\t\t * Are any inequalities required in the opposite direction only",
          "new_line_content": "\t\t\t\tAssert(array->scan_key == ikey);",
          "content_same": false
        },
        {
          "line": 3901,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subkey->sk_attno == skey->sk_attno)",
          "old_line_content": "\t\tbool\t\tisNull;",
          "new_line_content": "\tAssert(subkey->sk_attno == skey->sk_attno);",
          "content_same": false
        },
        {
          "line": 1861,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tif (((ScanDirectionIsForward(dir) &&",
          "content_same": false
        },
        {
          "line": 3909,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subkey->sk_flags & SK_ROW_MEMBER)",
          "old_line_content": "\t\t\t * this attribute in the first non-pivot tuple on the page to the",
          "new_line_content": "\t\tAssert(subkey->sk_flags & SK_ROW_MEMBER);",
          "content_same": false
        },
        {
          "line": 1863,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t/* Optimization: skip over known-satisfied scan keys */",
          "new_line_content": "\t\t\t\t (ScanDirectionIsBackward(dir) &&",
          "content_same": false
        },
        {
          "line": 3919,
          "old_api": null,
          "new_api": "BTreeTupleIsPivot",
          "old_text": null,
          "new_text": "BTreeTupleIsPivot(tuple)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tAssert(BTreeTupleIsPivot(tuple));",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(sktrig_required)",
          "old_line_content": "\t\t\t\t/* Set this just like _bt_tuple_before_array_skeys */",
          "new_line_content": "\t\t\tAssert(sktrig_required);",
          "content_same": false
        },
        {
          "line": 3927,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(tuple,\n\t\t\t\t\t\t\t  subkey->sk_attno,\n\t\t\t\t\t\t\t  tupdesc,\n\t\t\t\t\t\t\t  &isNull)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tdatum = index_getattr(tuple,",
          "content_same": false
        },
        {
          "line": 1882,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(sktrig < ikey)",
          "old_line_content": "\t\t * Handle a required non-array scan key that the initial call to",
          "new_line_content": "\t\t\t\tAssert(sktrig < ikey);",
          "content_same": false
        },
        {
          "line": 3949,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t\t\t * Since NULLs are sorted after non-NULLs, we know we have",
          "new_line_content": "\t\t\t\t\tScanDirectionIsBackward(dir))",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(sktrig_required && required && all_required_satisfied)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\tAssert(sktrig_required && required && all_required_satisfied);",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\t\t\tScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 1925,
          "old_api": null,
          "new_api": "unlikely",
          "old_text": null,
          "new_text": "unlikely(required_opposite_direction_only)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tif (unlikely(required_opposite_direction_only))",
          "content_same": false
        },
        {
          "line": 3988,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t\tScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 4003,
          "old_api": null,
          "new_api": "INVERT_COMPARE_RESULT",
          "old_text": null,
          "new_text": "INVERT_COMPARE_RESULT(cmpresult)",
          "old_line_content": "\t\tif (subkey->sk_flags & SK_ROW_END)",
          "new_line_content": "\t\t\tINVERT_COMPARE_RESULT(cmpresult);",
          "content_same": false
        },
        {
          "line": 1960,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tif (ScanDirectionIsBackward(dir) || !array)",
          "content_same": false
        },
        {
          "line": 4035,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"unrecognized RowCompareType: %d\",\n\t\t\t\t (int) subkey->sk_strategy)",
          "old_line_content": "\tif (!result)",
          "new_line_content": "\t\t\telog(ERROR, \"unrecognized RowCompareType: %d\",",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\tif (ScanDirectionIsForward(dir) || !array)",
          "content_same": false
        },
        {
          "line": 4050,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "",
          "new_line_content": "\t\t\tScanDirectionIsForward(dir))",
          "content_same": false
        },
        {
          "line": 4053,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t ScanDirectionIsBackward(dir))",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "index_getattr",
          "old_text": null,
          "new_text": "index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\ttupdatum = index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull);",
          "content_same": false
        },
        {
          "line": 2023,
          "old_api": null,
          "new_api": "_bt_binsrch_array_skey",
          "old_text": null,
          "new_text": "_bt_binsrch_array_skey(&so->orderProcs[ikey],\n\t\t\t\t\t\t\t\t\t\t\t  cur_elem_trig, dir,\n\t\t\t\t\t\t\t\t\t\t\t  tupdatum, tupnull, array, cur,\n\t\t\t\t\t\t\t\t\t\t\t  &result)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tset_elem = _bt_binsrch_array_skey(&so->orderProcs[ikey],",
          "content_same": false
        },
        {
          "line": 2028,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(set_elem >= 0 && set_elem < array->num_elems)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\tAssert(set_elem >= 0 && set_elem < array->num_elems);",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(sktrig_required && required)",
          "old_line_content": "\t\t\t * This scan key's imaginary \"array\" can't really advance, but it",
          "new_line_content": "\t\t\tAssert(sktrig_required && required);",
          "content_same": false
        },
        {
          "line": 2043,
          "old_api": null,
          "new_api": "_bt_compare_array_skey",
          "old_text": null,
          "new_text": "_bt_compare_array_skey(&so->orderProcs[ikey],\n\t\t\t\t\t\t\t\t\t\t\ttupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\t\tcur->sk_argument, cur)",
          "old_line_content": "\t\t * Consider \"beyond end of array element\" array advancement.",
          "new_line_content": "\t\t\tresult = _bt_compare_array_skey(&so->orderProcs[ikey],",
          "content_same": false
        },
        {
          "line": 4092,
          "old_api": null,
          "new_api": "ScanDirectionIsForward",
          "old_text": null,
          "new_text": "ScanDirectionIsForward(dir)",
          "old_line_content": "",
          "new_line_content": "\tif (ScanDirectionIsForward(dir) &&",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": null,
          "new_api": "ScanDirectionIsBackward",
          "old_text": null,
          "new_text": "ScanDirectionIsBackward(dir)",
          "old_line_content": "\t * allows _bt_readpage to skip over more tuples",
          "new_line_content": "\telse if (ScanDirectionIsBackward(dir) &&",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4103,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\tif (ScanDirectionIsForward(dir))",
          "new_line_content": "\tif (!pstate->targetdistance)",
          "content_same": false
        },
        {
          "line": 4104,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min((int) pstate->maxoff,\n\t\t\t\t\t\t  (int) pstate->offnum + pstate->targetdistance)",
          "new_text": null,
          "old_line_content": "\t\taheadoffnum = Min((int) pstate->maxoff,",
          "new_line_content": "\t\tpstate->targetdistance = LOOK_AHEAD_DEFAULT_DISTANCE;",
          "content_same": false
        },
        {
          "line": 4107,
          "old_api": "Max",
          "new_api": null,
          "old_text": "Max((int) pstate->minoff,\n\t\t\t\t\t\t  (int) pstate->offnum - pstate->targetdistance)",
          "new_text": null,
          "old_line_content": "\t\taheadoffnum = Max((int) pstate->minoff,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4111,
          "old_api": "PageGetItemId",
          "new_api": null,
          "old_text": "PageGetItemId(pstate->page, aheadoffnum)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t PageGetItemId(pstate->page, aheadoffnum));",
          "new_line_content": "\t\t\t\t\t\t  (int) pstate->offnum + pstate->targetdistance);",
          "content_same": false
        },
        {
          "line": 4112,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, ahead, tupdesc, tupnatts,\n\t\t\t\t\t\t\t\t\t false, 0, NULL)",
          "new_text": null,
          "old_line_content": "\tif (_bt_tuple_before_array_skeys(scan, dir, ahead, tupdesc, tupnatts,",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t((ScanDirectionIsForward(dir) && result > 0) ||",
          "new_line_content": "\t\t * We don't need any special handling for required scan keys that lack",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t (ScanDirectionIsBackward(dir) && result < 0)))",
          "new_line_content": "\t\t * a real array to advance, nor for redundant scan keys that couldn't",
          "content_same": false
        },
        {
          "line": 4119,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "new_line_content": "\t\t\t\t\t\t\t\t\t false, 0, NULL))",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(all_required_satisfied && all_satisfied)",
          "new_text": null,
          "old_line_content": "\t\tAssert(all_required_satisfied && all_satisfied);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4134,
          "old_api": "Max",
          "new_api": null,
          "old_text": "Max(pstate->targetdistance / 8, 1)",
          "new_text": null,
          "old_line_content": "\t\tpstate->targetdistance = Max(pstate->targetdistance / 8, 1);",
          "new_line_content": "\t\t *",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": "_bt_advance_array_keys_increment",
          "new_api": null,
          "old_text": "_bt_advance_array_keys_increment(scan, dir)",
          "new_text": null,
          "old_line_content": "\tif (beyond_end_advance && !_bt_advance_array_keys_increment(scan, dir))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2115,
          "old_api": "_bt_verify_keys_with_arraykeys",
          "new_api": null,
          "old_text": "_bt_verify_keys_with_arraykeys(scan)",
          "new_text": null,
          "old_line_content": "\tAssert(_bt_verify_keys_with_arraykeys(scan));",
          "new_line_content": "\t * higher-order arrays (might exhaust all the scan's arrays instead, which",
          "content_same": false
        },
        {
          "line": 4182,
          "old_api": "BTScanPosIsValid",
          "new_api": null,
          "old_text": "BTScanPosIsValid(so->currPos)",
          "new_text": null,
          "old_line_content": "\tAssert(BTScanPosIsValid(so->currPos));",
          "new_line_content": "\tOffsetNumber maxoff;",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(all_required_satisfied)",
          "new_text": null,
          "old_line_content": "\t\tAssert(all_required_satisfied);",
          "new_line_content": "\tif ((sktrig_required && all_required_satisfied) ||",
          "content_same": false
        },
        {
          "line": 4190,
          "old_api": "BTScanPosIsPinned",
          "new_api": null,
          "old_text": "BTScanPosIsPinned(so->currPos)",
          "new_text": null,
          "old_line_content": "\tif (BTScanPosIsPinned(so->currPos))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "_bt_check_compare",
          "new_api": null,
          "old_text": "_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\t  false, false, false,\n\t\t\t\t\t\t\t  &continuescan, &nsktrig)",
          "new_text": null,
          "old_line_content": "\t\tif (_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,",
          "new_line_content": "\t\tint\t\t\tnsktrig = sktrig + 1;",
          "content_same": false
        },
        {
          "line": 4199,
          "old_api": "_bt_lockbuf",
          "new_api": null,
          "old_text": "_bt_lockbuf(scan->indexRelation, so->currPos.buf, BT_READ)",
          "new_text": null,
          "old_line_content": "\t\t_bt_lockbuf(scan->indexRelation, so->currPos.buf, BT_READ);",
          "new_line_content": "\t\t * We have held the pin on this page since we read the index tuples,",
          "content_same": false
        },
        {
          "line": 4201,
          "old_api": "BufferGetPage",
          "new_api": null,
          "old_text": "BufferGetPage(so->currPos.buf)",
          "new_text": null,
          "old_line_content": "\t\tpage = BufferGetPage(so->currPos.buf);",
          "new_line_content": "\t\t * re-use of any TID on the page, so there is no need to check the",
          "content_same": false
        },
        {
          "line": 4209,
          "old_api": "_bt_getbuf",
          "new_api": null,
          "old_text": "_bt_getbuf(scan->indexRelation, so->currPos.currPage, BT_READ)",
          "new_text": null,
          "old_line_content": "\t\tbuf = _bt_getbuf(scan->indexRelation, so->currPos.currPage, BT_READ);",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 4211,
          "old_api": "BufferGetPage",
          "new_api": null,
          "old_text": "BufferGetPage(buf)",
          "new_text": null,
          "old_line_content": "\t\tpage = BufferGetPage(buf);",
          "new_line_content": "\t\tBuffer\t\tbuf;",
          "content_same": false
        },
        {
          "line": 4212,
          "old_api": "BufferGetLSNAtomic",
          "new_api": null,
          "old_text": "BufferGetLSNAtomic(buf)",
          "new_text": null,
          "old_line_content": "\t\tif (BufferGetLSNAtomic(buf) == so->currPos.lsn)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(!continuescan)",
          "new_text": null,
          "old_line_content": "\t\tif (unlikely(!continuescan))",
          "new_line_content": "\t\t *",
          "content_same": false
        },
        {
          "line": 4222,
          "old_api": "BTPageGetOpaque",
          "new_api": null,
          "old_text": "BTPageGetOpaque(page)",
          "new_text": null,
          "old_line_content": "\topaque = BTPageGetOpaque(page);",
          "new_line_content": "\t\t\t/* Modified while not pinned means hinting is not safe. */",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(sktrig_required)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(sktrig_required);",
          "new_line_content": "\t\t * didn't perform this step, then that guarantee wouldn't quite hold.",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->keyData[nsktrig].sk_strategy != BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(so->keyData[nsktrig].sk_strategy != BTEqualStrategyNumber);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4224,
          "old_api": "PageGetMaxOffsetNumber",
          "new_api": null,
          "old_text": "PageGetMaxOffsetNumber(page)",
          "new_text": null,
          "old_line_content": "\tmaxoff = PageGetMaxOffsetNumber(page);",
          "new_line_content": "\t\t\treturn;",
          "content_same": false
        },
        {
          "line": 2184,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!beyond_end_advance)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!beyond_end_advance);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4232,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(itemIndex >= so->currPos.firstItem &&\n\t\t\t   itemIndex <= so->currPos.lastItem)",
          "new_text": null,
          "old_line_content": "\t\tAssert(itemIndex >= so->currPos.firstItem &&",
          "new_line_content": "\tfor (i = 0; i < numKilled; i++)",
          "content_same": false
        },
        {
          "line": 2187,
          "old_api": "_bt_advance_array_keys",
          "new_api": null,
          "old_text": "_bt_advance_array_keys(scan, pstate, tuple, tupnatts,\n\t\t\t\t\t\t\t\t\t\t\t   tupdesc, nsktrig, true)",
          "new_text": null,
          "old_line_content": "\t\t\tsatisfied = _bt_advance_array_keys(scan, pstate, tuple, tupnatts,",
          "new_line_content": "\t\t\t * recursive call, so we cannot possibly end up back here when",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!satisfied)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!satisfied);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4239,
          "old_api": "PageGetItem",
          "new_api": null,
          "old_text": "PageGetItem(page, iid)",
          "new_text": null,
          "old_line_content": "\t\t\tIndexTuple\tituple = (IndexTuple) PageGetItem(page, iid);",
          "new_line_content": "\t\t\t   itemIndex <= so->currPos.lastItem);",
          "content_same": false
        },
        {
          "line": 4242,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(ituple)",
          "new_text": null,
          "old_line_content": "\t\t\tif (BTreeTupleIsPosting(ituple))",
          "new_line_content": "\t\twhile (offnum <= maxoff)",
          "content_same": false
        },
        {
          "line": 4264,
          "old_api": "BTreeTupleGetPostingN",
          "new_api": null,
          "old_text": "BTreeTupleGetPostingN(ituple, j)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tItemPointer item = BTreeTupleGetPostingN(ituple, j);",
          "new_line_content": "\t\t\t\t * since we first read it (in the !droppedpin case), so it's",
          "content_same": false
        },
        {
          "line": 4266,
          "old_api": "ItemPointerEquals",
          "new_api": null,
          "old_text": "ItemPointerEquals(item, &kitem->heapTid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (!ItemPointerEquals(item, &kitem->heapTid))",
          "new_line_content": "\t\t\t\t * tuple when we first encountered its heap TIDs.",
          "content_same": false
        },
        {
          "line": 4274,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(kitem->indexOffset == offnum || !droppedpin)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(kitem->indexOffset == offnum || !droppedpin);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2231,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts,\n\t\t\t\t\t\t\t\t\t\tfalse, 0, NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts,",
          "new_line_content": "\t * scan keys required in the opposite direction only; those aren't tracked",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,\n\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup, rel),\n\t\t\t\t\t\t\t\t\t false, 0, &so->scanBehind)",
          "new_text": null,
          "old_line_content": "\t\t_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "BTreeTupleGetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleGetNAtts(pstate->finaltup, rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup, rel),",
          "new_line_content": "\t * Note: if so->scanBehind hasn't already been set for finaltup by us,",
          "content_same": false
        },
        {
          "line": 4306,
          "old_api": "ItemPointerEquals",
          "new_api": null,
          "old_text": "ItemPointerEquals(&ituple->t_tid, &kitem->heapTid)",
          "new_text": null,
          "old_line_content": "\t\t\telse if (ItemPointerEquals(&ituple->t_tid, &kitem->heapTid))",
          "new_line_content": "\t\t\t\t * TID instead, so we'll advance to the next offnum/index",
          "content_same": false
        },
        {
          "line": 4317,
          "old_api": "ItemIdIsDead",
          "new_api": null,
          "old_text": "ItemIdIsDead(iid)",
          "new_text": null,
          "old_line_content": "\t\t\tif (killtuple && !ItemIdIsDead(iid))",
          "new_line_content": "\t\t\t * happens while holding a buffer lock possibly in shared mode,",
          "content_same": false
        },
        {
          "line": 4320,
          "old_api": "ItemIdMarkDead",
          "new_api": null,
          "old_text": "ItemIdMarkDead(iid)",
          "new_text": null,
          "old_line_content": "\t\t\t\tItemIdMarkDead(iid);",
          "new_line_content": "\t\t\t * to WAL (if wal_log_hints or data checksums are enabled), which",
          "content_same": false
        },
        {
          "line": 4324,
          "old_api": "OffsetNumberNext",
          "new_api": null,
          "old_text": "OffsetNumberNext(offnum)",
          "new_text": null,
          "old_line_content": "\t\t\toffnum = OffsetNumberNext(offnum);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 4338,
          "old_api": "MarkBufferDirtyHint",
          "new_api": null,
          "old_text": "MarkBufferDirtyHint(so->currPos.buf, true)",
          "new_text": null,
          "old_line_content": "\t\tMarkBufferDirtyHint(so->currPos.buf, true);",
          "new_line_content": "\t * BTP_HAS_GARBAGE flag, which is likewise just a hint.  (Note that we",
          "content_same": false
        },
        {
          "line": 4341,
          "old_api": "_bt_unlockbuf",
          "new_api": null,
          "old_text": "_bt_unlockbuf(scan->indexRelation, so->currPos.buf)",
          "new_text": null,
          "old_line_content": "\t_bt_unlockbuf(scan->indexRelation, so->currPos.buf);",
          "new_line_content": "\tif (killedsomething)",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": "BTreeTupleGetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleGetNAtts(pstate->finaltup, rel)",
          "new_text": null,
          "old_line_content": "\t\tint\t\t\tnfinaltupatts = BTreeTupleGetNAtts(pstate->finaltup, rel);",
          "new_line_content": "\t * also before the _bt_first-wise start of tuples for our new qual.  That",
          "content_same": false
        },
        {
          "line": 4393,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(BtreeVacuumLock, LW_SHARED)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_SHARED);",
          "new_line_content": "_bt_vacuum_cycleid(Relation rel)",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!so->scanBehind)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!so->scanBehind);",
          "new_line_content": "\t\t * cannot reuse work from caller's earlier _bt_check_compare call.",
          "content_same": false
        },
        {
          "line": 4407,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": "_bt_check_compare",
          "new_api": null,
          "old_text": "_bt_check_compare(scan, flipped,\n\t\t\t\t\t\t  pstate->finaltup, nfinaltupatts, tupdesc,\n\t\t\t\t\t\t  false, false, false,\n\t\t\t\t\t\t  &continuescanflip, &opsktrig)",
          "new_text": null,
          "old_line_content": "\t\t_bt_check_compare(scan, flipped,",
          "new_line_content": "\t\t * so that it will set continuescanflip=false when it encounters an",
          "content_same": false
        },
        {
          "line": 4427,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "new_line_content": "_bt_start_vacuum(Relation rel)",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(all_required_satisfied != oppodir_inequality_sktrig)",
          "new_text": null,
          "old_line_content": "\t\tAssert(all_required_satisfied != oppodir_inequality_sktrig);",
          "new_line_content": "\t\t * unsatisfied scan key at offset opsktrig/sktrig.  (This depends on",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(!continuescanflip &&\n\t\t\t\t\t ((all_required_satisfied && opsktrig > sktrig) ||\n\t\t\t\t\t  (oppodir_inequality_sktrig && opsktrig >= sktrig)))",
          "new_text": null,
          "old_line_content": "\t\tif (unlikely(!continuescanflip &&",
          "new_line_content": "\t\t * _bt_check_compare not caring about the direction that inequalities",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->keyData[opsktrig].sk_strategy != BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(so->keyData[opsktrig].sk_strategy != BTEqualStrategyNumber);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4450,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\t\t\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 4451,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",\n\t\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"multiple active vacuums for index \\\"%s\\\"\",",
          "new_line_content": "\t\t\t * Unlike most places in the backend, we have to explicitly",
          "content_same": false
        },
        {
          "line": 4452,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t\t\t * release our LWLock before throwing an error.  This is because",
          "content_same": false
        },
        {
          "line": 4459,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\t\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 4460,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"out of btvacinfo slots\")",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"out of btvacinfo slots\");",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 4467,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tAssert(ScanDirectionIsForward(dir));",
          "new_line_content": "\tpstate->continuescan = true;\t/* Override _bt_check_compare */",
          "content_same": false
        },
        {
          "line": 4482,
          "old_api": "LWLockAcquire",
          "new_api": null,
          "old_text": "LWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE)",
          "new_text": null,
          "old_line_content": "\tLWLockAcquire(BtreeVacuumLock, LW_EXCLUSIVE);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 2441,
          "old_api": "_bt_parallel_primscan_schedule",
          "new_api": null,
          "old_text": "_bt_parallel_primscan_schedule(scan, pstate->prev_scan_page)",
          "new_text": null,
          "old_line_content": "\t\t_bt_parallel_primscan_schedule(scan, pstate->prev_scan_page);",
          "new_line_content": "\t * index scan won't go ahead after all.",
          "content_same": false
        },
        {
          "line": 4499,
          "old_api": "LWLockRelease",
          "new_api": null,
          "old_text": "LWLockRelease(BtreeVacuumLock)",
          "new_text": null,
          "old_line_content": "\tLWLockRelease(BtreeVacuumLock);",
          "new_line_content": "\t\t\t*vac = btvacinfo->vacuums[btvacinfo->num_vacuums - 1];",
          "content_same": false
        },
        {
          "line": 4508,
          "old_api": "DatumGetPointer",
          "new_api": null,
          "old_text": "DatumGetPointer(arg)",
          "new_text": null,
          "old_line_content": "\t_bt_end_vacuum((Relation) DatumGetPointer(arg));",
          "new_line_content": "/*",
          "content_same": false
        },
        {
          "line": 4519,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTVacInfo, vacuums)",
          "new_text": null,
          "old_line_content": "\tsize = offsetof(BTVacInfo, vacuums);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4520,
          "old_api": "mul_size",
          "new_api": null,
          "old_text": "mul_size(MaxBackends, sizeof(BTOneVacInfo))",
          "new_text": null,
          "old_line_content": "\tsize = add_size(size, mul_size(MaxBackends, sizeof(BTOneVacInfo)));",
          "new_line_content": "Size",
          "content_same": false
        },
        {
          "line": 4532,
          "old_api": "ShmemInitStruct",
          "new_api": null,
          "old_text": "ShmemInitStruct(\"BTree Vacuum State\",\n\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),\n\t\t\t\t\t\t\t\t\t\t\t  &found)",
          "new_text": null,
          "old_line_content": "\tbtvacinfo = (BTVacInfo *) ShmemInitStruct(\"BTree Vacuum State\",",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4533,
          "old_api": "BTreeShmemSize",
          "new_api": null,
          "old_text": "BTreeShmemSize()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t  BTreeShmemSize(),",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 4546,
          "old_api": "time",
          "new_api": null,
          "old_text": "time(NULL)",
          "new_text": null,
          "old_line_content": "\t\tbtvacinfo->cycle_ctr = (BTCycleId) time(NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4559,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTOptions, fillfactor)",
          "new_text": null,
          "old_line_content": "\t\t{\"fillfactor\", RELOPT_TYPE_INT, offsetof(BTOptions, fillfactor)},",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 4561,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTOptions, vacuum_cleanup_index_scale_factor)",
          "new_text": null,
          "old_line_content": "\t\toffsetof(BTOptions, vacuum_cleanup_index_scale_factor)},",
          "new_line_content": "bytea *",
          "content_same": false
        },
        {
          "line": 4563,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(BTOptions, deduplicate_items)",
          "new_text": null,
          "old_line_content": "\t\toffsetof(BTOptions, deduplicate_items)}",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4566,
          "old_api": "build_reloptions",
          "new_api": null,
          "old_text": "build_reloptions(reloptions, validate,\n\t\t\t\t\t\t\t\t\t  RELOPT_KIND_BTREE,\n\t\t\t\t\t\t\t\t\t  sizeof(BTOptions),\n\t\t\t\t\t\t\t\t\t  tab, lengthof(tab))",
          "new_text": null,
          "old_line_content": "\treturn (bytea *) build_reloptions(reloptions, validate,",
          "new_line_content": "\t\t{\"vacuum_cleanup_index_scale_factor\", RELOPT_TYPE_REAL,",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->numArrayKeys)",
          "new_text": null,
          "old_line_content": "\t\tAssert(so->numArrayKeys);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": "_bt_verify_keys_with_arraykeys",
          "new_api": null,
          "old_text": "_bt_verify_keys_with_arraykeys(scan)",
          "new_text": null,
          "old_line_content": "\t\tAssert(_bt_verify_keys_with_arraykeys(scan));",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 2595,
          "old_api": "_bt_preprocess_array_keys",
          "new_api": null,
          "old_text": "_bt_preprocess_array_keys(scan)",
          "new_text": null,
          "old_line_content": "\tarrayKeyData = _bt_preprocess_array_keys(scan);",
          "new_line_content": "\tso->numberOfKeys = 0;",
          "content_same": false
        },
        {
          "line": 4653,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(rel)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "new_line_content": " * final datum.",
          "content_same": false
        },
        {
          "line": 4654,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 560,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->numArrayKeys)",
          "new_text": null,
          "old_line_content": "\tAssert(so->numArrayKeys);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(so->arrayContext,\n\t\t\t\t\t\t\t\t\t\tnumberOfKeys * sizeof(int))",
          "new_text": null,
          "old_line_content": "\t\tkeyDataMap = MemoryContextAlloc(so->arrayContext,",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(outkey->sk_strategy != InvalidStrategy)",
          "new_text": null,
          "old_line_content": "\t\tAssert(outkey->sk_strategy != InvalidStrategy);",
          "new_line_content": "\tfor (int output_ikey = 0; output_ikey < so->numberOfKeys; output_ikey++)",
          "content_same": false
        },
        {
          "line": 4665,
          "old_api": "BTreeTupleIsPivot",
          "new_api": null,
          "old_text": "BTreeTupleIsPivot(firstright)",
          "new_text": null,
          "old_line_content": "\tAssert(!BTreeTupleIsPivot(lastleft) && !BTreeTupleIsPivot(firstright));",
          "new_line_content": "\tSize\t\tnewsize;",
          "content_same": false
        },
        {
          "line": 4668,
          "old_api": "_bt_keep_natts",
          "new_api": null,
          "old_text": "_bt_keep_natts(rel, lastleft, firstright, itup_key)",
          "new_text": null,
          "old_line_content": "\tkeepnatts = _bt_keep_natts(rel, lastleft, firstright, itup_key);",
          "new_line_content": "\t * We should only ever truncate non-pivot tuples from leaf pages.  It's",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"btree index keys must be ordered by attribute\")",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"btree index keys must be ordered by attribute\");",
          "new_line_content": "\t\tinkeys = scan->keyData;",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(last_equal_output_ikey < output_ikey)",
          "new_text": null,
          "old_line_content": "\t\tAssert(last_equal_output_ikey < output_ikey);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(last_equal_output_ikey < input_ikey)",
          "new_text": null,
          "old_line_content": "\t\tAssert(last_equal_output_ikey < input_ikey);",
          "new_line_content": "\t\tif (outkey->sk_strategy != BTEqualStrategyNumber)",
          "content_same": false
        },
        {
          "line": 4675,
          "old_api": "index_truncate_tuple",
          "new_api": null,
          "old_text": "index_truncate_tuple(itupdesc, firstright,\n\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts))",
          "new_text": null,
          "old_line_content": "\tpivot = index_truncate_tuple(itupdesc, firstright,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4676,
          "old_api": "Min",
          "new_api": null,
          "old_text": "Min(keepnatts, nkeyatts)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t Min(keepnatts, nkeyatts));",
          "new_line_content": "#ifdef DEBUG_NO_TRUNCATE",
          "content_same": false
        },
        {
          "line": 2630,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(outkeys, cur, sizeof(ScanKeyData))",
          "new_text": null,
          "old_line_content": "\t\tmemcpy(outkeys, cur, sizeof(ScanKeyData));",
          "new_line_content": "\t/* We can short-circuit most of the work if there's just one key */",
          "content_same": false
        },
        {
          "line": 4678,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(pivot)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleIsPosting(pivot))",
          "new_line_content": "\tkeepnatts = nkeyatts + 1;",
          "content_same": false
        },
        {
          "line": 4685,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1)",
          "new_text": null,
          "old_line_content": "\t\tAssert(keepnatts == nkeyatts || keepnatts == nkeyatts + 1);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 4686,
          "old_api": "IndexRelationGetNumberOfAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfAttributes(rel)",
          "new_text": null,
          "old_line_content": "\t\tAssert(IndexRelationGetNumberOfAttributes(rel) == nkeyatts);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 4688,
          "old_api": "BTreeTupleGetPostingOffset",
          "new_api": null,
          "old_text": "BTreeTupleGetPostingOffset(firstright)",
          "new_text": null,
          "old_line_content": "\t\tpivot->t_info |= MAXALIGN(BTreeTupleGetPostingOffset(firstright));",
          "new_line_content": "\t\t * when it has no attributes to truncate.  When that happens, we may",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur->sk_flags & SK_SEARCHARRAY)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(cur->sk_flags & SK_SEARCHARRAY);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2643,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur->sk_strategy != BTEqualStrategyNumber ||\n\t\t\t\t   (so->arrayKeys[0].scan_key == 0 &&\n\t\t\t\t\tOidIsValid(so->orderProcs[0].fn_oid)))",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(cur->sk_strategy != BTEqualStrategyNumber ||",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(so->orderProcs[0].fn_oid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tOidIsValid(so->orderProcs[0].fn_oid)));",
          "new_line_content": "\t\t\t * (we'll miss out on the single value array transformation, but",
          "content_same": false
        },
        {
          "line": 4697,
          "old_api": "BTreeTupleSetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleSetNAtts(pivot, keepnatts, false)",
          "new_text": null,
          "old_line_content": "\t\tBTreeTupleSetNAtts(pivot, keepnatts, false);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "_bt_setup_array_cmp",
          "new_api": null,
          "old_text": "_bt_setup_array_cmp(scan, outkey, elemtype,\n\t\t\t\t\t\t\t\t&so->orderProcs[output_ikey], NULL)",
          "new_text": null,
          "old_line_content": "\t\t\t_bt_setup_array_cmp(scan, outkey, elemtype,",
          "new_line_content": "\t\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(xform, 0, sizeof(xform))",
          "new_text": null,
          "old_line_content": "\tmemset(xform, 0, sizeof(xform));",
          "new_line_content": "\t * Initialize for processing of keys for attr 1.",
          "content_same": false
        },
        {
          "line": 4714,
          "old_api": "MAXALIGN",
          "new_api": null,
          "old_text": "MAXALIGN(sizeof(ItemPointerData))",
          "new_text": null,
          "old_line_content": "\tnewsize = MAXALIGN(IndexTupleSize(pivot)) + MAXALIGN(sizeof(ItemPointerData));",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 4715,
          "old_api": "palloc0",
          "new_api": null,
          "old_text": "palloc0(newsize)",
          "new_text": null,
          "old_line_content": "\ttidpivot = palloc0(newsize);",
          "new_line_content": "\t * Use enlarged space that holds a copy of pivot.  We need the extra space",
          "content_same": false
        },
        {
          "line": 4716,
          "old_api": "IndexTupleSize",
          "new_api": null,
          "old_text": "IndexTupleSize(pivot)",
          "new_text": null,
          "old_line_content": "\tmemcpy(tidpivot, pivot, MAXALIGN(IndexTupleSize(pivot)));",
          "new_line_content": "\t * to store a heap TID at the end (using the special pivot tuple",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->num_elems > 0)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(array->num_elems > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4718,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(pivot)",
          "new_text": null,
          "old_line_content": "\tpfree(pivot);",
          "new_line_content": "\t * possible posting list/non-key attribute values removed at this point.",
          "content_same": false
        },
        {
          "line": 2676,
          "old_api": "_bt_fix_scankey_strategy",
          "new_api": null,
          "old_text": "_bt_fix_scankey_strategy(cur, indoption)",
          "new_text": null,
          "old_line_content": "\t\t\tif (!_bt_fix_scankey_strategy(cur, indoption))",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 4726,
          "old_api": "BTreeTupleSetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleSetNAtts(tidpivot, nkeyatts, true)",
          "new_text": null,
          "old_line_content": "\tBTreeTupleSetNAtts(tidpivot, nkeyatts, true);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4727,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(tidpivot)",
          "new_text": null,
          "old_line_content": "\tpivotheaptid = BTreeTupleGetHeapTID(tidpivot);",
          "new_line_content": "\t * Store all of firstright's key attribute values plus a tiebreaker heap",
          "content_same": false
        },
        {
          "line": 4736,
          "old_api": "BTreeTupleGetMaxHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "new_text": null,
          "old_line_content": "\tItemPointerCopy(BTreeTupleGetMaxHeapTID(lastleft), pivotheaptid);",
          "new_line_content": "\t * Lehman & Yao use lastleft as the leaf high key in all cases, but don't",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(array, array + 1,\n\t\t\t\t\t\t\tsizeof(BTArrayKeyInfo) *\n\t\t\t\t\t\t\t(so->numArrayKeys - arrayidx))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemmove(array, array + 1,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"btree index keys must be ordered by attribute\")",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(ERROR, \"btree index keys must be ordered by attribute\");",
          "new_line_content": "\t\tif (i == numberOfKeys || cur->sk_attno != attno)",
          "content_same": false
        },
        {
          "line": 4749,
          "old_api": "BTreeTupleGetMaxHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetMaxHeapTID(lastleft)",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(BTreeTupleGetMaxHeapTID(lastleft),",
          "new_line_content": "\t * a strict lower bound on items on the right page, and a non-strict upper",
          "content_same": false
        },
        {
          "line": 4750,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "new_line_content": "\t * bound for items on the left page.  Assert that heap TIDs follow these",
          "content_same": false
        },
        {
          "line": 4751,
          "old_api": "ItemPointerCompare",
          "new_api": null,
          "old_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft))",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "new_line_content": "\t * invariants, since a heap TID value is apparently needed as a",
          "content_same": false
        },
        {
          "line": 4752,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(lastleft)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(lastleft)) >= 0);",
          "new_line_content": "\t * tiebreaker.",
          "content_same": false
        },
        {
          "line": 4753,
          "old_api": "ItemPointerCompare",
          "new_api": null,
          "old_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 4754,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "new_line_content": "#ifndef DEBUG_NO_TRUNCATE",
          "content_same": false
        },
        {
          "line": 666,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(found)",
          "new_text": null,
          "old_line_content": "\t\tAssert(found);",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 4767,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\tItemPointerCopy(BTreeTupleGetHeapTID(firstright), pivotheaptid);",
          "new_line_content": "\t * needed as a tiebreaker).  DEBUG_NO_TRUNCATE must therefore use a heap",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->scan_key == eq_in_ikey)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(array->scan_key == eq_in_ikey);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(orderproc->fn_oid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(OidIsValid(orderproc->fn_oid));",
          "new_line_content": "\t\t\t\t\teq_in_ikey = xform[BTEqualStrategyNumber - 1].ikey;",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg_internal(\"number of array scan keys left by preprocessing (%d) exceeds the maximum allowed by parallel btree index scans (%d)\",\n\t\t\t\t\t\t\t\t so->numArrayKeys, INDEX_MAX_KEYS)))",
          "new_text": null,
          "old_line_content": "\t\tereport(ERROR,",
          "new_line_content": "\t * current array elements (for arrays kept by preprocessing) to schedule",
          "content_same": false
        },
        {
          "line": 678,
          "old_api": "errcode",
          "new_api": null,
          "old_text": "errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED)",
          "new_text": null,
          "old_line_content": "\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "new_line_content": "\t * the next primitive index scan.  The underlying structure is protected",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "errmsg_internal",
          "new_api": null,
          "old_text": "errmsg_internal(\"number of array scan keys left by preprocessing (%d) exceeds the maximum allowed by parallel btree index scans (%d)\",\n\t\t\t\t\t\t\t\t so->numArrayKeys, INDEX_MAX_KEYS)",
          "new_text": null,
          "old_line_content": "\t\t\t\t errmsg_internal(\"number of array scan keys left by preprocessing (%d) exceeds the maximum allowed by parallel btree index scans (%d)\",",
          "new_line_content": "\t * using a spinlock, so defensively limit its size.  In practice this can",
          "content_same": false
        },
        {
          "line": 4774,
          "old_api": "ItemPointerSetOffsetNumber",
          "new_api": null,
          "old_text": "ItemPointerSetOffsetNumber(pivotheaptid,\n\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)))",
          "new_text": null,
          "old_line_content": "\tItemPointerSetOffsetNumber(pivotheaptid,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4775,
          "old_api": "ItemPointerGetOffsetNumber",
          "new_api": null,
          "old_text": "ItemPointerGetOffsetNumber(pivotheaptid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t   OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)));",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4776,
          "old_api": "ItemPointerCompare",
          "new_api": null,
          "old_text": "ItemPointerCompare(pivotheaptid,\n\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright))",
          "new_text": null,
          "old_line_content": "\tAssert(ItemPointerCompare(pivotheaptid,",
          "new_line_content": "\t * Pivot heap TID should never be fully equal to firstright.  Note that",
          "content_same": false
        },
        {
          "line": 4777,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(firstright)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t  BTreeTupleGetHeapTID(firstright)) < 0);",
          "new_line_content": "\t * the pivot heap TID will still end up equal to lastleft's heap TID when",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": "_bt_compare_scankey_args",
          "new_api": null,
          "old_text": "_bt_compare_scankey_args(scan, chk, eq, chk,\n\t\t\t\t\t\t\t\t\t\t\t\t array, orderproc,\n\t\t\t\t\t\t\t\t\t\t\t\t &test_result)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (_bt_compare_scankey_args(scan, chk, eq, chk,",
          "new_line_content": "\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 4798,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint\t\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * caller must use a heap TID as a unique-ifier in new pivot tuple.",
          "content_same": false
        },
        {
          "line": 4799,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(rel)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 2752,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!array || array->num_elems > 0)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(!array || array->num_elems > 0);",
          "new_line_content": "\t\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(skey->sk_strategy == BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\tAssert(skey->sk_strategy == BTEqualStrategyNumber);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 716,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(elemtype)",
          "new_text": null,
          "old_line_content": "\tAssert(OidIsValid(elemtype));",
          "new_line_content": "\tBTScanOpaque so = (BTScanOpaque) scan->opaque;",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": "_bt_compare_scankey_args",
          "new_api": null,
          "old_text": "_bt_compare_scankey_args(scan, le, lt, le, NULL, NULL,\n\t\t\t\t\t\t\t\t\t\t\t &test_result)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (_bt_compare_scankey_args(scan, le, lt, le, NULL, NULL,",
          "new_line_content": "\t\t\tif (xform[BTLessStrategyNumber - 1].skey",
          "content_same": false
        },
        {
          "line": 4820,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "new_text": null,
          "old_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 725,
          "old_api": "index_getprocinfo",
          "new_api": null,
          "old_text": "index_getprocinfo(rel, skey->sk_attno, BTORDER_PROC)",
          "new_text": null,
          "old_line_content": "\t\t*orderproc = *index_getprocinfo(rel, skey->sk_attno, BTORDER_PROC);",
          "new_line_content": "\t * If scankey operator is not a cross-type comparison, we can use the",
          "content_same": false
        },
        {
          "line": 4821,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "new_text": null,
          "old_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "new_line_content": "\t\tDatum\t\tdatum1,",
          "content_same": false
        },
        {
          "line": 2786,
          "old_api": "_bt_compare_scankey_args",
          "new_api": null,
          "old_text": "_bt_compare_scankey_args(scan, ge, gt, ge, NULL, NULL,\n\t\t\t\t\t\t\t\t\t\t\t &test_result)",
          "new_text": null,
          "old_line_content": "\t\t\t\tif (_bt_compare_scankey_args(scan, ge, gt, ge, NULL, NULL,",
          "new_line_content": "\t\t\tif (xform[BTGreaterStrategyNumber - 1].skey",
          "content_same": false
        },
        {
          "line": 743,
          "old_api": "get_opfamily_proc",
          "new_api": null,
          "old_text": "get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t opcintype, elemtype, BTORDER_PROC)",
          "new_text": null,
          "old_line_content": "\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],",
          "new_line_content": "\t * index tuple's attribute value to search for a matching array element).",
          "content_same": false
        },
        {
          "line": 4840,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!itup_key->allequalimage ||\n\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright))",
          "new_text": null,
          "old_line_content": "\tAssert(!itup_key->allequalimage ||",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 745,
          "old_api": "RegProcedureIsValid",
          "new_api": null,
          "old_text": "RegProcedureIsValid(cmp_proc)",
          "new_text": null,
          "old_line_content": "\tif (!RegProcedureIsValid(cmp_proc))",
          "new_line_content": "\t * Note: it's possible that this would fail, if the opfamily is",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",\n\t\t\t BTORDER_PROC, opcintype, elemtype, skey->sk_attno,\n\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",",
          "new_line_content": "\t * incomplete, but only in cases where it's quite likely that _bt_first",
          "content_same": false
        },
        {
          "line": 4841,
          "old_api": "_bt_keep_natts_fast",
          "new_api": null,
          "old_text": "_bt_keep_natts_fast(rel, lastleft, firstright)",
          "new_text": null,
          "old_line_content": "\t\t   keepnatts == _bt_keep_natts_fast(rel, lastleft, firstright));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 748,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2807,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(outkey, xform[j].skey, sizeof(ScanKeyData))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemcpy(outkey, xform[j].skey, sizeof(ScanKeyData));",
          "new_line_content": "\t\t\tfor (j = BTMaxStrategyNumber; --j >= 0;)",
          "content_same": false
        },
        {
          "line": 2811,
          "old_api": "_bt_mark_scankey_required",
          "new_api": null,
          "old_text": "_bt_mark_scankey_required(outkey)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t_bt_mark_scankey_required(outkey);",
          "new_line_content": "\t\t\t\t\tScanKey\t\toutkey = &outkeys[new_numberOfKeys++];",
          "content_same": false
        },
        {
          "line": 765,
          "old_api": "get_opfamily_proc",
          "new_api": null,
          "old_text": "get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t elemtype, elemtype, BTORDER_PROC)",
          "new_text": null,
          "old_line_content": "\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 767,
          "old_api": "RegProcedureIsValid",
          "new_api": null,
          "old_text": "RegProcedureIsValid(cmp_proc)",
          "new_text": null,
          "old_line_content": "\tif (!RegProcedureIsValid(cmp_proc))",
          "new_line_content": "\t * incomplete, but it seems quite unlikely that an opfamily would omit",
          "content_same": false
        },
        {
          "line": 768,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",\n\t\t\t BTORDER_PROC, elemtype, elemtype,\n\t\t\t skey->sk_attno, RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"missing support function %d(%u,%u) for attribute %d of index \\\"%s\\\"\",",
          "new_line_content": "\t * non-cross-type comparison procs for any datatype that it supports at",
          "content_same": false
        },
        {
          "line": 770,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t skey->sk_attno, RelationGetRelationName(rel));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2823,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(xform, 0, sizeof(xform))",
          "new_text": null,
          "old_line_content": "\t\t\tmemset(xform, 0, sizeof(xform));",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 4871,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(rel)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\titupdesc = RelationGetDescr(rel);",
          "new_line_content": " * negatives generally only have the effect of making leaf page splits use a",
          "content_same": false
        },
        {
          "line": 4872,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint\t\t\tkeysz = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * more balanced split point.",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(outkey, cur, sizeof(ScanKeyData))",
          "new_text": null,
          "old_line_content": "\t\t\tmemcpy(outkey, cur, sizeof(ScanKeyData));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4884,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(lastleft, attnum, itupdesc, &isNull1)",
          "new_text": null,
          "old_line_content": "\t\tdatum1 = index_getattr(lastleft, attnum, itupdesc, &isNull1);",
          "new_line_content": "\t\tDatum\t\tdatum1,",
          "content_same": false
        },
        {
          "line": 4885,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(firstright, attnum, itupdesc, &isNull2)",
          "new_text": null,
          "old_line_content": "\t\tdatum2 = index_getattr(firstright, attnum, itupdesc, &isNull2);",
          "new_line_content": "\t\t\t\t\tdatum2;",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": "_bt_mark_scankey_required",
          "new_api": null,
          "old_text": "_bt_mark_scankey_required(outkey)",
          "new_text": null,
          "old_line_content": "\t\t\t\t_bt_mark_scankey_required(outkey);",
          "new_line_content": "\t\t\tScanKey\t\toutkey = &outkeys[new_numberOfKeys++];",
          "content_same": false
        },
        {
          "line": 4886,
          "old_api": "TupleDescAttr",
          "new_api": null,
          "old_text": "TupleDescAttr(itupdesc, attnum - 1)",
          "new_text": null,
          "old_line_content": "\t\tatt = TupleDescAttr(itupdesc, attnum - 1);",
          "new_line_content": "\t\tbool\t\tisNull1,",
          "content_same": false
        },
        {
          "line": 803,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(skey->sk_strategy != BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\tAssert(skey->sk_strategy != BTEqualStrategyNumber);",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 804,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(elemtype)",
          "new_text": null,
          "old_line_content": "\tAssert(OidIsValid(elemtype));",
          "new_line_content": "\t * Note: it's possible that this would fail, if the opfamily is",
          "content_same": false
        },
        {
          "line": 805,
          "old_api": "get_opfamily_member",
          "new_api": null,
          "old_text": "get_opfamily_member(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t elemtype,\n\t\t\t\t\t\t\t\t elemtype,\n\t\t\t\t\t\t\t\t strat)",
          "new_text": null,
          "old_line_content": "\tcmp_op = get_opfamily_member(rel->rd_opfamily[skey->sk_attno - 1],",
          "new_line_content": "\t * incomplete, but it seems quite unlikely that an opfamily would omit",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(arrayKeyData)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(arrayKeyData);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur->sk_flags & SK_SEARCHARRAY)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(cur->sk_flags & SK_SEARCHARRAY);",
          "new_line_content": "\t\t * Does this input scan key require further processing as an array?",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "get_opcode",
          "new_api": null,
          "old_text": "get_opcode(cmp_op)",
          "new_text": null,
          "old_line_content": "\tcmp_proc = get_opcode(cmp_op);",
          "new_line_content": "\t\t\t\t\t\t\t\t elemtype,",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "RegProcedureIsValid",
          "new_api": null,
          "old_text": "RegProcedureIsValid(cmp_proc)",
          "new_text": null,
          "old_line_content": "\tif (!RegProcedureIsValid(cmp_proc))",
          "new_line_content": "\t\t\t\t\t\t\t\t strat);",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(arrayKeyData)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(arrayKeyData);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "fmgr_info",
          "new_api": null,
          "old_text": "fmgr_info(cmp_proc, &flinfo)",
          "new_text": null,
          "old_line_content": "\tfmgr_info(cmp_proc, &flinfo);",
          "new_line_content": "\t\t\t strat, elemtype, elemtype,",
          "content_same": false
        },
        {
          "line": 4918,
          "old_api": "IndexRelationGetNumberOfAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint16\t\tnatts = IndexRelationGetNumberOfAttributes(rel);",
          "new_line_content": " * context check is appropriate.  This routine is as strict as possible about",
          "content_same": false
        },
        {
          "line": 4919,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tint16\t\tnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);",
          "new_line_content": " * what is expected on each version of btree.",
          "content_same": false
        },
        {
          "line": 4920,
          "old_api": "BTPageGetOpaque",
          "new_api": null,
          "old_text": "BTPageGetOpaque(page)",
          "new_text": null,
          "old_line_content": "\tBTPageOpaque opaque = BTPageGetOpaque(page);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 4928,
          "old_api": "P_IGNORE",
          "new_api": null,
          "old_text": "P_IGNORE(opaque)",
          "new_text": null,
          "old_line_content": "\tif (P_IGNORE(opaque))",
          "new_line_content": "\tint\t\t\ttupnatts;",
          "content_same": false
        },
        {
          "line": 4931,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(offnum >= FirstOffsetNumber &&\n\t\t   offnum <= PageGetMaxOffsetNumber(page))",
          "new_text": null,
          "old_line_content": "\tAssert(offnum >= FirstOffsetNumber &&",
          "new_line_content": "\t * We cannot reliably test a deleted or half-dead page, since they have",
          "content_same": false
        },
        {
          "line": 4932,
          "old_api": "PageGetMaxOffsetNumber",
          "new_api": null,
          "old_text": "PageGetMaxOffsetNumber(page)",
          "new_text": null,
          "old_line_content": "\t\t   offnum <= PageGetMaxOffsetNumber(page));",
          "new_line_content": "\t * dummy high keys",
          "content_same": false
        },
        {
          "line": 4935,
          "old_api": "BTreeTupleGetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleGetNAtts(itup, rel)",
          "new_text": null,
          "old_line_content": "\ttupnatts = BTreeTupleGetNAtts(itup, rel);",
          "new_line_content": "\t\treturn true;",
          "content_same": false
        },
        {
          "line": 4942,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleIsPosting(itup) &&",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4943,
          "old_api": "ItemPointerGetOffsetNumberNoCheck",
          "new_api": null,
          "old_text": "ItemPointerGetOffsetNumberNoCheck(&itup->t_tid)",
          "new_text": null,
          "old_line_content": "\t\t(ItemPointerGetOffsetNumberNoCheck(&itup->t_tid) &",
          "new_line_content": "\t/* !heapkeyspace indexes do not support deduplication */",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->scan_key == i)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(array->scan_key == i);",
          "new_line_content": "\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 2898,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(orderproc->fn_oid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(OidIsValid(orderproc->fn_oid));",
          "new_line_content": "\t\t\t\tif ((cur->sk_flags & SK_SEARCHARRAY))",
          "content_same": false
        },
        {
          "line": 4951,
          "old_api": "P_ISLEAF",
          "new_api": null,
          "old_text": "P_ISLEAF(opaque)",
          "new_text": null,
          "old_line_content": "\tif (P_ISLEAF(opaque))",
          "new_line_content": "\t\treturn false;",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "qsort_arg",
          "new_api": null,
          "old_text": "qsort_arg(elems, nelems, sizeof(Datum),\n\t\t\t  _bt_compare_array_elements, &cxt)",
          "new_text": null,
          "old_line_content": "\tqsort_arg(elems, nelems, sizeof(Datum),",
          "new_line_content": "\t\treturn nelems;\t\t\t/* no work to do */",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->scan_key == xform[j].ikey)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(array->scan_key == xform[j].ikey);",
          "new_line_content": "\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 2906,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(orderproc->fn_oid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(OidIsValid(orderproc->fn_oid));",
          "new_line_content": "\t\t\t\telse if ((xform[j].skey->sk_flags & SK_SEARCHARRAY))",
          "content_same": false
        },
        {
          "line": 4953,
          "old_api": "P_FIRSTDATAKEY",
          "new_api": null,
          "old_text": "P_FIRSTDATAKEY(opaque)",
          "new_text": null,
          "old_line_content": "\t\tif (offnum >= P_FIRSTDATAKEY(opaque))",
          "new_line_content": "\t/* INCLUDE indexes do not support deduplication */",
          "content_same": false
        },
        {
          "line": 860,
          "old_api": "qunique_arg",
          "new_api": null,
          "old_text": "qunique_arg(elems, nelems, sizeof(Datum),\n\t\t\t\t\t   _bt_compare_array_elements, &cxt)",
          "new_text": null,
          "old_line_content": "\treturn qunique_arg(elems, nelems, sizeof(Datum),",
          "new_line_content": "\tcxt.collation = skey->sk_collation;",
          "content_same": false
        },
        {
          "line": 2920,
          "old_api": "_bt_compare_scankey_args",
          "new_api": null,
          "old_text": "_bt_compare_scankey_args(scan, cur, cur, xform[j].skey,\n\t\t\t\t\t\t\t\t\t\t array, orderproc, &test_result)",
          "new_text": null,
          "old_line_content": "\t\t\tif (_bt_compare_scankey_args(scan, cur, cur, xform[j].skey,",
          "new_line_content": "\t\t\t\t * failed to eliminate redundant arrays through array merging.",
          "content_same": false
        },
        {
          "line": 4976,
          "old_api": "P_RIGHTMOST",
          "new_api": null,
          "old_text": "P_RIGHTMOST(opaque)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!P_RIGHTMOST(opaque));",
          "new_line_content": "\t\telse",
          "content_same": false
        },
        {
          "line": 2934,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!array || array->scan_key == i)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(!array || array->scan_key == i);",
          "new_line_content": "\t\t\t\t\t/*",
          "content_same": false
        },
        {
          "line": 4991,
          "old_api": "P_FIRSTDATAKEY",
          "new_api": null,
          "old_text": "P_FIRSTDATAKEY(opaque)",
          "new_text": null,
          "old_line_content": "\t\tif (offnum == P_FIRSTDATAKEY(opaque))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(j == (BTEqualStrategyNumber - 1))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(j == (BTEqualStrategyNumber - 1));",
          "new_line_content": "\t\t\t\t\t\t * ...unless we have to keep the old key because it's",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(skey->sk_strategy == BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\tAssert(skey->sk_strategy == BTEqualStrategyNumber);",
          "new_line_content": "\tBTSortArrayContext cxt;",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(nextelemtype)",
          "new_text": null,
          "old_line_content": "\tAssert(OidIsValid(origelemtype) && OidIsValid(nextelemtype));",
          "new_line_content": "\tint\t\t\tnelems_orig_start = *nelems_orig,",
          "content_same": false
        },
        {
          "line": 2949,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(xform[j].skey->sk_flags & SK_SEARCHARRAY)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(xform[j].skey->sk_flags & SK_SEARCHARRAY);",
          "new_line_content": "\t\t\t\t\t\t * an array that rendered the new key redundant.  We",
          "content_same": false
        },
        {
          "line": 2950,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(xform[j].ikey == array->scan_key)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(xform[j].ikey == array->scan_key);",
          "new_line_content": "\t\t\t\t\t\t * need to make sure that we don't throw away an array",
          "content_same": false
        },
        {
          "line": 2951,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!(cur->sk_flags & SK_SEARCHARRAY))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(!(cur->sk_flags & SK_SEARCHARRAY));",
          "new_line_content": "\t\t\t\t\t\t * scan key.  _bt_compare_scankey_args expects us to",
          "content_same": false
        },
        {
          "line": 912,
          "old_api": "get_opfamily_proc",
          "new_api": null,
          "old_text": "get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],\n\t\t\t\t\t\t\t\t\t origelemtype, nextelemtype, BTORDER_PROC)",
          "new_text": null,
          "old_line_content": "\t\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[skey->sk_attno - 1],",
          "new_line_content": "\t\tRegProcedure cmp_proc;",
          "content_same": false
        },
        {
          "line": 914,
          "old_api": "RegProcedureIsValid",
          "new_api": null,
          "old_text": "RegProcedureIsValid(cmp_proc)",
          "new_text": null,
          "old_line_content": "\t\tif (!RegProcedureIsValid(cmp_proc))",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 5015,
          "old_api": "ItemPointerGetOffsetNumber",
          "new_api": null,
          "old_text": "ItemPointerGetOffsetNumber(&(itup->t_tid))",
          "new_text": null,
          "old_line_content": "\t\t\t\tItemPointerGetOffsetNumber(&(itup->t_tid)) == P_HIKEY;",
          "new_line_content": "\t\t\t *",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "fmgr_info_cxt",
          "new_api": null,
          "old_text": "fmgr_info_cxt(cmp_proc, mergeproc, so->arrayContext)",
          "new_text": null,
          "old_line_content": "\t\tfmgr_info_cxt(cmp_proc, mergeproc, so->arrayContext);",
          "new_line_content": "\t\t\t/* Can't make the required comparisons */",
          "content_same": false
        },
        {
          "line": 2976,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(outkey, xform[j].skey, sizeof(ScanKeyData))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(outkey, xform[j].skey, sizeof(ScanKeyData));",
          "new_line_content": "\t\t\t\t * always in the same order as their corresponding scan keys,",
          "content_same": false
        },
        {
          "line": 2980,
          "old_api": "_bt_mark_scankey_required",
          "new_api": null,
          "old_text": "_bt_mark_scankey_required(outkey)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t_bt_mark_scankey_required(outkey);",
          "new_line_content": "\t\t\t\tScanKey\t\toutkey = &outkeys[new_numberOfKeys++];",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "_bt_compare_array_elements",
          "new_api": null,
          "old_text": "_bt_compare_array_elements(oelem, nelem, &cxt)",
          "new_text": null,
          "old_line_content": "\t\tint\t\t\tres = _bt_compare_array_elements(oelem, nelem, &cxt);",
          "new_line_content": "\tcxt.reverse = reverse;",
          "content_same": false
        },
        {
          "line": 5033,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(heapkeyspace)",
          "new_text": null,
          "old_line_content": "\tAssert(heapkeyspace);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5040,
          "old_api": "BTreeTupleIsPivot",
          "new_api": null,
          "old_text": "BTreeTupleIsPivot(itup)",
          "new_text": null,
          "old_line_content": "\tif (!BTreeTupleIsPivot(itup))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5044,
          "old_api": "BTreeTupleIsPosting",
          "new_api": null,
          "old_text": "BTreeTupleIsPosting(itup)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleIsPosting(itup))",
          "new_line_content": "\t * non-key attributes.",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "_bt_preprocess_array_keys_final",
          "new_api": null,
          "old_text": "_bt_preprocess_array_keys_final(scan, keyDataMap)",
          "new_text": null,
          "old_line_content": "\t\t_bt_preprocess_array_keys_final(scan, keyDataMap);",
          "new_line_content": "\t * Now that we've built a temporary mapping from so->keyData[] (output",
          "content_same": false
        },
        {
          "line": 5051,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(itup)",
          "new_text": null,
          "old_line_content": "\tif (BTreeTupleGetHeapTID(itup) != NULL && tupnatts != nkeyatts)",
          "new_line_content": "\t\treturn false;",
          "content_same": false
        },
        {
          "line": 3029,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (((cur->sk_flags & SK_BT_REQFWD) && ScanDirectionIsForward(dir)) ||",
          "new_line_content": "\t\tif (!(cur->sk_flags & SK_SEARCHARRAY) ||",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t((cur->sk_flags & SK_BT_REQBKWD) && ScanDirectionIsBackward(dir)))",
          "new_line_content": "\t\t\tcur->sk_strategy != BTEqualStrategyNumber)",
          "content_same": false
        },
        {
          "line": 984,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(arraysk->sk_attno == skey->sk_attno)",
          "new_text": null,
          "old_line_content": "\tAssert(arraysk->sk_attno == skey->sk_attno);",
          "new_line_content": "\t\t\t\tcmpexact = 0,",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->num_elems > 0)",
          "new_text": null,
          "old_line_content": "\tAssert(array->num_elems > 0);",
          "new_line_content": "\t\t\t\tmatchelem,",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!(arraysk->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)))",
          "new_text": null,
          "old_line_content": "\tAssert(!(arraysk->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)));",
          "new_line_content": "\t\t\t\tnew_nelems = 0;",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert((arraysk->sk_flags & SK_SEARCHARRAY) &&\n\t\t   arraysk->sk_strategy == BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\tAssert((arraysk->sk_flags & SK_SEARCHARRAY) &&",
          "new_line_content": "\tFmgrInfo\tcrosstypeproc;",
          "content_same": false
        },
        {
          "line": 3033,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "new_line_content": "\t\tarray = &so->arrayKeys[arrayidx++];",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!(skey->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)))",
          "new_text": null,
          "old_line_content": "\tAssert(!(skey->sk_flags & (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5082,
          "old_api": "IndexTupleSize",
          "new_api": null,
          "old_text": "IndexTupleSize(newtup)",
          "new_text": null,
          "old_line_content": "\titemsz = MAXALIGN(IndexTupleSize(newtup));",
          "new_line_content": "_bt_check_third_page(Relation rel, Relation heap, bool needheaptidspace,",
          "content_same": false
        },
        {
          "line": 5085,
          "old_api": "BTMaxItemSize",
          "new_api": null,
          "old_text": "BTMaxItemSize(page)",
          "new_text": null,
          "old_line_content": "\tif (itemsz <= BTMaxItemSize(page))",
          "new_line_content": "\tSize\t\titemsz;",
          "content_same": false
        },
        {
          "line": 3042,
          "old_api": "_bt_verify_keys_with_arraykeys",
          "new_api": null,
          "old_text": "_bt_verify_keys_with_arraykeys(scan)",
          "new_text": null,
          "old_line_content": "\treturn _bt_verify_keys_with_arraykeys(scan);",
          "new_line_content": "\t\t\tfirst_elem_dir = array->num_elems - 1;",
          "content_same": false
        },
        {
          "line": 5093,
          "old_api": "BTMaxItemSizeNoHeapTid",
          "new_api": null,
          "old_text": "BTMaxItemSizeNoHeapTid(page)",
          "new_text": null,
          "old_line_content": "\tif (!needheaptidspace && itemsz <= BTMaxItemSizeNoHeapTid(page))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5100,
          "old_api": "BTPageGetOpaque",
          "new_api": null,
          "old_text": "BTPageGetOpaque(page)",
          "new_text": null,
          "old_line_content": "\topaque = BTPageGetOpaque(page);",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 5101,
          "old_api": "P_ISLEAF",
          "new_api": null,
          "old_text": "P_ISLEAF(opaque)",
          "new_text": null,
          "old_line_content": "\tif (!P_ISLEAF(opaque))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5102,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",\n\t\t\t itemsz, RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"cannot insert oversized tuple of size %zu on internal page of index \\\"%s\\\"\",",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 5103,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t itemsz, RelationGetRelationName(rel));",
          "new_line_content": "\t * Internal page insertions cannot fail here, because that would mean that",
          "content_same": false
        },
        {
          "line": 5105,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t errmsg(\"index row size %zu exceeds btree version %u maximum %zu for index \\\"%s\\\"\",\n\t\t\t\t\titemsz,\n\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,\n\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :\n\t\t\t\t\tBTMaxItemSizeNoHeapTid(page),\n\t\t\t\t\tRelationGetRelationName(rel)),\n\t\t\t errdetail(\"Index row references tuple (%u,%u) in relation \\\"%s\\\".\",\n\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),\n\t\t\t\t\t   RelationGetRelationName(heap)),\n\t\t\t errhint(\"Values larger than 1/3 of a buffer page cannot be indexed.\\n\"\n\t\t\t\t\t \"Consider a function index of an MD5 hash of the value, \"\n\t\t\t\t\t \"or use full text indexing.\"),\n\t\t\t errtableconstraint(heap, RelationGetRelationName(rel))))",
          "new_text": null,
          "old_line_content": "\tereport(ERROR,",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 5110,
          "old_api": "BTMaxItemSize",
          "new_api": null,
          "old_text": "BTMaxItemSize(page)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tneedheaptidspace ? BTMaxItemSize(page) :",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5114,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(newtup)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t   ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),",
          "new_line_content": "\t\t\t\t\titemsz,",
          "content_same": false
        },
        {
          "line": 5115,
          "old_api": "BTreeTupleGetHeapTID",
          "new_api": null,
          "old_text": "BTreeTupleGetHeapTID(newtup)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t   ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),",
          "new_line_content": "\t\t\t\t\tneedheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": "get_opfamily_proc",
          "new_api": null,
          "old_text": "get_opfamily_proc(rel->rd_opfamily[arraysk->sk_attno - 1],\n\t\t\t\t\t\t\t\t\t skey->sk_subtype, arraysk_elemtype,\n\t\t\t\t\t\t\t\t\t BTORDER_PROC)",
          "new_text": null,
          "old_line_content": "\t\tcmp_proc = get_opfamily_proc(rel->rd_opfamily[arraysk->sk_attno - 1],",
          "new_line_content": "\t\t * Scalar scan key's argument will be passed to _bt_compare_array_skey",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "RegProcedureIsValid",
          "new_api": null,
          "old_text": "RegProcedureIsValid(cmp_proc)",
          "new_text": null,
          "old_line_content": "\t\tif (!RegProcedureIsValid(cmp_proc))",
          "new_line_content": "\t\tarraysk_elemtype = arraysk->sk_subtype;",
          "content_same": false
        },
        {
          "line": 1032,
          "old_api": "fmgr_info",
          "new_api": null,
          "old_text": "fmgr_info(cmp_proc, orderprocp)",
          "new_text": null,
          "old_line_content": "\t\tfmgr_info(cmp_proc, orderprocp);",
          "new_line_content": "\t\t\t*qual_ok = false;\t/* suppress compiler warnings */",
          "content_same": false
        },
        {
          "line": 1035,
          "old_api": "_bt_binsrch_array_skey",
          "new_api": null,
          "old_text": "_bt_binsrch_array_skey(orderprocp, false,\n\t\t\t\t\t\t\t\t\t   NoMovementScanDirection,\n\t\t\t\t\t\t\t\t\t   skey->sk_argument, false, array,\n\t\t\t\t\t\t\t\t\t   arraysk, &cmpresult)",
          "new_text": null,
          "old_line_content": "\tmatchelem = _bt_binsrch_array_skey(orderprocp, false,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5139,
          "old_api": "IndexRelationGetNumberOfAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tif (IndexRelationGetNumberOfAttributes(rel) !=",
          "new_line_content": "bool",
          "content_same": false
        },
        {
          "line": 5140,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\t\tIndexRelationGetNumberOfKeyAttributes(rel))",
          "new_line_content": "_bt_allequalimage(Relation rel, bool debugmessage)",
          "content_same": false
        },
        {
          "line": 5143,
          "old_api": "IndexRelationGetNumberOfKeyAttributes",
          "new_api": null,
          "old_text": "IndexRelationGetNumberOfKeyAttributes(rel)",
          "new_text": null,
          "old_line_content": "\tfor (int i = 0; i < IndexRelationGetNumberOfKeyAttributes(rel); i++)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5150,
          "old_api": "get_opfamily_proc",
          "new_api": null,
          "old_text": "get_opfamily_proc(opfamily, opcintype, opcintype,\n\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC)",
          "new_text": null,
          "old_line_content": "\t\tequalimageproc = get_opfamily_proc(opfamily, opcintype, opcintype,",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 5157,
          "old_api": "OidIsValid",
          "new_api": null,
          "old_text": "OidIsValid(equalimageproc)",
          "new_text": null,
          "old_line_content": "\t\tif (!OidIsValid(equalimageproc) ||",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   BTEQUALIMAGE_PROC);",
          "content_same": false
        },
        {
          "line": 5158,
          "old_api": "OidFunctionCall1Coll",
          "new_api": null,
          "old_text": "OidFunctionCall1Coll(equalimageproc, collation,\n\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))",
          "new_text": null,
          "old_line_content": "\t\t\t!DatumGetBool(OidFunctionCall1Coll(equalimageproc, collation,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5159,
          "old_api": "ObjectIdGetDatum",
          "new_api": null,
          "old_text": "ObjectIdGetDatum(opcintype)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t   ObjectIdGetDatum(opcintype))))",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1072,
          "old_api": "memmove",
          "new_api": null,
          "old_text": "memmove(array->elem_values, array->elem_values + matchelem,\n\t\t\t\t\tsizeof(Datum) * new_nelems)",
          "new_text": null,
          "old_line_content": "\t\t\tmemmove(array->elem_values, array->elem_values + matchelem,",
          "new_line_content": "\t\t\t/* FALL THRU */",
          "content_same": false
        },
        {
          "line": 5169,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" can safely use deduplication\",",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 5170,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"unrecognized StrategyNumber: %d\",\n\t\t\t\t (int) skey->sk_strategy)",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"unrecognized StrategyNumber: %d\",",
          "new_line_content": "\t\t\t/* Shift matching elements to the start of the array, resize */",
          "content_same": false
        },
        {
          "line": 5172,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",\n\t\t\t\t RelationGetRelationName(rel))",
          "new_text": null,
          "old_line_content": "\t\t\telog(DEBUG1, \"index \\\"%s\\\" cannot use deduplication\",",
          "new_line_content": "\tif (debugmessage)",
          "content_same": false
        },
        {
          "line": 5173,
          "old_api": "RelationGetRelationName",
          "new_api": null,
          "old_text": "RelationGetRelationName(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t RelationGetRelationName(rel));",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(new_nelems >= 0)",
          "new_text": null,
          "old_line_content": "\tAssert(new_nelems >= 0);",
          "new_line_content": "\t\tdefault:",
          "content_same": false
        },
        {
          "line": 1101,
          "old_api": "FunctionCall2Coll",
          "new_api": null,
          "old_text": "FunctionCall2Coll(cxt->sortproc,\n\t\t\t\t\t\t\t\t\t\t\t  cxt->collation,\n\t\t\t\t\t\t\t\t\t\t\t  da, db)",
          "new_text": null,
          "old_line_content": "\tcompare = DatumGetInt32(FunctionCall2Coll(cxt->sortproc,",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(leftarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL))",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(leftarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL));",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "INVERT_COMPARE_RESULT",
          "new_api": null,
          "old_text": "INVERT_COMPARE_RESULT(compare)",
          "new_text": null,
          "old_line_content": "\t\tINVERT_COMPARE_RESULT(compare);",
          "new_line_content": "\tint32\t\tcompare;",
          "content_same": false
        },
        {
          "line": 3159,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(rightarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL))",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(rightarg->sk_flags & (SK_SEARCHNULL | SK_SEARCHNOTNULL));",
          "new_line_content": "\t\t\tleftnull = true;",
          "content_same": false
        },
        {
          "line": 3172,
          "old_api": "BTCommuteStrategyNumber",
          "new_api": null,
          "old_text": "BTCommuteStrategyNumber(strat)",
          "new_text": null,
          "old_line_content": "\t\t\tstrat = BTCommuteStrategyNumber(strat);",
          "new_line_content": "\t\t * We treat NULL as either greater than or less than all other values.",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur->sk_strategy == BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\tAssert(cur->sk_strategy == BTEqualStrategyNumber);",
          "new_line_content": "_bt_compare_array_skey(FmgrInfo *orderproc,",
          "content_same": false
        },
        {
          "line": 3192,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"unrecognized StrategyNumber: %d\", (int) strat)",
          "new_text": null,
          "old_line_content": "\t\t\t\telog(ERROR, \"unrecognized StrategyNumber: %d\", (int) strat);",
          "new_line_content": "\t\t\t\t*result = (leftnull >= rightnull);",
          "content_same": false
        },
        {
          "line": 1156,
          "old_api": "FunctionCall2Coll",
          "new_api": null,
          "old_text": "FunctionCall2Coll(orderproc, cur->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t tupdatum, arrdatum)",
          "new_text": null,
          "old_line_content": "\t\tresult = DatumGetInt32(FunctionCall2Coll(orderproc, cur->sk_collation,",
          "new_line_content": "\telse",
          "content_same": false
        },
        {
          "line": 1169,
          "old_api": "INVERT_COMPARE_RESULT",
          "new_api": null,
          "old_text": "INVERT_COMPARE_RESULT(result)",
          "new_text": null,
          "old_line_content": "\t\t\tINVERT_COMPARE_RESULT(result);",
          "new_line_content": "\t\t * _bt_compare does it the wrong way around (flip when *ASC*) in order",
          "content_same": false
        },
        {
          "line": 3232,
          "old_api": "_bt_compare_array_scankey_args",
          "new_api": null,
          "old_text": "_bt_compare_array_scankey_args(scan, leftarg, rightarg,\n\t\t\t\t\t\t\t\t\t\t\t\t  orderproc, array, result)",
          "new_text": null,
          "old_line_content": "\t\t\treturn _bt_compare_array_scankey_args(scan, leftarg, rightarg,",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 3235,
          "old_api": "_bt_compare_array_scankey_args",
          "new_api": null,
          "old_text": "_bt_compare_array_scankey_args(scan, rightarg, leftarg,\n\t\t\t\t\t\t\t\t\t\t\t\t  orderproc, array, result)",
          "new_text": null,
          "old_line_content": "\t\t\treturn _bt_compare_array_scankey_args(scan, rightarg, leftarg,",
          "new_line_content": "\t\t * function.",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(leftarg->sk_attno == rightarg->sk_attno)",
          "new_text": null,
          "old_line_content": "\tAssert(leftarg->sk_attno == rightarg->sk_attno);",
          "new_line_content": "\t\t/* FALL THRU */",
          "content_same": false
        },
        {
          "line": 1208,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur->sk_flags & SK_SEARCHARRAY)",
          "new_text": null,
          "old_line_content": "\tAssert(cur->sk_flags & SK_SEARCHARRAY);",
          "new_line_content": "\tint\t\t\tlow_elem = 0,",
          "content_same": false
        },
        {
          "line": 1209,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur->sk_strategy == BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\tAssert(cur->sk_strategy == BTEqualStrategyNumber);",
          "new_line_content": "\t\t\t\tmid_elem = -1,",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": "ScanDirectionIsNoMovement",
          "new_api": null,
          "old_text": "ScanDirectionIsNoMovement(dir)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!ScanDirectionIsNoMovement(dir));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3269,
          "old_api": "FunctionCall2Coll",
          "new_api": null,
          "old_text": "FunctionCall2Coll(&op->sk_func,\n\t\t\t\t\t\t\t\t\t\t\t\t op->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t leftarg->sk_argument,\n\t\t\t\t\t\t\t\t\t\t\t\t rightarg->sk_argument)",
          "new_text": null,
          "old_line_content": "\t\t*result = DatumGetBool(FunctionCall2Coll(&op->sk_func,",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1235,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "new_line_content": "\t\t * is often either an exact tupdatum match, or a \"close by\" near-match",
          "content_same": false
        },
        {
          "line": 3287,
          "old_api": "BTCommuteStrategyNumber",
          "new_api": null,
          "old_text": "BTCommuteStrategyNumber(strat)",
          "new_text": null,
          "old_line_content": "\t\tstrat = BTCommuteStrategyNumber(strat);",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 3289,
          "old_api": "get_opfamily_member",
          "new_api": null,
          "old_text": "get_opfamily_member(rel->rd_opfamily[leftarg->sk_attno - 1],\n\t\t\t\t\t\t\t\t lefttype,\n\t\t\t\t\t\t\t\t righttype,\n\t\t\t\t\t\t\t\t strat)",
          "new_text": null,
          "old_line_content": "\tcmp_op = get_opfamily_member(rel->rd_opfamily[leftarg->sk_attno - 1],",
          "new_line_content": "\t * un-flip it to get the correct opfamily member.",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": "_bt_compare_array_skey",
          "new_api": null,
          "old_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\t\t\tarrdatum, cur)",
          "new_text": null,
          "old_line_content": "\t\t\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "new_line_content": "\t\t\tlow_elem = array->cur_elem + 1; /* old cur_elem exhausted */",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": "RegProcedureIsValid",
          "new_api": null,
          "old_text": "RegProcedureIsValid(cmp_proc)",
          "new_text": null,
          "old_line_content": "\t\tif (RegProcedureIsValid(cmp_proc))",
          "new_line_content": "\t\t\t\t\t\t\t\t righttype,",
          "content_same": false
        },
        {
          "line": 1271,
          "old_api": "_bt_compare_array_skey",
          "new_api": null,
          "old_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\t\t\tarrdatum, cur)",
          "new_text": null,
          "old_line_content": "\t\t\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "new_line_content": "\t\t\thigh_elem = array->cur_elem - 1;\t/* old cur_elem exhausted */",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "_bt_compare_array_skey",
          "new_api": null,
          "old_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\tarrdatum, cur)",
          "new_text": null,
          "old_line_content": "\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3364,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!(skey->sk_flags & SK_ROW_HEADER))",
          "new_text": null,
          "old_line_content": "\t\tAssert(!(skey->sk_flags & SK_ROW_HEADER));",
          "new_line_content": "\t * column's collation.  At the moment this is a non-issue because we'll",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "_bt_compare_array_skey",
          "new_api": null,
          "old_text": "_bt_compare_array_skey(orderproc, tupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\tarray->elem_values[low_elem], cur)",
          "new_text": null,
          "old_line_content": "\t\tresult = _bt_compare_array_skey(orderproc, tupdatum, tupnull,",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->numArrayKeys)",
          "new_text": null,
          "old_line_content": "\tAssert(so->numArrayKeys);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->qual_ok)",
          "new_text": null,
          "old_line_content": "\tAssert(so->qual_ok);",
          "new_line_content": "_bt_start_array_keys(IndexScanDesc scan, ScanDirection dir)",
          "content_same": false
        },
        {
          "line": 3397,
          "old_api": "BTCommuteStrategyNumber",
          "new_api": null,
          "old_text": "BTCommuteStrategyNumber(skey->sk_strategy)",
          "new_text": null,
          "old_line_content": "\t\tskey->sk_strategy = BTCommuteStrategyNumber(skey->sk_strategy);",
          "new_line_content": "\t\t/* Needn't do the rest */",
          "content_same": false
        },
        {
          "line": 1351,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(curArrayKey->num_elems > 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(curArrayKey->num_elems > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1352,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(skey->sk_flags & SK_SEARCHARRAY)",
          "new_text": null,
          "old_line_content": "\t\tAssert(skey->sk_flags & SK_SEARCHARRAY);",
          "new_line_content": "\tfor (i = 0; i < so->numArrayKeys; i++)",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsBackward(dir))",
          "new_line_content": "\t\tBTArrayKeyInfo *curArrayKey = &so->arrayKeys[i];",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subkey->sk_flags & SK_ROW_MEMBER)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(subkey->sk_flags & SK_ROW_MEMBER);",
          "new_line_content": "\tif (skey->sk_flags & SK_ROW_HEADER)",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": "BTCommuteStrategyNumber",
          "new_api": null,
          "old_text": "BTCommuteStrategyNumber(subkey->sk_strategy)",
          "new_text": null,
          "old_line_content": "\t\t\t\tsubkey->sk_strategy = BTCommuteStrategyNumber(subkey->sk_strategy);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1393,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsForward(dir) && ++cur_elem >= num_elems)",
          "new_line_content": "\t\tBTArrayKeyInfo *curArrayKey = &so->arrayKeys[i];",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\telse if (ScanDirectionIsBackward(dir) && --cur_elem < 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3455,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"unrecognized StrategyNumber: %d\",\n\t\t\t\t (int) skey->sk_strategy)",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"unrecognized StrategyNumber: %d\",",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 3465,
          "old_api": "DatumGetPointer",
          "new_api": null,
          "old_text": "DatumGetPointer(skey->sk_argument)",
          "new_text": null,
          "old_line_content": "\t\tScanKey\t\tsubkey = (ScanKey) DatumGetPointer(skey->sk_argument);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3468,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subkey->sk_flags & SK_ROW_MEMBER)",
          "new_text": null,
          "old_line_content": "\t\tAssert(subkey->sk_flags & SK_ROW_MEMBER);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3469,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subkey->sk_attno == skey->sk_attno)",
          "new_text": null,
          "old_line_content": "\t\tAssert(subkey->sk_attno == skey->sk_attno);",
          "new_line_content": "\tif (skey->sk_flags & SK_ROW_HEADER)",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": "_bt_start_array_keys",
          "new_api": null,
          "old_text": "_bt_start_array_keys(scan, -dir)",
          "new_text": null,
          "old_line_content": "\t_bt_start_array_keys(scan, -dir);",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 3470,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subkey->sk_strategy == skey->sk_strategy)",
          "new_text": null,
          "old_line_content": "\t\tAssert(subkey->sk_strategy == skey->sk_strategy);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3510,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(scan->indexRelation)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\ttupdesc = RelationGetDescr(scan->indexRelation);",
          "new_line_content": " * tupnatts: number of attributes in tupnatts (high key may be truncated)",
          "content_same": false
        },
        {
          "line": 3518,
          "old_api": "_bt_check_compare",
          "new_api": null,
          "old_text": "_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\tarrayKeys, pstate->prechecked, pstate->firstmatch,\n\t\t\t\t\t\t\t&pstate->continuescan, &ikey)",
          "new_text": null,
          "old_line_content": "\tres = _bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,",
          "new_line_content": "\tScanDirection dir = pstate->dir;",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->scan_key == ikey)",
          "new_text": null,
          "old_line_content": "\t\tAssert(array->scan_key == ikey);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3530,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!so->scanBehind && !pstate->prechecked && !pstate->firstmatch)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!so->scanBehind && !pstate->prechecked && !pstate->firstmatch);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (ScanDirectionIsForward(dir))",
          "new_line_content": "\t\tarray = &so->arrayKeys[arrayidx++];",
          "content_same": false
        },
        {
          "line": 3531,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t tupnatts, false, 0, NULL)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 3543,
          "old_api": "_bt_check_compare",
          "new_api": null,
          "old_text": "_bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\t\t\t\tfalse, false, false,\n\t\t\t\t\t\t\t\t\t\t&dcontinuescan, &dikey)",
          "new_text": null,
          "old_line_content": "\t\tAssert(res == _bt_check_compare(scan, dir, tuple, tupnatts, tupdesc,",
          "new_line_content": "\t\tint\t\t\tdikey = 0;",
          "content_same": false
        },
        {
          "line": 3546,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(pstate->continuescan == dcontinuescan)",
          "new_text": null,
          "old_line_content": "\t\tAssert(pstate->continuescan == dcontinuescan);",
          "new_line_content": "\t\t * Call relied on continuescan/firstmatch prechecks -- assert that we",
          "content_same": false
        },
        {
          "line": 3567,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts, true,\n\t\t\t\t\t\t\t\t\t ikey, NULL)",
          "new_text": null,
          "old_line_content": "\tif (_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc, tupnatts, true,",
          "new_line_content": "\t * equality type array keys.  This could mean that the tuple is just past",
          "content_same": false
        },
        {
          "line": 3581,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!so->scanBehind ||\n\t\t\t   so->keyData[ikey].sk_strategy == BTEqualStrategyNumber)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!so->scanBehind ||",
          "new_line_content": "\t\t * _bt_advance_array_keys occasionally sets so->scanBehind to signal",
          "content_same": false
        },
        {
          "line": 3583,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(so->scanBehind)",
          "new_text": null,
          "old_line_content": "\t\tif (unlikely(so->scanBehind) && pstate->finaltup &&",
          "new_line_content": "\t\t * behind (multiple pages behind) its current array keys.  When this",
          "content_same": false
        },
        {
          "line": 3584,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,\n\t\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscan->indexRelation),\n\t\t\t\t\t\t\t\t\t\t false, 0, NULL)",
          "new_text": null,
          "old_line_content": "\t\t\t_bt_tuple_before_array_skeys(scan, dir, pstate->finaltup, tupdesc,",
          "new_line_content": "\t\t * happens, we need to be prepared to recover by starting a new",
          "content_same": false
        },
        {
          "line": 3585,
          "old_api": "BTreeTupleGetNAtts",
          "new_api": null,
          "old_text": "BTreeTupleGetNAtts(pstate->finaltup,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tscan->indexRelation)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t BTreeTupleGetNAtts(pstate->finaltup,",
          "new_line_content": "\t\t * primitive index scan here, on our own.",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->numArrayKeys)",
          "new_text": null,
          "old_line_content": "\tAssert(so->numArrayKeys);",
          "new_line_content": "_bt_tuple_before_array_skeys(IndexScanDesc scan, ScanDirection dir,",
          "content_same": false
        },
        {
          "line": 1546,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->numberOfKeys)",
          "new_text": null,
          "old_line_content": "\tAssert(so->numberOfKeys);",
          "new_line_content": "\t\t\t\t\t\t\t IndexTuple tuple, TupleDesc tupdesc, int tupnatts,",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(sktrig == 0 || readpagetup)",
          "new_text": null,
          "old_line_content": "\tAssert(sktrig == 0 || readpagetup);",
          "new_line_content": "\t\t\t\t\t\t\t bool readpagetup, int sktrig, bool *scanBehind)",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!readpagetup || scanBehind == NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(!readpagetup || scanBehind == NULL);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1561,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!readpagetup || ikey == sktrig)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!readpagetup || ikey == sktrig);",
          "new_line_content": "\t\tScanKey\t\tcur = so->keyData + ikey;",
          "content_same": false
        },
        {
          "line": 3617,
          "old_api": "_bt_checkkeys_look_ahead",
          "new_api": null,
          "old_text": "_bt_checkkeys_look_ahead(scan, pstate, tupnatts, tupdesc)",
          "new_text": null,
          "old_line_content": "\t\t\t\t_bt_checkkeys_look_ahead(scan, pstate, tupnatts, tupdesc);",
          "new_line_content": "\t\t\t * linear search process has examined starts to get out of hand.",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!readpagetup)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!readpagetup);",
          "new_line_content": "\t\t * Note: we deliberately don't consider the scan direction here.",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ikey > sktrig || ikey == 0)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(ikey > sktrig || ikey == 0);",
          "new_line_content": "\t\t * _bt_advance_array_keys caller requires that we track *scanBehind",
          "content_same": false
        },
        {
          "line": 3638,
          "old_api": "_bt_advance_array_keys",
          "new_api": null,
          "old_text": "_bt_advance_array_keys(scan, pstate, tuple, tupnatts, tupdesc,\n\t\t\t\t\t\t\t\t  ikey, true)",
          "new_text": null,
          "old_line_content": "\treturn _bt_advance_array_keys(scan, pstate, tuple, tupnatts, tupdesc,",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull)",
          "new_text": null,
          "old_line_content": "\t\ttupdatum = index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull);",
          "new_line_content": "\t\t\t * scan keys (required in either direction) in order to correctly",
          "content_same": false
        },
        {
          "line": 1617,
          "old_api": "_bt_compare_array_skey",
          "new_api": null,
          "old_text": "_bt_compare_array_skey(&so->orderProcs[ikey],\n\t\t\t\t\t\t\t\t\t\ttupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\tcur->sk_argument, cur)",
          "new_text": null,
          "old_line_content": "\t\tresult = _bt_compare_array_skey(&so->orderProcs[ikey],",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif ((ScanDirectionIsForward(dir) && result < 0) ||",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\tcur->sk_argument, cur);",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t(ScanDirectionIsBackward(dir) && result > 0))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1635,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(result != 0)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(result != 0);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(result == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(result == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1647,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!readpagetup)",
          "new_text": null,
          "old_line_content": "\tAssert(!readpagetup);",
          "new_line_content": "\t\t *",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\tif (((key->sk_flags & SK_BT_REQFWD) && ScanDirectionIsForward(dir)) ||",
          "new_line_content": "\t\t\t\t\trequiredOppositeDirOnly = false;",
          "content_same": false
        },
        {
          "line": 3703,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t((key->sk_flags & SK_BT_REQBKWD) && ScanDirectionIsBackward(dir)))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3705,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\telse if (((key->sk_flags & SK_BT_REQFWD) && ScanDirectionIsBackward(dir)) ||",
          "new_line_content": "\t\t * Check if the key is required in the current scan direction, in the",
          "content_same": false
        },
        {
          "line": 3706,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t ((key->sk_flags & SK_BT_REQBKWD) && ScanDirectionIsForward(dir)))",
          "new_line_content": "\t\t * opposite scan direction _only_, or in neither direction",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(so->numArrayKeys)",
          "new_text": null,
          "old_line_content": "\tAssert(so->numArrayKeys);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "BTreeTupleIsPivot",
          "new_api": null,
          "old_text": "BTreeTupleIsPivot(tuple)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(BTreeTupleIsPivot(tuple));",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": "_bt_check_rowcompare",
          "new_api": null,
          "old_text": "_bt_check_rowcompare(key, tuple, tupnatts, tupdesc, dir,\n\t\t\t\t\t\t\t\t\t continuescan)",
          "new_text": null,
          "old_line_content": "\t\t\tif (_bt_check_rowcompare(key, tuple, tupnatts, tupdesc, dir,",
          "new_line_content": "\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "_bt_verify_arrays_bt_first",
          "new_api": null,
          "old_text": "_bt_verify_arrays_bt_first(scan, dir)",
          "new_text": null,
          "old_line_content": "\t\tAssert(_bt_verify_arrays_bt_first(scan, dir));",
          "new_line_content": "\t * and advance the arrays).  The array keys won't have advanced in these",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(key->sk_flags & SK_SEARCHNOTNULL)",
          "new_text": null,
          "old_line_content": "\t\t\t\tAssert(key->sk_flags & SK_SEARCHNOTNULL);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": "_bt_parallel_done",
          "new_api": null,
          "old_text": "_bt_parallel_done(scan)",
          "new_text": null,
          "old_line_content": "\t\t_bt_parallel_done(scan);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 3802,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tScanDirectionIsBackward(dir))",
          "new_line_content": "\t\t\t\t * a forward scan, however, we must keep going, because we may",
          "content_same": false
        },
        {
          "line": 3820,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tScanDirectionIsForward(dir))",
          "new_line_content": "\t\t\t\t * a backward scan, however, we must keep going, because we",
          "content_same": false
        },
        {
          "line": 3838,
          "old_api": "FunctionCall2Coll",
          "new_api": null,
          "old_text": "FunctionCall2Coll(&key->sk_func, key->sk_collation,\n\t\t\t\t\t\t\t\t\t\t\tdatum, key->sk_argument)",
          "new_text": null,
          "old_line_content": "\t\t\t!DatumGetBool(FunctionCall2Coll(&key->sk_func, key->sk_collation,",
          "new_line_content": "\t\t *",
          "content_same": false
        },
        {
          "line": 1803,
          "old_api": "_bt_tuple_before_array_skeys",
          "new_api": null,
          "old_text": "_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,\n\t\t\t\t\t\t\t\t\t\t\t tupnatts, false, 0, NULL)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!_bt_tuple_before_array_skeys(scan, dir, tuple, tupdesc,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3863,
          "old_api": "_bt_advance_array_keys",
          "new_api": null,
          "old_text": "_bt_advance_array_keys(scan, NULL, tuple, tupnatts,\n\t\t\t\t\t\t\t\t\t\t\t  tupdesc, *ikey, false)",
          "new_text": null,
          "old_line_content": "\t\t\t\treturn _bt_advance_array_keys(scan, NULL, tuple, tupnatts,",
          "new_line_content": "\t\t\t * this by \"advancing\" the scan key's array to a matching value",
          "content_same": false
        },
        {
          "line": 1817,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!pstate->prechecked)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!pstate->prechecked);",
          "new_line_content": "\t\t * scan's required-in-opposite-direction-only keys are known to be",
          "content_same": false
        },
        {
          "line": 1827,
          "old_api": "_bt_verify_keys_with_arraykeys",
          "new_api": null,
          "old_text": "_bt_verify_keys_with_arraykeys(scan)",
          "new_text": null,
          "old_line_content": "\tAssert(_bt_verify_keys_with_arraykeys(scan));",
          "new_line_content": "\t\t * reset state used by \"look ahead\" optimization",
          "content_same": false
        },
        {
          "line": 3890,
          "old_api": "DatumGetPointer",
          "new_api": null,
          "old_text": "DatumGetPointer(skey->sk_argument)",
          "new_text": null,
          "old_line_content": "\tScanKey\t\tsubkey = (ScanKey) DatumGetPointer(skey->sk_argument);",
          "new_line_content": " * This is a subroutine for _bt_checkkeys/_bt_check_compare.",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(array->scan_key == ikey)",
          "new_text": null,
          "old_line_content": "\t\t\t\tAssert(array->scan_key == ikey);",
          "new_line_content": "\t\tif (cur->sk_strategy == BTEqualStrategyNumber)",
          "content_same": false
        },
        {
          "line": 3895,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subkey->sk_attno == skey->sk_attno)",
          "new_text": null,
          "old_line_content": "\tAssert(subkey->sk_attno == skey->sk_attno);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3903,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subkey->sk_flags & SK_ROW_MEMBER)",
          "new_text": null,
          "old_line_content": "\t\tAssert(subkey->sk_flags & SK_ROW_MEMBER);",
          "new_line_content": "\t/* Loop over columns of the row condition */",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\tif (((ScanDirectionIsForward(dir) &&",
          "new_line_content": "\t\telse",
          "content_same": false
        },
        {
          "line": 1857,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t (ScanDirectionIsBackward(dir) &&",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 3913,
          "old_api": "BTreeTupleIsPivot",
          "new_api": null,
          "old_text": "BTreeTupleIsPivot(tuple)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(BTreeTupleIsPivot(tuple));",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(sktrig_required)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(sktrig_required);",
          "new_line_content": "\t\t/* Optimization: skip over known-satisfied scan keys */",
          "content_same": false
        },
        {
          "line": 3921,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(tuple,\n\t\t\t\t\t\t\t  subkey->sk_attno,\n\t\t\t\t\t\t\t  tupdesc,\n\t\t\t\t\t\t\t  &isNull)",
          "new_text": null,
          "old_line_content": "\t\tdatum = index_getattr(tuple,",
          "new_line_content": "\t\t\tif (subkey->sk_flags & SK_ROW_END)",
          "content_same": false
        },
        {
          "line": 1876,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(sktrig < ikey)",
          "new_text": null,
          "old_line_content": "\t\t\t\tAssert(sktrig < ikey);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tScanDirectionIsBackward(dir))",
          "new_line_content": "\t\t\t\t * a forward scan, however, we must keep going, because we may",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(sktrig_required && required && all_required_satisfied)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(sktrig_required && required && all_required_satisfied);",
          "new_line_content": "\t\t * If this is a required inequality strategy scan key, we _must_ rely",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tScanDirectionIsForward(dir))",
          "new_line_content": "\t\t\t\t * a backward scan, however, we must keep going, because we",
          "content_same": false
        },
        {
          "line": 1919,
          "old_api": "unlikely",
          "new_api": null,
          "old_text": "unlikely(required_opposite_direction_only)",
          "new_text": null,
          "old_line_content": "\t\t\tif (unlikely(required_opposite_direction_only))",
          "new_line_content": "\t\t\t * triggered the call here.",
          "content_same": false
        },
        {
          "line": 3979,
          "old_api": "DatumGetPointer",
          "new_api": null,
          "old_text": "DatumGetPointer(skey->sk_argument)",
          "new_text": null,
          "old_line_content": "\t\t\tif (subkey != (ScanKey) DatumGetPointer(skey->sk_argument))",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 3982,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\tScanDirectionIsForward(dir))",
          "new_line_content": "\t\t\t * columns are required for the scan direction, we can stop the",
          "content_same": false
        },
        {
          "line": 1954,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\tif (ScanDirectionIsBackward(dir) || !array)",
          "new_line_content": "\t\t * value > the closest matching array key (or < for backwards scans).",
          "content_same": false
        },
        {
          "line": 4029,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"unrecognized RowCompareType: %d\",\n\t\t\t\t (int) subkey->sk_strategy)",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"unrecognized RowCompareType: %d\",",
          "new_line_content": "\t\t\tresult = (cmpresult >= 0);",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\tif (ScanDirectionIsForward(dir) || !array)",
          "new_line_content": "\t\t * value -inf.  Again, the arrays must never get ahead of the scan.",
          "content_same": false
        },
        {
          "line": 4044,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\tScanDirectionIsForward(dir))",
          "new_line_content": "\t\t * Tuple fails this qual.  If it's a required qual for the current",
          "content_same": false
        },
        {
          "line": 4047,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\t\t\t\t ScanDirectionIsBackward(dir))",
          "new_line_content": "\t\t * necessarily the first or last column of the row condition.",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "index_getattr",
          "new_api": null,
          "old_text": "index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull)",
          "new_text": null,
          "old_line_content": "\t\ttupdatum = index_getattr(tuple, cur->sk_attno, tupdesc, &tupnull);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "_bt_binsrch_array_skey",
          "new_api": null,
          "old_text": "_bt_binsrch_array_skey(&so->orderProcs[ikey],\n\t\t\t\t\t\t\t\t\t\t\t  cur_elem_trig, dir,\n\t\t\t\t\t\t\t\t\t\t\t  tupdatum, tupnull, array, cur,\n\t\t\t\t\t\t\t\t\t\t\t  &result)",
          "new_text": null,
          "old_line_content": "\t\t\tset_elem = _bt_binsrch_array_skey(&so->orderProcs[ikey],",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2022,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(set_elem >= 0 && set_elem < array->num_elems)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(set_elem >= 0 && set_elem < array->num_elems);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(sktrig_required && required)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(sktrig_required && required);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t  &result);",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "_bt_compare_array_skey",
          "new_api": null,
          "old_text": "_bt_compare_array_skey(&so->orderProcs[ikey],\n\t\t\t\t\t\t\t\t\t\t\ttupdatum, tupnull,\n\t\t\t\t\t\t\t\t\t\t\tcur->sk_argument, cur)",
          "new_text": null,
          "old_line_content": "\t\t\tresult = _bt_compare_array_skey(&so->orderProcs[ikey],",
          "new_line_content": "\t\t\t *",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": "ScanDirectionIsForward",
          "new_api": null,
          "old_text": "ScanDirectionIsForward(dir)",
          "new_text": null,
          "old_line_content": "\tif (ScanDirectionIsForward(dir) &&",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 4089,
          "old_api": "ScanDirectionIsBackward",
          "new_api": null,
          "old_text": "ScanDirectionIsBackward(dir)",
          "new_text": null,
          "old_line_content": "\telse if (ScanDirectionIsBackward(dir) &&",
          "new_line_content": "\t * Don't look ahead when there aren't enough tuples remaining on the page",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 44,
      "total_additions": 358,
      "total_deletions": 359,
      "total_api_changes": 761
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 7,
        "api_related_lines": 761,
        "non_api_lines": 6,
        "non_api_line_numbers": [
          561,
          562,
          563,
          564,
          565,
          566
        ]
      }
    },
    "api_calls_before": 503,
    "api_calls_after": 502,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 1,
      "total_diff_lines": 20
    }
  }
}