diff --git a/src/backend/executor/nodeRecursiveunion.c b/src/backend/executor/nodeRecursiveunion.c
index c7f8a19fa4..22e7b83b2e 100644
--- a/src/backend/executor/nodeRecursiveunion.c
+++ b/src/backend/executor/nodeRecursiveunion.c
@@ -115,19 +115,26 @@ ExecRecursiveUnion(PlanState *pstate)
 		slot = ExecProcNode(innerPlan);
 		if (TupIsNull(slot))
 		{
+			Tuplestorestate *swaptemp;
+
 			/* Done if there's nothing in the intermediate table */
 			if (node->intermediate_empty)
 				break;
 
-			/* done with old working table ... */
-			tuplestore_end(node->working_table);
+			/*
+			 * Now we let the intermediate table become the work table.  We
+			 * need a fresh intermediate table, so delete the tuples from the
+			 * current working table and use that as the new intermediate
+			 * table.  This saves a round of free/malloc from creating a new
+			 * tuple store.
+			 */
+			tuplestore_clear(node->working_table);
 
-			/* intermediate table becomes working table */
+			swaptemp = node->working_table;
 			node->working_table = node->intermediate_table;
+			node->intermediate_table = swaptemp;
 
-			/* create new empty intermediate table */
-			node->intermediate_table = tuplestore_begin_heap(false, false,
-															 work_mem);
+			/* mark the intermediate table as empty */
 			node->intermediate_empty = true;
 
 			/* reset the recursive term */
