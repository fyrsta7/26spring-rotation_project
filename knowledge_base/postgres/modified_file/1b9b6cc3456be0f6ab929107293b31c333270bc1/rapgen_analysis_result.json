{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1b9b6cc3456be0f6ab929107293b31c333270bc1",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1b9b6cc3456be0f6ab929107293b31c333270bc1/before.c",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1b9b6cc3456be0f6ab929107293b31c333270bc1/after.c",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/postgres/modified_file/1b9b6cc3456be0f6ab929107293b31c333270bc1/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 424,
          "old_api": "dlist_init",
          "new_api": "MemoryContextAlloc",
          "old_text": "dlist_init(&txn->tuplecids)",
          "new_text": "MemoryContextAlloc(rb->txn_context, sizeof(ReorderBufferTXN))",
          "old_line_content": "\tdlist_init(&txn->tuplecids);",
          "new_line_content": "\t\tMemoryContextAlloc(rb->txn_context, sizeof(ReorderBufferTXN));",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "ReorderBufferToastReset",
          "new_api": "pfree",
          "old_text": "ReorderBufferToastReset(rb, txn)",
          "new_text": "pfree(txn->invalidations)",
          "old_line_content": "\tReorderBufferToastReset(rb, txn);",
          "new_line_content": "\t\tpfree(txn->invalidations);",
          "content_same": false
        },
        {
          "line": 473,
          "old_api": "pfree",
          "new_api": "ReorderBufferToastReset",
          "old_text": "pfree(txn)",
          "new_text": "ReorderBufferToastReset(rb, txn)",
          "old_line_content": "\tpfree(txn);",
          "new_line_content": "\tReorderBufferToastReset(rb, txn);",
          "content_same": false
        },
        {
          "line": 831,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": "dlist_push_tail",
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, true,\n\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "new_text": "dlist_push_tail(&txn->changes, &change->node)",
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, true,",
          "new_line_content": "\tdlist_push_tail(&txn->changes, &change->node);",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "memcpy",
          "new_api": "ReorderBufferGetChange",
          "old_text": "memcpy(change->data.msg.message, message, message_size)",
          "new_text": "ReorderBufferGetChange(rb)",
          "old_line_content": "\t\tmemcpy(change->data.msg.message, message, message_size);",
          "new_line_content": "\t\tchange = ReorderBufferGetChange(rb);",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": "ReorderBufferQueueChange",
          "new_api": "pstrdup",
          "old_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "new_text": "pstrdup(prefix)",
          "old_line_content": "\t\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "new_line_content": "\t\tchange->data.msg.prefix = pstrdup(prefix);",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "MemoryContextSwitchTo",
          "new_api": "palloc",
          "old_text": "MemoryContextSwitchTo(oldcontext)",
          "new_text": "palloc(message_size)",
          "old_line_content": "\t\tMemoryContextSwitchTo(oldcontext);",
          "new_line_content": "\t\tchange->data.msg.message = palloc(message_size);",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": "TeardownHistoricSnapshot",
          "new_api": "SetupHistoricSnapshot",
          "old_text": "TeardownHistoricSnapshot(false)",
          "new_text": "SetupHistoricSnapshot(snapshot_now, NULL)",
          "old_line_content": "\t\t\tTeardownHistoricSnapshot(false);",
          "new_line_content": "\t\tSetupHistoricSnapshot(snapshot_now, NULL);",
          "content_same": false
        },
        {
          "line": 900,
          "old_api": "PG_RE_THROW",
          "new_api": "TeardownHistoricSnapshot",
          "old_text": "PG_RE_THROW()",
          "new_text": "TeardownHistoricSnapshot(false)",
          "old_line_content": "\t\t\tPG_RE_THROW();",
          "new_line_content": "\t\t\tTeardownHistoricSnapshot(false);",
          "content_same": false
        },
        {
          "line": 902,
          "old_api": "PG_END_TRY",
          "new_api": "PG_CATCH",
          "old_text": "PG_END_TRY()",
          "new_text": "PG_CATCH()",
          "old_line_content": "\t\tPG_END_TRY();",
          "new_line_content": "\t\tPG_CATCH();",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "dlist_container",
          "new_api": "SnapBuildXactNeedsSkip",
          "old_text": "dlist_container(ReorderBufferTXN, node,\n\t\t\t\t\t\t\t\t\t\t\t\t\titer.cur)",
          "new_text": "SnapBuildXactNeedsSkip(ctx->snapshot_builder, ctx->reader->EndRecPtr)",
          "old_line_content": "\t\tReorderBufferTXN *cur_txn = dlist_container(ReorderBufferTXN, node,",
          "new_line_content": "\tif (SnapBuildXactNeedsSkip(ctx->snapshot_builder, ctx->reader->EndRecPtr))",
          "content_same": false
        },
        {
          "line": 958,
          "old_api": "dlist_foreach",
          "new_api": "rbtxn_is_known_subxact",
          "old_text": "dlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "new_text": "rbtxn_is_known_subxact(cur_txn)",
          "old_line_content": "\tdlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "new_line_content": "\t\tAssert(!rbtxn_is_known_subxact(cur_txn));",
          "content_same": false
        },
        {
          "line": 965,
          "old_api": "Assert",
          "new_api": "dlist_container",
          "old_text": "Assert(cur_txn->base_snapshot != NULL)",
          "new_text": "dlist_container(ReorderBufferTXN,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbase_snapshot_node,\n\t\t\t\t\t\t\t\t\t\t\t\t\titer.cur)",
          "old_line_content": "\t\tAssert(cur_txn->base_snapshot != NULL);",
          "new_line_content": "\t\tReorderBufferTXN *cur_txn = dlist_container(ReorderBufferTXN,",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": "dlist_head_element",
          "new_api": "AssertTXNLsnOrder",
          "old_text": "dlist_head_element(ReorderBufferTXN, node, &rb->toplevel_by_lsn)",
          "new_text": "AssertTXNLsnOrder(rb)",
          "old_line_content": "\ttxn = dlist_head_element(ReorderBufferTXN, node, &rb->toplevel_by_lsn);",
          "new_line_content": "\tAssertTXNLsnOrder(rb);",
          "content_same": false
        },
        {
          "line": 1028,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": "dlist_is_empty",
          "old_text": "rbtxn_is_known_subxact(txn)",
          "new_text": "dlist_is_empty(&rb->toplevel_by_lsn)",
          "old_line_content": "\tAssert(!rbtxn_is_known_subxact(txn));",
          "new_line_content": "\tif (dlist_is_empty(&rb->toplevel_by_lsn))",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": "dlist_head_element",
          "new_api": "AssertTXNLsnOrder",
          "old_text": "dlist_head_element(ReorderBufferTXN, base_snapshot_node,\n\t\t\t\t\t\t\t &rb->txns_by_base_snapshot_lsn)",
          "new_text": "AssertTXNLsnOrder(rb)",
          "old_line_content": "\ttxn = dlist_head_element(ReorderBufferTXN, base_snapshot_node,",
          "new_line_content": "\tAssertTXNLsnOrder(rb);",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": "ReorderBufferTXNByXid",
          "old_text": "rbtxn_is_known_subxact(subtxn)",
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, &new_top, lsn, true)",
          "old_line_content": "\t\tif (rbtxn_is_known_subxact(subtxn))",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, &new_top, lsn, true);",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": "SnapBuildSnapDecRefcount",
          "new_api": "dlist_delete",
          "old_text": "SnapBuildSnapDecRefcount(subtxn->base_snapshot)",
          "new_text": "dlist_delete(&subtxn->base_snapshot_node)",
          "old_line_content": "\t\t\tSnapBuildSnapDecRefcount(subtxn->base_snapshot);",
          "new_line_content": "\t\t\tdlist_delete(&subtxn->base_snapshot_node);",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": "dlist_init",
          "new_api": "MemoryContextAllocZero",
          "old_text": "dlist_init(&state->old_change)",
          "new_text": "MemoryContextAllocZero(rb->context,\n\t\t\t\t\t\t\t   sizeof(ReorderBufferIterTXNState) +\n\t\t\t\t\t\t\t   sizeof(ReorderBufferIterTXNEntry) * nr_txns)",
          "old_line_content": "\tdlist_init(&state->old_change);",
          "new_line_content": "\t\tMemoryContextAllocZero(rb->context,",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "dlist_head_element",
          "new_api": "ReorderBufferSerializeTXN",
          "old_text": "dlist_head_element(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t\t\t&txn->changes)",
          "new_text": "ReorderBufferSerializeTXN(rb, txn)",
          "old_line_content": "\t\tcur_change = dlist_head_element(ReorderBufferChange, node,",
          "new_line_content": "\t\t\tReorderBufferSerializeTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "dlist_head_element",
          "new_api": "ReorderBufferSerializeTXN",
          "old_text": "dlist_head_element(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t\t\t\t&cur_txn->changes)",
          "new_text": "ReorderBufferSerializeTXN(rb, cur_txn)",
          "old_line_content": "\t\t\tcur_change = dlist_head_element(ReorderBufferChange, node,",
          "new_line_content": "\t\t\t\tReorderBufferSerializeTXN(rb, cur_txn);",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": "binaryheap_build",
          "new_api": "Int32GetDatum",
          "old_text": "binaryheap_build(state->heap)",
          "new_text": "Int32GetDatum(off++)",
          "old_line_content": "\tbinaryheap_build(state->heap);",
          "new_line_content": "\t\t\tbinaryheap_add_unordered(state->heap, Int32GetDatum(off++));",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "dlist_head_element",
          "new_api": "ReorderBufferRestoreChanges",
          "old_text": "dlist_head_element(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t   &entry->txn->changes)",
          "new_text": "ReorderBufferRestoreChanges(rb, entry->txn, &entry->file,\n\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno)",
          "old_line_content": "\t\t\t\tdlist_head_element(ReorderBufferChange, node,",
          "new_line_content": "\t\tif (ReorderBufferRestoreChanges(rb, entry->txn, &entry->file,",
          "content_same": false
        },
        {
          "line": 1494,
          "old_api": "dlist_pop_head_node",
          "new_api": "dlist_is_empty",
          "old_text": "dlist_pop_head_node(&state->old_change)",
          "new_text": "dlist_is_empty(&state->old_change)",
          "old_line_content": "\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change));",
          "new_line_content": "\tif (!dlist_is_empty(&state->old_change))",
          "content_same": false
        },
        {
          "line": 1499,
          "old_api": "binaryheap_free",
          "new_api": "dlist_pop_head_node",
          "old_text": "binaryheap_free(state->heap)",
          "new_text": "dlist_pop_head_node(&state->old_change)",
          "old_line_content": "\tbinaryheap_free(state->heap);",
          "new_line_content": "\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change));",
          "content_same": false
        },
        {
          "line": 1500,
          "old_api": "pfree",
          "new_api": "ReorderBufferReturnChange",
          "old_text": "pfree(state)",
          "new_text": "ReorderBufferReturnChange(rb, change, true)",
          "old_line_content": "\tpfree(state);",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, true);",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": "hash_search",
          "new_api": "dlist_delete",
          "old_text": "hash_search(rb->by_txn, &txn->xid, HASH_REMOVE, &found)",
          "new_text": "dlist_delete(&txn->node)",
          "old_line_content": "\thash_search(rb->by_txn, &txn->xid, HASH_REMOVE, &found);",
          "new_line_content": "\tdlist_delete(&txn->node);",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": "Assert",
          "new_api": "rbtxn_has_catalog_changes",
          "old_text": "Assert(found)",
          "new_text": "rbtxn_has_catalog_changes(txn)",
          "old_line_content": "\tAssert(found);",
          "new_line_content": "\tif (rbtxn_has_catalog_changes(txn))",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": "ReorderBufferRestoreCleanup",
          "new_api": "hash_search",
          "old_text": "ReorderBufferRestoreCleanup(rb, txn)",
          "new_text": "hash_search(rb->by_txn, &txn->xid, HASH_REMOVE, &found)",
          "old_line_content": "\t\tReorderBufferRestoreCleanup(rb, txn);",
          "new_line_content": "\thash_search(rb->by_txn, &txn->xid, HASH_REMOVE, &found);",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "ReorderBufferReturnChange",
          "new_api": "Assert",
          "old_text": "ReorderBufferReturnChange(rb, change, true)",
          "new_text": "Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)",
          "old_line_content": "\t\t\tReorderBufferReturnChange(rb, change, true);",
          "new_line_content": "\t\t\tAssert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "rbtxn_is_serialized",
          "new_api": "hash_destroy",
          "old_text": "rbtxn_is_serialized(txn)",
          "new_text": "hash_destroy(txn->tuplecid_hash)",
          "old_line_content": "\tif (rbtxn_is_serialized(txn))",
          "new_line_content": "\t\thash_destroy(txn->tuplecid_hash);",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": "memset",
          "new_api": "dlist_container",
          "old_text": "memset(&key, 0, sizeof(ReorderBufferTupleCidKey))",
          "new_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "old_line_content": "\t\tmemset(&key, 0, sizeof(ReorderBufferTupleCidKey));",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 2026,
          "old_api": "message",
          "new_api": "stream_message",
          "old_text": "rb->message(rb, txn, change->lsn, true,\n\t\t\t\t\tchange->data.msg.prefix,\n\t\t\t\t\tchange->data.msg.message_size,\n\t\t\t\t\tchange->data.msg.message)",
          "new_text": "rb->stream_message(rb, txn, change->lsn, true,\n\t\t\t\t\t\t   change->data.msg.prefix,\n\t\t\t\t\t\t   change->data.msg.message_size,\n\t\t\t\t\t\t   change->data.msg.message)",
          "old_line_content": "\t\trb->message(rb, txn, change->lsn, true,",
          "new_line_content": "\t\trb->stream_message(rb, txn, change->lsn, true,",
          "content_same": false
        },
        {
          "line": 2073,
          "old_api": "ReorderBufferReturnChange",
          "new_api": "ReorderBufferToastReset",
          "old_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "new_text": "ReorderBufferToastReset(rb, txn)",
          "old_line_content": "\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "new_line_content": "\tReorderBufferToastReset(rb, txn);",
          "content_same": false
        },
        {
          "line": 2088,
          "old_api": "Assert",
          "new_api": "stream_stop",
          "old_text": "Assert(txn->size == 0)",
          "new_text": "rb->stream_stop(rb, txn, last_lsn)",
          "old_line_content": "\tAssert(txn->size == 0);",
          "new_line_content": "\t\trb->stream_stop(rb, txn, last_lsn);",
          "content_same": false
        },
        {
          "line": 2159,
          "old_api": "ReorderBufferIterTXNInit",
          "new_api": "begin_prepare",
          "old_text": "ReorderBufferIterTXNInit(rb, txn, &iterstate)",
          "new_text": "rb->begin_prepare(rb, txn)",
          "old_line_content": "\t\tReorderBufferIterTXNInit(rb, txn, &iterstate);",
          "new_line_content": "\t\t\t\trb->begin_prepare(rb, txn);",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "CHECK_FOR_INTERRUPTS",
          "new_api": "ReorderBufferIterTXNNext",
          "old_text": "CHECK_FOR_INTERRUPTS()",
          "new_text": "ReorderBufferIterTXNNext(rb, iterstate)",
          "old_line_content": "\t\t\tCHECK_FOR_INTERRUPTS();",
          "new_line_content": "\t\twhile ((change = ReorderBufferIterTXNNext(rb, iterstate)) != NULL)",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": "RelationIsValid",
          "new_api": "relpathperm",
          "old_text": "RelationIsValid(relation)",
          "new_text": "relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM)",
          "old_line_content": "\t\t\t\t\tif (!RelationIsValid(relation))",
          "new_line_content": "\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,",
          "content_same": false
        },
        {
          "line": 2251,
          "old_api": "relpathperm",
          "new_api": "RelationIdGetRelation",
          "old_text": "relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM)",
          "new_text": "RelationIdGetRelation(reloid)",
          "old_line_content": "\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,",
          "new_line_content": "\t\t\t\t\trelation = RelationIdGetRelation(reloid);",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": "RelationIsLogicallyLogged",
          "new_api": "elog",
          "old_text": "RelationIsLogicallyLogged(relation)",
          "new_text": "elog(ERROR, \"could not open relation with OID %u (for filenumber \\\"%s\\\")\",\n\t\t\t\t\t\t\t reloid,\n\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM))",
          "old_line_content": "\t\t\t\t\tif (!RelationIsLogicallyLogged(relation))",
          "new_line_content": "\t\t\t\t\t\telog(ERROR, \"could not open relation with OID %u (for filenumber \\\"%s\\\")\",",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "dlist_delete",
          "new_api": "ReorderBufferReturnChange",
          "old_text": "dlist_delete(&change->node)",
          "new_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "old_line_content": "\t\t\t\t\tdlist_delete(&change->node);",
          "new_line_content": "\t\t\t\t\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "RelationIsLogicallyLogged",
          "new_api": "RelationIdGetRelation",
          "old_text": "RelationIsLogicallyLogged(rel)",
          "new_text": "RelationIdGetRelation(relid)",
          "old_line_content": "\t\t\t\t\t\t\tif (!RelationIsLogicallyLogged(rel))",
          "new_line_content": "\t\t\t\t\t\t\trel = RelationIdGetRelation(relid);",
          "content_same": false
        },
        {
          "line": 2408,
          "old_api": "RelationClose",
          "new_api": "ReorderBufferApplyTruncate",
          "old_text": "RelationClose(relations[i])",
          "new_text": "ReorderBufferApplyTruncate(rb, txn, nrelations,\n\t\t\t\t\t\t\t\t\t\t\t\t   relations, change,\n\t\t\t\t\t\t\t\t\t\t\t\t   streaming)",
          "old_line_content": "\t\t\t\t\t\t\tRelationClose(relations[i]);",
          "new_line_content": "\t\t\t\t\t\tReorderBufferApplyTruncate(rb, txn, nrelations,",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": "ReorderBufferExecuteInvalidations",
          "new_api": "ReorderBufferApplyMessage",
          "old_text": "ReorderBufferExecuteInvalidations(change->data.inval.ninvalidations,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  change->data.inval.invalidations)",
          "new_text": "ReorderBufferApplyMessage(rb, txn, change, streaming)",
          "old_line_content": "\t\t\t\t\tReorderBufferExecuteInvalidations(change->data.inval.ninvalidations,",
          "new_line_content": "\t\t\t\t\tReorderBufferApplyMessage(rb, txn, change, streaming);",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "elog",
          "new_api": "commit",
          "old_text": "elog(ERROR, \"output plugin used XID %u\",\n\t\t\t\t GetCurrentTransactionId())",
          "new_text": "rb->commit(rb, txn, commit_lsn)",
          "old_line_content": "\t\t\telog(ERROR, \"output plugin used XID %u\",",
          "new_line_content": "\t\t\t\trb->commit(rb, txn, commit_lsn);",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "TeardownHistoricSnapshot",
          "new_api": "ReorderBufferSaveTXNSnapshot",
          "old_text": "TeardownHistoricSnapshot(false)",
          "new_text": "ReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id)",
          "old_line_content": "\t\tTeardownHistoricSnapshot(false);",
          "new_line_content": "\t\t\tReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id);",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": "rbtxn_prepared",
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\t\tReorderBufferTruncateTXN(rb, txn, rbtxn_prepared(txn));",
          "content_same": false
        },
        {
          "line": 2603,
          "old_api": "CopyErrorData",
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": "CopyErrorData()",
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": "\t\tErrorData  *errdata = CopyErrorData();",
          "new_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": "ReorderBufferIterTXNFinish",
          "new_api": "MemoryContextSwitchTo",
          "old_text": "ReorderBufferIterTXNFinish(rb, iterstate)",
          "new_text": "MemoryContextSwitchTo(ccxt)",
          "old_line_content": "\t\t\tReorderBufferIterTXNFinish(rb, iterstate);",
          "new_line_content": "\t\tMemoryContext ecxt = MemoryContextSwitchTo(ccxt);",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": "ReorderBufferResetTXN",
          "new_api": "FreeErrorData",
          "old_text": "ReorderBufferResetTXN(rb, txn, snapshot_now,\n\t\t\t\t\t\t\t\t  command_id, prev_lsn,\n\t\t\t\t\t\t\t\t  specinsert)",
          "new_text": "FreeErrorData(errdata)",
          "old_line_content": "\t\t\tReorderBufferResetTXN(rb, txn, snapshot_now,",
          "new_line_content": "\t\t\tFreeErrorData(errdata);",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": "PG_END_TRY",
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": "PG_END_TRY()",
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": "\tPG_END_TRY();",
          "new_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": "ReorderBufferReplay",
          "new_api": "pstrdup",
          "old_text": "ReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,\n\t\t\t\t\t\ttxn->xact_time.prepare_time, txn->origin_id, txn->origin_lsn)",
          "new_text": "pstrdup(gid)",
          "old_line_content": "\tReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,",
          "new_line_content": "\ttxn->gid = pstrdup(gid);",
          "content_same": false
        },
        {
          "line": 2908,
          "old_api": "ReorderBufferExecuteInvalidations",
          "new_api": "commit_prepared",
          "old_text": "ReorderBufferExecuteInvalidations(txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t  txn->invalidations)",
          "new_text": "rb->commit_prepared(rb, txn, commit_lsn)",
          "old_line_content": "\tReorderBufferExecuteInvalidations(txn->ninvalidations,",
          "new_line_content": "\t\trb->commit_prepared(rb, txn, commit_lsn);",
          "content_same": false
        },
        {
          "line": 2910,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": "rollback_prepared",
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": "rb->rollback_prepared(rb, txn, prepare_end_lsn, prepare_time)",
          "old_line_content": "\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\trb->rollback_prepared(rb, txn, prepare_end_lsn, prepare_time);",
          "content_same": false
        },
        {
          "line": 2993,
          "old_api": "rbtxn_is_streamed",
          "new_api": "TransactionIdPrecedes",
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": "TransactionIdPrecedes(txn->xid, oldestRunningXid)",
          "old_line_content": "\t\t\tif (rbtxn_is_streamed(txn))",
          "new_line_content": "\t\tif (TransactionIdPrecedes(txn->xid, oldestRunningXid))",
          "content_same": false
        },
        {
          "line": 3147,
          "old_api": "ReorderBufferQueueChange",
          "new_api": "ReorderBufferGetChange",
          "old_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "new_text": "ReorderBufferGetChange(rb)",
          "old_line_content": "\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "new_line_content": "\tReorderBufferChange *change = ReorderBufferGetChange(rb);",
          "content_same": false
        },
        {
          "line": 3196,
          "old_api": "ReorderBufferQueueChange",
          "new_api": "ReorderBufferGetChange",
          "old_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "new_text": "ReorderBufferGetChange(rb)",
          "old_line_content": "\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "new_line_content": "\tReorderBufferChange *change = ReorderBufferGetChange(rb);",
          "content_same": false
        },
        {
          "line": 3263,
          "old_api": "Assert",
          "new_api": "pairingheap_remove",
          "old_text": "Assert((rb->size >= sz) && (txn->size >= sz))",
          "new_text": "pairingheap_remove(rb->txn_heap, &txn->txn_node)",
          "old_line_content": "\t\tAssert((rb->size >= sz) && (txn->size >= sz));",
          "new_line_content": "\t\t\tpairingheap_remove(rb->txn_heap, &txn->txn_node);",
          "content_same": false
        },
        {
          "line": 3276,
          "old_api": "Assert",
          "new_api": "pairingheap_remove",
          "old_text": "Assert(txn->size <= rb->size)",
          "new_text": "pairingheap_remove(rb->txn_heap, &txn->txn_node)",
          "old_line_content": "\tAssert(txn->size <= rb->size);",
          "new_line_content": "\t\tpairingheap_remove(rb->txn_heap, &txn->txn_node);",
          "content_same": false
        },
        {
          "line": 3365,
          "old_api": "ReorderBufferGetChange",
          "new_api": "memcpy",
          "old_text": "ReorderBufferGetChange(rb)",
          "new_text": "memcpy(txn->invalidations + txn->ninvalidations, msgs,\n\t\t\t   nmsgs * sizeof(SharedInvalidationMessage))",
          "old_line_content": "\tchange = ReorderBufferGetChange(rb);",
          "new_line_content": "\t\tmemcpy(txn->invalidations + txn->ninvalidations, msgs,",
          "content_same": false
        },
        {
          "line": 3370,
          "old_api": "memcpy",
          "new_api": "ReorderBufferGetChange",
          "old_text": "memcpy(change->data.inval.invalidations, msgs,\n\t\t   sizeof(SharedInvalidationMessage) * nmsgs)",
          "new_text": "ReorderBufferGetChange(rb)",
          "old_line_content": "\tmemcpy(change->data.inval.invalidations, msgs,",
          "new_line_content": "\tchange = ReorderBufferGetChange(rb);",
          "content_same": false
        },
        {
          "line": 3375,
          "old_api": "MemoryContextSwitchTo",
          "new_api": "memcpy",
          "old_text": "MemoryContextSwitchTo(oldcontext)",
          "new_text": "memcpy(change->data.inval.invalidations, msgs,\n\t\t   sizeof(SharedInvalidationMessage) * nmsgs)",
          "old_line_content": "\tMemoryContextSwitchTo(oldcontext);",
          "new_line_content": "\tmemcpy(change->data.inval.invalidations, msgs,",
          "content_same": false
        },
        {
          "line": 3405,
          "old_api": "dclist_push_tail",
          "new_api": "ReorderBufferTXNByXid",
          "old_text": "dclist_push_tail(&rb->catchange_txns, &txn->catchange_node)",
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "old_line_content": "\t\tdclist_push_tail(&rb->catchange_txns, &txn->catchange_node);",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "content_same": false
        },
        {
          "line": 3421,
          "old_api": "dclist_push_tail",
          "new_api": "rbtxn_get_toptxn",
          "old_text": "dclist_push_tail(&rb->catchange_txns, &toptxn->catchange_node)",
          "new_text": "rbtxn_get_toptxn(txn)",
          "old_line_content": "\t\t\tdclist_push_tail(&rb->catchange_txns, &toptxn->catchange_node);",
          "new_line_content": "\t\tReorderBufferTXN *toptxn = rbtxn_get_toptxn(txn);",
          "content_same": false
        },
        {
          "line": 3457,
          "old_api": "qsort",
          "new_api": "rbtxn_has_catalog_changes",
          "old_text": "qsort(xids, xcnt, sizeof(TransactionId), xidComparator)",
          "new_text": "rbtxn_has_catalog_changes(txn)",
          "old_line_content": "\tqsort(xids, xcnt, sizeof(TransactionId), xidComparator);",
          "new_line_content": "\t\tAssert(rbtxn_has_catalog_changes(txn));",
          "content_same": false
        },
        {
          "line": 3477,
          "old_api": "rbtxn_has_catalog_changes",
          "new_api": "ReorderBufferTXNByXid",
          "old_text": "rbtxn_has_catalog_changes(txn)",
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "old_line_content": "\treturn rbtxn_has_catalog_changes(txn);",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "content_same": false
        },
        {
          "line": 3524,
          "old_api": "repalloc",
          "new_api": "MemoryContextAlloc",
          "old_text": "repalloc(rb->outbuf, sz)",
          "new_text": "MemoryContextAlloc(rb->context, sz)",
          "old_line_content": "\t\trb->outbuf = repalloc(rb->outbuf, sz);",
          "new_line_content": "\t\trb->outbuf = MemoryContextAlloc(rb->context, sz);",
          "content_same": false
        },
        {
          "line": 3558,
          "old_api": "Assert",
          "new_api": "pairingheap_container",
          "old_text": "Assert(largest->size <= rb->size)",
          "new_text": "pairingheap_container(ReorderBufferTXN, txn_node,\n\t\t\t\t\t\t\t\t\tpairingheap_first(rb->txn_heap))",
          "old_line_content": "\tAssert(largest->size <= rb->size);",
          "new_line_content": "\tlargest = pairingheap_container(ReorderBufferTXN, txn_node,",
          "content_same": false
        },
        {
          "line": 3604,
          "old_api": "Assert",
          "new_api": "dlist_container",
          "old_text": "Assert(txn->base_snapshot != NULL)",
          "new_text": "dlist_container(ReorderBufferTXN, base_snapshot_node, iter.cur)",
          "old_line_content": "\t\tAssert(txn->base_snapshot != NULL);",
          "new_line_content": "\t\ttxn = dlist_container(ReorderBufferTXN, base_snapshot_node, iter.cur);",
          "content_same": false
        },
        {
          "line": 3607,
          "old_api": "rbtxn_has_partial_change",
          "new_api": "rbtxn_is_known_subxact",
          "old_text": "rbtxn_has_partial_change(txn)",
          "new_text": "rbtxn_is_known_subxact(txn)",
          "old_line_content": "\t\t\t(txn->total_size > 0) && !(rbtxn_has_partial_change(txn)) &&",
          "new_line_content": "\t\tAssert(!rbtxn_is_known_subxact(txn));",
          "content_same": false
        },
        {
          "line": 3667,
          "old_api": "Assert",
          "new_api": "ReorderBufferCanStartStreaming",
          "old_text": "Assert(txn->total_size > 0)",
          "new_text": "ReorderBufferCanStartStreaming(rb)",
          "old_line_content": "\t\t\tAssert(txn->total_size > 0);",
          "new_line_content": "\t\tif (ReorderBufferCanStartStreaming(rb) &&",
          "content_same": false
        },
        {
          "line": 3668,
          "old_api": "Assert",
          "new_api": "ReorderBufferLargestStreamableTopTXN",
          "old_text": "Assert(rb->size >= txn->total_size)",
          "new_text": "ReorderBufferLargestStreamableTopTXN(rb)",
          "old_line_content": "\t\t\tAssert(rb->size >= txn->total_size);",
          "new_line_content": "\t\t\t(txn = ReorderBufferLargestStreamableTopTXN(rb)) != NULL)",
          "content_same": false
        },
        {
          "line": 3683,
          "old_api": "Assert",
          "new_api": "ReorderBufferLargestTXN",
          "old_text": "Assert(rb->size >= txn->size)",
          "new_text": "ReorderBufferLargestTXN(rb)",
          "old_line_content": "\t\t\tAssert(rb->size >= txn->size);",
          "new_line_content": "\t\t\ttxn = ReorderBufferLargestTXN(rb);",
          "content_same": false
        },
        {
          "line": 3723,
          "old_api": "ReorderBufferSerializeTXN",
          "new_api": "dlist_foreach",
          "old_text": "ReorderBufferSerializeTXN(rb, subtxn)",
          "new_text": "dlist_foreach(subtxn_i, &txn->subtxns)",
          "old_line_content": "\t\tReorderBufferSerializeTXN(rb, subtxn);",
          "new_line_content": "\tdlist_foreach(subtxn_i, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 3727,
          "old_api": "dlist_foreach_modify",
          "new_api": "dlist_container",
          "old_text": "dlist_foreach_modify(change_i, &txn->changes)",
          "new_text": "dlist_container(ReorderBufferTXN, node, subtxn_i.cur)",
          "old_line_content": "\tdlist_foreach_modify(change_i, &txn->changes)",
          "new_line_content": "\t\tsubtxn = dlist_container(ReorderBufferTXN, node, subtxn_i.cur);",
          "content_same": false
        },
        {
          "line": 3743,
          "old_api": "CloseTransientFile",
          "new_api": "XLByteInSeg",
          "old_text": "CloseTransientFile(fd)",
          "new_text": "XLByteInSeg(change->lsn, curOpenSegNo, wal_segment_size)",
          "old_line_content": "\t\t\t\tCloseTransientFile(fd);",
          "new_line_content": "\t\t\t!XLByteInSeg(change->lsn, curOpenSegNo, wal_segment_size))",
          "content_same": false
        },
        {
          "line": 3760,
          "old_api": "errcode_for_file_access",
          "new_api": "OpenTransientFile",
          "old_text": "errcode_for_file_access()",
          "new_text": "OpenTransientFile(path,\n\t\t\t\t\t\t\t\t   O_CREAT | O_WRONLY | O_APPEND | PG_BINARY)",
          "old_line_content": "\t\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\tfd = OpenTransientFile(path,",
          "content_same": false
        },
        {
          "line": 3764,
          "old_api": "ReorderBufferSerializeChange",
          "new_api": "ereport",
          "old_text": "ReorderBufferSerializeChange(rb, txn, fd, change)",
          "new_text": "ereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)))",
          "old_line_content": "\t\tReorderBufferSerializeChange(rb, txn, fd, change);",
          "new_line_content": "\t\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 3765,
          "old_api": "dlist_delete",
          "new_api": "errcode_for_file_access",
          "old_text": "dlist_delete(&change->node)",
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\tdlist_delete(&change->node);",
          "new_line_content": "\t\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 3766,
          "old_api": "ReorderBufferReturnChange",
          "new_api": "errmsg",
          "old_text": "ReorderBufferReturnChange(rb, change, false)",
          "new_text": "errmsg(\"could not open file \\\"%s\\\": %m\", path)",
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "new_line_content": "\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)));",
          "content_same": false
        },
        {
          "line": 3793,
          "old_api": "CloseTransientFile",
          "new_api": "dlist_is_empty",
          "old_text": "CloseTransientFile(fd)",
          "new_text": "dlist_is_empty(&txn->changes)",
          "old_line_content": "\t\tCloseTransientFile(fd);",
          "new_line_content": "\tAssert(dlist_is_empty(&txn->changes));",
          "content_same": false
        },
        {
          "line": 3911,
          "old_api": "memcpy",
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": "memcpy(data, change->data.inval.invalidations, inval_size)",
          "new_text": "ReorderBufferSerializeReserve(rb, sz)",
          "old_line_content": "\t\t\t\tmemcpy(data, change->data.inval.invalidations, inval_size);",
          "new_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "content_same": false
        },
        {
          "line": 3933,
          "old_api": "memcpy",
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": "memcpy(data, snap, sizeof(SnapshotData))",
          "new_text": "ReorderBufferSerializeReserve(rb, sz)",
          "old_line_content": "\t\t\t\tmemcpy(data, snap, sizeof(SnapshotData));",
          "new_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "content_same": false
        },
        {
          "line": 3988,
          "old_api": "CloseTransientFile",
          "new_api": "pgstat_report_wait_start",
          "old_text": "CloseTransientFile(fd)",
          "new_text": "pgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE)",
          "old_line_content": "\t\tCloseTransientFile(fd);",
          "new_line_content": "\tpgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE);",
          "content_same": false
        },
        {
          "line": 3993,
          "old_api": "errcode_for_file_access",
          "new_api": "CloseTransientFile",
          "old_text": "errcode_for_file_access()",
          "new_text": "CloseTransientFile(fd)",
          "old_line_content": "\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\tCloseTransientFile(fd);",
          "content_same": false
        },
        {
          "line": 3997,
          "old_api": "pgstat_report_wait_end",
          "new_api": "ereport",
          "old_text": "pgstat_report_wait_end()",
          "new_text": "ereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to data file for XID %u: %m\",\n\t\t\t\t\t\ttxn->xid)))",
          "old_line_content": "\tpgstat_report_wait_end();",
          "new_line_content": "\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4086,
          "old_api": "dlist_foreach",
          "new_api": "rbtxn_is_streamed",
          "old_text": "dlist_foreach(subxact_i, &txn->subtxns)",
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t\tdlist_foreach(subxact_i, &txn->subtxns)",
          "new_line_content": "\t\tAssert(!rbtxn_is_streamed(txn));",
          "content_same": false
        },
        {
          "line": 4091,
          "old_api": "ReorderBufferTransferSnapToParent",
          "new_api": "dlist_foreach",
          "old_text": "ReorderBufferTransferSnapToParent(txn, subtxn)",
          "new_text": "dlist_foreach(subxact_i, &txn->subtxns)",
          "old_line_content": "\t\t\tReorderBufferTransferSnapToParent(txn, subtxn);",
          "new_line_content": "\t\tdlist_foreach(subxact_i, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 4105,
          "old_api": "ReorderBufferCopySnap",
          "new_api": "Assert",
          "old_text": "ReorderBufferCopySnap(rb, txn->base_snapshot,\n\t\t\t\t\t\t\t\t\t\t\t txn, command_id)",
          "new_text": "Assert(txn->ninvalidations == 0)",
          "old_line_content": "\t\tsnapshot_now = ReorderBufferCopySnap(rb, txn->base_snapshot,",
          "new_line_content": "\t\t\tAssert(txn->ninvalidations == 0);",
          "content_same": false
        },
        {
          "line": 4132,
          "old_api": "ReorderBufferFreeSnap",
          "new_api": "ReorderBufferCopySnap",
          "old_text": "ReorderBufferFreeSnap(rb, txn->snapshot_now)",
          "new_text": "ReorderBufferCopySnap(rb, txn->snapshot_now,\n\t\t\t\t\t\t\t\t\t\t\t txn, command_id)",
          "old_line_content": "\t\tReorderBufferFreeSnap(rb, txn->snapshot_now);",
          "new_line_content": "\t\tsnapshot_now = ReorderBufferCopySnap(rb, txn->snapshot_now,",
          "content_same": false
        },
        {
          "line": 4269,
          "old_api": "dlist_delete",
          "new_api": "dlist_foreach_modify",
          "old_text": "dlist_delete(&cleanup->node)",
          "new_text": "dlist_foreach_modify(cleanup_iter, &txn->changes)",
          "old_line_content": "\t\tdlist_delete(&cleanup->node);",
          "new_line_content": "\tdlist_foreach_modify(cleanup_iter, &txn->changes)",
          "content_same": false
        },
        {
          "line": 4275,
          "old_api": "XLByteToSeg",
          "new_api": "ReorderBufferReturnChange",
          "old_text": "XLByteToSeg(txn->final_lsn, last_segno, wal_segment_size)",
          "new_text": "ReorderBufferReturnChange(rb, cleanup, true)",
          "old_line_content": "\tXLByteToSeg(txn->final_lsn, last_segno, wal_segment_size);",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, cleanup, true);",
          "content_same": false
        },
        {
          "line": 4343,
          "old_api": "errcode_for_file_access",
          "new_api": "ereport",
          "old_text": "errcode_for_file_access()",
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")))",
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4344,
          "old_api": "errmsg",
          "new_api": "errcode_for_file_access",
          "old_text": "errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) sizeof(ReorderBufferDiskChange))",
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4368,
          "old_api": "errcode_for_file_access",
          "new_api": "ereport",
          "old_text": "errcode_for_file_access()",
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")))",
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4369,
          "old_api": "errmsg",
          "new_api": "errcode_for_file_access",
          "old_text": "errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))",
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4475,
          "old_api": "Assert",
          "new_api": "memcpy",
          "old_text": "Assert(change->data.msg.prefix[prefix_size - 1] == '\\0')",
          "new_text": "memcpy(&prefix_size, data, sizeof(Size))",
          "old_line_content": "\t\t\t\tAssert(change->data.msg.prefix[prefix_size - 1] == '\\0');",
          "new_line_content": "\t\t\t\tmemcpy(&prefix_size, data, sizeof(Size));",
          "content_same": false
        },
        {
          "line": 4612,
          "old_api": "snprintf",
          "new_api": "ReadDirExtended",
          "old_text": "snprintf(path, sizeof(path),\n\t\t\t\t\t \"%s/%s/%s\", PG_REPLSLOT_DIR, slotname,\n\t\t\t\t\t spill_de->d_name)",
          "new_text": "ReadDirExtended(spill_dir, path, INFO)",
          "old_line_content": "\t\t\tsnprintf(path, sizeof(path),",
          "new_line_content": "\twhile ((spill_de = ReadDirExtended(spill_dir, path, INFO)) != NULL)",
          "content_same": false
        },
        {
          "line": 4617,
          "old_api": "ereport",
          "new_api": "snprintf",
          "old_text": "ereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\" during removal of %s/%s/xid*: %m\",\n\t\t\t\t\t\t\t\tpath, PG_REPLSLOT_DIR, slotname)))",
          "new_text": "snprintf(path, sizeof(path),\n\t\t\t\t\t \"%s/%s/%s\", PG_REPLSLOT_DIR, slotname,\n\t\t\t\t\t spill_de->d_name)",
          "old_line_content": "\t\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\tsnprintf(path, sizeof(path),",
          "content_same": false
        },
        {
          "line": 4623,
          "old_api": "FreeDir",
          "new_api": "errcode_for_file_access",
          "old_text": "FreeDir(spill_dir)",
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\tFreeDir(spill_dir);",
          "new_line_content": "\t\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4642,
          "old_api": "LSN_FORMAT_ARGS",
          "new_api": "XLogSegNoOffsetToRecPtr",
          "old_text": "LSN_FORMAT_ARGS(recptr)",
          "new_text": "XLogSegNoOffsetToRecPtr(segno, 0, wal_segment_size, recptr)",
          "old_line_content": "\t\t\t xid, LSN_FORMAT_ARGS(recptr));",
          "new_line_content": "\tXLogSegNoOffsetToRecPtr(segno, 0, wal_segment_size, recptr);",
          "content_same": false
        },
        {
          "line": 4663,
          "old_api": "ReplicationSlotValidateName",
          "new_api": "strcmp",
          "old_text": "ReplicationSlotValidateName(logical_de->d_name, DEBUG2)",
          "new_text": "strcmp(logical_de->d_name, \".\")",
          "old_line_content": "\t\tif (!ReplicationSlotValidateName(logical_de->d_name, DEBUG2))",
          "new_line_content": "\t\tif (strcmp(logical_de->d_name, \".\") == 0 ||",
          "content_same": false
        },
        {
          "line": 4693,
          "old_api": "hash_create",
          "new_api": "Assert",
          "old_text": "hash_create(\"ReorderBufferToastHash\", 5, &hash_ctl,\n\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS | HASH_CONTEXT)",
          "new_text": "Assert(txn->toast_hash == NULL)",
          "old_line_content": "\ttxn->toast_hash = hash_create(\"ReorderBufferToastHash\", 5, &hash_ctl,",
          "new_line_content": "\tAssert(txn->toast_hash == NULL);",
          "content_same": false
        },
        {
          "line": 4718,
          "old_api": "ReorderBufferToastInitHash",
          "new_api": "RelationGetDescr",
          "old_text": "ReorderBufferToastInitHash(rb, txn)",
          "new_text": "RelationGetDescr(relation)",
          "old_line_content": "\t\tReorderBufferToastInitHash(rb, txn);",
          "new_line_content": "\tTupleDesc\tdesc = RelationGetDescr(relation);",
          "content_same": false
        },
        {
          "line": 4723,
          "old_api": "fastgetattr",
          "new_api": "ReorderBufferToastInitHash",
          "old_text": "fastgetattr(newtup, 1, desc, &isnull)",
          "new_text": "ReorderBufferToastInitHash(rb, txn)",
          "old_line_content": "\tchunk_id = DatumGetObjectId(fastgetattr(newtup, 1, desc, &isnull));",
          "new_line_content": "\t\tReorderBufferToastInitHash(rb, txn);",
          "content_same": false
        },
        {
          "line": 4725,
          "old_api": "fastgetattr",
          "new_api": "IsToastRelation",
          "old_text": "fastgetattr(newtup, 2, desc, &isnull)",
          "new_text": "IsToastRelation(relation)",
          "old_line_content": "\tchunk_seq = DatumGetInt32(fastgetattr(newtup, 2, desc, &isnull));",
          "new_line_content": "\tAssert(IsToastRelation(relation));",
          "content_same": false
        },
        {
          "line": 4729,
          "old_api": "hash_search",
          "new_api": "Assert",
          "old_text": "hash_search(txn->toast_hash, &chunk_id, HASH_ENTER, &found)",
          "new_text": "Assert(!isnull)",
          "old_line_content": "\t\thash_search(txn->toast_hash, &chunk_id, HASH_ENTER, &found);",
          "new_line_content": "\tAssert(!isnull);",
          "content_same": false
        },
        {
          "line": 4738,
          "old_api": "dlist_init",
          "new_api": "Assert",
          "old_text": "dlist_init(&ent->chunks)",
          "new_text": "Assert(ent->chunk_id == chunk_id)",
          "old_line_content": "\t\tdlist_init(&ent->chunks);",
          "new_line_content": "\t\tAssert(ent->chunk_id == chunk_id);",
          "content_same": false
        },
        {
          "line": 4753,
          "old_api": "VARSIZE",
          "new_api": "fastgetattr",
          "old_text": "VARSIZE(chunk)",
          "new_text": "fastgetattr(newtup, 3, desc, &isnull)",
          "old_line_content": "\t\tchunksize = VARSIZE(chunk) - VARHDRSZ;",
          "new_line_content": "\tchunk = DatumGetPointer(fastgetattr(newtup, 3, desc, &isnull));",
          "content_same": false
        },
        {
          "line": 4754,
          "old_api": "VARATT_IS_SHORT",
          "new_api": "Assert",
          "old_text": "VARATT_IS_SHORT(chunk)",
          "new_text": "Assert(!isnull)",
          "old_line_content": "\telse if (VARATT_IS_SHORT(chunk))",
          "new_line_content": "\tAssert(!isnull);",
          "content_same": false
        },
        {
          "line": 4758,
          "old_api": "elog",
          "new_api": "VARSIZE",
          "old_text": "elog(ERROR, \"unexpected type of toast chunk\")",
          "new_text": "VARSIZE(chunk)",
          "old_line_content": "\t\telog(ERROR, \"unexpected type of toast chunk\");",
          "new_line_content": "\t\tchunksize = VARSIZE(chunk) - VARHDRSZ;",
          "content_same": false
        },
        {
          "line": 4763,
          "old_api": "dlist_push_tail",
          "new_api": "elog",
          "old_text": "dlist_push_tail(&ent->chunks, &change->node)",
          "new_text": "elog(ERROR, \"unexpected type of toast chunk\")",
          "old_line_content": "\tdlist_push_tail(&ent->chunks, &change->node);",
          "new_line_content": "\t\telog(ERROR, \"unexpected type of toast chunk\");",
          "content_same": false
        },
        {
          "line": 4821,
          "old_api": "Assert",
          "new_api": "ReorderBufferChangeSize",
          "old_text": "Assert(change->data.tp.newtuple)",
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": "\tAssert(change->data.tp.newtuple);",
          "new_line_content": "\told_size = ReorderBufferChangeSize(change);",
          "content_same": false
        },
        {
          "line": 4823,
          "old_api": "RelationGetDescr",
          "new_api": "MemoryContextSwitchTo",
          "old_text": "RelationGetDescr(relation)",
          "new_text": "MemoryContextSwitchTo(rb->context)",
          "old_line_content": "\tdesc = RelationGetDescr(relation);",
          "new_line_content": "\toldcontext = MemoryContextSwitchTo(rb->context);",
          "content_same": false
        },
        {
          "line": 4826,
          "old_api": "RelationIsValid",
          "new_api": "Assert",
          "old_text": "RelationIsValid(toast_rel)",
          "new_text": "Assert(change->data.tp.newtuple)",
          "old_line_content": "\tif (!RelationIsValid(toast_rel))",
          "new_line_content": "\tAssert(change->data.tp.newtuple);",
          "content_same": false
        },
        {
          "line": 4828,
          "old_api": "RelationGetRelationName",
          "new_api": "RelationGetDescr",
          "old_text": "RelationGetRelationName(relation)",
          "new_text": "RelationGetDescr(relation)",
          "old_line_content": "\t\t\t relation->rd_rel->reltoastrelid, RelationGetRelationName(relation));",
          "new_line_content": "\tdesc = RelationGetDescr(relation);",
          "content_same": false
        },
        {
          "line": 4830,
          "old_api": "RelationGetDescr",
          "new_api": "RelationIdGetRelation",
          "old_text": "RelationGetDescr(toast_rel)",
          "new_text": "RelationIdGetRelation(relation->rd_rel->reltoastrelid)",
          "old_line_content": "\ttoast_desc = RelationGetDescr(toast_rel);",
          "new_line_content": "\ttoast_rel = RelationIdGetRelation(relation->rd_rel->reltoastrelid);",
          "content_same": false
        },
        {
          "line": 4833,
          "old_api": "palloc0",
          "new_api": "RelationGetRelationName",
          "old_text": "palloc0(sizeof(Datum) * desc->natts)",
          "new_text": "RelationGetRelationName(relation)",
          "old_line_content": "\tattrs = palloc0(sizeof(Datum) * desc->natts);",
          "new_line_content": "\t\t\t relation->rd_rel->reltoastrelid, RelationGetRelationName(relation));",
          "content_same": false
        },
        {
          "line": 4835,
          "old_api": "palloc0",
          "new_api": "RelationGetDescr",
          "old_text": "palloc0(sizeof(bool) * desc->natts)",
          "new_text": "RelationGetDescr(toast_rel)",
          "old_line_content": "\tfree = palloc0(sizeof(bool) * desc->natts);",
          "new_line_content": "\ttoast_desc = RelationGetDescr(toast_rel);",
          "content_same": false
        },
        {
          "line": 4839,
          "old_api": "heap_deform_tuple",
          "new_api": "palloc0",
          "old_text": "heap_deform_tuple(newtup, desc, attrs, isnull)",
          "new_text": "palloc0(sizeof(bool) * desc->natts)",
          "old_line_content": "\theap_deform_tuple(newtup, desc, attrs, isnull);",
          "new_line_content": "\tisnull = palloc0(sizeof(bool) * desc->natts);",
          "content_same": false
        },
        {
          "line": 4900,
          "old_api": "dlist_foreach",
          "new_api": "palloc0",
          "old_text": "dlist_foreach(it, &ent->chunks)",
          "new_text": "palloc0(toast_pointer.va_rawsize)",
          "old_line_content": "\t\tdlist_foreach(it, &ent->chunks)",
          "new_line_content": "\t\treconstructed = palloc0(toast_pointer.va_rawsize);",
          "content_same": false
        },
        {
          "line": 4912,
          "old_api": "VARATT_IS_EXTERNAL",
          "new_api": "dlist_container",
          "old_text": "VARATT_IS_EXTERNAL(chunk)",
          "new_text": "dlist_container(ReorderBufferChange, node, it.cur)",
          "old_line_content": "\t\t\tAssert(!VARATT_IS_EXTERNAL(chunk));",
          "new_line_content": "\t\t\tcchange = dlist_container(ReorderBufferChange, node, it.cur);",
          "content_same": false
        },
        {
          "line": 4916,
          "old_api": "VARDATA",
          "new_api": "Assert",
          "old_text": "VARDATA(chunk)",
          "new_text": "Assert(!cisnull)",
          "old_line_content": "\t\t\t\t   VARDATA(chunk),",
          "new_line_content": "\t\t\tAssert(!cisnull);",
          "content_same": false
        },
        {
          "line": 4917,
          "old_api": "VARSIZE",
          "new_api": "VARATT_IS_EXTERNAL",
          "old_text": "VARSIZE(chunk)",
          "new_text": "VARATT_IS_EXTERNAL(chunk)",
          "old_line_content": "\t\t\t\t   VARSIZE(chunk) - VARHDRSZ);",
          "new_line_content": "\t\t\tAssert(!VARATT_IS_EXTERNAL(chunk));",
          "content_same": false
        },
        {
          "line": 4918,
          "old_api": "VARSIZE",
          "new_api": "VARATT_IS_SHORT",
          "old_text": "VARSIZE(chunk)",
          "new_text": "VARATT_IS_SHORT(chunk)",
          "old_line_content": "\t\t\tdata_done += VARSIZE(chunk) - VARHDRSZ;",
          "new_line_content": "\t\t\tAssert(!VARATT_IS_SHORT(chunk));",
          "content_same": false
        },
        {
          "line": 4920,
          "old_api": "VARATT_EXTERNAL_GET_EXTSIZE",
          "new_api": "VARDATA",
          "old_text": "VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer)",
          "new_text": "VARDATA(reconstructed)",
          "old_line_content": "\t\tAssert(data_done == VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer));",
          "new_line_content": "\t\t\tmemcpy(VARDATA(reconstructed) + data_done,",
          "content_same": false
        },
        {
          "line": 4923,
          "old_api": "VARATT_EXTERNAL_IS_COMPRESSED",
          "new_api": "VARSIZE",
          "old_text": "VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer)",
          "new_text": "VARSIZE(chunk)",
          "old_line_content": "\t\tif (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))",
          "new_line_content": "\t\t\tdata_done += VARSIZE(chunk) - VARHDRSZ;",
          "content_same": false
        },
        {
          "line": 4928,
          "old_api": "memset",
          "new_api": "VARATT_EXTERNAL_IS_COMPRESSED",
          "old_text": "memset(&redirect_pointer, 0, sizeof(redirect_pointer))",
          "new_text": "VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer)",
          "old_line_content": "\t\tmemset(&redirect_pointer, 0, sizeof(redirect_pointer));",
          "new_line_content": "\t\tif (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))",
          "content_same": false
        },
        {
          "line": 4931,
          "old_api": "SET_VARTAG_EXTERNAL",
          "new_api": "SET_VARSIZE",
          "old_text": "SET_VARTAG_EXTERNAL(new_datum, VARTAG_INDIRECT)",
          "new_text": "SET_VARSIZE(reconstructed, data_done + VARHDRSZ)",
          "old_line_content": "\t\tSET_VARTAG_EXTERNAL(new_datum, VARTAG_INDIRECT);",
          "new_line_content": "\t\t\tSET_VARSIZE(reconstructed, data_done + VARHDRSZ);",
          "content_same": false
        },
        {
          "line": 4959,
          "old_api": "DatumGetPointer",
          "new_api": "RelationClose",
          "old_text": "DatumGetPointer(attrs[natt])",
          "new_text": "RelationClose(toast_rel)",
          "old_line_content": "\t\t\tpfree(DatumGetPointer(attrs[natt]));",
          "new_line_content": "\tRelationClose(toast_rel);",
          "content_same": false
        },
        {
          "line": 4968,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": "pfree",
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, false, old_size)",
          "new_text": "pfree(isnull)",
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, false, old_size);",
          "new_line_content": "\tpfree(isnull);",
          "content_same": false
        },
        {
          "line": 4970,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": "MemoryContextSwitchTo",
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, true,\n\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "new_text": "MemoryContextSwitchTo(oldcontext)",
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, true,",
          "new_line_content": "\tMemoryContextSwitchTo(oldcontext);",
          "content_same": false
        },
        {
          "line": 4993,
          "old_api": "pfree",
          "new_api": "hash_seq_search",
          "old_text": "pfree(ent->reconstructed)",
          "new_text": "hash_seq_search(&hstat)",
          "old_line_content": "\t\t\tpfree(ent->reconstructed);",
          "new_line_content": "\twhile ((ent = (ReorderBufferToastEnt *) hash_seq_search(&hstat)) != NULL)",
          "content_same": false
        },
        {
          "line": 4998,
          "old_api": "dlist_container",
          "new_api": "pfree",
          "old_text": "dlist_container(ReorderBufferChange, node, it.cur)",
          "new_text": "pfree(ent->reconstructed)",
          "old_line_content": "\t\t\t\tdlist_container(ReorderBufferChange, node, it.cur);",
          "new_line_content": "\t\t\tpfree(ent->reconstructed);",
          "content_same": false
        },
        {
          "line": 5000,
          "old_api": "dlist_delete",
          "new_api": "dlist_foreach_modify",
          "old_text": "dlist_delete(&change->node)",
          "new_text": "dlist_foreach_modify(it, &ent->chunks)",
          "old_line_content": "\t\t\tdlist_delete(&change->node);",
          "new_line_content": "\t\tdlist_foreach_modify(it, &ent->chunks)",
          "content_same": false
        },
        {
          "line": 5005,
          "old_api": "hash_destroy",
          "new_api": "dlist_delete",
          "old_text": "hash_destroy(txn->toast_hash)",
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "\thash_destroy(txn->toast_hash);",
          "new_line_content": "\t\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 5062,
          "old_api": "ItemPointerGetOffsetNumber",
          "new_api": "elog",
          "old_text": "ItemPointerGetOffsetNumber(&ent->key.tid)",
          "new_text": "elog(DEBUG3, \"mapping: node: %u/%u/%u tid: %u/%u cmin: %u, cmax: %u\",\n\t\t\t ent->key.rlocator.dbOid,\n\t\t\t ent->key.rlocator.spcOid,\n\t\t\t ent->key.rlocator.relNumber,\n\t\t\t ItemPointerGetBlockNumber(&ent->key.tid),\n\t\t\t ItemPointerGetOffsetNumber(&ent->key.tid),\n\t\t\t ent->cmin,\n\t\t\t ent->cmax\n\t\t\t)",
          "old_line_content": "\t\t\t ItemPointerGetOffsetNumber(&ent->key.tid),",
          "new_line_content": "\t\telog(DEBUG3, \"mapping: node: %u/%u/%u tid: %u/%u cmin: %u, cmax: %u\",",
          "content_same": false
        },
        {
          "line": 5089,
          "old_api": "errmsg",
          "new_api": "sprintf",
          "old_text": "errmsg(\"could not open file \\\"%s\\\": %m\", path)",
          "new_text": "sprintf(path, \"%s/%s\", PG_LOGICAL_MAPPINGS_DIR, fname)",
          "old_line_content": "\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)));",
          "new_line_content": "\tsprintf(path, \"%s/%s\", PG_LOGICAL_MAPPINGS_DIR, fname);",
          "content_same": false
        },
        {
          "line": 5104,
          "old_api": "pgstat_report_wait_end",
          "new_api": "memset",
          "old_text": "pgstat_report_wait_end()",
          "new_text": "memset(&key, 0, sizeof(ReorderBufferTupleCidKey))",
          "old_line_content": "\t\tpgstat_report_wait_end();",
          "new_line_content": "\t\tmemset(&key, 0, sizeof(ReorderBufferTupleCidKey));",
          "content_same": false
        },
        {
          "line": 5107,
          "old_api": "ereport",
          "new_api": "pgstat_report_wait_start",
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpath)))",
          "new_text": "pgstat_report_wait_start(WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ)",
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\tpgstat_report_wait_start(WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ);",
          "content_same": false
        },
        {
          "line": 5108,
          "old_api": "errcode_for_file_access",
          "new_api": "read",
          "old_text": "errcode_for_file_access()",
          "new_text": "read(fd, &map, sizeof(LogicalRewriteMappingData))",
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\treadBytes = read(fd, &map, sizeof(LogicalRewriteMappingData));",
          "content_same": false
        },
        {
          "line": 5109,
          "old_api": "errmsg",
          "new_api": "pgstat_report_wait_end",
          "old_text": "errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpath)",
          "new_text": "pgstat_report_wait_end()",
          "old_line_content": "\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",",
          "new_line_content": "\t\tpgstat_report_wait_end();",
          "content_same": false
        },
        {
          "line": 5114,
          "old_api": "ereport",
          "new_api": "errmsg",
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": read %d instead of %d bytes\",\n\t\t\t\t\t\t\tpath, readBytes,\n\t\t\t\t\t\t\t(int32) sizeof(LogicalRewriteMappingData))))",
          "new_text": "errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpath)",
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",",
          "content_same": false
        },
        {
          "line": 5121,
          "old_api": "ItemPointerCopy",
          "new_api": "errmsg",
          "old_text": "ItemPointerCopy(&map.old_tid,\n\t\t\t\t\t\t&key.tid)",
          "new_text": "errmsg(\"could not read from file \\\"%s\\\": read %d instead of %d bytes\",\n\t\t\t\t\t\t\tpath, readBytes,\n\t\t\t\t\t\t\t(int32) sizeof(LogicalRewriteMappingData))",
          "old_line_content": "\t\tItemPointerCopy(&map.old_tid,",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": read %d instead of %d bytes\",",
          "content_same": false
        },
        {
          "line": 5126,
          "old_api": "hash_search",
          "new_api": "ItemPointerCopy",
          "old_text": "hash_search(tuplecid_data, &key, HASH_FIND, NULL)",
          "new_text": "ItemPointerCopy(&map.old_tid,\n\t\t\t\t\t\t&key.tid)",
          "old_line_content": "\t\t\thash_search(tuplecid_data, &key, HASH_FIND, NULL);",
          "new_line_content": "\t\tItemPointerCopy(&map.old_tid,",
          "content_same": false
        },
        {
          "line": 5217,
          "old_api": "strncmp",
          "new_api": "strcmp",
          "old_text": "strncmp(mapping_de->d_name, \"map-\", 4)",
          "new_text": "strcmp(mapping_de->d_name, \".\")",
          "old_line_content": "\t\tif (strncmp(mapping_de->d_name, \"map-\", 4) != 0)",
          "new_line_content": "\t\tif (strcmp(mapping_de->d_name, \".\") == 0 ||",
          "content_same": false
        },
        {
          "line": 5249,
          "old_api": "FreeDir",
          "new_api": "palloc",
          "old_text": "FreeDir(mapping_dir)",
          "new_text": "palloc(sizeof(RewriteMappingFile))",
          "old_line_content": "\tFreeDir(mapping_dir);",
          "new_line_content": "\t\tf = palloc(sizeof(RewriteMappingFile));",
          "content_same": false
        },
        {
          "line": 5252,
          "old_api": "list_sort",
          "new_api": "lappend",
          "old_text": "list_sort(files, file_sort_by_lsn)",
          "new_text": "lappend(files, f)",
          "old_line_content": "\tlist_sort(files, file_sort_by_lsn);",
          "new_line_content": "\t\tfiles = lappend(files, f);",
          "content_same": false
        },
        {
          "line": 5261,
          "old_api": "pfree",
          "new_api": "lfirst",
          "old_text": "pfree(f)",
          "new_text": "lfirst(file)",
          "old_line_content": "\t\tpfree(f);",
          "new_line_content": "\t\tRewriteMappingFile *f = (RewriteMappingFile *) lfirst(file);",
          "content_same": false
        },
        {
          "line": 5312,
          "old_api": "hash_search",
          "new_api": "ItemPointerCopy",
          "old_text": "hash_search(tuplecid_data, &key, HASH_FIND, NULL)",
          "new_text": "ItemPointerCopy(&htup->t_self,\n\t\t\t\t\t&key.tid)",
          "old_line_content": "\t\thash_search(tuplecid_data, &key, HASH_FIND, NULL);",
          "new_line_content": "\tItemPointerCopy(&htup->t_self,",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 4096,
          "old_api": null,
          "new_api": "ReorderBufferTransferSnapToParent",
          "old_text": null,
          "new_text": "ReorderBufferTransferSnapToParent(txn, subtxn)",
          "old_line_content": "\t\t * the database till now, so there's nothing to decode.",
          "new_line_content": "\t\t\tReorderBufferTransferSnapToParent(txn, subtxn);",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": null,
          "new_api": "ReorderBufferCopySnap",
          "old_text": null,
          "new_text": "ReorderBufferCopySnap(rb, snapshot_now,\n\t\t\t\t\t\t\t\t\t\t\t\t  txn, command_id)",
          "old_line_content": " * Helper function for ReorderBufferProcessTXN to handle the concurrent",
          "new_line_content": "\t\ttxn->snapshot_now = ReorderBufferCopySnap(rb, snapshot_now,",
          "content_same": false
        },
        {
          "line": 4110,
          "old_api": null,
          "new_api": "ReorderBufferCopySnap",
          "old_text": null,
          "new_text": "ReorderBufferCopySnap(rb, txn->base_snapshot,\n\t\t\t\t\t\t\t\t\t\t\t txn, command_id)",
          "old_line_content": "\t\t/* the transaction must have been already streamed */",
          "new_line_content": "\t\tsnapshot_now = ReorderBufferCopySnap(rb, txn->base_snapshot,",
          "content_same": false
        },
        {
          "line": 4116,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t\t * the LSN condition in the previous branch (so no need to walk",
          "new_line_content": "\t\tAssert(rbtxn_is_streamed(txn));",
          "content_same": false
        },
        {
          "line": 2070,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "\t/* Return the spec insert change if it is not NULL */",
          "new_line_content": "\tReorderBufferTruncateTXN(rb, txn, rbtxn_prepared(txn));",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "old_line_content": "\t * For the streaming case, stop the stream and remember the command ID and",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "content_same": false
        },
        {
          "line": 2086,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "",
          "new_line_content": "\tif (rbtxn_is_streamed(txn))",
          "content_same": false
        },
        {
          "line": 4136,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->snapshot_now->copied)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\tAssert(txn->snapshot_now->copied);",
          "content_same": false
        },
        {
          "line": 2089,
          "old_api": null,
          "new_api": "ReorderBufferSaveTXNSnapshot",
          "old_text": null,
          "new_text": "ReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id)",
          "old_line_content": "}",
          "new_line_content": "\t\tReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id);",
          "content_same": false
        },
        {
          "line": 4137,
          "old_api": null,
          "new_api": "ReorderBufferFreeSnap",
          "old_text": null,
          "new_text": "ReorderBufferFreeSnap(rb, txn->snapshot_now)",
          "old_line_content": "\t * Remember this information to be used later to update stats. We can't",
          "new_line_content": "\t\tReorderBufferFreeSnap(rb, txn->snapshot_now);",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->size == 0)",
          "old_line_content": " *",
          "new_line_content": "\tAssert(txn->size == 0);",
          "content_same": false
        },
        {
          "line": 4147,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t\t\t\t\t\t\tcommand_id, true);",
          "new_line_content": "\ttxn_is_streamed = rbtxn_is_streamed(txn);",
          "content_same": false
        },
        {
          "line": 4151,
          "old_api": null,
          "new_api": "ReorderBufferProcessTXN",
          "old_text": null,
          "new_text": "ReorderBufferProcessTXN(rb, txn, InvalidXLogRecPtr, snapshot_now,\n\t\t\t\t\t\t\tcommand_id, true)",
          "old_line_content": "",
          "new_line_content": "\tReorderBufferProcessTXN(rb, txn, InvalidXLogRecPtr, snapshot_now,",
          "content_same": false
        },
        {
          "line": 4161,
          "old_api": null,
          "new_api": "UpdateDecodingStats",
          "old_text": null,
          "new_text": "UpdateDecodingStats((LogicalDecodingContext *) rb->private_data)",
          "old_line_content": "}",
          "new_line_content": "\tUpdateDecodingStats((LogicalDecodingContext *) rb->private_data);",
          "content_same": false
        },
        {
          "line": 4163,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&txn->changes)",
          "old_line_content": "/*",
          "new_line_content": "\tAssert(dlist_is_empty(&txn->changes));",
          "content_same": false
        },
        {
          "line": 4164,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->nentries == 0)",
          "old_line_content": " * Size of a change in memory.",
          "new_line_content": "\tAssert(txn->nentries == 0);",
          "content_same": false
        },
        {
          "line": 4165,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->nentries_mem == 0)",
          "old_line_content": " */",
          "new_line_content": "\tAssert(txn->nentries_mem == 0);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": null,
          "new_api": "ReorderBufferBuildTupleCidHash",
          "old_text": null,
          "new_text": "ReorderBufferBuildTupleCidHash(rb, txn)",
          "old_line_content": "\t/*",
          "new_line_content": "\tReorderBufferBuildTupleCidHash(rb, txn);",
          "content_same": false
        },
        {
          "line": 2127,
          "old_api": null,
          "new_api": "SetupHistoricSnapshot",
          "old_text": null,
          "new_text": "SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash)",
          "old_line_content": "\t * keep track of those.  The easiest way is to simply use a transaction",
          "new_line_content": "\tSetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": null,
          "new_api": "IsTransactionOrTransactionBlock",
          "old_text": null,
          "new_text": "IsTransactionOrTransactionBlock()",
          "old_line_content": "\t\tint\t\t\tchanges_count = 0;\t/* used to accumulate the number of",
          "new_line_content": "\tusing_subtxn = IsTransactionOrTransactionBlock();",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": null,
          "new_api": "PG_TRY",
          "old_text": null,
          "new_text": "PG_TRY()",
          "old_line_content": "",
          "new_line_content": "\tPG_TRY();",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "BeginInternalSubTransaction",
          "old_text": null,
          "new_text": "BeginInternalSubTransaction(streaming ? \"stream\" : \"replay\")",
          "old_line_content": "\t\t * We only need to send begin/begin-prepare for non-streamed",
          "new_line_content": "\t\t\tBeginInternalSubTransaction(streaming ? \"stream\" : \"replay\");",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": null,
          "new_api": "StartTransactionCommand",
          "old_text": null,
          "new_text": "StartTransactionCommand()",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\tStartTransactionCommand();",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (rbtxn_prepared(txn))",
          "content_same": false
        },
        {
          "line": 2161,
          "old_api": null,
          "new_api": "begin",
          "old_text": null,
          "new_text": "rb->begin(rb, txn)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\trb->begin(rb, txn);",
          "content_same": false
        },
        {
          "line": 4210,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(change->data.msg.prefix)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\tSize\t\tprefix_size = strlen(change->data.msg.prefix) + 1;",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": null,
          "new_api": "ReorderBufferIterTXNInit",
          "old_text": null,
          "new_text": "ReorderBufferIterTXNInit(rb, txn, &iterstate)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferIterTXNInit(rb, txn, &iterstate);",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": null,
          "new_api": "CHECK_FOR_INTERRUPTS",
          "old_text": null,
          "new_text": "CHECK_FOR_INTERRUPTS()",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tCHECK_FOR_INTERRUPTS();",
          "content_same": false
        },
        {
          "line": 2181,
          "old_api": null,
          "new_api": "stream_start",
          "old_text": null,
          "new_text": "rb->stream_start(rb, txn, change->lsn)",
          "old_line_content": "\t\t\t/*",
          "new_line_content": "\t\t\t\t\trb->stream_start(rb, txn, change->lsn);",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(prev_lsn == InvalidXLogRecPtr || prev_lsn <= change->lsn)",
          "old_line_content": "\t\t\t * Set the current xid to detect concurrent aborts. This is",
          "new_line_content": "\t\t\tAssert(prev_lsn == InvalidXLogRecPtr || prev_lsn <= change->lsn);",
          "content_same": false
        },
        {
          "line": 2200,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(change->txn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (streaming || rbtxn_prepared(change->txn))",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": null,
          "new_api": "SetupCheckXidLive",
          "old_text": null,
          "new_text": "SetupCheckXidLive(curtxn->xid)",
          "old_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:",
          "new_line_content": "\t\t\t\tSetupCheckXidLive(curtxn->xid);",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"invalid ordering of speculative insertion changes\")",
          "old_line_content": "\t\t\t\t\t/* intentionally fall through */",
          "new_line_content": "\t\t\t\t\t\telog(ERROR, \"invalid ordering of speculative insertion changes\");",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(specinsert->data.tp.oldtuple == NULL)",
          "old_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_INSERT:",
          "new_line_content": "\t\t\t\t\tAssert(specinsert->data.tp.oldtuple == NULL);",
          "content_same": false
        },
        {
          "line": 4265,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "old_line_content": "\t{",
          "new_line_content": "\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 4266,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "old_line_content": "\t\tReorderBufferChange *cleanup =",
          "new_line_content": "\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 4272,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, cleanup_iter.cur)",
          "old_line_content": "\ttxn->nentries_mem = 0;",
          "new_line_content": "\t\t\tdlist_container(ReorderBufferChange, node, cleanup_iter.cur);",
          "content_same": false
        },
        {
          "line": 2225,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(snapshot_now)",
          "old_line_content": "\t\t\t\t\t/*",
          "new_line_content": "\t\t\t\t\tAssert(snapshot_now);",
          "content_same": false
        },
        {
          "line": 4274,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&cleanup->node)",
          "old_line_content": "",
          "new_line_content": "\t\tdlist_delete(&cleanup->node);",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "RelidByRelfilenumber",
          "old_text": null,
          "new_text": "RelidByRelfilenumber(change->data.tp.rlocator.spcOid,\n\t\t\t\t\t\t\t\t\t\t\t\t  change->data.tp.rlocator.relNumber)",
          "old_line_content": "\t\t\t\t\t * catalog table was in the process of being rewritten. We",
          "new_line_content": "\t\t\t\t\treloid = RelidByRelfilenumber(change->data.tp.rlocator.spcOid,",
          "content_same": false
        },
        {
          "line": 4278,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&txn->changes)",
          "old_line_content": "\t{",
          "new_line_content": "\tAssert(dlist_is_empty(&txn->changes));",
          "content_same": false
        },
        {
          "line": 4280,
          "old_api": null,
          "new_api": "XLByteToSeg",
          "old_text": null,
          "new_text": "XLByteToSeg(txn->final_lsn, last_segno, wal_segment_size)",
          "old_line_content": "\t\tReorderBufferDiskChange *ondisk;",
          "new_line_content": "\tXLByteToSeg(txn->final_lsn, last_segno, wal_segment_size);",
          "content_same": false
        },
        {
          "line": 4287,
          "old_api": null,
          "new_api": "CHECK_FOR_INTERRUPTS",
          "old_text": null,
          "new_text": "CHECK_FOR_INTERRUPTS()",
          "old_line_content": "",
          "new_line_content": "\t\tCHECK_FOR_INTERRUPTS();",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"could not map filenumber \\\"%s\\\" to relation OID\",\n\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\telog(ERROR, \"could not map filenumber \\\"%s\\\" to relation OID\",",
          "content_same": false
        },
        {
          "line": 4295,
          "old_api": null,
          "new_api": "XLByteToSeg",
          "old_text": null,
          "new_text": "XLByteToSeg(txn->first_lsn, *segno, wal_segment_size)",
          "old_line_content": "\t\t\t * No need to care about TLIs here, only used during a single run,",
          "new_line_content": "\t\t\t\tXLByteToSeg(txn->first_lsn, *segno, wal_segment_size);",
          "content_same": false
        },
        {
          "line": 4297,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&txn->changes)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tAssert(*segno != 0 || dlist_is_empty(&txn->changes));",
          "content_same": false
        },
        {
          "line": 2253,
          "old_api": null,
          "new_api": "RelationIsValid",
          "old_text": null,
          "new_text": "RelationIsValid(relation)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tif (!RelationIsValid(relation))",
          "content_same": false
        },
        {
          "line": 4303,
          "old_api": null,
          "new_api": "ReorderBufferSerializedPath",
          "old_text": null,
          "new_text": "ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,\n\t\t\t\t\t\t\t\t\t\t*segno)",
          "old_line_content": "\t\t\t/* No harm in resetting the offset even in case of failure */",
          "new_line_content": "\t\t\tReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": null,
          "new_api": "relpathperm",
          "old_text": null,
          "new_text": "relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,",
          "content_same": false
        },
        {
          "line": 4306,
          "old_api": null,
          "new_api": "PathNameOpenFile",
          "old_text": null,
          "new_text": "PathNameOpenFile(path, O_RDONLY | PG_BINARY)",
          "old_line_content": "\t\t\tif (*fd < 0 && errno == ENOENT)",
          "new_line_content": "\t\t\t*fd = PathNameOpenFile(path, O_RDONLY | PG_BINARY);",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": null,
          "new_api": "RelationIsLogicallyLogged",
          "old_text": null,
          "new_text": "RelationIsLogicallyLogged(relation)",
          "old_line_content": "\t\t\t\t\t * plugin has asked for them.",
          "new_line_content": "\t\t\t\t\tif (!RelationIsLogicallyLogged(relation))",
          "content_same": false
        },
        {
          "line": 4318,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tpath)))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4319,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4320,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tpath)",
          "old_line_content": "\t\t * Read the statically sized part of a change which has information",
          "new_line_content": "\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "IsToastRelation",
          "old_text": null,
          "new_text": "IsToastRelation(relation)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tif (!IsToastRelation(relation))",
          "content_same": false
        },
        {
          "line": 2281,
          "old_api": null,
          "new_api": "ReorderBufferToastReplace",
          "old_text": null,
          "new_text": "ReorderBufferToastReplace(rb, txn, relation, change)",
          "old_line_content": "\t\t\t\t\t\t * Only clear reassembled toast chunks if we're sure",
          "new_line_content": "\t\t\t\t\t\tReorderBufferToastReplace(rb, txn, relation, change);",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": null,
          "new_api": "ReorderBufferApplyChange",
          "old_text": null,
          "new_text": "ReorderBufferApplyChange(rb, txn, relation, change,\n\t\t\t\t\t\t\t\t\t\t\t\t streaming)",
          "old_line_content": "\t\t\t\t\t\t * they're not required anymore. The creator of the",
          "new_line_content": "\t\t\t\t\t\tReorderBufferApplyChange(rb, txn, relation, change,",
          "content_same": false
        },
        {
          "line": 4329,
          "old_api": null,
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": null,
          "new_text": "ReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange))",
          "old_line_content": "\t\t/* eof */",
          "new_line_content": "\t\tReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange));",
          "content_same": false
        },
        {
          "line": 4330,
          "old_api": null,
          "new_api": "FileRead",
          "old_text": null,
          "new_text": "FileRead(file->vfd, rb->outbuf,\n\t\t\t\t\t\t\t sizeof(ReorderBufferDiskChange),\n\t\t\t\t\t\t\t file->curOffset, WAIT_EVENT_REORDER_BUFFER_READ)",
          "old_line_content": "\t\tif (readBytes == 0)",
          "new_line_content": "\t\treadBytes = FileRead(file->vfd, rb->outbuf,",
          "content_same": false
        },
        {
          "line": 4337,
          "old_api": null,
          "new_api": "FileClose",
          "old_text": null,
          "new_text": "FileClose(*fd)",
          "old_line_content": "\t\telse if (readBytes < 0)",
          "new_line_content": "\t\t\tFileClose(*fd);",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "ReorderBufferToastReset",
          "old_text": null,
          "new_text": "ReorderBufferToastReset(rb, txn)",
          "old_line_content": "\t\t\t\t\t\t/*",
          "new_line_content": "\t\t\t\t\t\t\tReorderBufferToastReset(rb, txn);",
          "content_same": false
        },
        {
          "line": 4345,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not read from reorderbuffer spill file: %m\")",
          "old_line_content": "\t\t\t\t\t\t\treadBytes,",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")));",
          "content_same": false
        },
        {
          "line": 4347,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) sizeof(ReorderBufferDiskChange))))",
          "old_line_content": "",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4348,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\tfile->curOffset += readBytes;",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4349,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) sizeof(ReorderBufferDiskChange))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->data.tp.newtuple != NULL)",
          "old_line_content": "\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tAssert(change->data.tp.newtuple != NULL);",
          "content_same": false
        },
        {
          "line": 2306,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "\t\t\tchange_done:",
          "new_line_content": "\t\t\t\t\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": null,
          "new_api": "ReorderBufferToastAppendChunk",
          "old_text": null,
          "new_text": "ReorderBufferToastAppendChunk(rb, txn, relation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  change)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tReorderBufferToastAppendChunk(rb, txn, relation,",
          "content_same": false
        },
        {
          "line": 4357,
          "old_api": null,
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": null,
          "new_text": "ReorderBufferSerializeReserve(rb,\n\t\t\t\t\t\t\t\t\t  sizeof(ReorderBufferDiskChange) + ondisk->size)",
          "old_line_content": "\t\t\t\t\t\t\t rb->outbuf + sizeof(ReorderBufferDiskChange),",
          "new_line_content": "\t\tReorderBufferSerializeReserve(rb,",
          "content_same": false
        },
        {
          "line": 4361,
          "old_api": null,
          "new_api": "FileRead",
          "old_text": null,
          "new_text": "FileRead(file->vfd,\n\t\t\t\t\t\t\t rb->outbuf + sizeof(ReorderBufferDiskChange),\n\t\t\t\t\t\t\t ondisk->size - sizeof(ReorderBufferDiskChange),\n\t\t\t\t\t\t\t file->curOffset,\n\t\t\t\t\t\t\t WAIT_EVENT_REORDER_BUFFER_READ)",
          "old_line_content": "",
          "new_line_content": "\t\treadBytes = FileRead(file->vfd,",
          "content_same": false
        },
        {
          "line": 2319,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "old_line_content": "\t\t\t\t\t{",
          "new_line_content": "\t\t\t\t\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "content_same": false
        },
        {
          "line": 4370,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not read from reorderbuffer spill file: %m\")",
          "old_line_content": "\t\t\t\t\t\t\treadBytes,",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")));",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": null,
          "new_api": "RelationIsValid",
          "old_text": null,
          "new_text": "RelationIsValid(relation)",
          "old_line_content": "\t\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\t\tif (RelationIsValid(relation))",
          "content_same": false
        },
        {
          "line": 4372,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))))",
          "old_line_content": "",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": null,
          "new_api": "RelationClose",
          "old_text": null,
          "new_text": "RelationClose(relation)",
          "old_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:",
          "new_line_content": "\t\t\t\t\t\tRelationClose(relation);",
          "content_same": false
        },
        {
          "line": 4373,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\tfile->curOffset += readBytes;",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4374,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",",
          "content_same": false
        },
        {
          "line": 4376,
          "old_api": null,
          "new_api": "uint32) (ondisk->size - sizeof(ReorderBufferDiskChange))",
          "old_text": null,
          "new_text": "uint32) (ondisk->size - sizeof(ReorderBufferDiskChange))",
          "old_line_content": "\t\t * ok, read a full change from disk, now restore it into proper",
          "new_line_content": "\t\t\t\t\t\t\t(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))));",
          "content_same": false
        },
        {
          "line": 4384,
          "old_api": null,
          "new_api": "ReorderBufferRestoreChange",
          "old_text": null,
          "new_text": "ReorderBufferRestoreChange(rb, txn, rb->outbuf)",
          "old_line_content": "}",
          "new_line_content": "\t\tReorderBufferRestoreChange(rb, txn, rb->outbuf);",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 4408,
          "old_api": null,
          "new_api": "ReorderBufferGetChange",
          "old_text": null,
          "new_text": "ReorderBufferGetChange(rb)",
          "old_line_content": "\tdata += sizeof(ReorderBufferDiskChange);",
          "new_line_content": "\tchange = ReorderBufferGetChange(rb);",
          "content_same": false
        },
        {
          "line": 4411,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change, &ondisk->change, sizeof(ReorderBufferChange))",
          "old_line_content": "\tswitch (change->action)",
          "new_line_content": "\tmemcpy(change, &ondisk->change, sizeof(ReorderBufferChange));",
          "content_same": false
        },
        {
          "line": 2374,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->data.tp.clear_toast_afterwards)",
          "old_line_content": "\t\t\t\t\t\tspecinsert = NULL;",
          "new_line_content": "\t\t\t\t\t\tAssert(change->data.tp.clear_toast_afterwards);",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": null,
          "new_api": "ReorderBufferToastReset",
          "old_text": null,
          "new_text": "ReorderBufferToastReset(rb, txn)",
          "old_line_content": "\t\t\t\t\t}",
          "new_line_content": "\t\t\t\t\t\tReorderBufferToastReset(rb, txn);",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "old_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_TRUNCATE:",
          "new_line_content": "\t\t\t\t\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "content_same": false
        },
        {
          "line": 4428,
          "old_api": null,
          "new_api": "ReorderBufferGetTupleBuf",
          "old_text": null,
          "new_text": "ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader)",
          "old_line_content": "\t\t\t\tdata += sizeof(HeapTupleData);",
          "new_line_content": "\t\t\t\t\tReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);",
          "content_same": false
        },
        {
          "line": 4431,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.tp.oldtuple, data,\n\t\t\t\t\t   sizeof(HeapTupleData))",
          "old_line_content": "\t\t\t\tchange->data.tp.oldtuple->t_data =",
          "new_line_content": "\t\t\t\tmemcpy(change->data.tp.oldtuple, data,",
          "content_same": false
        },
        {
          "line": 4437,
          "old_api": null,
          "new_api": "HeapTupleHeader) ((char *) change->data.tp.oldtuple + HEAPTUPLESIZE)",
          "old_text": null,
          "new_text": "HeapTupleHeader) ((char *) change->data.tp.oldtuple + HEAPTUPLESIZE)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\t(HeapTupleHeader) ((char *) change->data.tp.oldtuple + HEAPTUPLESIZE);",
          "content_same": false
        },
        {
          "line": 2390,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(nrelids * sizeof(Relation))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\trelations = palloc0(nrelids * sizeof(Relation));",
          "content_same": false
        },
        {
          "line": 4440,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.tp.oldtuple->t_data, data, tuplelen)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tmemcpy(change->data.tp.oldtuple->t_data, data, tuplelen);",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "GenerationContextCreate",
          "old_text": null,
          "new_text": "GenerationContextCreate(new_ctx,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"Tuples\",\n\t\t\t\t\t\t\t\t\t\t\t\t  SLAB_DEFAULT_BLOCK_SIZE,\n\t\t\t\t\t\t\t\t\t\t\t\t  SLAB_DEFAULT_BLOCK_SIZE,\n\t\t\t\t\t\t\t\t\t\t\t\t  SLAB_DEFAULT_BLOCK_SIZE)",
          "old_line_content": "",
          "new_line_content": "\tbuffer->tup_context = GenerationContextCreate(new_ctx,",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": null,
          "new_api": "RelationIsValid",
          "old_text": null,
          "new_text": "RelationIsValid(rel)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tif (!RelationIsValid(rel))",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"could not open relation with OID %u\", relid)",
          "old_line_content": "\t\t\t\t\t\t\trelations[nrelations++] = rel;",
          "new_line_content": "\t\t\t\t\t\t\t\telog(ERROR, \"could not open relation with OID %u\", relid);",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "RelationIsLogicallyLogged",
          "old_text": null,
          "new_text": "RelationIsLogicallyLogged(rel)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tif (!RelationIsLogicallyLogged(rel))",
          "content_same": false
        },
        {
          "line": 4449,
          "old_api": null,
          "new_api": "offsetof",
          "old_text": null,
          "new_text": "offsetof(HeapTupleData, t_len)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tmemcpy(&tuplelen, data + offsetof(HeapTupleData, t_len),",
          "content_same": false
        },
        {
          "line": 4453,
          "old_api": null,
          "new_api": "ReorderBufferGetTupleBuf",
          "old_text": null,
          "new_text": "ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader)",
          "old_line_content": "\t\t\t\tdata += sizeof(HeapTupleData);",
          "new_line_content": "\t\t\t\t\tReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);",
          "content_same": false
        },
        {
          "line": 359,
          "old_api": null,
          "new_api": "hash_create",
          "old_text": null,
          "new_text": "hash_create(\"ReorderBufferByXid\", 1000, &hash_ctl,\n\t\t\t\t\t\t\t\t HASH_ELEM | HASH_BLOBS | HASH_CONTEXT)",
          "old_line_content": "",
          "new_line_content": "\tbuffer->by_txn = hash_create(\"ReorderBufferByXid\", 1000, &hash_ctl,",
          "content_same": false
        },
        {
          "line": 4456,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.tp.newtuple, data,\n\t\t\t\t\t   sizeof(HeapTupleData))",
          "old_line_content": "\t\t\t\tchange->data.tp.newtuple->t_data =",
          "new_line_content": "\t\t\t\tmemcpy(change->data.tp.newtuple, data,",
          "content_same": false
        },
        {
          "line": 2413,
          "old_api": null,
          "new_api": "RelationClose",
          "old_text": null,
          "new_text": "RelationClose(relations[i])",
          "old_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_MESSAGE:",
          "new_line_content": "\t\t\t\t\t\t\tRelationClose(relations[i]);",
          "content_same": false
        },
        {
          "line": 4462,
          "old_api": null,
          "new_api": "HeapTupleHeader) ((char *) change->data.tp.newtuple + HEAPTUPLESIZE)",
          "old_text": null,
          "new_text": "HeapTupleHeader) ((char *) change->data.tp.newtuple + HEAPTUPLESIZE)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\t(HeapTupleHeader) ((char *) change->data.tp.newtuple + HEAPTUPLESIZE);",
          "content_same": false
        },
        {
          "line": 4465,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.tp.newtuple->t_data, data, tuplelen)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_MESSAGE:",
          "new_line_content": "\t\t\t\tmemcpy(change->data.tp.newtuple->t_data, data, tuplelen);",
          "content_same": false
        },
        {
          "line": 370,
          "old_api": null,
          "new_api": "pairingheap_allocate",
          "old_text": null,
          "new_text": "pairingheap_allocate(ReorderBufferTXNSizeCompare, NULL)",
          "old_line_content": "\tbuffer->streamTxns = 0;",
          "new_line_content": "\tbuffer->txn_heap = pairingheap_allocate(ReorderBufferTXNSizeCompare, NULL);",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "ReorderBufferExecuteInvalidations",
          "old_text": null,
          "new_text": "ReorderBufferExecuteInvalidations(change->data.inval.ninvalidations,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  change->data.inval.invalidations)",
          "old_line_content": "\t\t\t\t\t/* get rid of the old */",
          "new_line_content": "\t\t\t\t\tReorderBufferExecuteInvalidations(change->data.inval.ninvalidations,",
          "content_same": false
        },
        {
          "line": 4477,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(rb->context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t prefix_size)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tchange->data.msg.prefix = MemoryContextAlloc(rb->context,",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "TeardownHistoricSnapshot",
          "old_text": null,
          "new_text": "TeardownHistoricSnapshot(false)",
          "old_line_content": "\t\t\t\t\t\tsnapshot_now =",
          "new_line_content": "\t\t\t\t\tTeardownHistoricSnapshot(false);",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&buffer->toplevel_by_lsn)",
          "old_line_content": "\t * Ensure there's no stale data from prior uses of this slot, in case some",
          "new_line_content": "\tdlist_init(&buffer->toplevel_by_lsn);",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&buffer->txns_by_base_snapshot_lsn)",
          "old_line_content": "\t * prior exit avoided calling ReorderBufferFree. Failure to do this can",
          "new_line_content": "\tdlist_init(&buffer->txns_by_base_snapshot_lsn);",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "dclist_init",
          "old_text": null,
          "new_text": "dclist_init(&buffer->catchange_txns)",
          "old_line_content": "\t * produce duplicated txns, and it's very cheap if there's nothing there.",
          "new_line_content": "\tdclist_init(&buffer->catchange_txns);",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": null,
          "new_api": "ReorderBufferFreeSnap",
          "old_text": null,
          "new_text": "ReorderBufferFreeSnap(rb, snapshot_now)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tReorderBufferFreeSnap(rb, snapshot_now);",
          "content_same": false
        },
        {
          "line": 4480,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->data.msg.prefix[prefix_size - 1] == '\\0')",
          "old_line_content": "\t\t\t\tdata += sizeof(Size);",
          "new_line_content": "\t\t\t\tAssert(change->data.msg.prefix[prefix_size - 1] == '\\0');",
          "content_same": false
        },
        {
          "line": 2436,
          "old_api": null,
          "new_api": "ReorderBufferCopySnap",
          "old_text": null,
          "new_text": "ReorderBufferCopySnap(rb, change->data.snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t  txn, command_id)",
          "old_line_content": "\t\t\t\t\t * Restored from disk, need to be careful not to double",
          "new_line_content": "\t\t\t\t\t\t\tReorderBufferCopySnap(rb, change->data.snapshot,",
          "content_same": false
        },
        {
          "line": 4484,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&change->data.msg.message_size, data, sizeof(Size))",
          "old_line_content": "\t\t\t\t\t   change->data.msg.message_size);",
          "new_line_content": "\t\t\t\tmemcpy(&change->data.msg.message_size, data, sizeof(Size));",
          "content_same": false
        },
        {
          "line": 4486,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(rb->context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  change->data.msg.message_size)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tchange->data.msg.message = MemoryContextAlloc(rb->context,",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "NameStr",
          "old_text": null,
          "new_text": "NameStr(MyReplicationSlot->data.name)",
          "old_line_content": "/*",
          "new_line_content": "\tReorderBufferCleanupSerializedTXNs(NameStr(MyReplicationSlot->data.name));",
          "content_same": false
        },
        {
          "line": 4488,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.msg.message, data,\n\t\t\t\t\t   change->data.msg.message_size)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tmemcpy(change->data.msg.message, data,",
          "content_same": false
        },
        {
          "line": 2448,
          "old_api": null,
          "new_api": "ReorderBufferCopySnap",
          "old_text": null,
          "new_text": "ReorderBufferCopySnap(rb, change->data.snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t  txn, command_id)",
          "old_line_content": "\t\t\t\t\t\tsnapshot_now = change->data.snapshot;",
          "new_line_content": "\t\t\t\t\t\t\tReorderBufferCopySnap(rb, change->data.snapshot,",
          "content_same": false
        },
        {
          "line": 4500,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(rb->context, inval_size)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\t\tMemoryContextAlloc(rb->context, inval_size);",
          "content_same": false
        },
        {
          "line": 4503,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.inval.invalidations, data, inval_size)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tmemcpy(change->data.inval.invalidations, data, inval_size);",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "MemoryContextDelete",
          "old_text": null,
          "new_text": "MemoryContextDelete(context)",
          "old_line_content": "",
          "new_line_content": "\tMemoryContextDelete(context);",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": null,
          "new_api": "SetupHistoricSnapshot",
          "old_text": null,
          "new_text": "SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tSetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": null,
          "new_api": "NameStr",
          "old_text": null,
          "new_text": "NameStr(MyReplicationSlot->data.name)",
          "old_line_content": " */",
          "new_line_content": "\tReorderBufferCleanupSerializedTXNs(NameStr(MyReplicationSlot->data.name));",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->data.command_id != InvalidCommandId)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\tAssert(change->data.command_id != InvalidCommandId);",
          "content_same": false
        },
        {
          "line": 2470,
          "old_api": null,
          "new_api": "ReorderBufferCopySnap",
          "old_text": null,
          "new_text": "ReorderBufferCopySnap(rb, snapshot_now,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t txn, command_id)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\tsnapshot_now = ReorderBufferCopySnap(rb, snapshot_now,",
          "content_same": false
        },
        {
          "line": 4519,
          "old_api": null,
          "new_api": "MemoryContextAllocZero",
          "old_text": null,
          "new_text": "MemoryContextAllocZero(rb->context, size)",
          "old_line_content": "\t\t\t\tnewsnap->xip = (TransactionId *)",
          "new_line_content": "\t\t\t\tchange->data.snapshot = MemoryContextAllocZero(rb->context, size);",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(txn, 0, sizeof(ReorderBufferTXN))",
          "old_line_content": "",
          "new_line_content": "\tmemset(txn, 0, sizeof(ReorderBufferTXN));",
          "content_same": false
        },
        {
          "line": 4523,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(newsnap, data, size)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\tmemcpy(newsnap, data, size);",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&txn->changes)",
          "old_line_content": "\ttxn->command_id = InvalidCommandId;",
          "new_line_content": "\tdlist_init(&txn->changes);",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&txn->tuplecids)",
          "old_line_content": "\ttxn->output_plugin_private = NULL;",
          "new_line_content": "\tdlist_init(&txn->tuplecids);",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&txn->subtxns)",
          "old_line_content": "",
          "new_line_content": "\tdlist_init(&txn->subtxns);",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": null,
          "new_api": "TeardownHistoricSnapshot",
          "old_text": null,
          "new_text": "TeardownHistoricSnapshot(false)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\tTeardownHistoricSnapshot(false);",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": null,
          "new_api": "SetupHistoricSnapshot",
          "old_text": null,
          "new_text": "SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash)",
          "old_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID:",
          "new_line_content": "\t\t\t\t\t\tSetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);",
          "content_same": false
        },
        {
          "line": 2483,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"tuplecid value in changequeue\")",
          "old_line_content": "\t\t\t * It is possible that the data is not sent to downstream for a",
          "new_line_content": "\t\t\t\t\telog(ERROR, \"tuplecid value in changequeue\");",
          "content_same": false
        },
        {
          "line": 4535,
          "old_api": null,
          "new_api": "ReorderBufferGetRelids",
          "old_text": null,
          "new_text": "ReorderBufferGetRelids(rb,\n\t\t\t\t\t\t\t\t\t\t\t\tchange->data.truncate.nrelids)",
          "old_line_content": "\t\t\t\tbreak;",
          "new_line_content": "\t\t\t\trelids = ReorderBufferGetRelids(rb,",
          "content_same": false
        },
        {
          "line": 4537,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(relids, data, change->data.truncate.nrelids * sizeof(Oid))",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:",
          "new_line_content": "\t\t\t\tmemcpy(relids, data, change->data.truncate.nrelids * sizeof(Oid));",
          "content_same": false
        },
        {
          "line": 2501,
          "old_api": null,
          "new_api": "update_progress_txn",
          "old_text": null,
          "new_text": "rb->update_progress_txn(rb, txn, change->lsn)",
          "old_line_content": "\t\t/* speculative insertion record must be freed by now */",
          "new_line_content": "\t\t\t\trb->update_progress_txn(rb, txn, change->lsn);",
          "content_same": false
        },
        {
          "line": 4549,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&txn->changes, &change->node)",
          "old_line_content": "\t * although we don't check the memory limit when restoring the changes in",
          "new_line_content": "\tdlist_push_tail(&txn->changes, &change->node);",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(txn->gid)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tpfree(txn->gid);",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!specinsert)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(!specinsert);",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": null,
          "new_api": "hash_destroy",
          "old_text": null,
          "new_text": "hash_destroy(txn->tuplecid_hash)",
          "old_line_content": "\t{",
          "new_line_content": "\t\thash_destroy(txn->tuplecid_hash);",
          "content_same": false
        },
        {
          "line": 2510,
          "old_api": null,
          "new_api": "ReorderBufferIterTXNFinish",
          "old_text": null,
          "new_text": "ReorderBufferIterTXNFinish(rb, iterstate)",
          "old_line_content": "\t\t * transaction and its subtransactions. Ensure to not count the",
          "new_line_content": "\t\tReorderBufferIterTXNFinish(rb, iterstate);",
          "content_same": false
        },
        {
          "line": 4560,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, true,\n\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "old_line_content": " * Remove all on-disk stored for the passed in transaction.",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, true,",
          "content_same": false
        },
        {
          "line": 4561,
          "old_api": null,
          "new_api": "ReorderBufferChangeSize",
          "old_text": null,
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": " */",
          "new_line_content": "\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "content_same": false
        },
        {
          "line": 2522,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tif (!rbtxn_is_streamed(txn))",
          "content_same": false
        },
        {
          "line": 476,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->size == 0)",
          "old_line_content": "/*",
          "new_line_content": "\tAssert(txn->size == 0);",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(txn)",
          "old_line_content": " */",
          "new_line_content": "\tpfree(txn);",
          "content_same": false
        },
        {
          "line": 4574,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "old_line_content": "",
          "new_line_content": "\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 4575,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "old_line_content": "\t/* iterate over all possible filenames, and delete them */",
          "new_line_content": "\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 4577,
          "old_api": null,
          "new_api": "XLByteToSeg",
          "old_text": null,
          "new_text": "XLByteToSeg(txn->first_lsn, first, wal_segment_size)",
          "old_line_content": "\t{",
          "new_line_content": "\tXLByteToSeg(txn->first_lsn, first, wal_segment_size);",
          "content_same": false
        },
        {
          "line": 4578,
          "old_api": null,
          "new_api": "XLByteToSeg",
          "old_text": null,
          "new_text": "XLByteToSeg(txn->final_lsn, last, wal_segment_size)",
          "old_line_content": "\t\tchar\t\tpath[MAXPGPATH];",
          "new_line_content": "\tXLByteToSeg(txn->final_lsn, last, wal_segment_size);",
          "content_same": false
        },
        {
          "line": 2535,
          "old_api": null,
          "new_api": "stream_stop",
          "old_text": null,
          "new_text": "rb->stream_stop(rb, txn, prev_lsn)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\t\trb->stream_stop(rb, txn, prev_lsn);",
          "content_same": false
        },
        {
          "line": 4585,
          "old_api": null,
          "new_api": "ReorderBufferSerializedPath",
          "old_text": null,
          "new_text": "ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid, cur)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid, cur);",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(rb->change_context, sizeof(ReorderBufferChange))",
          "old_line_content": "",
          "new_line_content": "\t\tMemoryContextAlloc(rb->change_context, sizeof(ReorderBufferChange));",
          "content_same": false
        },
        {
          "line": 4586,
          "old_api": null,
          "new_api": "unlink",
          "old_text": null,
          "new_text": "unlink(path)",
          "old_line_content": "}",
          "new_line_content": "\t\tif (unlink(path) != 0 && errno != ENOENT)",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(change, 0, sizeof(ReorderBufferChange))",
          "old_line_content": " * Free a ReorderBufferChange and update memory accounting, if requested.",
          "new_line_content": "\tmemset(change, 0, sizeof(ReorderBufferChange));",
          "content_same": false
        },
        {
          "line": 4587,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", path)))",
          "old_line_content": "",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4588,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 4589,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not remove file \\\"%s\\\": %m\", path)",
          "old_line_content": " * Remove any leftover serialized reorder buffers from a slot directory after a",
          "new_line_content": "\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", path)));",
          "content_same": false
        },
        {
          "line": 2545,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tif (rbtxn_prepared(txn))",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": null,
          "new_api": "prepare",
          "old_text": null,
          "new_text": "rb->prepare(rb, txn, commit_lsn)",
          "old_line_content": "\t\t/* this is just a sanity check against bad output plugin behaviour */",
          "new_line_content": "\t\t\t\trb->prepare(rb, txn, commit_lsn);",
          "content_same": false
        },
        {
          "line": 2552,
          "old_api": null,
          "new_api": "GetCurrentTransactionIdIfAny",
          "old_text": null,
          "new_text": "GetCurrentTransactionIdIfAny()",
          "old_line_content": "\t\t * Remember the command ID and snapshot for the next set of changes in",
          "new_line_content": "\t\tif (GetCurrentTransactionIdIfAny() != InvalidTransactionId)",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"output plugin used XID %u\",\n\t\t\t\t GetCurrentTransactionId())",
          "old_line_content": "\t\t * streaming mode.",
          "new_line_content": "\t\t\telog(ERROR, \"output plugin used XID %u\",",
          "content_same": false
        },
        {
          "line": 2554,
          "old_api": null,
          "new_api": "GetCurrentTransactionId",
          "old_text": null,
          "new_text": "GetCurrentTransactionId()",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\t\t\t GetCurrentTransactionId());",
          "content_same": false
        },
        {
          "line": 505,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, false,\n\t\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "old_line_content": "\t{",
          "new_line_content": "\t\tReorderBufferChangeMemoryUpdate(rb, change, NULL, false,",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": null,
          "new_api": "ReorderBufferChangeSize",
          "old_text": null,
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INSERT:",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "content_same": false
        },
        {
          "line": 4605,
          "old_api": null,
          "new_api": "sprintf",
          "old_text": null,
          "new_text": "sprintf(path, \"%s/%s\", PG_REPLSLOT_DIR, slotname)",
          "old_line_content": "",
          "new_line_content": "\tsprintf(path, \"%s/%s\", PG_REPLSLOT_DIR, slotname);",
          "content_same": false
        },
        {
          "line": 4608,
          "old_api": null,
          "new_api": "S_ISDIR",
          "old_text": null,
          "new_text": "S_ISDIR(statbuf.st_mode)",
          "old_line_content": "\t{",
          "new_line_content": "\tif (lstat(path, &statbuf) == 0 && !S_ISDIR(statbuf.st_mode))",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "ReorderBufferFreeSnap",
          "old_text": null,
          "new_text": "ReorderBufferFreeSnap(rb, snapshot_now)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tReorderBufferFreeSnap(rb, snapshot_now);",
          "content_same": false
        },
        {
          "line": 4611,
          "old_api": null,
          "new_api": "AllocateDir",
          "old_text": null,
          "new_text": "AllocateDir(path)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tspill_dir = AllocateDir(path);",
          "content_same": false
        },
        {
          "line": 517,
          "old_api": null,
          "new_api": "ReorderBufferReturnTupleBuf",
          "old_text": null,
          "new_text": "ReorderBufferReturnTupleBuf(change->data.tp.newtuple)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tReorderBufferReturnTupleBuf(change->data.tp.newtuple);",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": null,
          "new_api": "TeardownHistoricSnapshot",
          "old_text": null,
          "new_text": "TeardownHistoricSnapshot(false)",
          "old_line_content": "\t\t * reassigned to the parent and we do not want any database access",
          "new_line_content": "\t\tTeardownHistoricSnapshot(false);",
          "content_same": false
        },
        {
          "line": 4615,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(spill_de->d_name, \"xid\", 3)",
          "old_line_content": "",
          "new_line_content": "\t\tif (strncmp(spill_de->d_name, \"xid\", 3) == 0)",
          "content_same": false
        },
        {
          "line": 523,
          "old_api": null,
          "new_api": "ReorderBufferReturnTupleBuf",
          "old_text": null,
          "new_text": "ReorderBufferReturnTupleBuf(change->data.tp.oldtuple)",
          "old_line_content": "\t\t\tif (change->data.msg.prefix != NULL)",
          "new_line_content": "\t\t\t\tReorderBufferReturnTupleBuf(change->data.tp.oldtuple);",
          "content_same": false
        },
        {
          "line": 4621,
          "old_api": null,
          "new_api": "unlink",
          "old_text": null,
          "new_text": "unlink(path)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tif (unlink(path) != 0)",
          "content_same": false
        },
        {
          "line": 2574,
          "old_api": null,
          "new_api": "AbortCurrentTransaction",
          "old_text": null,
          "new_text": "AbortCurrentTransaction()",
          "old_line_content": "\t\tif (using_subtxn)",
          "new_line_content": "\t\tAbortCurrentTransaction();",
          "content_same": false
        },
        {
          "line": 4622,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\" during removal of %s/%s/xid*: %m\",\n\t\t\t\t\t\t\t\tpath, PG_REPLSLOT_DIR, slotname)))",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 4624,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not remove file \\\"%s\\\" during removal of %s/%s/xid*: %m\",\n\t\t\t\t\t\t\t\tpath, PG_REPLSLOT_DIR, slotname)",
          "old_line_content": "}",
          "new_line_content": "\t\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\" during removal of %s/%s/xid*: %m\",",
          "content_same": false
        },
        {
          "line": 529,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(change->data.msg.prefix)",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\t\tpfree(change->data.msg.prefix);",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": null,
          "new_api": "ReorderBufferExecuteInvalidations",
          "old_text": null,
          "new_text": "ReorderBufferExecuteInvalidations(txn->ninvalidations, txn->invalidations)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tReorderBufferExecuteInvalidations(txn->ninvalidations, txn->invalidations);",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": null,
          "new_api": "RollbackAndReleaseCurrentSubTransaction",
          "old_text": null,
          "new_text": "RollbackAndReleaseCurrentSubTransaction()",
          "old_line_content": "\t\t * prepared txn that was (partially) streamed. 4. Decoding a committed",
          "new_line_content": "\t\t\tRollbackAndReleaseCurrentSubTransaction();",
          "content_same": false
        },
        {
          "line": 4628,
          "old_api": null,
          "new_api": "FreeDir",
          "old_text": null,
          "new_text": "FreeDir(spill_dir)",
          "old_line_content": " * corresponding spill file into 'path', which is a caller-owned buffer of size",
          "new_line_content": "\tFreeDir(spill_dir);",
          "content_same": false
        },
        {
          "line": 537,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(change->data.inval.invalidations)",
          "old_line_content": "\t\t\t{",
          "new_line_content": "\t\t\t\tpfree(change->data.inval.invalidations);",
          "content_same": false
        },
        {
          "line": 543,
          "old_api": null,
          "new_api": "ReorderBufferFreeSnap",
          "old_text": null,
          "new_text": "ReorderBufferFreeSnap(rb, change->data.snapshot)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_TRUNCATE:",
          "new_line_content": "\t\t\t\tReorderBufferFreeSnap(rb, change->data.snapshot);",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tif (streaming || rbtxn_prepared(txn))",
          "content_same": false
        },
        {
          "line": 4644,
          "old_api": null,
          "new_api": "snprintf",
          "old_text": null,
          "new_text": "snprintf(path, MAXPGPATH, \"%s/%s/xid-%u-lsn-%X-%X.spill\",\n\t\t\t PG_REPLSLOT_DIR,\n\t\t\t NameStr(MyReplicationSlot->data.name),\n\t\t\t xid, LSN_FORMAT_ARGS(recptr))",
          "old_line_content": "",
          "new_line_content": "\tsnprintf(path, MAXPGPATH, \"%s/%s/xid-%u-lsn-%X-%X.spill\",",
          "content_same": false
        },
        {
          "line": 4646,
          "old_api": null,
          "new_api": "NameStr",
          "old_text": null,
          "new_text": "NameStr(MyReplicationSlot->data.name)",
          "old_line_content": " * Delete all data spilled to disk after we've restarted/crashed. It will be",
          "new_line_content": "\t\t\t NameStr(MyReplicationSlot->data.name),",
          "content_same": false
        },
        {
          "line": 551,
          "old_api": null,
          "new_api": "ReorderBufferReturnRelids",
          "old_text": null,
          "new_text": "ReorderBufferReturnRelids(rb, change->data.truncate.relids)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:",
          "new_line_content": "\t\t\t\tReorderBufferReturnRelids(rb, change->data.truncate.relids);",
          "content_same": false
        },
        {
          "line": 4647,
          "old_api": null,
          "new_api": "LSN_FORMAT_ARGS",
          "old_text": null,
          "new_text": "LSN_FORMAT_ARGS(recptr)",
          "old_line_content": " * recreated when the respective slots are reused.",
          "new_line_content": "\t\t\t xid, LSN_FORMAT_ARGS(recptr));",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": null,
          "new_api": "PG_CATCH",
          "old_text": null,
          "new_text": "PG_CATCH()",
          "old_line_content": "\t\t/* TODO: Encapsulate cleanup from the PG_TRY and PG_CATCH blocks */",
          "new_line_content": "\tPG_CATCH();",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": null,
          "new_api": "CopyErrorData",
          "old_text": null,
          "new_text": "CopyErrorData()",
          "old_line_content": "",
          "new_line_content": "\t\tErrorData  *errdata = CopyErrorData();",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(change)",
          "old_line_content": " * overhead).",
          "new_line_content": "\tpfree(change);",
          "content_same": false
        },
        {
          "line": 2612,
          "old_api": null,
          "new_api": "ReorderBufferIterTXNFinish",
          "old_text": null,
          "new_text": "ReorderBufferIterTXNFinish(rb, iterstate)",
          "old_line_content": "\t\t * Force cache invalidation to happen outside of a valid transaction",
          "new_line_content": "\t\t\tReorderBufferIterTXNFinish(rb, iterstate);",
          "content_same": false
        },
        {
          "line": 4660,
          "old_api": null,
          "new_api": "AllocateDir",
          "old_text": null,
          "new_text": "AllocateDir(PG_REPLSLOT_DIR)",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\tlogical_dir = AllocateDir(PG_REPLSLOT_DIR);",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": null,
          "new_api": "TeardownHistoricSnapshot",
          "old_text": null,
          "new_text": "TeardownHistoricSnapshot(true)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tTeardownHistoricSnapshot(true);",
          "content_same": false
        },
        {
          "line": 4661,
          "old_api": null,
          "new_api": "ReadDir",
          "old_text": null,
          "new_text": "ReadDir(logical_dir, PG_REPLSLOT_DIR)",
          "old_line_content": "",
          "new_line_content": "\twhile ((logical_de = ReadDir(logical_dir, PG_REPLSLOT_DIR)) != NULL)",
          "content_same": false
        },
        {
          "line": 4664,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(logical_de->d_name, \"..\")",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\t\t\tstrcmp(logical_de->d_name, \"..\") == 0)",
          "content_same": false
        },
        {
          "line": 2620,
          "old_api": null,
          "new_api": "AbortCurrentTransaction",
          "old_text": null,
          "new_text": "AbortCurrentTransaction()",
          "old_line_content": "",
          "new_line_content": "\t\tAbortCurrentTransaction();",
          "content_same": false
        },
        {
          "line": 4668,
          "old_api": null,
          "new_api": "ReplicationSlotValidateName",
          "old_text": null,
          "new_text": "ReplicationSlotValidateName(logical_de->d_name, DEBUG2)",
          "old_line_content": "\t\t * everything starting with xid-*",
          "new_line_content": "\t\tif (!ReplicationSlotValidateName(logical_de->d_name, DEBUG2))",
          "content_same": false
        },
        {
          "line": 2623,
          "old_api": null,
          "new_api": "ReorderBufferExecuteInvalidations",
          "old_text": null,
          "new_text": "ReorderBufferExecuteInvalidations(txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t  txn->invalidations)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferExecuteInvalidations(txn->ninvalidations,",
          "content_same": false
        },
        {
          "line": 577,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(rb->tup_context,\n\t\t\t\t\t\t\t\t\t\t   HEAPTUPLESIZE + alloc_len)",
          "old_line_content": "}",
          "new_line_content": "\ttuple = (HeapTuple) MemoryContextAlloc(rb->tup_context,",
          "content_same": false
        },
        {
          "line": 579,
          "old_api": null,
          "new_api": "HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE)",
          "old_text": null,
          "new_text": "HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE)",
          "old_line_content": "/*",
          "new_line_content": "\ttuple->t_data = (HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE);",
          "content_same": false
        },
        {
          "line": 2627,
          "old_api": null,
          "new_api": "RollbackAndReleaseCurrentSubTransaction",
          "old_text": null,
          "new_text": "RollbackAndReleaseCurrentSubTransaction()",
          "old_line_content": "\t\t * need to do the cleanup and return gracefully on this error, see",
          "new_line_content": "\t\t\tRollbackAndReleaseCurrentSubTransaction();",
          "content_same": false
        },
        {
          "line": 4675,
          "old_api": null,
          "new_api": "ReorderBufferCleanupSerializedTXNs",
          "old_text": null,
          "new_text": "ReorderBufferCleanupSerializedTXNs(logical_de->d_name)",
          "old_line_content": "/* ---------------------------------------",
          "new_line_content": "\t\tReorderBufferCleanupSerializedTXNs(logical_de->d_name);",
          "content_same": false
        },
        {
          "line": 4677,
          "old_api": null,
          "new_api": "FreeDir",
          "old_text": null,
          "new_text": "FreeDir(logical_dir)",
          "old_line_content": " * ---------------------------------------",
          "new_line_content": "\tFreeDir(logical_dir);",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(tuple)",
          "old_line_content": " *",
          "new_line_content": "\tpfree(tuple);",
          "content_same": false
        },
        {
          "line": 2642,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "\t\t\t/* Cleanup the temporary error state. */",
          "new_line_content": "\t\t\t(stream_started || rbtxn_prepared(txn)))",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(curtxn)",
          "old_line_content": "\t\t\terrdata = NULL;",
          "new_line_content": "\t\t\tAssert(curtxn);",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": null,
          "new_api": "FlushErrorState",
          "old_text": null,
          "new_text": "FlushErrorState()",
          "old_line_content": "\t\t\t/* Reset the TXN so that it is allowed to stream remaining data. */",
          "new_line_content": "\t\t\tFlushErrorState();",
          "content_same": false
        },
        {
          "line": 4698,
          "old_api": null,
          "new_api": "hash_create",
          "old_text": null,
          "new_text": "hash_create(\"ReorderBufferToastHash\", 5, &hash_ctl,\n\t\t\t\t\t\t\t\t  HASH_ELEM | HASH_BLOBS | HASH_CONTEXT)",
          "old_line_content": " * Per toast-chunk handling for toast reconstruction",
          "new_line_content": "\ttxn->toast_hash = hash_create(\"ReorderBufferToastHash\", 5, &hash_ctl,",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": null,
          "new_api": "ReorderBufferResetTXN",
          "old_text": null,
          "new_text": "ReorderBufferResetTXN(rb, txn, snapshot_now,\n\t\t\t\t\t\t\t\t  command_id, prev_lsn,\n\t\t\t\t\t\t\t\t  specinsert)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tReorderBufferResetTXN(rb, txn, snapshot_now,",
          "content_same": false
        },
        {
          "line": 610,
          "old_api": null,
          "new_api": "MemoryContextAlloc",
          "old_text": null,
          "new_text": "MemoryContextAlloc(rb->context, alloc_len)",
          "old_line_content": "/*",
          "new_line_content": "\trelids = (Oid *) MemoryContextAlloc(rb->context, alloc_len);",
          "content_same": false
        },
        {
          "line": 2661,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(ecxt)",
          "old_line_content": "}",
          "new_line_content": "\t\t\tMemoryContextSwitchTo(ecxt);",
          "content_same": false
        },
        {
          "line": 2662,
          "old_api": null,
          "new_api": "PG_RE_THROW",
          "old_text": null,
          "new_text": "PG_RE_THROW()",
          "old_line_content": "",
          "new_line_content": "\t\t\tPG_RE_THROW();",
          "content_same": false
        },
        {
          "line": 2665,
          "old_api": null,
          "new_api": "PG_END_TRY",
          "old_text": null,
          "new_text": "PG_END_TRY()",
          "old_line_content": " *",
          "new_line_content": "\tPG_END_TRY();",
          "content_same": false
        },
        {
          "line": 621,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(relids)",
          "old_line_content": " * If create is true, and a transaction doesn't already exist, create it",
          "new_line_content": "\tpfree(relids);",
          "content_same": false
        },
        {
          "line": 4728,
          "old_api": null,
          "new_api": "fastgetattr",
          "old_text": null,
          "new_text": "fastgetattr(newtup, 1, desc, &isnull)",
          "old_line_content": "\tent = (ReorderBufferToastEnt *)",
          "new_line_content": "\tchunk_id = DatumGetObjectId(fastgetattr(newtup, 1, desc, &isnull));",
          "content_same": false
        },
        {
          "line": 4730,
          "old_api": null,
          "new_api": "fastgetattr",
          "old_text": null,
          "new_text": "fastgetattr(newtup, 2, desc, &isnull)",
          "old_line_content": "",
          "new_line_content": "\tchunk_seq = DatumGetInt32(fastgetattr(newtup, 2, desc, &isnull));",
          "content_same": false
        },
        {
          "line": 4731,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!isnull)",
          "old_line_content": "\tif (!found)",
          "new_line_content": "\tAssert(!isnull);",
          "content_same": false
        },
        {
          "line": 4734,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(txn->toast_hash, &chunk_id, HASH_ENTER, &found)",
          "old_line_content": "\t\tent->num_chunks = 0;",
          "new_line_content": "\t\thash_search(txn->toast_hash, &chunk_id, HASH_ENTER, &found);",
          "content_same": false
        },
        {
          "line": 643,
          "old_api": null,
          "new_api": "TransactionIdIsValid",
          "old_text": null,
          "new_text": "TransactionIdIsValid(rb->by_txn_last_xid)",
          "old_line_content": "\t\tif (txn != NULL)",
          "new_line_content": "\tif (TransactionIdIsValid(rb->by_txn_last_xid) &&",
          "content_same": false
        },
        {
          "line": 4743,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&ent->chunks)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tdlist_init(&ent->chunks);",
          "content_same": false
        },
        {
          "line": 4746,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq 0\",\n\t\t\t\t chunk_seq, chunk_id)",
          "old_line_content": "\t\t\t chunk_seq, chunk_id, ent->last_chunk_seq + 1);",
          "new_line_content": "\t\t\telog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq 0\",",
          "content_same": false
        },
        {
          "line": 2702,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "",
          "new_line_content": "\tif (rbtxn_is_streamed(txn))",
          "content_same": false
        },
        {
          "line": 4750,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq %d\",\n\t\t\t chunk_seq, chunk_id, ent->last_chunk_seq + 1)",
          "old_line_content": "",
          "new_line_content": "\t\telog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq %d\",",
          "content_same": false
        },
        {
          "line": 2704,
          "old_api": null,
          "new_api": "ReorderBufferStreamCommit",
          "old_text": null,
          "new_text": "ReorderBufferStreamCommit(rb, txn)",
          "old_line_content": "\t * If this transaction has no snapshot, it didn't make any changes to the",
          "new_line_content": "\t\tReorderBufferStreamCommit(rb, txn);",
          "content_same": false
        },
        {
          "line": 4757,
          "old_api": null,
          "new_api": "VARATT_IS_EXTENDED",
          "old_text": null,
          "new_text": "VARATT_IS_EXTENDED(chunk)",
          "old_line_content": "\telse",
          "new_line_content": "\tif (!VARATT_IS_EXTENDED(chunk))",
          "content_same": false
        },
        {
          "line": 4759,
          "old_api": null,
          "new_api": "VARATT_IS_SHORT",
          "old_text": null,
          "new_text": "VARATT_IS_SHORT(chunk)",
          "old_line_content": "",
          "new_line_content": "\telse if (VARATT_IS_SHORT(chunk))",
          "content_same": false
        },
        {
          "line": 4761,
          "old_api": null,
          "new_api": "VARSIZE_SHORT",
          "old_text": null,
          "new_text": "VARSIZE_SHORT(chunk)",
          "old_line_content": "\tent->last_chunk_seq = chunk_seq;",
          "new_line_content": "\t\tchunksize = VARSIZE_SHORT(chunk) - VARHDRSZ_SHORT;",
          "content_same": false
        },
        {
          "line": 2716,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->ninvalidations == 0)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tAssert(txn->ninvalidations == 0);",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(rb->by_txn,\n\t\t\t\t\t&xid,\n\t\t\t\t\tcreate ? HASH_ENTER : HASH_FIND,\n\t\t\t\t\t&found)",
          "old_line_content": "\t\ttxn = ent->txn;",
          "new_line_content": "\t\thash_search(rb->by_txn,",
          "content_same": false
        },
        {
          "line": 4768,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&ent->chunks, &change->node)",
          "old_line_content": " * on-disk toast tuples that may no longer exist (think DROP TABLE or VACUUM).",
          "new_line_content": "\tdlist_push_tail(&ent->chunks, &change->node);",
          "content_same": false
        },
        {
          "line": 2722,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "\tsnapshot_now = txn->base_snapshot;",
          "new_line_content": "\t\tif (!rbtxn_prepared(txn))",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 681,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(ent != NULL)",
          "old_line_content": "\t\ttxn = ent->txn;",
          "new_line_content": "\t\tAssert(ent != NULL);",
          "content_same": false
        },
        {
          "line": 682,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(lsn != InvalidXLogRecPtr)",
          "old_line_content": "\t\ttxn->first_lsn = lsn;",
          "new_line_content": "\t\tAssert(lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": null,
          "new_api": "ReorderBufferProcessTXN",
          "old_text": null,
          "new_text": "ReorderBufferProcessTXN(rb, txn, commit_lsn, snapshot_now,\n\t\t\t\t\t\t\tcommand_id, false)",
          "old_line_content": " * Commit a transaction.",
          "new_line_content": "\tReorderBufferProcessTXN(rb, txn, commit_lsn, snapshot_now,",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": null,
          "new_api": "ReorderBufferGetTXN",
          "old_text": null,
          "new_text": "ReorderBufferGetTXN(rb)",
          "old_line_content": "",
          "new_line_content": "\t\tent->txn = ReorderBufferGetTXN(rb);",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&rb->toplevel_by_lsn, &txn->node)",
          "old_line_content": "\t\ttxn = NULL;\t\t\t\t/* not found and not asked to create */",
          "new_line_content": "\t\t\tdlist_push_tail(&rb->toplevel_by_lsn, &txn->node);",
          "content_same": false
        },
        {
          "line": 693,
          "old_api": null,
          "new_api": "AssertTXNLsnOrder",
          "old_text": null,
          "new_text": "AssertTXNLsnOrder(rb)",
          "old_line_content": "",
          "new_line_content": "\t\t\tAssertTXNLsnOrder(rb);",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!create || txn != NULL)",
          "old_line_content": " * Record the partial change for the streaming of in-progress transactions.  We",
          "new_line_content": "\tAssert(!create || txn != NULL);",
          "content_same": false
        },
        {
          "line": 2754,
          "old_api": null,
          "new_api": "ReorderBufferReplay",
          "old_text": null,
          "new_text": "ReorderBufferReplay(txn, rb, xid, commit_lsn, end_lsn, commit_time,\n\t\t\t\t\t\torigin_id, origin_lsn)",
          "old_line_content": " * Record the prepare information for a transaction.",
          "new_line_content": "\tReorderBufferReplay(txn, rb, xid, commit_lsn, end_lsn, commit_time,",
          "content_same": false
        },
        {
          "line": 2769,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false)",
          "old_line_content": "",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": null,
          "new_api": "ReorderBufferCanStream",
          "old_text": null,
          "new_text": "ReorderBufferCanStream(rb)",
          "old_line_content": "",
          "new_line_content": "\tif (!ReorderBufferCanStream(rb))",
          "content_same": false
        },
        {
          "line": 733,
          "old_api": null,
          "new_api": "rbtxn_get_toptxn",
          "old_text": null,
          "new_text": "rbtxn_get_toptxn(txn)",
          "old_line_content": "\t * table and we are sure that the pending toast chunks are not required",
          "new_line_content": "\ttoptxn = rbtxn_get_toptxn(txn);",
          "content_same": false
        },
        {
          "line": 4831,
          "old_api": null,
          "new_api": "RelationIsValid",
          "old_text": null,
          "new_text": "RelationIsValid(toast_rel)",
          "old_line_content": "",
          "new_line_content": "\tif (!RelationIsValid(toast_rel))",
          "content_same": false
        },
        {
          "line": 4832,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"could not open toast relation with OID %u (base relation \\\"%s\\\")\",\n\t\t\t relation->rd_rel->reltoastrelid, RelationGetRelationName(relation))",
          "old_line_content": "\t/* should we allocate from stack instead? */",
          "new_line_content": "\t\telog(ERROR, \"could not open toast relation with OID %u (base relation \\\"%s\\\")\",",
          "content_same": false
        },
        {
          "line": 4838,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(sizeof(Datum) * desc->natts)",
          "old_line_content": "",
          "new_line_content": "\tattrs = palloc0(sizeof(Datum) * desc->natts);",
          "content_same": false
        },
        {
          "line": 4840,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(sizeof(bool) * desc->natts)",
          "old_line_content": "",
          "new_line_content": "\tfree = palloc0(sizeof(bool) * desc->natts);",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false)",
          "old_line_content": "",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);",
          "content_same": false
        },
        {
          "line": 4844,
          "old_api": null,
          "new_api": "heap_deform_tuple",
          "old_text": null,
          "new_text": "heap_deform_tuple(newtup, desc, attrs, isnull)",
          "old_line_content": "\t\tReorderBufferToastEnt *ent;",
          "new_line_content": "\theap_deform_tuple(newtup, desc, attrs, isnull);",
          "content_same": false
        },
        {
          "line": 751,
          "old_api": null,
          "new_api": "rbtxn_has_partial_change",
          "old_text": null,
          "new_text": "rbtxn_has_partial_change(toptxn)",
          "old_line_content": "\t/*",
          "new_line_content": "\telse if (rbtxn_has_partial_change(toptxn) &&",
          "content_same": false
        },
        {
          "line": 752,
          "old_api": null,
          "new_api": "IsInsertOrUpdate",
          "old_text": null,
          "new_text": "IsInsertOrUpdate(change->action)",
          "old_line_content": "\t * Indicate a partial change for speculative inserts.  The change will be",
          "new_line_content": "\t\t\t IsInsertOrUpdate(change->action) &&",
          "content_same": false
        },
        {
          "line": 4848,
          "old_api": null,
          "new_api": "TupleDescAttr",
          "old_text": null,
          "new_text": "TupleDescAttr(desc, natt)",
          "old_line_content": "\t\tstruct varatt_external toast_pointer;",
          "new_line_content": "\t\tForm_pg_attribute attr = TupleDescAttr(desc, natt);",
          "content_same": false
        },
        {
          "line": 761,
          "old_api": null,
          "new_api": "IsSpecInsert",
          "old_text": null,
          "new_text": "IsSpecInsert(change->action)",
          "old_line_content": "",
          "new_line_content": "\tif (IsSpecInsert(change->action))",
          "content_same": false
        },
        {
          "line": 763,
          "old_api": null,
          "new_api": "rbtxn_has_partial_change",
          "old_text": null,
          "new_text": "rbtxn_has_partial_change(toptxn)",
          "old_line_content": "\t * Stream the transaction if it is serialized before and the changes are",
          "new_line_content": "\telse if (rbtxn_has_partial_change(toptxn) &&",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": "IsSpecConfirmOrAbort",
          "old_text": null,
          "new_text": "IsSpecConfirmOrAbort(change->action)",
          "old_line_content": "\t * now complete in the top-level transaction.",
          "new_line_content": "\t\t\t IsSpecConfirmOrAbort(change->action))",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": null,
          "new_api": "ReorderBufferCanStartStreaming",
          "old_text": null,
          "new_text": "ReorderBufferCanStartStreaming(rb)",
          "old_line_content": "}",
          "new_line_content": "\tif (ReorderBufferCanStartStreaming(rb) &&",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "rbtxn_has_partial_change",
          "old_text": null,
          "new_text": "rbtxn_has_partial_change(toptxn)",
          "old_line_content": "",
          "new_line_content": "\t\t!(rbtxn_has_partial_change(toptxn)) &&",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "rbtxn_is_serialized",
          "old_text": null,
          "new_text": "rbtxn_is_serialized(txn)",
          "old_line_content": "/*",
          "new_line_content": "\t\trbtxn_is_serialized(txn) &&",
          "content_same": false
        },
        {
          "line": 779,
          "old_api": null,
          "new_api": "rbtxn_has_streamable_change",
          "old_text": null,
          "new_text": "rbtxn_has_streamable_change(toptxn)",
          "old_line_content": " * Queue a change into a transaction so it can be replayed upon commit or will be",
          "new_line_content": "\t\trbtxn_has_streamable_change(toptxn))",
          "content_same": false
        },
        {
          "line": 780,
          "old_api": null,
          "new_api": "ReorderBufferStreamTXN",
          "old_text": null,
          "new_text": "ReorderBufferStreamTXN(rb, toptxn)",
          "old_line_content": " * streamed when we reach logical_decoding_work_mem threshold.",
          "new_line_content": "\t\tReorderBufferStreamTXN(rb, toptxn);",
          "content_same": false
        },
        {
          "line": 2825,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 2827,
          "old_api": null,
          "new_api": "ReorderBufferReplay",
          "old_text": null,
          "new_text": "ReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,\n\t\t\t\t\t\ttxn->xact_time.prepare_time, txn->origin_id, txn->origin_lsn)",
          "old_line_content": "\t * when rollback prepared is decoded and sent, the downstream should be",
          "new_line_content": "\tReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,",
          "content_same": false
        },
        {
          "line": 4876,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(attrs[natt])",
          "old_line_content": "",
          "new_line_content": "\t\tvarlena = (struct varlena *) DatumGetPointer(attrs[natt]);",
          "content_same": false
        },
        {
          "line": 4879,
          "old_api": null,
          "new_api": "VARATT_IS_EXTERNAL",
          "old_text": null,
          "new_text": "VARATT_IS_EXTERNAL(varlena)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tif (!VARATT_IS_EXTERNAL(varlena))",
          "content_same": false
        },
        {
          "line": 4882,
          "old_api": null,
          "new_api": "VARATT_EXTERNAL_GET_POINTER",
          "old_text": null,
          "new_text": "VARATT_EXTERNAL_GET_POINTER(toast_pointer, varlena)",
          "old_line_content": "\t\tent = (ReorderBufferToastEnt *)",
          "new_line_content": "\t\tVARATT_EXTERNAL_GET_POINTER(toast_pointer, varlena);",
          "content_same": false
        },
        {
          "line": 2838,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": " * This is used to handle COMMIT/ROLLBACK PREPARED.",
          "new_line_content": "\tif (txn->concurrent_abort && !rbtxn_is_streamed(txn))",
          "content_same": false
        },
        {
          "line": 2839,
          "old_api": null,
          "new_api": "prepare",
          "old_text": null,
          "new_text": "rb->prepare(rb, txn, txn->final_lsn)",
          "old_line_content": " */",
          "new_line_content": "\t\trb->prepare(rb, txn, txn->final_lsn);",
          "content_same": false
        },
        {
          "line": 4888,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(txn->toast_hash,\n\t\t\t\t\t\t&toast_pointer.va_valueid,\n\t\t\t\t\t\tHASH_FIND,\n\t\t\t\t\t\tNULL)",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\t\t\thash_search(txn->toast_hash,",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "old_line_content": "\t * changes for it.",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "content_same": false
        },
        {
          "line": 4896,
          "old_api": null,
          "new_api": "palloc0",
          "old_text": null,
          "new_text": "palloc0(INDIRECT_POINTER_SIZE)",
          "old_line_content": "",
          "new_line_content": "\t\t\t(struct varlena *) palloc0(INDIRECT_POINTER_SIZE);",
          "content_same": false
        },
        {
          "line": 806,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, false)",
          "old_line_content": "\t * The changes that are sent downstream are considered streamable.  We",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "content_same": false
        },
        {
          "line": 2856,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, commit_lsn, false)",
          "old_line_content": "",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, commit_lsn, false);",
          "content_same": false
        },
        {
          "line": 4905,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(it, &ent->chunks)",
          "old_line_content": "\t\t\tPointer\t\tchunk;",
          "new_line_content": "\t\tdlist_foreach(it, &ent->chunks)",
          "content_same": false
        },
        {
          "line": 4914,
          "old_api": null,
          "new_api": "fastgetattr",
          "old_text": null,
          "new_text": "fastgetattr(ctup, 3, toast_desc, &cisnull)",
          "old_line_content": "",
          "new_line_content": "\t\t\tchunk = DatumGetPointer(fastgetattr(ctup, 3, toast_desc, &cisnull));",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "rbtxn_get_toptxn",
          "old_text": null,
          "new_text": "rbtxn_get_toptxn(txn)",
          "old_line_content": "\tchange->lsn = lsn;",
          "new_line_content": "\t\tReorderBufferTXN *toptxn = rbtxn_get_toptxn(txn);",
          "content_same": false
        },
        {
          "line": 2870,
          "old_api": null,
          "new_api": "pstrdup",
          "old_text": null,
          "new_text": "pstrdup(gid)",
          "old_line_content": "\t * two_phase was not enabled, or it was decoded earlier but we have",
          "new_line_content": "\ttxn->gid = pstrdup(gid);",
          "content_same": false
        },
        {
          "line": 4921,
          "old_api": null,
          "new_api": "VARDATA",
          "old_text": null,
          "new_text": "VARDATA(chunk)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t   VARDATA(chunk),",
          "content_same": false
        },
        {
          "line": 4922,
          "old_api": null,
          "new_api": "VARSIZE",
          "old_text": null,
          "new_text": "VARSIZE(chunk)",
          "old_line_content": "\t\t/* make sure its marked as compressed or not */",
          "new_line_content": "\t\t\t\t   VARSIZE(chunk) - VARHDRSZ);",
          "content_same": false
        },
        {
          "line": 4925,
          "old_api": null,
          "new_api": "VARATT_EXTERNAL_GET_EXTSIZE",
          "old_text": null,
          "new_text": "VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\tAssert(data_done == VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer));",
          "content_same": false
        },
        {
          "line": 830,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(InvalidXLogRecPtr != lsn)",
          "old_line_content": "\t/* update memory accounting information */",
          "new_line_content": "\tAssert(InvalidXLogRecPtr != lsn);",
          "content_same": false
        },
        {
          "line": 4929,
          "old_api": null,
          "new_api": "SET_VARSIZE_COMPRESSED",
          "old_text": null,
          "new_text": "SET_VARSIZE_COMPRESSED(reconstructed, data_done + VARHDRSZ)",
          "old_line_content": "\t\tredirect_pointer.pointer = reconstructed;",
          "new_line_content": "\t\t\tSET_VARSIZE_COMPRESSED(reconstructed, data_done + VARHDRSZ);",
          "content_same": false
        },
        {
          "line": 836,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, true,\n\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "old_line_content": "",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, true,",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "ReorderBufferChangeSize",
          "old_text": null,
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": "\t/* check the memory limits and evict something if needed */",
          "new_line_content": "\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "content_same": false
        },
        {
          "line": 4933,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&redirect_pointer, 0, sizeof(redirect_pointer))",
          "old_line_content": "\t\t\t   sizeof(redirect_pointer));",
          "new_line_content": "\t\tmemset(&redirect_pointer, 0, sizeof(redirect_pointer));",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": null,
          "new_api": "ReorderBufferProcessPartialChange",
          "old_text": null,
          "new_text": "ReorderBufferProcessPartialChange(rb, txn, change, toast_insert)",
          "old_line_content": "",
          "new_line_content": "\tReorderBufferProcessPartialChange(rb, txn, change, toast_insert);",
          "content_same": false
        },
        {
          "line": 2888,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "old_line_content": "\t\t * information. If instead, we have passed commit information here",
          "new_line_content": "\t\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 4936,
          "old_api": null,
          "new_api": "SET_VARTAG_EXTERNAL",
          "old_text": null,
          "new_text": "SET_VARTAG_EXTERNAL(new_datum, VARTAG_INDIRECT)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tSET_VARTAG_EXTERNAL(new_datum, VARTAG_INDIRECT);",
          "content_same": false
        },
        {
          "line": 843,
          "old_api": null,
          "new_api": "ReorderBufferCheckMemoryLimit",
          "old_text": null,
          "new_text": "ReorderBufferCheckMemoryLimit(rb)",
          "old_line_content": " * non-transactional message gets processed immediately.",
          "new_line_content": "\tReorderBufferCheckMemoryLimit(rb);",
          "content_same": false
        },
        {
          "line": 4937,
          "old_api": null,
          "new_api": "VARDATA_EXTERNAL",
          "old_text": null,
          "new_text": "VARDATA_EXTERNAL(new_datum)",
          "old_line_content": "",
          "new_line_content": "\t\tmemcpy(VARDATA_EXTERNAL(new_datum), &redirect_pointer,",
          "content_same": false
        },
        {
          "line": 4940,
          "old_api": null,
          "new_api": "PointerGetDatum",
          "old_text": null,
          "new_text": "PointerGetDatum(new_datum)",
          "old_line_content": "\t * passed to the output plugin. We can't directly heap_fill_tuple() into",
          "new_line_content": "\t\tattrs[natt] = PointerGetDatum(new_datum);",
          "content_same": false
        },
        {
          "line": 2897,
          "old_api": null,
          "new_api": "ReorderBufferReplay",
          "old_text": null,
          "new_text": "ReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,\n\t\t\t\t\t\t\ttxn->xact_time.prepare_time, txn->origin_id, txn->origin_lsn)",
          "old_line_content": "\ttxn->end_lsn = end_lsn;",
          "new_line_content": "\t\tReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,",
          "content_same": false
        },
        {
          "line": 4948,
          "old_api": null,
          "new_api": "heap_form_tuple",
          "old_text": null,
          "new_text": "heap_form_tuple(desc, attrs, isnull)",
          "old_line_content": "\tnewtup->t_len = tmphtup->t_len;",
          "new_line_content": "\ttmphtup = heap_form_tuple(desc, attrs, isnull);",
          "content_same": false
        },
        {
          "line": 4949,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(newtup->t_len <= MaxHeapTupleSize)",
          "old_line_content": "",
          "new_line_content": "\tAssert(newtup->t_len <= MaxHeapTupleSize);",
          "content_same": false
        },
        {
          "line": 4950,
          "old_api": null,
          "new_api": "HeapTupleHeader) ((char *) newtup + HEAPTUPLESIZE)",
          "old_text": null,
          "new_text": "HeapTupleHeader) ((char *) newtup + HEAPTUPLESIZE)",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert(newtup->t_data == (HeapTupleHeader) ((char *) newtup + HEAPTUPLESIZE));",
          "content_same": false
        },
        {
          "line": 4952,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(newtup->t_data, tmphtup->t_data, tmphtup->t_len)",
          "old_line_content": "\t * free'd in ReorderBufferToastReset().",
          "new_line_content": "\tmemcpy(newtup->t_data, tmphtup->t_data, tmphtup->t_len);",
          "content_same": false
        },
        {
          "line": 861,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(xid != InvalidTransactionId)",
          "old_line_content": "\t\t * skipped).",
          "new_line_content": "\t\tAssert(xid != InvalidTransactionId);",
          "content_same": false
        },
        {
          "line": 4960,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(tmphtup)",
          "old_line_content": "\t}",
          "new_line_content": "\tpfree(tmphtup);",
          "content_same": false
        },
        {
          "line": 2913,
          "old_api": null,
          "new_api": "ReorderBufferExecuteInvalidations",
          "old_text": null,
          "new_text": "ReorderBufferExecuteInvalidations(txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t  txn->invalidations)",
          "old_line_content": "/*",
          "new_line_content": "\tReorderBufferExecuteInvalidations(txn->ninvalidations,",
          "content_same": false
        },
        {
          "line": 2915,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": " * called for subtransactions and then for the toplevel xid.",
          "new_line_content": "\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 868,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(!snap)",
          "old_line_content": "\t\tchange->action = REORDER_BUFFER_CHANGE_MESSAGE;",
          "new_line_content": "\t\tAssert(!snap);",
          "content_same": false
        },
        {
          "line": 4964,
          "old_api": null,
          "new_api": "DatumGetPointer",
          "old_text": null,
          "new_text": "DatumGetPointer(attrs[natt])",
          "old_line_content": "",
          "new_line_content": "\t\t\tpfree(DatumGetPointer(attrs[natt]));",
          "content_same": false
        },
        {
          "line": 870,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(rb->context)",
          "old_line_content": "\t\tchange->data.msg.message_size = message_size;",
          "new_line_content": "\t\toldcontext = MemoryContextSwitchTo(rb->context);",
          "content_same": false
        },
        {
          "line": 4966,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(attrs)",
          "old_line_content": "",
          "new_line_content": "\tpfree(attrs);",
          "content_same": false
        },
        {
          "line": 4967,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(free)",
          "old_line_content": "\t/* subtract the old change size */",
          "new_line_content": "\tpfree(free);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(change->data.msg.message, message, message_size)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tmemcpy(change->data.msg.message, message, message_size);",
          "content_same": false
        },
        {
          "line": 4973,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, false, old_size)",
          "old_line_content": "",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, false, old_size);",
          "content_same": false
        },
        {
          "line": 879,
          "old_api": null,
          "new_api": "ReorderBufferQueueChange",
          "old_text": null,
          "new_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "content_same": false
        },
        {
          "line": 4975,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, true,\n\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "old_line_content": " * Free all resources allocated for toast reconstruction.",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, true,",
          "content_same": false
        },
        {
          "line": 881,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(oldcontext)",
          "old_line_content": "\t\tvolatile Snapshot snapshot_now = snap;",
          "new_line_content": "\t\tMemoryContextSwitchTo(oldcontext);",
          "content_same": false
        },
        {
          "line": 4976,
          "old_api": null,
          "new_api": "ReorderBufferChangeSize",
          "old_text": null,
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": " */",
          "new_line_content": "\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "content_same": false
        },
        {
          "line": 2936,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "content_same": false
        },
        {
          "line": 889,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(snapshot_now)",
          "old_line_content": "\t\t/* setup snapshot to allow catalog access */",
          "new_line_content": "\t\tAssert(snapshot_now);",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "content_same": false
        },
        {
          "line": 896,
          "old_api": null,
          "new_api": "PG_TRY",
          "old_text": null,
          "new_text": "PG_TRY()",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\tPG_TRY();",
          "content_same": false
        },
        {
          "line": 4992,
          "old_api": null,
          "new_api": "hash_seq_init",
          "old_text": null,
          "new_text": "hash_seq_init(&hstat, txn->toast_hash)",
          "old_line_content": "\t\tif (ent->reconstructed != NULL)",
          "new_line_content": "\thash_seq_init(&hstat, txn->toast_hash);",
          "content_same": false
        },
        {
          "line": 898,
          "old_api": null,
          "new_api": "message",
          "old_text": null,
          "new_text": "rb->message(rb, txn, lsn, false, prefix, message_size, message)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\trb->message(rb, txn, lsn, false, prefix, message_size, message);",
          "content_same": false
        },
        {
          "line": 2946,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t\t * We might have decoded changes for this transaction that could load",
          "new_line_content": "\tif (rbtxn_is_streamed(txn))",
          "content_same": false
        },
        {
          "line": 2948,
          "old_api": null,
          "new_api": "stream_abort",
          "old_text": null,
          "new_text": "rb->stream_abort(rb, txn, lsn)",
          "old_line_content": "\t\t * happened in this transaction). We don't want the decoding of future",
          "new_line_content": "\t\trb->stream_abort(rb, txn, lsn);",
          "content_same": false
        },
        {
          "line": 904,
          "old_api": null,
          "new_api": "TeardownHistoricSnapshot",
          "old_text": null,
          "new_text": "TeardownHistoricSnapshot(true)",
          "old_line_content": "}",
          "new_line_content": "\t\t\tTeardownHistoricSnapshot(true);",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": null,
          "new_api": "PG_RE_THROW",
          "old_text": null,
          "new_text": "PG_RE_THROW()",
          "old_line_content": "",
          "new_line_content": "\t\t\tPG_RE_THROW();",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "PG_END_TRY",
          "old_text": null,
          "new_text": "PG_END_TRY()",
          "old_line_content": " * AssertTXNLsnOrder",
          "new_line_content": "\t\tPG_END_TRY();",
          "content_same": false
        },
        {
          "line": 5003,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, it.cur)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t\tdlist_container(ReorderBufferChange, node, it.cur);",
          "content_same": false
        },
        {
          "line": 2957,
          "old_api": null,
          "new_api": "ReorderBufferImmediateInvalidation",
          "old_text": null,
          "new_text": "ReorderBufferImmediateInvalidation(rb, txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t\t   txn->invalidations)",
          "old_line_content": "\ttxn->final_lsn = lsn;",
          "new_line_content": "\t\t\tReorderBufferImmediateInvalidation(rb, txn->ninvalidations,",
          "content_same": false
        },
        {
          "line": 5006,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, true)",
          "old_line_content": "\ttxn->toast_hash = NULL;",
          "new_line_content": "\t\t\tReorderBufferReturnChange(rb, change, true);",
          "content_same": false
        },
        {
          "line": 5010,
          "old_api": null,
          "new_api": "hash_destroy",
          "old_text": null,
          "new_text": "hash_destroy(txn->toast_hash)",
          "old_line_content": "/* ---------------------------------------",
          "new_line_content": "\thash_destroy(txn->toast_hash);",
          "content_same": false
        },
        {
          "line": 2965,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": " * server restarted.",
          "new_line_content": "\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 2987,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(it, &rb->toplevel_by_lsn)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(it, &rb->toplevel_by_lsn)",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(iter, &rb->toplevel_by_lsn)",
          "old_line_content": "\t\t/* start LSN must be set */",
          "new_line_content": "\tdlist_foreach(iter, &rb->toplevel_by_lsn)",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node,\n\t\t\t\t\t\t\t\t\t\t\t\t\titer.cur)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferTXN *cur_txn = dlist_container(ReorderBufferTXN, node,",
          "content_same": false
        },
        {
          "line": 2991,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, it.cur)",
          "old_line_content": "",
          "new_line_content": "\t\ttxn = dlist_container(ReorderBufferTXN, node, it.cur);",
          "content_same": false
        },
        {
          "line": 947,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur_txn->first_lsn != InvalidXLogRecPtr)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(cur_txn->first_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 2995,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG2, \"aborting old transaction %u\", txn->xid)",
          "old_line_content": "",
          "new_line_content": "\t\t\telog(DEBUG2, \"aborting old transaction %u\", txn->xid);",
          "content_same": false
        },
        {
          "line": 2998,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tif (rbtxn_is_streamed(txn))",
          "content_same": false
        },
        {
          "line": 951,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur_txn->first_lsn <= cur_txn->end_lsn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tAssert(cur_txn->first_lsn <= cur_txn->end_lsn);",
          "content_same": false
        },
        {
          "line": 2999,
          "old_api": null,
          "new_api": "stream_abort",
          "old_text": null,
          "new_text": "rb->stream_abort(rb, txn, InvalidXLogRecPtr)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\t\trb->stream_abort(rb, txn, InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 3002,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": "}",
          "new_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(prev_first_lsn < cur_txn->first_lsn)",
          "old_line_content": "\t\tprev_first_lsn = cur_txn->first_lsn;",
          "new_line_content": "\t\t\tAssert(prev_first_lsn < cur_txn->first_lsn);",
          "content_same": false
        },
        {
          "line": 963,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "content_same": false
        },
        {
          "line": 5059,
          "old_api": null,
          "new_api": "hash_seq_init",
          "old_text": null,
          "new_text": "hash_seq_init(&hstat, tuplecid_data)",
          "old_line_content": "\t\t\t ent->key.rlocator.spcOid,",
          "new_line_content": "\thash_seq_init(&hstat, tuplecid_data);",
          "content_same": false
        },
        {
          "line": 5060,
          "old_api": null,
          "new_api": "hash_seq_search",
          "old_text": null,
          "new_text": "hash_seq_search(&hstat)",
          "old_line_content": "\t\t\t ent->key.rlocator.relNumber,",
          "new_line_content": "\twhile ((ent = (ReorderBufferTupleCidEnt *) hash_seq_search(&hstat)) != NULL)",
          "content_same": false
        },
        {
          "line": 5066,
          "old_api": null,
          "new_api": "ItemPointerGetBlockNumber",
          "old_text": null,
          "new_text": "ItemPointerGetBlockNumber(&ent->key.tid)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\t ItemPointerGetBlockNumber(&ent->key.tid),",
          "content_same": false
        },
        {
          "line": 971,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur_txn->base_snapshot_lsn != InvalidXLogRecPtr)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(cur_txn->base_snapshot_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 5067,
          "old_api": null,
          "new_api": "ItemPointerGetOffsetNumber",
          "old_text": null,
          "new_text": "ItemPointerGetOffsetNumber(&ent->key.tid)",
          "old_line_content": "}",
          "new_line_content": "\t\t\t ItemPointerGetOffsetNumber(&ent->key.tid),",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(prev_base_snap_lsn < cur_txn->base_snapshot_lsn)",
          "old_line_content": "\t\tprev_base_snap_lsn = cur_txn->base_snapshot_lsn;",
          "new_line_content": "\t\t\tAssert(prev_base_snap_lsn < cur_txn->base_snapshot_lsn);",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(cur_txn)",
          "old_line_content": "}",
          "new_line_content": "\t\tAssert(!rbtxn_is_known_subxact(cur_txn));",
          "content_same": false
        },
        {
          "line": 3027,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "content_same": false
        },
        {
          "line": 3035,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t/*",
          "new_line_content": "\tAssert(!rbtxn_is_streamed(txn));",
          "content_same": false
        },
        {
          "line": 5090,
          "old_api": null,
          "new_api": "OpenTransientFile",
          "old_text": null,
          "new_text": "OpenTransientFile(path, O_RDONLY | PG_BINARY)",
          "old_line_content": "",
          "new_line_content": "\tfd = OpenTransientFile(path, O_RDONLY | PG_BINARY);",
          "content_same": false
        },
        {
          "line": 5092,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)))",
          "old_line_content": "\t{",
          "new_line_content": "\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(iter, &txn->changes)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach(iter, &txn->changes)",
          "content_same": false
        },
        {
          "line": 3046,
          "old_api": null,
          "new_api": "ReorderBufferImmediateInvalidation",
          "old_text": null,
          "new_text": "ReorderBufferImmediateInvalidation(rb, txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t   txn->invalidations)",
          "old_line_content": "\t/* remove potential on-disk data, and deallocate */",
          "new_line_content": "\t\tReorderBufferImmediateInvalidation(rb, txn->ninvalidations,",
          "content_same": false
        },
        {
          "line": 5093,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\tReorderBufferTupleCidKey key;",
          "new_line_content": "\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 5094,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not open file \\\"%s\\\": %m\", path)",
          "old_line_content": "\t\tReorderBufferTupleCidEnt *ent;",
          "new_line_content": "\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)));",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "old_line_content": "",
          "new_line_content": "\t\tcur_change = dlist_container(ReorderBufferChange, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 3049,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->ninvalidations == 0)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(txn->ninvalidations == 0);",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur_change->lsn != InvalidXLogRecPtr)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(cur_change->lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 3052,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": " * catalogs were manipulated as part of the transaction.",
          "new_line_content": "\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(cur_change->lsn <= txn->end_lsn)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tAssert(cur_change->lsn <= txn->end_lsn);",
          "content_same": false
        },
        {
          "line": 1010,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(prev_lsn <= cur_change->lsn)",
          "old_line_content": "}",
          "new_line_content": "\t\tAssert(prev_lsn <= cur_change->lsn);",
          "content_same": false
        },
        {
          "line": 5112,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tpath)))",
          "old_line_content": "\t\t\tbreak;",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 5113,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\telse if (readBytes != sizeof(LogicalRewriteMappingData))",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 3068,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "old_line_content": "\t\treturn;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "content_same": false
        },
        {
          "line": 5119,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": read %d instead of %d bytes\",\n\t\t\t\t\t\t\tpath, readBytes,\n\t\t\t\t\t\t\t(int32) sizeof(LogicalRewriteMappingData))))",
          "old_line_content": "",
          "new_line_content": "\t\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 5120,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "\t\tkey.rlocator = map.old_locator;",
          "new_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": null,
          "new_api": "dlist_head_element",
          "old_text": null,
          "new_text": "dlist_head_element(ReorderBufferTXN, node, &rb->toplevel_by_lsn)",
          "old_line_content": "}",
          "new_line_content": "\ttxn = dlist_head_element(ReorderBufferTXN, node, &rb->toplevel_by_lsn);",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(txn)",
          "old_line_content": "/*",
          "new_line_content": "\tAssert(!rbtxn_is_known_subxact(txn));",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "old_line_content": " * ReorderBufferGetOldestXmin",
          "new_line_content": "\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 3081,
          "old_api": null,
          "new_api": "ReorderBufferImmediateInvalidation",
          "old_text": null,
          "new_text": "ReorderBufferImmediateInvalidation(rb, txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t   txn->invalidations)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferImmediateInvalidation(rb, txn->ninvalidations,",
          "content_same": false
        },
        {
          "line": 3084,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->ninvalidations == 0)",
          "old_line_content": " * Execute invalidations happening outside the context of a decoded",
          "new_line_content": "\t\tAssert(txn->ninvalidations == 0);",
          "content_same": false
        },
        {
          "line": 5131,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(tuplecid_data, &key, HASH_FIND, NULL)",
          "old_line_content": "",
          "new_line_content": "\t\t\thash_search(tuplecid_data, &key, HASH_FIND, NULL);",
          "content_same": false
        },
        {
          "line": 5138,
          "old_api": null,
          "new_api": "ItemPointerCopy",
          "old_text": null,
          "new_text": "ItemPointerCopy(&map.new_tid,\n\t\t\t\t\t\t&key.tid)",
          "old_line_content": "",
          "new_line_content": "\t\tItemPointerCopy(&map.new_tid,",
          "content_same": false
        },
        {
          "line": 5142,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(tuplecid_data, &key, HASH_ENTER, &found)",
          "old_line_content": "\t\t\t * Make sure the existing mapping makes sense. We sometime update",
          "new_line_content": "\t\t\thash_search(tuplecid_data, &key, HASH_ENTER, &found);",
          "content_same": false
        },
        {
          "line": 3098,
          "old_api": null,
          "new_api": "IsTransactionOrTransactionBlock",
          "old_text": null,
          "new_text": "IsTransactionOrTransactionBlock()",
          "old_line_content": "",
          "new_line_content": "\tbool\t\tuse_subtxn = IsTransactionOrTransactionBlock();",
          "content_same": false
        },
        {
          "line": 3102,
          "old_api": null,
          "new_api": "BeginInternalSubTransaction",
          "old_text": null,
          "new_text": "BeginInternalSubTransaction(\"replay\")",
          "old_line_content": "\t * That's advantageous because we don't need to setup the full state",
          "new_line_content": "\t\tBeginInternalSubTransaction(\"replay\");",
          "content_same": false
        },
        {
          "line": 5151,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(ent->cmin == InvalidCommandId || ent->cmin == new_ent->cmin)",
          "old_line_content": "\t\t\t/* update mapping */",
          "new_line_content": "\t\t\tAssert(ent->cmin == InvalidCommandId || ent->cmin == new_ent->cmin);",
          "content_same": false
        },
        {
          "line": 1056,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&rb->txns_by_base_snapshot_lsn)",
          "old_line_content": "\treturn txn->base_snapshot->xmin;",
          "new_line_content": "\tif (dlist_is_empty(&rb->txns_by_base_snapshot_lsn))",
          "content_same": false
        },
        {
          "line": 5152,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(ent->cmax == InvalidCommandId || ent->cmax == new_ent->cmax)",
          "old_line_content": "\t\t\tnew_ent->cmin = ent->cmin;",
          "new_line_content": "\t\t\tAssert(ent->cmax == InvalidCommandId || ent->cmax == new_ent->cmax);",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": null,
          "new_api": "dlist_head_element",
          "old_text": null,
          "new_text": "dlist_head_element(ReorderBufferTXN, base_snapshot_node,\n\t\t\t\t\t\t\t &rb->txns_by_base_snapshot_lsn)",
          "old_line_content": "void",
          "new_line_content": "\ttxn = dlist_head_element(ReorderBufferTXN, base_snapshot_node,",
          "content_same": false
        },
        {
          "line": 3111,
          "old_api": null,
          "new_api": "AbortCurrentTransaction",
          "old_text": null,
          "new_text": "AbortCurrentTransaction()",
          "old_line_content": "\tif (use_subtxn)",
          "new_line_content": "\t\tAbortCurrentTransaction();",
          "content_same": false
        },
        {
          "line": 3114,
          "old_api": null,
          "new_api": "LocalExecuteInvalidationMessage",
          "old_text": null,
          "new_text": "LocalExecuteInvalidationMessage(&invalidations[i])",
          "old_line_content": "",
          "new_line_content": "\t\tLocalExecuteInvalidationMessage(&invalidations[i]);",
          "content_same": false
        },
        {
          "line": 5163,
          "old_api": null,
          "new_api": "CloseTransientFile",
          "old_text": null,
          "new_text": "CloseTransientFile(fd)",
          "old_line_content": "",
          "new_line_content": "\tif (CloseTransientFile(fd) != 0)",
          "content_same": false
        },
        {
          "line": 5164,
          "old_api": null,
          "new_api": "ereport",
          "old_text": null,
          "new_text": "ereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close file \\\"%s\\\": %m\", path)))",
          "old_line_content": "",
          "new_line_content": "\t\tereport(ERROR,",
          "content_same": false
        },
        {
          "line": 3117,
          "old_api": null,
          "new_api": "RollbackAndReleaseCurrentSubTransaction",
          "old_text": null,
          "new_text": "RollbackAndReleaseCurrentSubTransaction()",
          "old_line_content": " * least once for every xid in XLogRecord->xl_xid (other places in records",
          "new_line_content": "\t\tRollbackAndReleaseCurrentSubTransaction();",
          "content_same": false
        },
        {
          "line": 5165,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "/*",
          "new_line_content": "\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 5166,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not close file \\\"%s\\\": %m\", path)",
          "old_line_content": " * Check whether the TransactionId 'xid' is in the pre-sorted array 'xip'.",
          "new_line_content": "\t\t\t\t errmsg(\"could not close file \\\"%s\\\": %m\", path)));",
          "content_same": false
        },
        {
          "line": 5176,
          "old_api": null,
          "new_api": "bsearch",
          "old_text": null,
          "new_text": "bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator)",
          "old_line_content": " * list_sort() comparator for sorting RewriteMappingFiles in LSN order.",
          "new_line_content": "\treturn bsearch(&xid, xip, num,",
          "content_same": false
        },
        {
          "line": 1086,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, subxid, true, &new_sub, lsn, false)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tsubtxn = ReorderBufferTXNByXid(rb, subxid, true, &new_sub, lsn, false);",
          "content_same": false
        },
        {
          "line": 3135,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "old_line_content": " * because the previous snapshot doesn't describe the catalog correctly for",
          "new_line_content": "\t\tReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(subtxn)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\tif (rbtxn_is_known_subxact(subtxn))",
          "content_same": false
        },
        {
          "line": 5186,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(a_p)",
          "old_line_content": "",
          "new_line_content": "\tRewriteMappingFile *a = (RewriteMappingFile *) lfirst(a_p);",
          "content_same": false
        },
        {
          "line": 5187,
          "old_api": null,
          "new_api": "lfirst",
          "old_text": null,
          "new_text": "lfirst(b_p)",
          "old_line_content": "/*",
          "new_line_content": "\tRewriteMappingFile *b = (RewriteMappingFile *) lfirst(b_p);",
          "content_same": false
        },
        {
          "line": 5189,
          "old_api": null,
          "new_api": "pg_cmp_u64",
          "old_text": null,
          "new_text": "pg_cmp_u64(a->lsn, b->lsn)",
          "old_line_content": " * transaction for relid.",
          "new_line_content": "\treturn pg_cmp_u64(a->lsn, b->lsn);",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&subtxn->node)",
          "old_line_content": "\tsubtxn->toplevel_xid = xid;",
          "new_line_content": "\t\t\tdlist_delete(&subtxn->node);",
          "content_same": false
        },
        {
          "line": 3152,
          "old_api": null,
          "new_api": "ReorderBufferQueueChange",
          "old_text": null,
          "new_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "old_line_content": " *",
          "new_line_content": "\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "content_same": false
        },
        {
          "line": 5203,
          "old_api": null,
          "new_api": "IsSharedRelation",
          "old_text": null,
          "new_text": "IsSharedRelation(relid)",
          "old_line_content": "\t\tOid\t\t\tf_dboid;",
          "new_line_content": "\tOid\t\t\tdboid = IsSharedRelation(relid) ? InvalidOid : MyDatabaseId;",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subtxn->nsubtxns == 0)",
          "old_line_content": "\t/* add to subtransaction list */",
          "new_line_content": "\tAssert(subtxn->nsubtxns == 0);",
          "content_same": false
        },
        {
          "line": 5205,
          "old_api": null,
          "new_api": "AllocateDir",
          "old_text": null,
          "new_text": "AllocateDir(PG_LOGICAL_MAPPINGS_DIR)",
          "old_line_content": "\t\tTransactionId f_mapped_xid;",
          "new_line_content": "\tmapping_dir = AllocateDir(PG_LOGICAL_MAPPINGS_DIR);",
          "content_same": false
        },
        {
          "line": 5206,
          "old_api": null,
          "new_api": "ReadDir",
          "old_text": null,
          "new_text": "ReadDir(mapping_dir, PG_LOGICAL_MAPPINGS_DIR)",
          "old_line_content": "\t\tTransactionId f_create_xid;",
          "new_line_content": "\twhile ((mapping_de = ReadDir(mapping_dir, PG_LOGICAL_MAPPINGS_DIR)) != NULL)",
          "content_same": false
        },
        {
          "line": 1114,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&txn->subtxns, &subtxn->node)",
          "old_line_content": "",
          "new_line_content": "\tdlist_push_tail(&txn->subtxns, &subtxn->node);",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": null,
          "new_api": "ReorderBufferTransferSnapToParent",
          "old_text": null,
          "new_text": "ReorderBufferTransferSnapToParent(txn, subtxn)",
          "old_line_content": "",
          "new_line_content": "\tReorderBufferTransferSnapToParent(txn, subtxn);",
          "content_same": false
        },
        {
          "line": 3168,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(snap != NULL)",
          "old_line_content": "\t */",
          "new_line_content": "\tAssert(snap != NULL);",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "AssertTXNLsnOrder",
          "old_text": null,
          "new_text": "AssertTXNLsnOrder(rb)",
          "old_line_content": " *\t\tTransfer base snapshot from subtxn to top-level txn, if needed",
          "new_line_content": "\tAssertTXNLsnOrder(rb);",
          "content_same": false
        },
        {
          "line": 5218,
          "old_api": null,
          "new_api": "strcmp",
          "old_text": null,
          "new_text": "strcmp(mapping_de->d_name, \"..\")",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\t\t\tstrcmp(mapping_de->d_name, \"..\") == 0)",
          "content_same": false
        },
        {
          "line": 3174,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, &is_new, lsn, true)",
          "old_line_content": "",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, &is_new, lsn, true);",
          "content_same": false
        },
        {
          "line": 3175,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(txn)",
          "old_line_content": "\ttxn->base_snapshot = snap;",
          "new_line_content": "\tif (rbtxn_is_known_subxact(txn))",
          "content_same": false
        },
        {
          "line": 3176,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,\n\t\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false)",
          "old_line_content": "\ttxn->base_snapshot_lsn = lsn;",
          "new_line_content": "\t\ttxn = ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,",
          "content_same": false
        },
        {
          "line": 5222,
          "old_api": null,
          "new_api": "strncmp",
          "old_text": null,
          "new_text": "strncmp(mapping_de->d_name, \"map-\", 4)",
          "old_line_content": "\t\t\t\t   &f_mapped_xid, &f_create_xid) != 6)",
          "new_line_content": "\t\tif (strncmp(mapping_de->d_name, \"map-\", 4) != 0)",
          "content_same": false
        },
        {
          "line": 3178,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->base_snapshot == NULL)",
          "old_line_content": "",
          "new_line_content": "\tAssert(txn->base_snapshot == NULL);",
          "content_same": false
        },
        {
          "line": 5225,
          "old_api": null,
          "new_api": "sscanf",
          "old_text": null,
          "new_text": "sscanf(mapping_de->d_name, LOGICAL_REWRITE_FORMAT,\n\t\t\t\t   &f_dboid, &f_relid, &f_hi, &f_lo,\n\t\t\t\t   &f_mapped_xid, &f_create_xid)",
          "old_line_content": "\t\tf_lsn = ((uint64) f_hi) << 32 | f_lo;",
          "new_line_content": "\t\tif (sscanf(mapping_de->d_name, LOGICAL_REWRITE_FORMAT,",
          "content_same": false
        },
        {
          "line": 5228,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(ERROR, \"could not parse filename \\\"%s\\\"\", mapping_de->d_name)",
          "old_line_content": "\t\tif (f_dboid != dboid)",
          "new_line_content": "\t\t\telog(ERROR, \"could not parse filename \\\"%s\\\"\", mapping_de->d_name);",
          "content_same": false
        },
        {
          "line": 3182,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&rb->txns_by_base_snapshot_lsn, &txn->base_snapshot_node)",
          "old_line_content": "/*",
          "new_line_content": "\tdlist_push_tail(&rb->txns_by_base_snapshot_lsn, &txn->base_snapshot_node);",
          "content_same": false
        },
        {
          "line": 3184,
          "old_api": null,
          "new_api": "AssertTXNLsnOrder",
          "old_text": null,
          "new_text": "AssertTXNLsnOrder(rb)",
          "old_line_content": " *",
          "new_line_content": "\tAssertTXNLsnOrder(rb);",
          "content_same": false
        },
        {
          "line": 5241,
          "old_api": null,
          "new_api": "TransactionIdDidCommit",
          "old_text": null,
          "new_text": "TransactionIdDidCommit(f_create_xid)",
          "old_line_content": "\t\t\tcontinue;",
          "new_line_content": "\t\tif (!TransactionIdDidCommit(f_create_xid))",
          "content_same": false
        },
        {
          "line": 1146,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subtxn->toplevel_xid == txn->xid)",
          "old_line_content": "\t\t\tsubtxn->base_snapshot_lsn < txn->base_snapshot_lsn)",
          "new_line_content": "\tAssert(subtxn->toplevel_xid == txn->xid);",
          "content_same": false
        },
        {
          "line": 5245,
          "old_api": null,
          "new_api": "TransactionIdInArray",
          "old_text": null,
          "new_text": "TransactionIdInArray(f_mapped_xid, snapshot->subxip, snapshot->subxcnt)",
          "old_line_content": "\t\tf->lsn = f_lsn;",
          "new_line_content": "\t\tif (!TransactionIdInArray(f_mapped_xid, snapshot->subxip, snapshot->subxcnt))",
          "content_same": false
        },
        {
          "line": 3201,
          "old_api": null,
          "new_api": "ReorderBufferQueueChange",
          "old_text": null,
          "new_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "old_line_content": " *",
          "new_line_content": "\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "content_same": false
        },
        {
          "line": 5251,
          "old_api": null,
          "new_api": "strcpy",
          "old_text": null,
          "new_text": "strcpy(f->fname, mapping_de->d_name)",
          "old_line_content": "\t/* sort files so we apply them in LSN order */",
          "new_line_content": "\t\tstrcpy(f->fname, mapping_de->d_name);",
          "content_same": false
        },
        {
          "line": 5254,
          "old_api": null,
          "new_api": "FreeDir",
          "old_text": null,
          "new_text": "FreeDir(mapping_dir)",
          "old_line_content": "\tforeach(file, files)",
          "new_line_content": "\tFreeDir(mapping_dir);",
          "content_same": false
        },
        {
          "line": 1159,
          "old_api": null,
          "new_api": "SnapBuildSnapDecRefcount",
          "old_text": null,
          "new_text": "SnapBuildSnapDecRefcount(txn->base_snapshot)",
          "old_line_content": "\t\t\t * The snapshot is now the top transaction's; transfer it, and",
          "new_line_content": "\t\t\t\tSnapBuildSnapDecRefcount(txn->base_snapshot);",
          "content_same": false
        },
        {
          "line": 1160,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&txn->base_snapshot_node)",
          "old_line_content": "\t\t\t * adjust the list position of the top transaction in the list by",
          "new_line_content": "\t\t\t\tdlist_delete(&txn->base_snapshot_node);",
          "content_same": false
        },
        {
          "line": 5257,
          "old_api": null,
          "new_api": "list_sort",
          "old_text": null,
          "new_text": "list_sort(files, file_sort_by_lsn)",
          "old_line_content": "",
          "new_line_content": "\tlist_sort(files, file_sort_by_lsn);",
          "content_same": false
        },
        {
          "line": 5263,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG1, \"applying mapping: \\\"%s\\\" in %u\", f->fname,\n\t\t\t snapshot->subxip[0])",
          "old_line_content": "}",
          "new_line_content": "\t\telog(DEBUG1, \"applying mapping: \\\"%s\\\" in %u\", f->fname,",
          "content_same": false
        },
        {
          "line": 5265,
          "old_api": null,
          "new_api": "ApplyLogicalMappingFile",
          "old_text": null,
          "new_text": "ApplyLogicalMappingFile(tuplecid_data, relid, f->fname)",
          "old_line_content": "/*",
          "new_line_content": "\t\tApplyLogicalMappingFile(tuplecid_data, relid, f->fname);",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "dlist_insert_before",
          "old_text": null,
          "new_text": "dlist_insert_before(&subtxn->base_snapshot_node,\n\t\t\t\t\t\t\t\t&txn->base_snapshot_node)",
          "old_line_content": "\t\t\t * mustn't be in the list.)",
          "new_line_content": "\t\t\tdlist_insert_before(&subtxn->base_snapshot_node,",
          "content_same": false
        },
        {
          "line": 5266,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(f)",
          "old_line_content": " * Lookup cmin/cmax of a tuple, during logical decoding where we can't rely on",
          "new_line_content": "\t\tpfree(f);",
          "content_same": false
        },
        {
          "line": 3228,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn || change)",
          "old_line_content": "\t * trigger a pointless attempt to spill.",
          "new_line_content": "\tAssert(txn || change);",
          "content_same": false
        },
        {
          "line": 1184,
          "old_api": null,
          "new_api": "SnapBuildSnapDecRefcount",
          "old_text": null,
          "new_text": "SnapBuildSnapDecRefcount(subtxn->base_snapshot)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tSnapBuildSnapDecRefcount(subtxn->base_snapshot);",
          "content_same": false
        },
        {
          "line": 1185,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&subtxn->base_snapshot_node)",
          "old_line_content": "}",
          "new_line_content": "\t\t\tdlist_delete(&subtxn->base_snapshot_node);",
          "content_same": false
        },
        {
          "line": 3243,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn != NULL)",
          "old_line_content": "\t */",
          "new_line_content": "\tAssert(txn != NULL);",
          "content_same": false
        },
        {
          "line": 3249,
          "old_api": null,
          "new_api": "rbtxn_get_toptxn",
          "old_text": null,
          "new_text": "rbtxn_get_toptxn(txn)",
          "old_line_content": "",
          "new_line_content": "\ttoptxn = rbtxn_get_toptxn(txn);",
          "content_same": false
        },
        {
          "line": 5298,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&key, 0, sizeof(key))",
          "old_line_content": "\t * get relfilelocator from the buffer, no convenient way to access it",
          "new_line_content": "\tmemset(&key, 0, sizeof(key));",
          "content_same": false
        },
        {
          "line": 1203,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, subxid, false, NULL,\n\t\t\t\t\t\t\t\t   InvalidXLogRecPtr, false)",
          "old_line_content": "\t */",
          "new_line_content": "\tsubtxn = ReorderBufferTXNByXid(rb, subxid, false, NULL,",
          "content_same": false
        },
        {
          "line": 5300,
          "old_api": null,
          "new_api": "BufferIsLocal",
          "old_text": null,
          "new_text": "BufferIsLocal(buffer)",
          "old_line_content": "\t */",
          "new_line_content": "\tAssert(!BufferIsLocal(buffer));",
          "content_same": false
        },
        {
          "line": 5306,
          "old_api": null,
          "new_api": "BufferGetTag",
          "old_text": null,
          "new_text": "BufferGetTag(buffer, &key.rlocator, &forkno, &blockno)",
          "old_line_content": "",
          "new_line_content": "\tBufferGetTag(buffer, &key.rlocator, &forkno, &blockno);",
          "content_same": false
        },
        {
          "line": 5309,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(forkno == MAIN_FORKNUM)",
          "old_line_content": "",
          "new_line_content": "\tAssert(forkno == MAIN_FORKNUM);",
          "content_same": false
        },
        {
          "line": 5310,
          "old_api": null,
          "new_api": "ItemPointerGetBlockNumber",
          "old_text": null,
          "new_text": "ItemPointerGetBlockNumber(&htup->t_self)",
          "old_line_content": "restart:",
          "new_line_content": "\tAssert(blockno == ItemPointerGetBlockNumber(&htup->t_self));",
          "content_same": false
        },
        {
          "line": 3264,
          "old_api": null,
          "new_api": "pairingheap_add",
          "old_text": null,
          "new_text": "pairingheap_add(rb->txn_heap, &txn->txn_node)",
          "old_line_content": "\t\ttxn->size -= sz;",
          "new_line_content": "\t\tpairingheap_add(rb->txn_heap, &txn->txn_node);",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "ReorderBufferAssignChild",
          "old_text": null,
          "new_text": "ReorderBufferAssignChild(rb, xid, subxid, InvalidXLogRecPtr)",
          "old_line_content": " * Support for efficiently iterating over a transaction's and its",
          "new_line_content": "\tReorderBufferAssignChild(rb, xid, subxid, InvalidXLogRecPtr);",
          "content_same": false
        },
        {
          "line": 3268,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert((rb->size >= sz) && (txn->size >= sz))",
          "old_line_content": "\t\ttoptxn->total_size -= sz;",
          "new_line_content": "\t\tAssert((rb->size >= sz) && (txn->size >= sz));",
          "content_same": false
        },
        {
          "line": 5317,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(tuplecid_data, &key, HASH_FIND, NULL)",
          "old_line_content": "\t * mappings while we are in here since we have to hold a lock on the",
          "new_line_content": "\t\thash_search(tuplecid_data, &key, HASH_FIND, NULL);",
          "content_same": false
        },
        {
          "line": 3278,
          "old_api": null,
          "new_api": "pairingheap_add",
          "old_text": null,
          "new_text": "pairingheap_add(rb->txn_heap, &txn->txn_node)",
          "old_line_content": "",
          "new_line_content": "\t\t\tpairingheap_add(rb->txn_heap, &txn->txn_node);",
          "content_same": false
        },
        {
          "line": 5327,
          "old_api": null,
          "new_api": "UpdateLogicalMappings",
          "old_text": null,
          "new_text": "UpdateLogicalMappings(tuplecid_data, htup->t_tableOid, snapshot)",
          "old_line_content": "\telse if (ent == NULL)",
          "new_line_content": "\t\tUpdateLogicalMappings(tuplecid_data, htup->t_tableOid, snapshot);",
          "content_same": false
        },
        {
          "line": 3281,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->size <= rb->size)",
          "old_line_content": " *",
          "new_line_content": "\tAssert(txn->size <= rb->size);",
          "content_same": false
        },
        {
          "line": 1242,
          "old_api": null,
          "new_api": "DatumGetInt32",
          "old_text": null,
          "new_text": "DatumGetInt32(a)",
          "old_line_content": "\telse if (pos_a == pos_b)",
          "new_line_content": "\tXLogRecPtr\tpos_a = state->entries[DatumGetInt32(a)].lsn;",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "DatumGetInt32",
          "old_text": null,
          "new_text": "DatumGetInt32(b)",
          "old_line_content": "\t\treturn 0;",
          "new_line_content": "\tXLogRecPtr\tpos_b = state->entries[DatumGetInt32(b)].lsn;",
          "content_same": false
        },
        {
          "line": 3297,
          "old_api": null,
          "new_api": "ReorderBufferGetChange",
          "old_text": null,
          "new_text": "ReorderBufferGetChange(rb)",
          "old_line_content": "\tchange->data.tuplecid.locator = locator;",
          "new_line_content": "\tReorderBufferChange *change = ReorderBufferGetChange(rb);",
          "content_same": false
        },
        {
          "line": 3300,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "old_line_content": "\tchange->data.tuplecid.cmax = cmax;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "content_same": false
        },
        {
          "line": 3311,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&txn->tuplecids, &change->node)",
          "old_line_content": " * Accumulate the invalidations for executing them later.",
          "new_line_content": "\tdlist_push_tail(&txn->tuplecids, &change->node);",
          "content_same": false
        },
        {
          "line": 1273,
          "old_api": null,
          "new_api": "AssertChangeLsnOrder",
          "old_text": null,
          "new_text": "AssertChangeLsnOrder(txn)",
          "old_line_content": "\t * buffer, we count the one we were directly passed.)",
          "new_line_content": "\tAssertChangeLsnOrder(txn);",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(cur_txn_i, &txn->subtxns)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach(cur_txn_i, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 1287,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, cur_txn_i.cur)",
          "old_line_content": "\t\tif (cur_txn->nentries > 0)",
          "new_line_content": "\t\tcur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);",
          "content_same": false
        },
        {
          "line": 3337,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "old_line_content": "\t * Collect all the invalidations under the top transaction, if available,",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "AssertChangeLsnOrder",
          "old_text": null,
          "new_text": "AssertChangeLsnOrder(cur_txn)",
          "old_line_content": "",
          "new_line_content": "\t\tAssertChangeLsnOrder(cur_txn);",
          "content_same": false
        },
        {
          "line": 3339,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(rb->context)",
          "old_line_content": "\t * function.",
          "new_line_content": "\toldcontext = MemoryContextSwitchTo(rb->context);",
          "content_same": false
        },
        {
          "line": 3346,
          "old_api": null,
          "new_api": "rbtxn_get_toptxn",
          "old_text": null,
          "new_text": "rbtxn_get_toptxn(txn)",
          "old_line_content": "\tif (txn->ninvalidations == 0)",
          "new_line_content": "\ttxn = rbtxn_get_toptxn(txn);",
          "content_same": false
        },
        {
          "line": 3348,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(nmsgs > 0)",
          "old_line_content": "\t\ttxn->ninvalidations = nmsgs;",
          "new_line_content": "\tAssert(nmsgs > 0);",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": null,
          "new_api": "dlist_init",
          "old_text": null,
          "new_text": "dlist_init(&state->old_change)",
          "old_line_content": "\t\tstate->entries[off].segno = 0;",
          "new_line_content": "\tdlist_init(&state->old_change);",
          "content_same": false
        },
        {
          "line": 3355,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(SharedInvalidationMessage) * nmsgs)",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tpalloc(sizeof(SharedInvalidationMessage) * nmsgs);",
          "content_same": false
        },
        {
          "line": 3356,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(txn->invalidations, msgs,\n\t\t\t   sizeof(SharedInvalidationMessage) * nmsgs)",
          "old_line_content": "\t\ttxn->invalidations = (SharedInvalidationMessage *)",
          "new_line_content": "\t\tmemcpy(txn->invalidations, msgs,",
          "content_same": false
        },
        {
          "line": 1312,
          "old_api": null,
          "new_api": "binaryheap_allocate",
          "old_text": null,
          "new_text": "binaryheap_allocate(state->nr_txns,\n\t\t\t\t\t\t\t\t\t  ReorderBufferIterCompare,\n\t\t\t\t\t\t\t\t\t  state)",
          "old_line_content": "\t*iter_state = state;",
          "new_line_content": "\tstate->heap = binaryheap_allocate(state->nr_txns,",
          "content_same": false
        },
        {
          "line": 3362,
          "old_api": null,
          "new_api": "repalloc",
          "old_text": null,
          "new_text": "repalloc(txn->invalidations, sizeof(SharedInvalidationMessage) *\n\t\t\t\t\t (txn->ninvalidations + nmsgs))",
          "old_line_content": "\t\ttxn->ninvalidations += nmsgs;",
          "new_line_content": "\t\t\trepalloc(txn->invalidations, sizeof(SharedInvalidationMessage) *",
          "content_same": false
        },
        {
          "line": 3374,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(SharedInvalidationMessage) * nmsgs)",
          "old_line_content": "",
          "new_line_content": "\t\tpalloc(sizeof(SharedInvalidationMessage) * nmsgs);",
          "content_same": false
        },
        {
          "line": 3378,
          "old_api": null,
          "new_api": "ReorderBufferQueueChange",
          "old_text": null,
          "new_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "old_line_content": "/*",
          "new_line_content": "\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "content_same": false
        },
        {
          "line": 1331,
          "old_api": null,
          "new_api": "rbtxn_is_serialized",
          "old_text": null,
          "new_text": "rbtxn_is_serialized(txn)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno);",
          "new_line_content": "\t\tif (rbtxn_is_serialized(txn))",
          "content_same": false
        },
        {
          "line": 3380,
          "old_api": null,
          "new_api": "MemoryContextSwitchTo",
          "old_text": null,
          "new_text": "MemoryContextSwitchTo(oldcontext)",
          "old_line_content": " * in the changestream but we don't know which those are.",
          "new_line_content": "\tMemoryContextSwitchTo(oldcontext);",
          "content_same": false
        },
        {
          "line": 1335,
          "old_api": null,
          "new_api": "ReorderBufferRestoreChanges",
          "old_text": null,
          "new_text": "ReorderBufferRestoreChanges(rb, txn, &state->entries[off].file,\n\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t&txn->changes);",
          "new_line_content": "\t\t\tReorderBufferRestoreChanges(rb, txn, &state->entries[off].file,",
          "content_same": false
        },
        {
          "line": 1339,
          "old_api": null,
          "new_api": "dlist_head_element",
          "old_text": null,
          "new_text": "dlist_head_element(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t\t\t&txn->changes)",
          "old_line_content": "\t\tstate->entries[off].txn = txn;",
          "new_line_content": "\t\tcur_change = dlist_head_element(ReorderBufferChange, node,",
          "content_same": false
        },
        {
          "line": 3393,
          "old_api": null,
          "new_api": "LocalExecuteInvalidationMessage",
          "old_text": null,
          "new_text": "LocalExecuteInvalidationMessage(&msgs[i])",
          "old_line_content": " */",
          "new_line_content": "\t\tLocalExecuteInvalidationMessage(&msgs[i]);",
          "content_same": false
        },
        {
          "line": 1346,
          "old_api": null,
          "new_api": "Int32GetDatum",
          "old_text": null,
          "new_text": "Int32GetDatum(off++)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tbinaryheap_add_unordered(state->heap, Int32GetDatum(off++));",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(cur_txn_i, &txn->subtxns)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach(cur_txn_i, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 1354,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, cur_txn_i.cur)",
          "old_line_content": "",
          "new_line_content": "\t\tcur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);",
          "content_same": false
        },
        {
          "line": 3407,
          "old_api": null,
          "new_api": "rbtxn_has_catalog_changes",
          "old_text": null,
          "new_text": "rbtxn_has_catalog_changes(txn)",
          "old_line_content": "",
          "new_line_content": "\tif (!rbtxn_has_catalog_changes(txn))",
          "content_same": false
        },
        {
          "line": 1360,
          "old_api": null,
          "new_api": "rbtxn_is_serialized",
          "old_text": null,
          "new_text": "rbtxn_is_serialized(cur_txn)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t&state->entries[off].file,",
          "new_line_content": "\t\t\tif (rbtxn_is_serialized(cur_txn))",
          "content_same": false
        },
        {
          "line": 3410,
          "old_api": null,
          "new_api": "dclist_push_tail",
          "old_text": null,
          "new_text": "dclist_push_tail(&rb->catchange_txns, &txn->catchange_node)",
          "old_line_content": "\t * children has so that the ReorderBufferBuildTupleCidHash can",
          "new_line_content": "\t\tdclist_push_tail(&rb->catchange_txns, &txn->catchange_node);",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": null,
          "new_api": "ReorderBufferRestoreChanges",
          "old_text": null,
          "new_text": "ReorderBufferRestoreChanges(rb, cur_txn,\n\t\t\t\t\t\t\t\t\t\t\t&state->entries[off].file,\n\t\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t&cur_txn->changes);",
          "new_line_content": "\t\t\t\tReorderBufferRestoreChanges(rb, cur_txn,",
          "content_same": false
        },
        {
          "line": 1368,
          "old_api": null,
          "new_api": "dlist_head_element",
          "old_text": null,
          "new_text": "dlist_head_element(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t\t\t\t&cur_txn->changes)",
          "old_line_content": "\t\t\tstate->entries[off].txn = cur_txn;",
          "new_line_content": "\t\t\tcur_change = dlist_head_element(ReorderBufferChange, node,",
          "content_same": false
        },
        {
          "line": 3419,
          "old_api": null,
          "new_api": "rbtxn_is_subtxn",
          "old_text": null,
          "new_text": "rbtxn_is_subtxn(txn)",
          "old_line_content": "\t\t{",
          "new_line_content": "\tif (rbtxn_is_subtxn(txn))",
          "content_same": false
        },
        {
          "line": 3423,
          "old_api": null,
          "new_api": "rbtxn_has_catalog_changes",
          "old_text": null,
          "new_text": "rbtxn_has_catalog_changes(toptxn)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tif (!rbtxn_has_catalog_changes(toptxn))",
          "content_same": false
        },
        {
          "line": 3426,
          "old_api": null,
          "new_api": "dclist_push_tail",
          "old_text": null,
          "new_text": "dclist_push_tail(&rb->catchange_txns, &toptxn->catchange_node)",
          "old_line_content": "/*",
          "new_line_content": "\t\t\tdclist_push_tail(&rb->catchange_txns, &toptxn->catchange_node);",
          "content_same": false
        },
        {
          "line": 1380,
          "old_api": null,
          "new_api": "binaryheap_build",
          "old_text": null,
          "new_text": "binaryheap_build(state->heap)",
          "old_line_content": " * subtransactions.",
          "new_line_content": "\tbinaryheap_build(state->heap);",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": null,
          "new_api": "binaryheap_first",
          "old_text": null,
          "new_text": "binaryheap_first(state->heap)",
          "old_line_content": "\t{",
          "new_line_content": "\toff = DatumGetInt32(binaryheap_first(state->heap));",
          "content_same": false
        },
        {
          "line": 3449,
          "old_api": null,
          "new_api": "palloc",
          "old_text": null,
          "new_text": "palloc(sizeof(TransactionId) *\n\t\t\t\t\t\t\t\t\tdclist_count(&rb->catchange_txns))",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t catchange_node,",
          "new_line_content": "\txids = (TransactionId *) palloc(sizeof(TransactionId) *",
          "content_same": false
        },
        {
          "line": 3450,
          "old_api": null,
          "new_api": "dclist_count",
          "old_text": null,
          "new_text": "dclist_count(&rb->catchange_txns)",
          "old_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t iter.cur);",
          "new_line_content": "\t\t\t\t\t\t\t\t\tdclist_count(&rb->catchange_txns));",
          "content_same": false
        },
        {
          "line": 3451,
          "old_api": null,
          "new_api": "dclist_foreach",
          "old_text": null,
          "new_text": "dclist_foreach(iter, &rb->catchange_txns)",
          "old_line_content": "",
          "new_line_content": "\tdclist_foreach(iter, &rb->catchange_txns)",
          "content_same": false
        },
        {
          "line": 3453,
          "old_api": null,
          "new_api": "dclist_container",
          "old_text": null,
          "new_text": "dclist_container(ReorderBufferTXN,\n\t\t\t\t\t\t\t\t\t\t\t\t catchange_node,\n\t\t\t\t\t\t\t\t\t\t\t\t iter.cur)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferTXN *txn = dclist_container(ReorderBufferTXN,",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change))",
          "old_line_content": "",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node,",
          "content_same": false
        },
        {
          "line": 1407,
          "old_api": null,
          "new_api": "dlist_pop_head_node",
          "old_text": null,
          "new_text": "dlist_pop_head_node(&state->old_change)",
          "old_line_content": "\tchange = entry->change;",
          "new_line_content": "\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change));",
          "content_same": false
        },
        {
          "line": 1408,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, true)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, true);",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&state->old_change)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\tAssert(dlist_is_empty(&state->old_change));",
          "content_same": false
        },
        {
          "line": 3462,
          "old_api": null,
          "new_api": "qsort",
          "old_text": null,
          "new_text": "qsort(xids, xcnt, sizeof(TransactionId), xidComparator)",
          "old_line_content": "",
          "new_line_content": "\tqsort(xids, xcnt, sizeof(TransactionId), xidComparator);",
          "content_same": false
        },
        {
          "line": 3464,
          "old_api": null,
          "new_api": "dclist_count",
          "old_text": null,
          "new_text": "dclist_count(&rb->catchange_txns)",
          "old_line_content": " * Query whether a transaction is already *known* to contain catalog",
          "new_line_content": "\tAssert(xcnt == dclist_count(&rb->catchange_txns));",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": null,
          "new_api": "dlist_has_next",
          "old_text": null,
          "new_text": "dlist_has_next(&entry->txn->changes, &entry->change->node)",
          "old_line_content": "",
          "new_line_content": "\tif (dlist_has_next(&entry->txn->changes, &entry->change->node))",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": null,
          "new_api": "dlist_next_node",
          "old_text": null,
          "new_text": "dlist_next_node(&entry->txn->changes, &change->node)",
          "old_line_content": "\t\tstate->entries[off].lsn = next_change->lsn;",
          "new_line_content": "\t\tdlist_node *next = dlist_next_node(&entry->txn->changes, &change->node);",
          "content_same": false
        },
        {
          "line": 1424,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, next)",
          "old_line_content": "",
          "new_line_content": "\t\t\tdlist_container(ReorderBufferChange, node, next);",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "Int32GetDatum",
          "old_text": null,
          "new_text": "Int32GetDatum(off)",
          "old_line_content": "\tif (entry->txn->nentries != entry->txn->nentries_mem)",
          "new_line_content": "\t\tbinaryheap_replace_first(state->heap, Int32GetDatum(off));",
          "content_same": false
        },
        {
          "line": 3482,
          "old_api": null,
          "new_api": "rbtxn_has_catalog_changes",
          "old_text": null,
          "new_text": "rbtxn_has_catalog_changes(txn)",
          "old_line_content": " *\t\tHave we already set the base snapshot for the given txn/subtxn?",
          "new_line_content": "\treturn rbtxn_has_catalog_changes(txn);",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "\t\t * releasing the current set of changes and restoring the new set of",
          "new_line_content": "\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": null,
          "new_api": "dlist_push_tail",
          "old_text": null,
          "new_text": "dlist_push_tail(&state->old_change, &change->node)",
          "old_line_content": "\t\t * changes.",
          "new_line_content": "\t\tdlist_push_tail(&state->old_change, &change->node);",
          "content_same": false
        },
        {
          "line": 3494,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, xid, false,\n\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false)",
          "old_line_content": "\t\treturn false;",
          "new_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false,",
          "content_same": false
        },
        {
          "line": 3502,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(txn)",
          "old_line_content": "}",
          "new_line_content": "\tif (rbtxn_is_known_subxact(txn))",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "dlist_head_element",
          "old_text": null,
          "new_text": "dlist_head_element(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t   &entry->txn->changes)",
          "old_line_content": "\t\t\t\t (uint32) entry->txn->nentries);",
          "new_line_content": "\t\t\t\tdlist_head_element(ReorderBufferChange, node,",
          "content_same": false
        },
        {
          "line": 3503,
          "old_api": null,
          "new_api": "ReorderBufferTXNByXid",
          "old_text": null,
          "new_text": "ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,\n\t\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false)",
          "old_line_content": "",
          "new_line_content": "\t\ttxn = ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,",
          "content_same": false
        },
        {
          "line": 1458,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG2, \"restored %u/%u changes from disk\",\n\t\t\t\t (uint32) entry->txn->nentries_mem,\n\t\t\t\t (uint32) entry->txn->nentries)",
          "old_line_content": "\t\t\t/* txn stays the same */",
          "new_line_content": "\t\t\telog(DEBUG2, \"restored %u/%u changes from disk\",",
          "content_same": false
        },
        {
          "line": 1462,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(entry->txn->nentries_mem)",
          "old_line_content": "",
          "new_line_content": "\t\t\tAssert(entry->txn->nentries_mem);",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": null,
          "new_api": "Int32GetDatum",
          "old_text": null,
          "new_text": "Int32GetDatum(off)",
          "old_line_content": "",
          "new_line_content": "\t\t\tbinaryheap_replace_first(state->heap, Int32GetDatum(off));",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "binaryheap_remove_first",
          "old_text": null,
          "new_text": "binaryheap_remove_first(state->heap)",
          "old_line_content": "/*",
          "new_line_content": "\tbinaryheap_remove_first(state->heap);",
          "content_same": false
        },
        {
          "line": 3529,
          "old_api": null,
          "new_api": "repalloc",
          "old_text": null,
          "new_text": "repalloc(rb->outbuf, sz)",
          "old_line_content": "",
          "new_line_content": "\t\trb->outbuf = repalloc(rb->outbuf, sz);",
          "content_same": false
        },
        {
          "line": 1490,
          "old_api": null,
          "new_api": "FileClose",
          "old_text": null,
          "new_text": "FileClose(state->entries[off].file.vfd)",
          "old_line_content": "\t{",
          "new_line_content": "\t\t\tFileClose(state->entries[off].file.vfd);",
          "content_same": false
        },
        {
          "line": 3539,
          "old_api": null,
          "new_api": "pairingheap_const_container",
          "old_text": null,
          "new_text": "pairingheap_const_container(ReorderBufferTXN, txn_node, a)",
          "old_line_content": "\tif (ta->size > tb->size)",
          "new_line_content": "\tconst ReorderBufferTXN *ta = pairingheap_const_container(ReorderBufferTXN, txn_node, a);",
          "content_same": false
        },
        {
          "line": 3540,
          "old_api": null,
          "new_api": "pairingheap_const_container",
          "old_text": null,
          "new_text": "pairingheap_const_container(ReorderBufferTXN, txn_node, b)",
          "old_line_content": "\t\treturn 1;",
          "new_line_content": "\tconst ReorderBufferTXN *tb = pairingheap_const_container(ReorderBufferTXN, txn_node, b);",
          "content_same": false
        },
        {
          "line": 1498,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change))",
          "old_line_content": "",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node,",
          "content_same": false
        },
        {
          "line": 1501,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&state->old_change)",
          "old_line_content": "}",
          "new_line_content": "\t\tAssert(dlist_is_empty(&state->old_change));",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": null,
          "new_api": "binaryheap_free",
          "old_text": null,
          "new_text": "binaryheap_free(state->heap)",
          "old_line_content": " * Cleanup the contents of a transaction, usually after the transaction",
          "new_line_content": "\tbinaryheap_free(state->heap);",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(state)",
          "old_line_content": " * committed or aborted.",
          "new_line_content": "\tpfree(state);",
          "content_same": false
        },
        {
          "line": 3559,
          "old_api": null,
          "new_api": "pairingheap_first",
          "old_text": null,
          "new_text": "pairingheap_first(rb->txn_heap)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t\t\t\t\t\tpairingheap_first(rb->txn_heap));",
          "content_same": false
        },
        {
          "line": 3561,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(largest)",
          "old_line_content": "}",
          "new_line_content": "\tAssert(largest);",
          "content_same": false
        },
        {
          "line": 3562,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(largest->size > 0)",
          "old_line_content": "",
          "new_line_content": "\tAssert(largest->size > 0);",
          "content_same": false
        },
        {
          "line": 3563,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(largest->size <= rb->size)",
          "old_line_content": "/*",
          "new_line_content": "\tAssert(largest->size <= rb->size);",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(iter, &txn->subtxns)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(iter, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 1524,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, iter.cur)",
          "old_line_content": "\t\t * ever recurse more than one level deep here.",
          "new_line_content": "\t\tsubtxn = dlist_container(ReorderBufferTXN, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1531,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(subtxn)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(rbtxn_is_known_subxact(subtxn));",
          "content_same": false
        },
        {
          "line": 1532,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subtxn->nsubtxns == 0)",
          "old_line_content": "\t/* cleanup changes in the txn */",
          "new_line_content": "\t\tAssert(subtxn->nsubtxns == 0);",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, subtxn)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tReorderBufferCleanupTXN(rb, subtxn);",
          "content_same": false
        },
        {
          "line": 1538,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(iter, &txn->changes)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(iter, &txn->changes)",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1545,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->txn == txn)",
          "old_line_content": "\t\t * counter all together below. This saves costs of maintaining the",
          "new_line_content": "\t\tAssert(change->txn == txn);",
          "content_same": false
        },
        {
          "line": 3600,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "content_same": false
        },
        {
          "line": 1553,
          "old_api": null,
          "new_api": "ReorderBufferChangeSize",
          "old_text": null,
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": "\t/* Update the memory counter */",
          "new_line_content": "\t\tmem_freed += ReorderBufferChangeSize(change);",
          "content_same": false
        },
        {
          "line": 1555,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, false)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "content_same": false
        },
        {
          "line": 1559,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed)",
          "old_line_content": "\t */",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed);",
          "content_same": false
        },
        {
          "line": 3609,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->base_snapshot != NULL)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\tAssert(txn->base_snapshot != NULL);",
          "content_same": false
        },
        {
          "line": 3612,
          "old_api": null,
          "new_api": "rbtxn_has_partial_change",
          "old_text": null,
          "new_text": "rbtxn_has_partial_change(txn)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\t(txn->total_size > 0) && !(rbtxn_has_partial_change(txn)) &&",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(iter, &txn->tuplecids)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(iter, &txn->tuplecids)",
          "content_same": false
        },
        {
          "line": 3613,
          "old_api": null,
          "new_api": "rbtxn_has_streamable_change",
          "old_text": null,
          "new_text": "rbtxn_has_streamable_change(txn)",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\trbtxn_has_streamable_change(txn))",
          "content_same": false
        },
        {
          "line": 1569,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "old_line_content": "",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->txn == txn)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(change->txn == txn);",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\tAssert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, true)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, true);",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": null,
          "new_api": "SnapBuildSnapDecRefcount",
          "old_text": null,
          "new_text": "SnapBuildSnapDecRefcount(txn->base_snapshot)",
          "old_line_content": "\t * Cleanup the snapshot for the last streamed run.",
          "new_line_content": "\t\tSnapBuildSnapDecRefcount(txn->base_snapshot);",
          "content_same": false
        },
        {
          "line": 1584,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&txn->base_snapshot_node)",
          "old_line_content": "\t */",
          "new_line_content": "\t\tdlist_delete(&txn->base_snapshot_node);",
          "content_same": false
        },
        {
          "line": 1592,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t * Remove TXN from its containing lists.",
          "new_line_content": "\t\tAssert(rbtxn_is_streamed(txn));",
          "content_same": false
        },
        {
          "line": 1593,
          "old_api": null,
          "new_api": "ReorderBufferFreeSnap",
          "old_text": null,
          "new_text": "ReorderBufferFreeSnap(rb, txn->snapshot_now)",
          "old_line_content": "\t *",
          "new_line_content": "\t\tReorderBufferFreeSnap(rb, txn->snapshot_now);",
          "content_same": false
        },
        {
          "line": 1607,
          "old_api": null,
          "new_api": "dclist_delete_from",
          "old_text": null,
          "new_text": "dclist_delete_from(&rb->catchange_txns, &txn->catchange_node)",
          "old_line_content": "",
          "new_line_content": "\t\tdclist_delete_from(&rb->catchange_txns, &txn->catchange_node);",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(found)",
          "old_line_content": "",
          "new_line_content": "\tAssert(found);",
          "content_same": false
        },
        {
          "line": 1614,
          "old_api": null,
          "new_api": "rbtxn_is_serialized",
          "old_text": null,
          "new_text": "rbtxn_is_serialized(txn)",
          "old_line_content": "}",
          "new_line_content": "\tif (rbtxn_is_serialized(txn))",
          "content_same": false
        },
        {
          "line": 1615,
          "old_api": null,
          "new_api": "ReorderBufferRestoreCleanup",
          "old_text": null,
          "new_text": "ReorderBufferRestoreCleanup(rb, txn)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferRestoreCleanup(rb, txn);",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": null,
          "new_api": "ReorderBufferReturnTXN",
          "old_text": null,
          "new_text": "ReorderBufferReturnTXN(rb, txn)",
          "old_line_content": " * streaming or decoding them at PREPARE. Keep the remaining info -",
          "new_line_content": "\tReorderBufferReturnTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 3671,
          "old_api": null,
          "new_api": "rbtxn_is_toptxn",
          "old_text": null,
          "new_text": "rbtxn_is_toptxn(txn)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tAssert(txn && rbtxn_is_toptxn(txn));",
          "content_same": false
        },
        {
          "line": 3672,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->total_size > 0)",
          "old_line_content": "\t\telse",
          "new_line_content": "\t\t\tAssert(txn->total_size > 0);",
          "content_same": false
        },
        {
          "line": 3673,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(rb->size >= txn->total_size)",
          "old_line_content": "\t\t{",
          "new_line_content": "\t\t\tAssert(rb->size >= txn->total_size);",
          "content_same": false
        },
        {
          "line": 3675,
          "old_api": null,
          "new_api": "ReorderBufferStreamTXN",
          "old_text": null,
          "new_text": "ReorderBufferStreamTXN(rb, txn)",
          "old_line_content": "\t\t\t * Pick the largest transaction (or subtransaction) and evict it",
          "new_line_content": "\t\t\tReorderBufferStreamTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 3686,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn)",
          "old_line_content": "\t\t}",
          "new_line_content": "\t\t\tAssert(txn);",
          "content_same": false
        },
        {
          "line": 1639,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(iter, &txn->subtxns)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(iter, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 3687,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->size > 0)",
          "old_line_content": "",
          "new_line_content": "\t\t\tAssert(txn->size > 0);",
          "content_same": false
        },
        {
          "line": 3688,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(rb->size >= txn->size)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\t\tAssert(rb->size >= txn->size);",
          "content_same": false
        },
        {
          "line": 3690,
          "old_api": null,
          "new_api": "ReorderBufferSerializeTXN",
          "old_text": null,
          "new_text": "ReorderBufferSerializeTXN(rb, txn)",
          "old_line_content": "\t\t * and should use 0 bytes for changes.",
          "new_line_content": "\t\t\tReorderBufferSerializeTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 1643,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, iter.cur)",
          "old_line_content": "\t\t * ever recurse more than one level deep here.",
          "new_line_content": "\t\tsubtxn = dlist_container(ReorderBufferTXN, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": null,
          "new_api": "rbtxn_is_known_subxact",
          "old_text": null,
          "new_text": "rbtxn_is_known_subxact(subtxn)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(rbtxn_is_known_subxact(subtxn));",
          "content_same": false
        },
        {
          "line": 1651,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(subtxn->nsubtxns == 0)",
          "old_line_content": "\t/* cleanup changes in the txn */",
          "new_line_content": "\t\tAssert(subtxn->nsubtxns == 0);",
          "content_same": false
        },
        {
          "line": 3698,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->nentries_mem == 0)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(txn->nentries_mem == 0);",
          "content_same": false
        },
        {
          "line": 1653,
          "old_api": null,
          "new_api": "ReorderBufferTruncateTXN",
          "old_text": null,
          "new_text": "ReorderBufferTruncateTXN(rb, subtxn, txn_prepared)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tReorderBufferTruncateTXN(rb, subtxn, txn_prepared);",
          "content_same": false
        },
        {
          "line": 3702,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(rb->size < logical_decoding_work_mem * 1024L)",
          "old_line_content": " * Spill data of a large transaction (and its subtransactions) to disk.",
          "new_line_content": "\tAssert(rb->size < logical_decoding_work_mem * 1024L);",
          "content_same": false
        },
        {
          "line": 1657,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(iter, &txn->changes)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(iter, &txn->changes)",
          "content_same": false
        },
        {
          "line": 1661,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "old_line_content": "\t\t/* remove the change from it's containing list */",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1664,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->txn == txn)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\t\tAssert(change->txn == txn);",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "\t\t * counter all together below. This saves costs of maintaining the",
          "new_line_content": "\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 3719,
          "old_api": null,
          "new_api": "elog",
          "old_text": null,
          "new_text": "elog(DEBUG2, \"spill %u changes in XID %u to disk\",\n\t\t (uint32) txn->nentries_mem, txn->xid)",
          "old_line_content": "\t{",
          "new_line_content": "\telog(DEBUG2, \"spill %u changes in XID %u to disk\",",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": null,
          "new_api": "ReorderBufferChangeSize",
          "old_text": null,
          "new_text": "ReorderBufferChangeSize(change)",
          "old_line_content": "\t/* Update the memory counter */",
          "new_line_content": "\t\tmem_freed += ReorderBufferChangeSize(change);",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, false)",
          "old_line_content": "",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "content_same": false
        },
        {
          "line": 3728,
          "old_api": null,
          "new_api": "ReorderBufferSerializeTXN",
          "old_text": null,
          "new_text": "ReorderBufferSerializeTXN(rb, subtxn)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tReorderBufferSerializeTXN(rb, subtxn);",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed)",
          "old_line_content": "\t * The top-level transaction, is marked as streamed always, even if it",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed);",
          "content_same": false
        },
        {
          "line": 3732,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(change_i, &txn->changes)",
          "old_line_content": "",
          "new_line_content": "\tdlist_foreach_modify(change_i, &txn->changes)",
          "content_same": false
        },
        {
          "line": 3736,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, change_i.cur)",
          "old_line_content": "\t\t */",
          "new_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, change_i.cur);",
          "content_same": false
        },
        {
          "line": 1698,
          "old_api": null,
          "new_api": "rbtxn_is_toptxn",
          "old_text": null,
          "new_text": "rbtxn_is_toptxn(txn)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\tif ((!txn_prepared) && (rbtxn_is_toptxn(txn) || (txn->nentries_mem != 0)))",
          "content_same": false
        },
        {
          "line": 3748,
          "old_api": null,
          "new_api": "CloseTransientFile",
          "old_text": null,
          "new_text": "CloseTransientFile(fd)",
          "old_line_content": "\t\t\t * No need to care about TLIs here, only used during a single run,",
          "new_line_content": "\t\t\t\tCloseTransientFile(fd);",
          "content_same": false
        },
        {
          "line": 3750,
          "old_api": null,
          "new_api": "XLByteToSeg",
          "old_text": null,
          "new_text": "XLByteToSeg(change->lsn, curOpenSegNo, wal_segment_size)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tXLByteToSeg(change->lsn, curOpenSegNo, wal_segment_size);",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "dlist_foreach_modify",
          "old_text": null,
          "new_text": "dlist_foreach_modify(iter, &txn->tuplecids)",
          "old_line_content": "",
          "new_line_content": "\t\tdlist_foreach_modify(iter, &txn->tuplecids)",
          "content_same": false
        },
        {
          "line": 3756,
          "old_api": null,
          "new_api": "ReorderBufferSerializedPath",
          "old_text": null,
          "new_text": "ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,\n\t\t\t\t\t\t\t\t\t\tcurOpenSegNo)",
          "old_line_content": "\t\t\t\t\t\t\t\t   O_CREAT | O_WRONLY | O_APPEND | PG_BINARY);",
          "new_line_content": "\t\t\tReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,",
          "content_same": false
        },
        {
          "line": 1712,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "old_line_content": "",
          "new_line_content": "\t\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1715,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->txn == txn)",
          "old_line_content": "",
          "new_line_content": "\t\t\tAssert(change->txn == txn);",
          "content_same": false
        },
        {
          "line": 1719,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "",
          "new_line_content": "\t\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, true)",
          "old_line_content": "\t * Destroy the (relfilelocator, ctid) hashtable, so that we don't leak any",
          "new_line_content": "\t\t\tReorderBufferReturnChange(rb, change, true);",
          "content_same": false
        },
        {
          "line": 3769,
          "old_api": null,
          "new_api": "ReorderBufferSerializeChange",
          "old_text": null,
          "new_text": "ReorderBufferSerializeChange(rb, txn, fd, change)",
          "old_line_content": "\t}",
          "new_line_content": "\t\tReorderBufferSerializeChange(rb, txn, fd, change);",
          "content_same": false
        },
        {
          "line": 3770,
          "old_api": null,
          "new_api": "dlist_delete",
          "old_text": null,
          "new_text": "dlist_delete(&change->node)",
          "old_line_content": "",
          "new_line_content": "\t\tdlist_delete(&change->node);",
          "content_same": false
        },
        {
          "line": 3771,
          "old_api": null,
          "new_api": "ReorderBufferReturnChange",
          "old_text": null,
          "new_text": "ReorderBufferReturnChange(rb, change, false)",
          "old_line_content": "\t/* Update the memory counter */",
          "new_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "content_same": false
        },
        {
          "line": 3777,
          "old_api": null,
          "new_api": "ReorderBufferChangeMemoryUpdate",
          "old_text": null,
          "new_text": "ReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, size)",
          "old_line_content": "\t\trb->spillCount += 1;",
          "new_line_content": "\tReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, size);",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "rbtxn_is_serialized",
          "old_text": null,
          "new_text": "rbtxn_is_serialized(txn)",
          "old_line_content": "\t\t/*",
          "new_line_content": "\tif (rbtxn_is_serialized(txn))",
          "content_same": false
        },
        {
          "line": 3786,
          "old_api": null,
          "new_api": "rbtxn_is_serialized_clear",
          "old_text": null,
          "new_text": "rbtxn_is_serialized_clear(txn)",
          "old_line_content": "",
          "new_line_content": "\t\trb->spillTxns += (rbtxn_is_serialized(txn) || rbtxn_is_serialized_clear(txn)) ? 0 : 1;",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": null,
          "new_api": "ReorderBufferRestoreCleanup",
          "old_text": null,
          "new_text": "ReorderBufferRestoreCleanup(rb, txn)",
          "old_line_content": "\t\t * We need this to accurately update the stats as otherwise the same",
          "new_line_content": "\t\tReorderBufferRestoreCleanup(rb, txn);",
          "content_same": false
        },
        {
          "line": 3789,
          "old_api": null,
          "new_api": "UpdateDecodingStats",
          "old_text": null,
          "new_text": "UpdateDecodingStats((LogicalDecodingContext *) rb->private_data)",
          "old_line_content": "\ttxn->nentries_mem = 0;",
          "new_line_content": "\t\tUpdateDecodingStats((LogicalDecodingContext *) rb->private_data);",
          "content_same": false
        },
        {
          "line": 3792,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(spilled == txn->nentries_mem)",
          "old_line_content": "\tif (fd != -1)",
          "new_line_content": "\tAssert(spilled == txn->nentries_mem);",
          "content_same": false
        },
        {
          "line": 3798,
          "old_api": null,
          "new_api": "CloseTransientFile",
          "old_text": null,
          "new_text": "CloseTransientFile(fd)",
          "old_line_content": " */",
          "new_line_content": "\t\tCloseTransientFile(fd);",
          "content_same": false
        },
        {
          "line": 3811,
          "old_api": null,
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": null,
          "new_text": "ReorderBufferSerializeReserve(rb, sz)",
          "old_line_content": "\tswitch (change->action)",
          "new_line_content": "\tReorderBufferSerializeReserve(rb, sz);",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": null,
          "new_api": "dlist_is_empty",
          "old_text": null,
          "new_text": "dlist_is_empty(&txn->tuplecids)",
          "old_line_content": "\thash_ctl.hcxt = rb->context;",
          "new_line_content": "\tif (!rbtxn_has_catalog_changes(txn) || dlist_is_empty(&txn->tuplecids))",
          "content_same": false
        },
        {
          "line": 3814,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(&ondisk->change, change, sizeof(ReorderBufferChange))",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INSERT:",
          "new_line_content": "\tmemcpy(&ondisk->change, change, sizeof(ReorderBufferChange));",
          "content_same": false
        },
        {
          "line": 1777,
          "old_api": null,
          "new_api": "hash_create",
          "old_text": null,
          "new_text": "hash_create(\"ReorderBufferTupleCid\", txn->ntuplecids, &hash_ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT)",
          "old_line_content": "\t\tReorderBufferTupleCidKey key;",
          "new_line_content": "\t\thash_create(\"ReorderBufferTupleCid\", txn->ntuplecids, &hash_ctl,",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(iter, &txn->tuplecids)",
          "old_line_content": "\t\tReorderBufferChange *change;",
          "new_line_content": "\tdlist_foreach(iter, &txn->tuplecids)",
          "content_same": false
        },
        {
          "line": 1789,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)",
          "old_line_content": "\t\tkey.rlocator = change->data.tuplecid.locator;",
          "new_line_content": "\t\tAssert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "memset",
          "old_text": null,
          "new_text": "memset(&key, 0, sizeof(ReorderBufferTupleCidKey))",
          "old_line_content": "\t\t\t\t\t\t&key.tid);",
          "new_line_content": "\t\tmemset(&key, 0, sizeof(ReorderBufferTupleCidKey));",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "ItemPointerCopy",
          "old_text": null,
          "new_text": "ItemPointerCopy(&change->data.tuplecid.tid,\n\t\t\t\t\t\t&key.tid)",
          "old_line_content": "\t\tif (!found)",
          "new_line_content": "\t\tItemPointerCopy(&change->data.tuplecid.tid,",
          "content_same": false
        },
        {
          "line": 1800,
          "old_api": null,
          "new_api": "hash_search",
          "old_text": null,
          "new_text": "hash_search(txn->tuplecid_hash, &key, HASH_ENTER, &found)",
          "old_line_content": "\t\t\tent->combocid = change->data.tuplecid.combocid;",
          "new_line_content": "\t\t\thash_search(txn->tuplecid_hash, &key, HASH_ENTER, &found);",
          "content_same": false
        },
        {
          "line": 3848,
          "old_api": null,
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": null,
          "new_text": "ReorderBufferSerializeReserve(rb, sz)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "content_same": false
        },
        {
          "line": 3856,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, oldtup, sizeof(HeapTupleData))",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\tmemcpy(data, oldtup, sizeof(HeapTupleData));",
          "content_same": false
        },
        {
          "line": 3859,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, oldtup->t_data, oldlen)",
          "old_line_content": "\t\t\t\t{",
          "new_line_content": "\t\t\t\t\tmemcpy(data, oldtup->t_data, oldlen);",
          "content_same": false
        },
        {
          "line": 1813,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(ent->cmin == change->data.tuplecid.cmin)",
          "old_line_content": "\t\t\t */",
          "new_line_content": "\t\t\tAssert(ent->cmin == change->data.tuplecid.cmin);",
          "content_same": false
        },
        {
          "line": 3865,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, newtup, sizeof(HeapTupleData))",
          "old_line_content": "\t\t\t\t}",
          "new_line_content": "\t\t\t\t\tmemcpy(data, newtup, sizeof(HeapTupleData));",
          "content_same": false
        },
        {
          "line": 1819,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert((ent->cmax == InvalidCommandId) ||\n\t\t\t\t   ((change->data.tuplecid.cmax != InvalidCommandId) &&\n\t\t\t\t\t(change->data.tuplecid.cmax > ent->cmax)))",
          "old_line_content": "\t}",
          "new_line_content": "\t\t\tAssert((ent->cmax == InvalidCommandId) ||",
          "content_same": false
        },
        {
          "line": 3868,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, newtup->t_data, newlen)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_MESSAGE:",
          "new_line_content": "\t\t\t\t\tmemcpy(data, newtup->t_data, newlen);",
          "content_same": false
        },
        {
          "line": 3876,
          "old_api": null,
          "new_api": "strlen",
          "old_text": null,
          "new_text": "strlen(change->data.msg.prefix)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tSize\t\tprefix_size = strlen(change->data.msg.prefix) + 1;",
          "content_same": false
        },
        {
          "line": 3880,
          "old_api": null,
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": null,
          "new_text": "ReorderBufferSerializeReserve(rb, sz)",
          "old_line_content": "\t\t\t\tondisk = (ReorderBufferDiskChange *) rb->outbuf;",
          "new_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "content_same": false
        },
        {
          "line": 3888,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, &prefix_size, sizeof(Size))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tmemcpy(data, &prefix_size, sizeof(Size));",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": null,
          "new_api": "MemoryContextAllocZero",
          "old_text": null,
          "new_text": "MemoryContextAllocZero(rb->context, size)",
          "old_line_content": "\tsnap->regd_count = 0;",
          "new_line_content": "\tsnap = MemoryContextAllocZero(rb->context, size);",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(snap, orig_snap, sizeof(SnapshotData))",
          "old_line_content": "\tsnap->xip = (TransactionId *) (snap + 1);",
          "new_line_content": "\tmemcpy(snap, orig_snap, sizeof(SnapshotData));",
          "content_same": false
        },
        {
          "line": 3895,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, &change->data.msg.message_size, sizeof(Size))",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tmemcpy(data, &change->data.msg.message_size, sizeof(Size));",
          "content_same": false
        },
        {
          "line": 3897,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, change->data.msg.message,\n\t\t\t\t\t   change->data.msg.message_size)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\tmemcpy(data, change->data.msg.message,",
          "content_same": false
        },
        {
          "line": 1853,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(snap->xip, orig_snap->xip, sizeof(TransactionId) * snap->xcnt)",
          "old_line_content": "\t * transaction in there as well.",
          "new_line_content": "\tmemcpy(snap->xip, orig_snap->xip, sizeof(TransactionId) * snap->xcnt);",
          "content_same": false
        },
        {
          "line": 3916,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, change->data.inval.invalidations, inval_size)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT:",
          "new_line_content": "\t\t\t\tmemcpy(data, change->data.inval.invalidations, inval_size);",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "dlist_foreach",
          "old_text": null,
          "new_text": "dlist_foreach(iter, &txn->subtxns)",
          "old_line_content": "\t\tsnap->subxip[i++] = sub_txn->xid;",
          "new_line_content": "\tdlist_foreach(iter, &txn->subtxns)",
          "content_same": false
        },
        {
          "line": 1874,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, iter.cur)",
          "old_line_content": "\t/* sort so we can bsearch() later */",
          "new_line_content": "\t\tsub_txn = dlist_container(ReorderBufferTXN, node, iter.cur);",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": null,
          "new_api": "qsort",
          "old_text": null,
          "new_text": "qsort(snap->subxip, snap->subxcnt, sizeof(TransactionId), xidComparator)",
          "old_line_content": "\treturn snap;",
          "new_line_content": "\tqsort(snap->subxip, snap->subxcnt, sizeof(TransactionId), xidComparator);",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": null,
          "new_api": "pfree",
          "old_text": null,
          "new_text": "pfree(snap)",
          "old_line_content": "/*",
          "new_line_content": "\t\tpfree(snap);",
          "content_same": false
        },
        {
          "line": 3943,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, snap->xip,\n\t\t\t\t\t\t   sizeof(TransactionId) * snap->xcnt)",
          "old_line_content": "\t\t\t\tif (snap->subxcnt)",
          "new_line_content": "\t\t\t\t\tmemcpy(data, snap->xip,",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": null,
          "new_api": "SnapBuildSnapDecRefcount",
          "old_text": null,
          "new_text": "SnapBuildSnapDecRefcount(snap)",
          "old_line_content": " * it in a 'streamed' way.  That is, we first stream the remaining part of the",
          "new_line_content": "\t\tSnapBuildSnapDecRefcount(snap);",
          "content_same": false
        },
        {
          "line": 3950,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, snap->subxip,\n\t\t\t\t\t\t   sizeof(TransactionId) * snap->subxcnt)",
          "old_line_content": "\t\t\t}",
          "new_line_content": "\t\t\t\t\tmemcpy(data, snap->subxip,",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": null,
          "new_api": "rbtxn_is_streamed",
          "old_text": null,
          "new_text": "rbtxn_is_streamed(txn)",
          "old_line_content": "\t{",
          "new_line_content": "\tAssert(rbtxn_is_streamed(txn));",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": null,
          "new_api": "ReorderBufferStreamTXN",
          "old_text": null,
          "new_text": "ReorderBufferStreamTXN(rb, txn)",
          "old_line_content": "\t\t * Note, we send stream prepare even if a concurrent abort is",
          "new_line_content": "\tReorderBufferStreamTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": null,
          "new_api": "rbtxn_prepared",
          "old_text": null,
          "new_text": "rbtxn_prepared(txn)",
          "old_line_content": "\t\t */",
          "new_line_content": "\tif (rbtxn_prepared(txn))",
          "content_same": false
        },
        {
          "line": 3966,
          "old_api": null,
          "new_api": "ReorderBufferSerializeReserve",
          "old_text": null,
          "new_text": "ReorderBufferSerializeReserve(rb, sz)",
          "old_line_content": "",
          "new_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": null,
          "new_api": "stream_prepare",
          "old_text": null,
          "new_text": "rb->stream_prepare(rb, txn, txn->final_lsn)",
          "old_line_content": "\t\t * just truncate txn by removing changes and tuplecids.",
          "new_line_content": "\t\trb->stream_prepare(rb, txn, txn->final_lsn);",
          "content_same": false
        },
        {
          "line": 3972,
          "old_api": null,
          "new_api": "memcpy",
          "old_text": null,
          "new_text": "memcpy(data, change->data.truncate.relids, size)",
          "old_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:",
          "new_line_content": "\t\t\t\tmemcpy(data, change->data.truncate.relids, size);",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": null,
          "new_api": "ReorderBufferTruncateTXN",
          "old_text": null,
          "new_text": "ReorderBufferTruncateTXN(rb, txn, true)",
          "old_line_content": "\t{",
          "new_line_content": "\t\tReorderBufferTruncateTXN(rb, txn, true);",
          "content_same": false
        },
        {
          "line": 1933,
          "old_api": null,
          "new_api": "stream_commit",
          "old_text": null,
          "new_text": "rb->stream_commit(rb, txn, txn->final_lsn)",
          "old_line_content": "/*",
          "new_line_content": "\t\trb->stream_commit(rb, txn, txn->final_lsn);",
          "content_same": false
        },
        {
          "line": 1934,
          "old_api": null,
          "new_api": "ReorderBufferCleanupTXN",
          "old_text": null,
          "new_text": "ReorderBufferCleanupTXN(rb, txn)",
          "old_line_content": " * Set xid to detect concurrent aborts.",
          "new_line_content": "\t\tReorderBufferCleanupTXN(rb, txn);",
          "content_same": false
        },
        {
          "line": 3989,
          "old_api": null,
          "new_api": "write",
          "old_text": null,
          "new_text": "write(fd, rb->outbuf, ondisk->size)",
          "old_line_content": "",
          "new_line_content": "\tif (write(fd, rb->outbuf, ondisk->size) != ondisk->size)",
          "content_same": false
        },
        {
          "line": 3998,
          "old_api": null,
          "new_api": "errcode_for_file_access",
          "old_text": null,
          "new_text": "errcode_for_file_access()",
          "old_line_content": "",
          "new_line_content": "\t\t\t\t(errcode_for_file_access(),",
          "content_same": false
        },
        {
          "line": 3999,
          "old_api": null,
          "new_api": "errmsg",
          "old_text": null,
          "new_text": "errmsg(\"could not write to data file for XID %u: %m\",\n\t\t\t\t\t\ttxn->xid)",
          "old_line_content": "\t/*",
          "new_line_content": "\t\t\t\t errmsg(\"could not write to data file for XID %u: %m\",",
          "content_same": false
        },
        {
          "line": 4002,
          "old_api": null,
          "new_api": "pgstat_report_wait_end",
          "old_text": null,
          "new_text": "pgstat_report_wait_end()",
          "old_line_content": "\t * only do this on commit and abort records, but that doesn't work if a",
          "new_line_content": "\tpgstat_report_wait_end();",
          "content_same": false
        },
        {
          "line": 4015,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(ondisk->change.action == change->action)",
          "old_line_content": "ReorderBufferCanStream(ReorderBuffer *rb)",
          "new_line_content": "\tAssert(ondisk->change.action == change->action);",
          "content_same": false
        },
        {
          "line": 1977,
          "old_api": null,
          "new_api": "TransactionIdEquals",
          "old_text": null,
          "new_text": "TransactionIdEquals(CheckXidAlive, xid)",
          "old_line_content": "\t * xid is aborted.  That will happen during catalog access.",
          "new_line_content": "\tif (TransactionIdEquals(CheckXidAlive, xid))",
          "content_same": false
        },
        {
          "line": 1984,
          "old_api": null,
          "new_api": "TransactionIdDidCommit",
          "old_text": null,
          "new_text": "TransactionIdDidCommit(xid)",
          "old_line_content": "",
          "new_line_content": "\tif (!TransactionIdDidCommit(xid))",
          "content_same": false
        },
        {
          "line": 4035,
          "old_api": null,
          "new_api": "SnapBuildCurrentState",
          "old_text": null,
          "new_text": "SnapBuildCurrentState(builder)",
          "old_line_content": "\t * because we previously decoded this transaction and now just are",
          "new_line_content": "\tif (SnapBuildCurrentState(builder) < SNAPBUILD_CONSISTENT)",
          "content_same": false
        },
        {
          "line": 4043,
          "old_api": null,
          "new_api": "ReorderBufferCanStream",
          "old_text": null,
          "new_text": "ReorderBufferCanStream(rb)",
          "old_line_content": "}",
          "new_line_content": "\tif (ReorderBufferCanStream(rb) &&",
          "content_same": false
        },
        {
          "line": 4044,
          "old_api": null,
          "new_api": "SnapBuildXactNeedsSkip",
          "old_text": null,
          "new_text": "SnapBuildXactNeedsSkip(builder, ctx->reader->ReadRecPtr)",
          "old_line_content": "",
          "new_line_content": "\t\t!SnapBuildXactNeedsSkip(builder, ctx->reader->ReadRecPtr))",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "stream_change",
          "old_text": null,
          "new_text": "rb->stream_change(rb, txn, relation, change)",
          "old_line_content": "/*",
          "new_line_content": "\t\trb->stream_change(rb, txn, relation, change);",
          "content_same": false
        },
        {
          "line": 2001,
          "old_api": null,
          "new_api": "apply_change",
          "old_text": null,
          "new_text": "rb->apply_change(rb, txn, relation, change)",
          "old_line_content": " */",
          "new_line_content": "\t\trb->apply_change(rb, txn, relation, change);",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": null,
          "new_api": "stream_truncate",
          "old_text": null,
          "new_text": "rb->stream_truncate(rb, txn, nrelations, relations, change)",
          "old_line_content": "/*",
          "new_line_content": "\t\trb->stream_truncate(rb, txn, nrelations, relations, change);",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": null,
          "new_api": "apply_truncate",
          "old_text": null,
          "new_text": "rb->apply_truncate(rb, txn, nrelations, relations, change)",
          "old_line_content": " */",
          "new_line_content": "\t\trb->apply_truncate(rb, txn, nrelations, relations, change);",
          "content_same": false
        },
        {
          "line": 4063,
          "old_api": null,
          "new_api": "rbtxn_is_toptxn",
          "old_text": null,
          "new_text": "rbtxn_is_toptxn(txn)",
          "old_line_content": "\t * transferred from subxact in ReorderBufferCommitChild(), but that was",
          "new_line_content": "\tAssert(rbtxn_is_toptxn(txn));",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "message",
          "old_text": null,
          "new_text": "rb->message(rb, txn, change->lsn, true,\n\t\t\t\t\tchange->data.msg.prefix,\n\t\t\t\t\tchange->data.msg.message_size,\n\t\t\t\t\tchange->data.msg.message)",
          "old_line_content": "",
          "new_line_content": "\t\trb->message(rb, txn, change->lsn, true,",
          "content_same": false
        },
        {
          "line": 4089,
          "old_api": null,
          "new_api": "Assert",
          "old_text": null,
          "new_text": "Assert(txn->command_id == InvalidCommandId)",
          "old_line_content": "",
          "new_line_content": "\t\tAssert(txn->command_id == InvalidCommandId);",
          "content_same": false
        },
        {
          "line": 4095,
          "old_api": null,
          "new_api": "dlist_container",
          "old_text": null,
          "new_text": "dlist_container(ReorderBufferTXN, node, subxact_i.cur)",
          "old_line_content": "\t\t * If this transaction has no snapshot, it didn't make any changes to",
          "new_line_content": "\t\t\tsubtxn = dlist_container(ReorderBufferTXN, node, subxact_i.cur);",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 4100,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->ninvalidations == 0)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(txn->ninvalidations == 0);",
          "new_line_content": "\t\t * If this transaction has no snapshot, it didn't make any changes to",
          "content_same": false
        },
        {
          "line": 4111,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(rbtxn_is_streamed(txn));",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t txn, command_id);",
          "content_same": false
        },
        {
          "line": 2065,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferTruncateTXN(rb, txn, rbtxn_prepared(txn));",
          "new_line_content": "\t\t\t\t\t  CommandId command_id,",
          "content_same": false
        },
        {
          "line": 2068,
          "old_api": "ReorderBufferToastReset",
          "new_api": null,
          "old_text": "ReorderBufferToastReset(rb, txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferToastReset(rb, txn);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4127,
          "old_api": "ReorderBufferCopySnap",
          "new_api": null,
          "old_text": "ReorderBufferCopySnap(rb, txn->snapshot_now,\n\t\t\t\t\t\t\t\t\t\t\t txn, command_id)",
          "new_text": null,
          "old_line_content": "\t\tsnapshot_now = ReorderBufferCopySnap(rb, txn->snapshot_now,",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_streamed(txn))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2083,
          "old_api": "stream_stop",
          "new_api": null,
          "old_text": "rb->stream_stop(rb, txn, last_lsn)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_stop(rb, txn, last_lsn);",
          "new_line_content": "\t * For the streaming case, stop the stream and remember the command ID and",
          "content_same": false
        },
        {
          "line": 2084,
          "old_api": "ReorderBufferSaveTXNSnapshot",
          "new_api": null,
          "old_text": "ReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id);",
          "new_line_content": "\t * snapshot for the streaming run.",
          "content_same": false
        },
        {
          "line": 4131,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->snapshot_now->copied)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->snapshot_now->copied);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4142,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\ttxn_is_streamed = rbtxn_is_streamed(txn);",
          "new_line_content": "\t * Remember this information to be used later to update stats. We can't",
          "content_same": false
        },
        {
          "line": 4146,
          "old_api": "ReorderBufferProcessTXN",
          "new_api": null,
          "old_text": "ReorderBufferProcessTXN(rb, txn, InvalidXLogRecPtr, snapshot_now,\n\t\t\t\t\t\t\tcommand_id, true)",
          "new_text": null,
          "old_line_content": "\tReorderBufferProcessTXN(rb, txn, InvalidXLogRecPtr, snapshot_now,",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 4156,
          "old_api": "UpdateDecodingStats",
          "new_api": null,
          "old_text": "UpdateDecodingStats((LogicalDecodingContext *) rb->private_data)",
          "new_text": null,
          "old_line_content": "\tUpdateDecodingStats((LogicalDecodingContext *) rb->private_data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4158,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&txn->changes)",
          "new_text": null,
          "old_line_content": "\tAssert(dlist_is_empty(&txn->changes));",
          "new_line_content": "\trb->streamTxns += (txn_is_streamed) ? 0 : 1;",
          "content_same": false
        },
        {
          "line": 4159,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->nentries == 0)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->nentries == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4160,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->nentries_mem == 0)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->nentries_mem == 0);",
          "new_line_content": "\t/* update the decoding stats */",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": "ReorderBufferBuildTupleCidHash",
          "new_api": null,
          "old_text": "ReorderBufferBuildTupleCidHash(rb, txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferBuildTupleCidHash(rb, txn);",
          "new_line_content": "\tReorderBufferChange *volatile specinsert = NULL;",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "SetupHistoricSnapshot",
          "new_api": null,
          "old_text": "SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash)",
          "new_text": null,
          "old_line_content": "\tSetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "IsTransactionOrTransactionBlock",
          "new_api": null,
          "old_text": "IsTransactionOrTransactionBlock()",
          "new_text": null,
          "old_line_content": "\tusing_subtxn = IsTransactionOrTransactionBlock();",
          "new_line_content": "\t * to the database by checking for xid assignments.",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": "PG_TRY",
          "new_api": null,
          "old_text": "PG_TRY()",
          "new_text": null,
          "old_line_content": "\tPG_TRY();",
          "new_line_content": "\t * When we're called via the SQL SRF there's already a transaction",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "BeginInternalSubTransaction",
          "new_api": null,
          "old_text": "BeginInternalSubTransaction(streaming ? \"stream\" : \"replay\")",
          "new_text": null,
          "old_line_content": "\t\t\tBeginInternalSubTransaction(streaming ? \"stream\" : \"replay\");",
          "new_line_content": "\t\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "StartTransactionCommand",
          "new_api": null,
          "old_text": "StartTransactionCommand()",
          "new_text": null,
          "old_line_content": "\t\t\tStartTransactionCommand();",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t * changes */",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\t\t\tif (rbtxn_prepared(txn))",
          "new_line_content": "\t\t * We only need to send begin/begin-prepare for non-streamed",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": "begin_prepare",
          "new_api": null,
          "old_text": "rb->begin_prepare(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->begin_prepare(rb, txn);",
          "new_line_content": "\t\t * transactions.",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "begin",
          "new_api": null,
          "old_text": "rb->begin(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->begin(rb, txn);",
          "new_line_content": "\t\tif (!streaming)",
          "content_same": false
        },
        {
          "line": 4205,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(change->data.msg.prefix)",
          "new_text": null,
          "old_line_content": "\t\t\t\tSize\t\tprefix_size = strlen(change->data.msg.prefix) + 1;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "ReorderBufferIterTXNNext",
          "new_api": null,
          "old_text": "ReorderBufferIterTXNNext(rb, iterstate)",
          "new_text": null,
          "old_line_content": "\t\twhile ((change = ReorderBufferIterTXNNext(rb, iterstate)) != NULL)",
          "new_line_content": "\t\t\telse",
          "content_same": false
        },
        {
          "line": 2176,
          "old_api": "stream_start",
          "new_api": null,
          "old_text": "rb->stream_start(rb, txn, change->lsn)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\trb->stream_start(rb, txn, change->lsn);",
          "new_line_content": "\t\t\tif (prev_lsn == InvalidXLogRecPtr)",
          "content_same": false
        },
        {
          "line": 2186,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(prev_lsn == InvalidXLogRecPtr || prev_lsn <= change->lsn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(prev_lsn == InvalidXLogRecPtr || prev_lsn <= change->lsn);",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(change->txn)",
          "new_text": null,
          "old_line_content": "\t\t\tif (streaming || rbtxn_prepared(change->txn))",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 2198,
          "old_api": "SetupCheckXidLive",
          "new_api": null,
          "old_text": "SetupCheckXidLive(curtxn->xid)",
          "new_text": null,
          "old_line_content": "\t\t\t\tSetupCheckXidLive(curtxn->xid);",
          "new_line_content": "\t\t\t * COMMIT record is processed.",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"invalid ordering of speculative insertion changes\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\telog(ERROR, \"invalid ordering of speculative insertion changes\");",
          "new_line_content": "\t\t\t\t\t * Confirmation for speculative insertion arrived. Simply",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(specinsert->data.tp.oldtuple == NULL)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(specinsert->data.tp.oldtuple == NULL);",
          "new_line_content": "\t\t\t\t\t * use as a normal record. It'll be cleaned up at the end",
          "content_same": false
        },
        {
          "line": 4260,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\tSize\t\trestored = 0;",
          "content_same": false
        },
        {
          "line": 4261,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\tXLogSegNo\tlast_segno;",
          "content_same": false
        },
        {
          "line": 4264,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(cleanup_iter, &txn->changes)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(cleanup_iter, &txn->changes)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4267,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, cleanup_iter.cur)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_container(ReorderBufferChange, node, cleanup_iter.cur);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(snapshot_now)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(snapshot_now);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": "RelidByRelfilenumber",
          "new_api": null,
          "old_text": "RelidByRelfilenumber(change->data.tp.rlocator.spcOid,\n\t\t\t\t\t\t\t\t\t\t\t\t  change->data.tp.rlocator.relNumber)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\treloid = RelidByRelfilenumber(change->data.tp.rlocator.spcOid,",
          "new_line_content": "\t\t\t\tcase REORDER_BUFFER_CHANGE_INSERT:",
          "content_same": false
        },
        {
          "line": 4270,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, cleanup, true)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, cleanup, true);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 4273,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&txn->changes)",
          "new_text": null,
          "old_line_content": "\tAssert(dlist_is_empty(&txn->changes));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4282,
          "old_api": "CHECK_FOR_INTERRUPTS",
          "new_api": null,
          "old_text": "CHECK_FOR_INTERRUPTS()",
          "new_text": null,
          "old_line_content": "\t\tCHECK_FOR_INTERRUPTS();",
          "new_line_content": "\twhile (restored < max_changes_in_memory && *segno <= last_segno)",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"could not map filenumber \\\"%s\\\" to relation OID\",\n\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\telog(ERROR, \"could not map filenumber \\\"%s\\\" to relation OID\",",
          "new_line_content": "\t\t\t\t\tif (reloid == InvalidOid &&",
          "content_same": false
        },
        {
          "line": 2243,
          "old_api": "relpathperm",
          "new_api": null,
          "old_text": "relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,",
          "new_line_content": "\t\t\t\t\t\tchange->data.tp.newtuple == NULL &&",
          "content_same": false
        },
        {
          "line": 4290,
          "old_api": "XLByteToSeg",
          "new_api": null,
          "old_text": "XLByteToSeg(txn->first_lsn, *segno, wal_segment_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tXLByteToSeg(txn->first_lsn, *segno, wal_segment_size);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 4292,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&txn->changes)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(*segno != 0 || dlist_is_empty(&txn->changes));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2246,
          "old_api": "RelationIdGetRelation",
          "new_api": null,
          "old_text": "RelationIdGetRelation(reloid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\trelation = RelationIdGetRelation(reloid);",
          "new_line_content": "\t\t\t\t\telse if (reloid == InvalidOid)",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"could not open relation with OID %u (for filenumber \\\"%s\\\")\",\n\t\t\t\t\t\t\t reloid,\n\t\t\t\t\t\t\t relpathperm(change->data.tp.rlocator,\n\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\telog(ERROR, \"could not open relation with OID %u (for filenumber \\\"%s\\\")\",",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t MAIN_FORKNUM));",
          "content_same": false
        },
        {
          "line": 4298,
          "old_api": "ReorderBufferSerializedPath",
          "new_api": null,
          "old_text": "ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,\n\t\t\t\t\t\t\t\t\t\t*segno)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4301,
          "old_api": "PathNameOpenFile",
          "new_api": null,
          "old_text": "PathNameOpenFile(path, O_RDONLY | PG_BINARY)",
          "new_text": null,
          "old_line_content": "\t\t\t*fd = PathNameOpenFile(path, O_RDONLY | PG_BINARY);",
          "new_line_content": "\t\t\t * so each LSN only maps to a specific WAL record.",
          "content_same": false
        },
        {
          "line": 4313,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tpath)))",
          "new_text": null,
          "old_line_content": "\t\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t\t*fd = -1;",
          "content_same": false
        },
        {
          "line": 4314,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\t\t(*segno)++;",
          "content_same": false
        },
        {
          "line": 4315,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not open file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\t\tpath)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\",",
          "new_line_content": "\t\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 2274,
          "old_api": "IsToastRelation",
          "new_api": null,
          "old_text": "IsToastRelation(relation)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (!IsToastRelation(relation))",
          "new_line_content": "\t\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": "ReorderBufferToastReplace",
          "new_api": null,
          "old_text": "ReorderBufferToastReplace(rb, txn, relation, change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferToastReplace(rb, txn, relation, change);",
          "new_line_content": "\t\t\t\t\t\tgoto change_done;",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "ReorderBufferApplyChange",
          "new_api": null,
          "old_text": "ReorderBufferApplyChange(rb, txn, relation, change,\n\t\t\t\t\t\t\t\t\t\t\t\t streaming)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferApplyChange(rb, txn, relation, change,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4324,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange))",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferSerializeReserve(rb, sizeof(ReorderBufferDiskChange));",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 4325,
          "old_api": "FileRead",
          "new_api": null,
          "old_text": "FileRead(file->vfd, rb->outbuf,\n\t\t\t\t\t\t\t sizeof(ReorderBufferDiskChange),\n\t\t\t\t\t\t\t file->curOffset, WAIT_EVENT_REORDER_BUFFER_READ)",
          "new_text": null,
          "old_line_content": "\t\treadBytes = FileRead(file->vfd, rb->outbuf,",
          "new_line_content": "\t\t * Read the statically sized part of a change which has information",
          "content_same": false
        },
        {
          "line": 4332,
          "old_api": "FileClose",
          "new_api": null,
          "old_text": "FileClose(*fd)",
          "new_text": null,
          "old_line_content": "\t\t\tFileClose(*fd);",
          "new_line_content": "\t\t\t\t\t\t\t file->curOffset, WAIT_EVENT_REORDER_BUFFER_READ);",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "ReorderBufferToastReset",
          "new_api": null,
          "old_text": "ReorderBufferToastReset(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tReorderBufferToastReset(rb, txn);",
          "new_line_content": "\t\t\t\t\t\t * Only clear reassembled toast chunks if we're sure",
          "content_same": false
        },
        {
          "line": 4338,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t*fd = -1;",
          "content_same": false
        },
        {
          "line": 4339,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\t(*segno)++;",
          "content_same": false
        },
        {
          "line": 4340,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not read from reorderbuffer spill file: %m\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")));",
          "new_line_content": "\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 4342,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) sizeof(ReorderBufferDiskChange))))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\telse if (readBytes < 0)",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->data.tp.newtuple != NULL)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(change->data.tp.newtuple != NULL);",
          "new_line_content": "\t\t\t\t\t\t * we're done remove it from the list of this",
          "content_same": false
        },
        {
          "line": 2301,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&change->node)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tdlist_delete(&change->node);",
          "new_line_content": "\t\t\t\t\t\t * freed/reused while restoring spooled data from",
          "content_same": false
        },
        {
          "line": 2302,
          "old_api": "ReorderBufferToastAppendChunk",
          "new_api": null,
          "old_text": "ReorderBufferToastAppendChunk(rb, txn, relation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferToastAppendChunk(rb, txn, relation,",
          "new_line_content": "\t\t\t\t\t\t * disk.",
          "content_same": false
        },
        {
          "line": 4352,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb,\n\t\t\t\t\t\t\t\t\t  sizeof(ReorderBufferDiskChange) + ondisk->size)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferSerializeReserve(rb,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4356,
          "old_api": "FileRead",
          "new_api": null,
          "old_text": "FileRead(file->vfd,\n\t\t\t\t\t\t\t rb->outbuf + sizeof(ReorderBufferDiskChange),\n\t\t\t\t\t\t\t ondisk->size - sizeof(ReorderBufferDiskChange),\n\t\t\t\t\t\t\t file->curOffset,\n\t\t\t\t\t\t\t WAIT_EVENT_REORDER_BUFFER_READ)",
          "new_text": null,
          "old_line_content": "\t\treadBytes = FileRead(file->vfd,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "new_line_content": "\t\t\t\t\t * If speculative insertion was confirmed, the record",
          "content_same": false
        },
        {
          "line": 4363,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t\t\t\t\t ondisk->size - sizeof(ReorderBufferDiskChange),",
          "content_same": false
        },
        {
          "line": 4364,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\t\t\t\t\t file->curOffset,",
          "content_same": false
        },
        {
          "line": 4365,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not read from reorderbuffer spill file: %m\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: %m\")));",
          "new_line_content": "\t\t\t\t\t\t\t WAIT_EVENT_REORDER_BUFFER_READ);",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "RelationIsValid",
          "new_api": null,
          "old_text": "RelationIsValid(relation)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tif (RelationIsValid(relation))",
          "new_line_content": "\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 4367,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not read from reorderbuffer spill file: read %d instead of %u bytes\",\n\t\t\t\t\t\t\treadBytes,\n\t\t\t\t\t\t\t(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t\tif (readBytes < 0)",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": "RelationClose",
          "new_api": null,
          "old_text": "RelationClose(relation)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tRelationClose(relation);",
          "new_line_content": "\t\t\t\t\t\tspecinsert = NULL;",
          "content_same": false
        },
        {
          "line": 4371,
          "old_api": "uint32) (ondisk->size - sizeof(ReorderBufferDiskChange))",
          "new_api": null,
          "old_text": "uint32) (ondisk->size - sizeof(ReorderBufferDiskChange))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t(uint32) (ondisk->size - sizeof(ReorderBufferDiskChange)))));",
          "new_line_content": "\t\telse if (readBytes != ondisk->size - sizeof(ReorderBufferDiskChange))",
          "content_same": false
        },
        {
          "line": 4379,
          "old_api": "ReorderBufferRestoreChange",
          "new_api": null,
          "old_text": "ReorderBufferRestoreChange(rb, txn, rb->outbuf)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferRestoreChange(rb, txn, rb->outbuf);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2343,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "new_line_content": "\t\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 4403,
          "old_api": "ReorderBufferGetChange",
          "new_api": null,
          "old_text": "ReorderBufferGetChange(rb)",
          "new_text": null,
          "old_line_content": "\tchange = ReorderBufferGetChange(rb);",
          "new_line_content": "\tReorderBufferDiskChange *ondisk;",
          "content_same": false
        },
        {
          "line": 4406,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change, &ondisk->change, sizeof(ReorderBufferChange))",
          "new_text": null,
          "old_line_content": "\tmemcpy(change, &ondisk->change, sizeof(ReorderBufferChange));",
          "new_line_content": "\tondisk = (ReorderBufferDiskChange *) data;",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->data.tp.clear_toast_afterwards)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tAssert(change->data.tp.clear_toast_afterwards);",
          "new_line_content": "\t\t\t\t\t\t/*",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": "ReorderBufferToastReset",
          "new_api": null,
          "old_text": "ReorderBufferToastReset(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferToastReset(rb, txn);",
          "new_line_content": "\t\t\t\t\t\t * We must clean the toast hash before processing a",
          "content_same": false
        },
        {
          "line": 2373,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, specinsert, true)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferReturnChange(rb, specinsert, true);",
          "new_line_content": "\t\t\t\t\t\t */",
          "content_same": false
        },
        {
          "line": 4423,
          "old_api": "ReorderBufferGetTupleBuf",
          "new_api": null,
          "old_text": "ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);",
          "new_line_content": "\t\t\tif (change->data.tp.oldtuple)",
          "content_same": false
        },
        {
          "line": 4426,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.tp.oldtuple, data,\n\t\t\t\t\t   sizeof(HeapTupleData))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.tp.oldtuple, data,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4432,
          "old_api": "HeapTupleHeader) ((char *) change->data.tp.oldtuple + HEAPTUPLESIZE)",
          "new_api": null,
          "old_text": "HeapTupleHeader) ((char *) change->data.tp.oldtuple + HEAPTUPLESIZE)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(HeapTupleHeader) ((char *) change->data.tp.oldtuple + HEAPTUPLESIZE);",
          "new_line_content": "\t\t\t\t\t   sizeof(HeapTupleData));",
          "content_same": false
        },
        {
          "line": 2385,
          "old_api": "palloc0",
          "new_api": null,
          "old_text": "palloc0(nrelids * sizeof(Relation))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\trelations = palloc0(nrelids * sizeof(Relation));",
          "new_line_content": "\t\t\t\t\t\tint\t\t\ti;",
          "content_same": false
        },
        {
          "line": 4435,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.tp.oldtuple->t_data, data, tuplelen)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.tp.oldtuple->t_data, data, tuplelen);",
          "new_line_content": "\t\t\t\t/* reset t_data pointer into the new tuplebuf */",
          "content_same": false
        },
        {
          "line": 2391,
          "old_api": "RelationIdGetRelation",
          "new_api": null,
          "old_text": "RelationIdGetRelation(relid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\trel = RelationIdGetRelation(relid);",
          "new_line_content": "\t\t\t\t\t\tfor (i = 0; i < nrelids; i++)",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "GenerationContextCreate",
          "new_api": null,
          "old_text": "GenerationContextCreate(new_ctx,\n\t\t\t\t\t\t\t\t\t\t\t\t  \"Tuples\",\n\t\t\t\t\t\t\t\t\t\t\t\t  SLAB_LARGE_BLOCK_SIZE,\n\t\t\t\t\t\t\t\t\t\t\t\t  SLAB_LARGE_BLOCK_SIZE,\n\t\t\t\t\t\t\t\t\t\t\t\t  SLAB_LARGE_BLOCK_SIZE)",
          "new_text": null,
          "old_line_content": "\tbuffer->tup_context = GenerationContextCreate(new_ctx,",
          "new_line_content": "\t * decoding performance without causing fragmentation due to concurrent",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "RelationIsValid",
          "new_api": null,
          "old_text": "RelationIsValid(rel)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tif (!RelationIsValid(rel))",
          "new_line_content": "\t\t\t\t\t\t\tOid\t\t\trelid = change->data.truncate.relids[i];",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"could not open relation with OID %u\", relid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\telog(ERROR, \"could not open relation with OID %u\", relid);",
          "new_line_content": "\t\t\t\t\t\t\tRelation\trel;",
          "content_same": false
        },
        {
          "line": 4444,
          "old_api": "offsetof",
          "new_api": null,
          "old_text": "offsetof(HeapTupleData, t_len)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(&tuplelen, data + offsetof(HeapTupleData, t_len),",
          "new_line_content": "\t\t\tif (change->data.tp.newtuple)",
          "content_same": false
        },
        {
          "line": 4448,
          "old_api": "ReorderBufferGetTupleBuf",
          "new_api": null,
          "old_text": "ReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tReorderBufferGetTupleBuf(rb, tuplelen - SizeofHeapTupleHeader);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 354,
          "old_api": "hash_create",
          "new_api": null,
          "old_text": "hash_create(\"ReorderBufferByXid\", 1000, &hash_ctl,\n\t\t\t\t\t\t\t\t HASH_ELEM | HASH_BLOBS | HASH_CONTEXT)",
          "new_text": null,
          "old_line_content": "\tbuffer->by_txn = hash_create(\"ReorderBufferByXid\", 1000, &hash_ctl,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2403,
          "old_api": "ReorderBufferApplyTruncate",
          "new_api": null,
          "old_text": "ReorderBufferApplyTruncate(rb, txn, nrelations,\n\t\t\t\t\t\t\t\t\t\t\t\t   relations, change,\n\t\t\t\t\t\t\t\t\t\t\t\t   streaming)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferApplyTruncate(rb, txn, nrelations,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4451,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.tp.newtuple, data,\n\t\t\t\t\t   sizeof(HeapTupleData))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.tp.newtuple, data,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4457,
          "old_api": "HeapTupleHeader) ((char *) change->data.tp.newtuple + HEAPTUPLESIZE)",
          "new_api": null,
          "old_text": "HeapTupleHeader) ((char *) change->data.tp.newtuple + HEAPTUPLESIZE)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(HeapTupleHeader) ((char *) change->data.tp.newtuple + HEAPTUPLESIZE);",
          "new_line_content": "\t\t\t\t\t   sizeof(HeapTupleData));",
          "content_same": false
        },
        {
          "line": 4460,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.tp.newtuple->t_data, data, tuplelen)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.tp.newtuple->t_data, data, tuplelen);",
          "new_line_content": "\t\t\t\t/* reset t_data pointer into the new tuplebuf */",
          "content_same": false
        },
        {
          "line": 365,
          "old_api": "pairingheap_allocate",
          "new_api": null,
          "old_text": "pairingheap_allocate(ReorderBufferTXNSizeCompare, NULL)",
          "new_text": null,
          "old_line_content": "\tbuffer->txn_heap = pairingheap_allocate(ReorderBufferTXNSizeCompare, NULL);",
          "new_line_content": "\tbuffer->outbuf = NULL;",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": "ReorderBufferApplyMessage",
          "new_api": null,
          "old_text": "ReorderBufferApplyMessage(rb, txn, change, streaming)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tReorderBufferApplyMessage(rb, txn, change, streaming);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4470,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&prefix_size, data, sizeof(Size))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(&prefix_size, data, sizeof(Size));",
          "new_line_content": "\t\tcase REORDER_BUFFER_CHANGE_MESSAGE:",
          "content_same": false
        },
        {
          "line": 4472,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t prefix_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tchange->data.msg.prefix = MemoryContextAlloc(rb->context,",
          "new_line_content": "\t\t\t\tSize\t\tprefix_size;",
          "content_same": false
        },
        {
          "line": 2425,
          "old_api": "TeardownHistoricSnapshot",
          "new_api": null,
          "old_text": "TeardownHistoricSnapshot(false)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tTeardownHistoricSnapshot(false);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\t  change->data.inval.invalidations);",
          "content_same": false
        },
        {
          "line": 378,
          "old_api": "dlist_init",
          "new_api": null,
          "old_text": "dlist_init(&buffer->toplevel_by_lsn)",
          "new_text": null,
          "old_line_content": "\tdlist_init(&buffer->toplevel_by_lsn);",
          "new_line_content": "\tbuffer->totalTxns = 0;",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": "dlist_init",
          "new_api": null,
          "old_text": "dlist_init(&buffer->txns_by_base_snapshot_lsn)",
          "new_text": null,
          "old_line_content": "\tdlist_init(&buffer->txns_by_base_snapshot_lsn);",
          "new_line_content": "\tbuffer->totalBytes = 0;",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "dclist_init",
          "new_api": null,
          "old_text": "dclist_init(&buffer->catchange_txns)",
          "new_text": null,
          "old_line_content": "\tdclist_init(&buffer->catchange_txns);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": "ReorderBufferFreeSnap",
          "new_api": null,
          "old_text": "ReorderBufferFreeSnap(rb, snapshot_now)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tReorderBufferFreeSnap(rb, snapshot_now);",
          "new_line_content": "\t\t\t\t\t/* get rid of the old */",
          "content_same": false
        },
        {
          "line": 4474,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.msg.prefix, data, prefix_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.msg.prefix, data, prefix_size);",
          "new_line_content": "\t\t\t\t/* read prefix */",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "ReorderBufferCopySnap",
          "new_api": null,
          "old_text": "ReorderBufferCopySnap(rb, change->data.snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t  txn, command_id)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tReorderBufferCopySnap(rb, change->data.snapshot,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4481,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  change->data.msg.message_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tchange->data.msg.message = MemoryContextAlloc(rb->context,",
          "new_line_content": "\t\t\t\tdata += prefix_size;",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "NameStr",
          "new_api": null,
          "old_text": "NameStr(MyReplicationSlot->data.name)",
          "new_text": null,
          "old_line_content": "\tReorderBufferCleanupSerializedTXNs(NameStr(MyReplicationSlot->data.name));",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4483,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.msg.message, data,\n\t\t\t\t\t   change->data.msg.message_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.msg.message, data,",
          "new_line_content": "\t\t\t\t/* read the message */",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "ReorderBufferCopySnap",
          "new_api": null,
          "old_text": "ReorderBufferCopySnap(rb, change->data.snapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t  txn, command_id)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tReorderBufferCopySnap(rb, change->data.snapshot,",
          "new_line_content": "\t\t\t\t\t * now this seems infrequent enough not to care.",
          "content_same": false
        },
        {
          "line": 4495,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->context, inval_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tMemoryContextAlloc(rb->context, inval_size);",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 4498,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(change->data.inval.invalidations, data, inval_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(change->data.inval.invalidations, data, inval_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "MemoryContextDelete",
          "new_api": null,
          "old_text": "MemoryContextDelete(context)",
          "new_text": null,
          "old_line_content": "\tMemoryContextDelete(context);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2452,
          "old_api": "SetupHistoricSnapshot",
          "new_api": null,
          "old_text": "SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tSetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);",
          "new_line_content": "\t\t\t\t\t{",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "NameStr",
          "new_api": null,
          "old_text": "NameStr(MyReplicationSlot->data.name)",
          "new_text": null,
          "old_line_content": "\tReorderBufferCleanupSerializedTXNs(NameStr(MyReplicationSlot->data.name));",
          "new_line_content": "\t * memory context.",
          "content_same": false
        },
        {
          "line": 2456,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->data.command_id != InvalidCommandId)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tAssert(change->data.command_id != InvalidCommandId);",
          "new_line_content": "\t\t\t\t\t/* and continue with the new one */",
          "content_same": false
        },
        {
          "line": 2465,
          "old_api": "ReorderBufferCopySnap",
          "new_api": null,
          "old_text": "ReorderBufferCopySnap(rb, snapshot_now,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t txn, command_id)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\tsnapshot_now = ReorderBufferCopySnap(rb, snapshot_now,",
          "new_line_content": "\t\t\t\t\t\tcommand_id = change->data.command_id;",
          "content_same": false
        },
        {
          "line": 4514,
          "old_api": "MemoryContextAllocZero",
          "new_api": null,
          "old_text": "MemoryContextAllocZero(rb->context, size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tchange->data.snapshot = MemoryContextAllocZero(rb->context, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->txn_context, sizeof(ReorderBufferTXN))",
          "new_text": null,
          "old_line_content": "\t\tMemoryContextAlloc(rb->txn_context, sizeof(ReorderBufferTXN));",
          "new_line_content": "ReorderBufferGetTXN(ReorderBuffer *rb)",
          "content_same": false
        },
        {
          "line": 421,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(txn, 0, sizeof(ReorderBufferTXN))",
          "new_text": null,
          "old_line_content": "\tmemset(txn, 0, sizeof(ReorderBufferTXN));",
          "new_line_content": "\tReorderBufferTXN *txn;",
          "content_same": false
        },
        {
          "line": 4518,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(newsnap, data, size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(newsnap, data, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 423,
          "old_api": "dlist_init",
          "new_api": null,
          "old_text": "dlist_init(&txn->changes)",
          "new_text": null,
          "old_line_content": "\tdlist_init(&txn->changes);",
          "new_line_content": "\ttxn = (ReorderBufferTXN *)",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": "TeardownHistoricSnapshot",
          "new_api": null,
          "old_text": "TeardownHistoricSnapshot(false)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tTeardownHistoricSnapshot(false);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t txn, command_id);",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "dlist_init",
          "new_api": null,
          "old_text": "dlist_init(&txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_init(&txn->subtxns);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2472,
          "old_api": "SetupHistoricSnapshot",
          "new_api": null,
          "old_text": "SetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\tSetupHistoricSnapshot(snapshot_now, txn->tuplecid_hash);",
          "new_line_content": "\t\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"tuplecid value in changequeue\")",
          "new_text": null,
          "old_line_content": "\t\t\t\t\telog(ERROR, \"tuplecid value in changequeue\");",
          "new_line_content": "\t\t\t\t\t}",
          "content_same": false
        },
        {
          "line": 4530,
          "old_api": "ReorderBufferGetRelids",
          "new_api": null,
          "old_text": "ReorderBufferGetRelids(rb,\n\t\t\t\t\t\t\t\t\t\t\t\tchange->data.truncate.nrelids)",
          "new_text": null,
          "old_line_content": "\t\t\t\trelids = ReorderBufferGetRelids(rb,",
          "new_line_content": "\t\t\t/* the base struct contains all the data, easy peasy */",
          "content_same": false
        },
        {
          "line": 4532,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(relids, data, change->data.truncate.nrelids * sizeof(Oid))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(relids, data, change->data.truncate.nrelids * sizeof(Oid));",
          "new_line_content": "\t\t\t{",
          "content_same": false
        },
        {
          "line": 2496,
          "old_api": "update_progress_txn",
          "new_api": null,
          "old_text": "rb->update_progress_txn(rb, txn, change->lsn)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->update_progress_txn(rb, txn, change->lsn);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 4544,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&txn->changes, &change->node)",
          "new_text": null,
          "old_line_content": "\tdlist_push_tail(&txn->changes, &change->node);",
          "new_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:",
          "content_same": false
        },
        {
          "line": 451,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(txn->gid)",
          "new_text": null,
          "old_line_content": "\t\tpfree(txn->gid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2502,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!specinsert)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!specinsert);",
          "new_line_content": "\t\t\t\tchanges_count = 0;",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": "hash_destroy",
          "new_api": null,
          "old_text": "hash_destroy(txn->tuplecid_hash)",
          "new_text": null,
          "old_line_content": "\t\thash_destroy(txn->tuplecid_hash);",
          "new_line_content": "\t\ttxn->gid = NULL;",
          "content_same": false
        },
        {
          "line": 2505,
          "old_api": "ReorderBufferIterTXNFinish",
          "new_api": null,
          "old_text": "ReorderBufferIterTXNFinish(rb, iterstate)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferIterTXNFinish(rb, iterstate);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4555,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": null,
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, true,\n\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "new_text": null,
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, change, NULL, true,",
          "new_line_content": "\t * this branch (we only do that when initially queueing the changes after",
          "content_same": false
        },
        {
          "line": 4556,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "new_line_content": "\t * decoding), because we will release the changes later, and that will",
          "content_same": false
        },
        {
          "line": 463,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(txn->invalidations)",
          "new_text": null,
          "old_line_content": "\t\tpfree(txn->invalidations);",
          "new_line_content": "\t\ttxn->tuplecid_hash = NULL;",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\t\tif (!rbtxn_is_streamed(txn))",
          "new_line_content": "\t\t *",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->size == 0)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->size == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4569,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4570,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\tXLogSegNo\tfirst;",
          "content_same": false
        },
        {
          "line": 4572,
          "old_api": "XLByteToSeg",
          "new_api": null,
          "old_text": "XLByteToSeg(txn->first_lsn, first, wal_segment_size)",
          "new_text": null,
          "old_line_content": "\tXLByteToSeg(txn->first_lsn, first, wal_segment_size);",
          "new_line_content": "\tXLogSegNo\tlast;",
          "content_same": false
        },
        {
          "line": 4573,
          "old_api": "XLByteToSeg",
          "new_api": null,
          "old_text": "XLByteToSeg(txn->final_lsn, last, wal_segment_size)",
          "new_text": null,
          "old_line_content": "\tXLByteToSeg(txn->final_lsn, last, wal_segment_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": "stream_stop",
          "new_api": null,
          "old_text": "rb->stream_stop(rb, txn, prev_lsn)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->stream_stop(rb, txn, prev_lsn);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4580,
          "old_api": "ReorderBufferSerializedPath",
          "new_api": null,
          "old_text": "ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid, cur)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid, cur);",
          "new_line_content": "\t/* iterate over all possible filenames, and delete them */",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->change_context, sizeof(ReorderBufferChange))",
          "new_text": null,
          "old_line_content": "\t\tMemoryContextAlloc(rb->change_context, sizeof(ReorderBufferChange));",
          "new_line_content": "ReorderBufferGetChange(ReorderBuffer *rb)",
          "content_same": false
        },
        {
          "line": 4581,
          "old_api": "unlink",
          "new_api": null,
          "old_text": "unlink(path)",
          "new_text": null,
          "old_line_content": "\t\tif (unlink(path) != 0 && errno != ENOENT)",
          "new_line_content": "\tfor (cur = first; cur <= last; cur++)",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(change, 0, sizeof(ReorderBufferChange))",
          "new_text": null,
          "old_line_content": "\tmemset(change, 0, sizeof(ReorderBufferChange));",
          "new_line_content": "\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 4582,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", path)))",
          "new_text": null,
          "old_line_content": "\t\t\tereport(ERROR,",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 4583,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\tchar\t\tpath[MAXPGPATH];",
          "content_same": false
        },
        {
          "line": 4584,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not remove file \\\"%s\\\": %m\", path)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\": %m\", path)));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\t\t\tif (rbtxn_prepared(txn))",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": "prepare",
          "new_api": null,
          "old_text": "rb->prepare(rb, txn, commit_lsn)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->prepare(rb, txn, commit_lsn);",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 2543,
          "old_api": "commit",
          "new_api": null,
          "old_text": "rb->commit(rb, txn, commit_lsn)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->commit(rb, txn, commit_lsn);",
          "new_line_content": "\t\t\t * regular ones).",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "GetCurrentTransactionIdIfAny",
          "new_api": null,
          "old_text": "GetCurrentTransactionIdIfAny()",
          "new_text": null,
          "old_line_content": "\t\tif (GetCurrentTransactionIdIfAny() != InvalidTransactionId)",
          "new_line_content": "\t\t\telse",
          "content_same": false
        },
        {
          "line": 500,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": null,
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, change, NULL, false,\n\t\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change))",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferChangeMemoryUpdate(rb, change, NULL, false,",
          "new_line_content": "ReorderBufferReturnChange(ReorderBuffer *rb, ReorderBufferChange *change,",
          "content_same": false
        },
        {
          "line": 501,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "new_line_content": "\t\t\t\t\t\t  bool upd_mem)",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": "GetCurrentTransactionId",
          "new_api": null,
          "old_text": "GetCurrentTransactionId()",
          "new_text": null,
          "old_line_content": "\t\t\t\t GetCurrentTransactionId());",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 4600,
          "old_api": "sprintf",
          "new_api": null,
          "old_text": "sprintf(path, \"%s/%s\", PG_REPLSLOT_DIR, slotname)",
          "new_text": null,
          "old_line_content": "\tsprintf(path, \"%s/%s\", PG_REPLSLOT_DIR, slotname);",
          "new_line_content": "\tDIR\t\t   *spill_dir;",
          "content_same": false
        },
        {
          "line": 4603,
          "old_api": "S_ISDIR",
          "new_api": null,
          "old_text": "S_ISDIR(statbuf.st_mode)",
          "new_text": null,
          "old_line_content": "\tif (lstat(path, &statbuf) == 0 && !S_ISDIR(statbuf.st_mode))",
          "new_line_content": "\tchar\t\tpath[MAXPGPATH * 2 + sizeof(PG_REPLSLOT_DIR)];",
          "content_same": false
        },
        {
          "line": 2556,
          "old_api": "ReorderBufferSaveTXNSnapshot",
          "new_api": null,
          "old_text": "ReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferSaveTXNSnapshot(rb, txn, snapshot_now, command_id);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 4606,
          "old_api": "AllocateDir",
          "new_api": null,
          "old_text": "AllocateDir(path)",
          "new_text": null,
          "old_line_content": "\tspill_dir = AllocateDir(path);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2558,
          "old_api": "ReorderBufferFreeSnap",
          "new_api": null,
          "old_text": "ReorderBufferFreeSnap(rb, snapshot_now)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferFreeSnap(rb, snapshot_now);",
          "new_line_content": "\t\t * streaming mode.",
          "content_same": false
        },
        {
          "line": 512,
          "old_api": "ReorderBufferReturnTupleBuf",
          "new_api": null,
          "old_text": "ReorderBufferReturnTupleBuf(change->data.tp.newtuple)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferReturnTupleBuf(change->data.tp.newtuple);",
          "new_line_content": "\t\tcase REORDER_BUFFER_CHANGE_UPDATE:",
          "content_same": false
        },
        {
          "line": 4607,
          "old_api": "ReadDirExtended",
          "new_api": null,
          "old_text": "ReadDirExtended(spill_dir, path, INFO)",
          "new_text": null,
          "old_line_content": "\twhile ((spill_de = ReadDirExtended(spill_dir, path, INFO)) != NULL)",
          "new_line_content": "\t/* we're only handling directories here, skip if it's not ours */",
          "content_same": false
        },
        {
          "line": 4610,
          "old_api": "strncmp",
          "new_api": null,
          "old_text": "strncmp(spill_de->d_name, \"xid\", 3)",
          "new_text": null,
          "old_line_content": "\t\tif (strncmp(spill_de->d_name, \"xid\", 3) == 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 518,
          "old_api": "ReorderBufferReturnTupleBuf",
          "new_api": null,
          "old_text": "ReorderBufferReturnTupleBuf(change->data.tp.oldtuple)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferReturnTupleBuf(change->data.tp.oldtuple);",
          "new_line_content": "\t\t\t\tchange->data.tp.newtuple = NULL;",
          "content_same": false
        },
        {
          "line": 4616,
          "old_api": "unlink",
          "new_api": null,
          "old_text": "unlink(path)",
          "new_text": null,
          "old_line_content": "\t\t\tif (unlink(path) != 0)",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2569,
          "old_api": "AbortCurrentTransaction",
          "new_api": null,
          "old_text": "AbortCurrentTransaction()",
          "new_text": null,
          "old_line_content": "\t\tAbortCurrentTransaction();",
          "new_line_content": "\t\t * Aborting the current (sub-)transaction as a whole has the right",
          "content_same": false
        },
        {
          "line": 4618,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\t\t\t \"%s/%s/%s\", PG_REPLSLOT_DIR, slotname,",
          "content_same": false
        },
        {
          "line": 4619,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not remove file \\\"%s\\\" during removal of %s/%s/xid*: %m\",\n\t\t\t\t\t\t\t\tpath, PG_REPLSLOT_DIR, slotname)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t errmsg(\"could not remove file \\\"%s\\\" during removal of %s/%s/xid*: %m\",",
          "new_line_content": "\t\t\t\t\t spill_de->d_name);",
          "content_same": false
        },
        {
          "line": 524,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(change->data.msg.prefix)",
          "new_text": null,
          "old_line_content": "\t\t\t\tpfree(change->data.msg.prefix);",
          "new_line_content": "\t\t\t\tchange->data.tp.oldtuple = NULL;",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": "ReorderBufferExecuteInvalidations",
          "new_api": null,
          "old_text": "ReorderBufferExecuteInvalidations(txn->ninvalidations, txn->invalidations)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferExecuteInvalidations(txn->ninvalidations, txn->invalidations);",
          "new_line_content": "\t\t * have persistent effects.",
          "content_same": false
        },
        {
          "line": 527,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(change->data.msg.message)",
          "new_text": null,
          "old_line_content": "\t\t\t\tpfree(change->data.msg.message);",
          "new_line_content": "\t\tcase REORDER_BUFFER_CHANGE_MESSAGE:",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "RollbackAndReleaseCurrentSubTransaction",
          "new_api": null,
          "old_text": "RollbackAndReleaseCurrentSubTransaction()",
          "new_text": null,
          "old_line_content": "\t\t\tRollbackAndReleaseCurrentSubTransaction();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 538,
          "old_api": "ReorderBufferFreeSnap",
          "new_api": null,
          "old_text": "ReorderBufferFreeSnap(rb, change->data.snapshot)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferFreeSnap(rb, change->data.snapshot);",
          "new_line_content": "\t\t\tchange->data.inval.invalidations = NULL;",
          "content_same": false
        },
        {
          "line": 4637,
          "old_api": "XLogSegNoOffsetToRecPtr",
          "new_api": null,
          "old_text": "XLogSegNoOffsetToRecPtr(segno, 0, wal_segment_size, recptr)",
          "new_text": null,
          "old_line_content": "\tXLogSegNoOffsetToRecPtr(segno, 0, wal_segment_size, recptr);",
          "new_line_content": "ReorderBufferSerializedPath(char *path, ReplicationSlot *slot, TransactionId xid,",
          "content_same": false
        },
        {
          "line": 2591,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\t\tif (streaming || rbtxn_prepared(txn))",
          "new_line_content": "\t\t * ReorderBufferTruncateTXN to do more elaborate truncation of txn",
          "content_same": false
        },
        {
          "line": 4639,
          "old_api": "snprintf",
          "new_api": null,
          "old_text": "snprintf(path, MAXPGPATH, \"%s/%s/xid-%u-lsn-%X-%X.spill\",\n\t\t\t PG_REPLSLOT_DIR,\n\t\t\t NameStr(MyReplicationSlot->data.name),\n\t\t\t xid, LSN_FORMAT_ARGS(recptr))",
          "new_text": null,
          "old_line_content": "\tsnprintf(path, MAXPGPATH, \"%s/%s/xid-%u-lsn-%X-%X.spill\",",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2593,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferTruncateTXN(rb, txn, rbtxn_prepared(txn));",
          "new_line_content": "\t\t * For 4, as the entire txn has been decoded, we can fully clean up",
          "content_same": false
        },
        {
          "line": 546,
          "old_api": "ReorderBufferReturnRelids",
          "new_api": null,
          "old_text": "ReorderBufferReturnRelids(rb, change->data.truncate.relids)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferReturnRelids(rb, change->data.truncate.relids);",
          "new_line_content": "\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 4641,
          "old_api": "NameStr",
          "new_api": null,
          "old_text": "NameStr(MyReplicationSlot->data.name)",
          "new_text": null,
          "old_line_content": "\t\t\t NameStr(MyReplicationSlot->data.name),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2600,
          "old_api": "PG_CATCH",
          "new_api": null,
          "old_text": "PG_CATCH()",
          "new_text": null,
          "old_line_content": "\tPG_CATCH();",
          "new_line_content": "\t\t\tCheckXidAlive = InvalidTransactionId;",
          "content_same": false
        },
        {
          "line": 2602,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(ccxt)",
          "new_text": null,
          "old_line_content": "\t\tMemoryContext ecxt = MemoryContextSwitchTo(ccxt);",
          "new_line_content": "\t\telse",
          "content_same": false
        },
        {
          "line": 557,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(change)",
          "new_text": null,
          "old_line_content": "\tpfree(change);",
          "new_line_content": "\t\tcase REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:",
          "content_same": false
        },
        {
          "line": 4655,
          "old_api": "AllocateDir",
          "new_api": null,
          "old_text": "AllocateDir(PG_REPLSLOT_DIR)",
          "new_text": null,
          "old_line_content": "\tlogical_dir = AllocateDir(PG_REPLSLOT_DIR);",
          "new_line_content": "StartupReorderBuffer(void)",
          "content_same": false
        },
        {
          "line": 4656,
          "old_api": "ReadDir",
          "new_api": null,
          "old_text": "ReadDir(logical_dir, PG_REPLSLOT_DIR)",
          "new_text": null,
          "old_line_content": "\twhile ((logical_de = ReadDir(logical_dir, PG_REPLSLOT_DIR)) != NULL)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2609,
          "old_api": "TeardownHistoricSnapshot",
          "new_api": null,
          "old_text": "TeardownHistoricSnapshot(true)",
          "new_text": null,
          "old_line_content": "\t\tTeardownHistoricSnapshot(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4658,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(logical_de->d_name, \".\")",
          "new_text": null,
          "old_line_content": "\t\tif (strcmp(logical_de->d_name, \".\") == 0 ||",
          "new_line_content": "\tstruct dirent *logical_de;",
          "content_same": false
        },
        {
          "line": 4659,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(logical_de->d_name, \"..\")",
          "new_text": null,
          "old_line_content": "\t\t\tstrcmp(logical_de->d_name, \"..\") == 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": "AbortCurrentTransaction",
          "new_api": null,
          "old_text": "AbortCurrentTransaction()",
          "new_text": null,
          "old_line_content": "\t\tAbortCurrentTransaction();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2618,
          "old_api": "ReorderBufferExecuteInvalidations",
          "new_api": null,
          "old_text": "ReorderBufferExecuteInvalidations(txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t  txn->invalidations)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferExecuteInvalidations(txn->ninvalidations,",
          "new_line_content": "\t\t * to prevent catalog access as we just caught an error.",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->tup_context,\n\t\t\t\t\t\t\t\t\t\t   HEAPTUPLESIZE + alloc_len)",
          "new_text": null,
          "old_line_content": "\ttuple = (HeapTuple) MemoryContextAlloc(rb->tup_context,",
          "new_line_content": "\tHeapTuple\ttuple;",
          "content_same": false
        },
        {
          "line": 574,
          "old_api": "HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE)",
          "new_api": null,
          "old_text": "HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE)",
          "new_text": null,
          "old_line_content": "\ttuple->t_data = (HeapTupleHeader) ((char *) tuple + HEAPTUPLESIZE);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "RollbackAndReleaseCurrentSubTransaction",
          "new_api": null,
          "old_text": "RollbackAndReleaseCurrentSubTransaction()",
          "new_text": null,
          "old_line_content": "\t\t\tRollbackAndReleaseCurrentSubTransaction();",
          "new_line_content": "\t\t/* make sure there's no cache pollution */",
          "content_same": false
        },
        {
          "line": 4670,
          "old_api": "ReorderBufferCleanupSerializedTXNs",
          "new_api": null,
          "old_text": "ReorderBufferCleanupSerializedTXNs(logical_de->d_name)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferCleanupSerializedTXNs(logical_de->d_name);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4672,
          "old_api": "FreeDir",
          "new_api": null,
          "old_text": "FreeDir(logical_dir)",
          "new_text": null,
          "old_line_content": "\tFreeDir(logical_dir);",
          "new_line_content": "\t\t * ok, has to be a surviving logical slot, iterate and delete",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(tuple)",
          "new_text": null,
          "old_line_content": "\tpfree(tuple);",
          "new_line_content": " * Free a HeapTuple returned by ReorderBufferGetTupleBuf().",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\t\t\t(stream_started || rbtxn_prepared(txn)))",
          "new_line_content": "\t\t * when we are sending the data in streaming mode and the streaming is",
          "content_same": false
        },
        {
          "line": 2640,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(curtxn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(curtxn);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4688,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->toast_hash == NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->toast_hash == NULL);",
          "new_line_content": "static void",
          "content_same": false
        },
        {
          "line": 2643,
          "old_api": "FlushErrorState",
          "new_api": null,
          "old_text": "FlushErrorState()",
          "new_text": null,
          "old_line_content": "\t\t\tFlushErrorState();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2644,
          "old_api": "FreeErrorData",
          "new_api": null,
          "old_text": "FreeErrorData(errdata)",
          "new_text": null,
          "old_line_content": "\t\t\tFreeErrorData(errdata);",
          "new_line_content": "\t\t\t/* curtxn must be set for streaming or prepared transactions */",
          "content_same": false
        },
        {
          "line": 605,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->context, alloc_len)",
          "new_text": null,
          "old_line_content": "\trelids = (Oid *) MemoryContextAlloc(rb->context, alloc_len);",
          "new_line_content": "\tOid\t\t   *relids;",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\t\t\t\t\t\t\t  command_id, prev_lsn,",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(ecxt)",
          "new_text": null,
          "old_line_content": "\t\t\tMemoryContextSwitchTo(ecxt);",
          "new_line_content": "\t\t\t\t\t\t\t\t  specinsert);",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "PG_RE_THROW",
          "new_api": null,
          "old_text": "PG_RE_THROW()",
          "new_text": null,
          "old_line_content": "\t\t\tPG_RE_THROW();",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 616,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(relids)",
          "new_text": null,
          "old_line_content": "\tpfree(relids);",
          "new_line_content": " * Free an array of relids.",
          "content_same": false
        },
        {
          "line": 4713,
          "old_api": "RelationGetDescr",
          "new_api": null,
          "old_text": "RelationGetDescr(relation)",
          "new_text": null,
          "old_line_content": "\tTupleDesc\tdesc = RelationGetDescr(relation);",
          "new_line_content": "\tHeapTuple\tnewtup;",
          "content_same": false
        },
        {
          "line": 4720,
          "old_api": "IsToastRelation",
          "new_api": null,
          "old_text": "IsToastRelation(relation)",
          "new_text": null,
          "old_line_content": "\tAssert(IsToastRelation(relation));",
          "new_line_content": "\tint32\t\tchunk_seq;",
          "content_same": false
        },
        {
          "line": 4724,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!isnull)",
          "new_text": null,
          "old_line_content": "\tAssert(!isnull);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4726,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!isnull)",
          "new_text": null,
          "old_line_content": "\tAssert(!isnull);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 633,
          "old_api": "TransactionIdIsValid",
          "new_api": null,
          "old_text": "TransactionIdIsValid(xid)",
          "new_text": null,
          "old_line_content": "\tAssert(TransactionIdIsValid(xid));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4733,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ent->chunk_id == chunk_id)",
          "new_text": null,
          "old_line_content": "\t\tAssert(ent->chunk_id == chunk_id);",
          "new_line_content": "\tent = (ReorderBufferToastEnt *)",
          "content_same": false
        },
        {
          "line": 4741,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq 0\",\n\t\t\t\t chunk_seq, chunk_id)",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq 0\",",
          "new_line_content": "\t\tent->size = 0;",
          "content_same": false
        },
        {
          "line": 2697,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_streamed(txn))",
          "new_line_content": "\t * transaction, and then invoke stream_commit message.",
          "content_same": false
        },
        {
          "line": 4745,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq %d\",\n\t\t\t chunk_seq, chunk_id, ent->last_chunk_seq + 1)",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"got sequence entry %d for toast chunk %u instead of seq %d\",",
          "new_line_content": "\t\tif (chunk_seq != 0)",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "ReorderBufferStreamCommit",
          "new_api": null,
          "old_text": "ReorderBufferStreamCommit(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferStreamCommit(rb, txn);",
          "new_line_content": "\t * Called after everything (origin ID, LSN, ...) is stored in the",
          "content_same": false
        },
        {
          "line": 4748,
          "old_api": "fastgetattr",
          "new_api": null,
          "old_text": "fastgetattr(newtup, 3, desc, &isnull)",
          "new_text": null,
          "old_line_content": "\tchunk = DatumGetPointer(fastgetattr(newtup, 3, desc, &isnull));",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 4749,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!isnull)",
          "new_text": null,
          "old_line_content": "\tAssert(!isnull);",
          "new_line_content": "\telse if (found && chunk_seq != ent->last_chunk_seq + 1)",
          "content_same": false
        },
        {
          "line": 4752,
          "old_api": "VARATT_IS_EXTENDED",
          "new_api": null,
          "old_text": "VARATT_IS_EXTENDED(chunk)",
          "new_text": null,
          "old_line_content": "\tif (!VARATT_IS_EXTENDED(chunk))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4756,
          "old_api": "VARSIZE_SHORT",
          "new_api": null,
          "old_text": "VARSIZE_SHORT(chunk)",
          "new_text": null,
          "old_line_content": "\t\tchunksize = VARSIZE_SHORT(chunk) - VARHDRSZ_SHORT;",
          "new_line_content": "\t/* calculate size so we can allocate the right size at once later */",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->ninvalidations == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->ninvalidations == 0);",
          "new_line_content": "\t * ReorderBufferCommitChild will have transferred any snapshots from",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "hash_search",
          "new_api": null,
          "old_text": "hash_search(rb->by_txn,\n\t\t\t\t\t&xid,\n\t\t\t\t\tcreate ? HASH_ENTER : HASH_FIND,\n\t\t\t\t\t&found)",
          "new_text": null,
          "old_line_content": "\t\thash_search(rb->by_txn,",
          "new_line_content": "\t * create an entry.",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\t\tif (!rbtxn_prepared(txn))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2718,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 676,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ent != NULL)",
          "new_text": null,
          "old_line_content": "\t\tAssert(ent != NULL);",
          "new_line_content": "\tif (found)",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\tAssert(lsn != InvalidXLogRecPtr);",
          "new_line_content": "\t\ttxn = ent->txn;",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": "ReorderBufferProcessTXN",
          "new_api": null,
          "old_text": "ReorderBufferProcessTXN(rb, txn, commit_lsn, snapshot_now,\n\t\t\t\t\t\t\tcommand_id, false)",
          "new_text": null,
          "old_line_content": "\tReorderBufferProcessTXN(rb, txn, commit_lsn, snapshot_now,",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": "ReorderBufferGetTXN",
          "new_api": null,
          "old_text": "ReorderBufferGetTXN(rb)",
          "new_text": null,
          "old_line_content": "\t\tent->txn = ReorderBufferGetTXN(rb);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 687,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&rb->toplevel_by_lsn, &txn->node)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_push_tail(&rb->toplevel_by_lsn, &txn->node);",
          "new_line_content": "\t\ttxn->first_lsn = lsn;",
          "content_same": false
        },
        {
          "line": 688,
          "old_api": "AssertTXNLsnOrder",
          "new_api": null,
          "old_text": "AssertTXNLsnOrder(rb)",
          "new_text": null,
          "old_line_content": "\t\t\tAssertTXNLsnOrder(rb);",
          "new_line_content": "\t\ttxn->restart_decoding_lsn = rb->current_restart_decoding_lsn;",
          "content_same": false
        },
        {
          "line": 2742,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "new_line_content": "\t\t\t\t\tTimestampTz commit_time,",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!create || txn != NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(!create || txn != NULL);",
          "new_line_content": "\trb->by_txn_last_txn = txn;",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "ReorderBufferReplay",
          "new_api": null,
          "old_text": "ReorderBufferReplay(txn, rb, xid, commit_lsn, end_lsn, commit_time,\n\t\t\t\t\t\torigin_id, origin_lsn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferReplay(txn, rb, xid, commit_lsn, end_lsn, commit_time,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2764,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);",
          "new_line_content": "\t\t\t\t\t\t\t\t TimestampTz prepare_time,",
          "content_same": false
        },
        {
          "line": 4816,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\told_size = ReorderBufferChangeSize(change);",
          "new_line_content": "\t * the old size because if there is any error before we add the new size,",
          "content_same": false
        },
        {
          "line": 4818,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(rb->context)",
          "new_text": null,
          "old_line_content": "\toldcontext = MemoryContextSwitchTo(rb->context);",
          "new_line_content": "\t * (subtracting the size from the counters). And we don't want to",
          "content_same": false
        },
        {
          "line": 724,
          "old_api": "ReorderBufferCanStream",
          "new_api": null,
          "old_text": "ReorderBufferCanStream(rb)",
          "new_text": null,
          "old_line_content": "\tif (!ReorderBufferCanStream(rb))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 728,
          "old_api": "rbtxn_get_toptxn",
          "new_api": null,
          "old_text": "rbtxn_get_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\ttoptxn = rbtxn_get_toptxn(txn);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 4825,
          "old_api": "RelationIdGetRelation",
          "new_api": null,
          "old_text": "RelationIdGetRelation(relation->rd_rel->reltoastrelid)",
          "new_text": null,
          "old_line_content": "\ttoast_rel = RelationIdGetRelation(relation->rd_rel->reltoastrelid);",
          "new_line_content": "\t/* we should only have toast tuples in an INSERT or UPDATE */",
          "content_same": false
        },
        {
          "line": 4827,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"could not open toast relation with OID %u (base relation \\\"%s\\\")\",\n\t\t\t relation->rd_rel->reltoastrelid, RelationGetRelationName(relation))",
          "new_text": null,
          "old_line_content": "\t\telog(ERROR, \"could not open toast relation with OID %u (base relation \\\"%s\\\")\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4834,
          "old_api": "palloc0",
          "new_api": null,
          "old_text": "palloc0(sizeof(bool) * desc->natts)",
          "new_text": null,
          "old_line_content": "\tisnull = palloc0(sizeof(bool) * desc->natts);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2789,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr, false);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 746,
          "old_api": "rbtxn_has_partial_change",
          "new_api": null,
          "old_text": "rbtxn_has_partial_change(toptxn)",
          "new_text": null,
          "old_line_content": "\telse if (rbtxn_has_partial_change(toptxn) &&",
          "new_line_content": "\t * just to allow this case because anyway we will stream the transaction",
          "content_same": false
        },
        {
          "line": 747,
          "old_api": "IsInsertOrUpdate",
          "new_api": null,
          "old_text": "IsInsertOrUpdate(change->action)",
          "new_text": null,
          "old_line_content": "\t\t\t IsInsertOrUpdate(change->action) &&",
          "new_line_content": "\t * once such an insert is complete.",
          "content_same": false
        },
        {
          "line": 4843,
          "old_api": "TupleDescAttr",
          "new_api": null,
          "old_text": "TupleDescAttr(desc, natt)",
          "new_text": null,
          "old_line_content": "\t\tForm_pg_attribute attr = TupleDescAttr(desc, natt);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "IsSpecInsert",
          "new_api": null,
          "old_text": "IsSpecInsert(change->action)",
          "new_text": null,
          "old_line_content": "\tif (IsSpecInsert(change->action))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": "rbtxn_has_partial_change",
          "new_api": null,
          "old_text": "rbtxn_has_partial_change(toptxn)",
          "new_text": null,
          "old_line_content": "\telse if (rbtxn_has_partial_change(toptxn) &&",
          "new_line_content": "\t * considered as complete once we get the speculative confirm or abort",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": "IsSpecConfirmOrAbort",
          "new_api": null,
          "old_text": "IsSpecConfirmOrAbort(change->action)",
          "new_text": null,
          "old_line_content": "\t\t\t IsSpecConfirmOrAbort(change->action))",
          "new_line_content": "\t * token.",
          "content_same": false
        },
        {
          "line": 2809,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "new_line_content": "ReorderBufferPrepare(ReorderBuffer *rb, TransactionId xid,",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": "pstrdup",
          "new_api": null,
          "old_text": "pstrdup(gid)",
          "new_text": null,
          "old_line_content": "\ttxn->gid = pstrdup(gid);",
          "new_line_content": "\t/* unknown transaction, nothing to replay */",
          "content_same": false
        },
        {
          "line": 771,
          "old_api": "ReorderBufferCanStartStreaming",
          "new_api": null,
          "old_text": "ReorderBufferCanStartStreaming(rb)",
          "new_text": null,
          "old_line_content": "\tif (ReorderBufferCanStartStreaming(rb) &&",
          "new_line_content": "\t * The reason for doing the streaming of such a transaction as soon as we",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "rbtxn_has_partial_change",
          "new_api": null,
          "old_text": "rbtxn_has_partial_change(toptxn)",
          "new_text": null,
          "old_line_content": "\t\t!(rbtxn_has_partial_change(toptxn)) &&",
          "new_line_content": "\t * get the complete change for it is that previously it would have reached",
          "content_same": false
        },
        {
          "line": 773,
          "old_api": "rbtxn_is_serialized",
          "new_api": null,
          "old_text": "rbtxn_is_serialized(txn)",
          "new_text": null,
          "old_line_content": "\t\trbtxn_is_serialized(txn) &&",
          "new_line_content": "\t * the memory threshold and wouldn't get streamed because of incomplete",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": "rbtxn_has_streamable_change",
          "new_api": null,
          "old_text": "rbtxn_has_streamable_change(toptxn)",
          "new_text": null,
          "old_line_content": "\t\trbtxn_has_streamable_change(toptxn))",
          "new_line_content": "\t * changes.  Delaying such transactions would increase apply lag for them.",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "ReorderBufferStreamTXN",
          "new_api": null,
          "old_text": "ReorderBufferStreamTXN(rb, toptxn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferStreamTXN(rb, toptxn);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2820,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4871,
          "old_api": "DatumGetPointer",
          "new_api": null,
          "old_text": "DatumGetPointer(attrs[natt])",
          "new_text": null,
          "old_line_content": "\t\tvarlena = (struct varlena *) DatumGetPointer(attrs[natt]);",
          "new_line_content": "\t\t/* no data */",
          "content_same": false
        },
        {
          "line": 4874,
          "old_api": "VARATT_IS_EXTERNAL",
          "new_api": null,
          "old_text": "VARATT_IS_EXTERNAL(varlena)",
          "new_text": null,
          "old_line_content": "\t\tif (!VARATT_IS_EXTERNAL(varlena))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4877,
          "old_api": "VARATT_EXTERNAL_GET_POINTER",
          "new_api": null,
          "old_text": "VARATT_EXTERNAL_GET_POINTER(toast_pointer, varlena)",
          "new_text": null,
          "old_line_content": "\t\tVARATT_EXTERNAL_GET_POINTER(toast_pointer, varlena);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2833,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\tif (txn->concurrent_abort && !rbtxn_is_streamed(txn))",
          "new_line_content": "\t * able to rollback such a xact. See comments atop DecodePrepare.",
          "content_same": false
        },
        {
          "line": 2834,
          "old_api": "prepare",
          "new_api": null,
          "old_text": "rb->prepare(rb, txn, txn->final_lsn)",
          "new_text": null,
          "old_line_content": "\t\trb->prepare(rb, txn, txn->final_lsn);",
          "new_line_content": "\t *",
          "content_same": false
        },
        {
          "line": 4883,
          "old_api": "hash_search",
          "new_api": null,
          "old_text": "hash_search(txn->toast_hash,\n\t\t\t\t\t\t&toast_pointer.va_valueid,\n\t\t\t\t\t\tHASH_FIND,\n\t\t\t\t\t\tNULL)",
          "new_text": null,
          "old_line_content": "\t\t\thash_search(txn->toast_hash,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 788,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "new_line_content": "ReorderBufferQueueChange(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn,",
          "content_same": false
        },
        {
          "line": 4891,
          "old_api": "palloc0",
          "new_api": null,
          "old_text": "palloc0(INDIRECT_POINTER_SIZE)",
          "new_text": null,
          "old_line_content": "\t\t\t(struct varlena *) palloc0(INDIRECT_POINTER_SIZE);",
          "new_line_content": "\t\t\t\t\t\tNULL);",
          "content_same": false
        },
        {
          "line": 4895,
          "old_api": "palloc0",
          "new_api": null,
          "old_text": "palloc0(toast_pointer.va_rawsize)",
          "new_text": null,
          "old_line_content": "\t\treconstructed = palloc0(toast_pointer.va_rawsize);",
          "new_line_content": "\t\tnew_datum =",
          "content_same": false
        },
        {
          "line": 801,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, false)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, commit_lsn, false)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, commit_lsn, false);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4907,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, it.cur)",
          "new_text": null,
          "old_line_content": "\t\t\tcchange = dlist_container(ReorderBufferChange, node, it.cur);",
          "new_line_content": "\t\t\tbool\t\tcisnull;",
          "content_same": false
        },
        {
          "line": 4909,
          "old_api": "fastgetattr",
          "new_api": null,
          "old_text": "fastgetattr(ctup, 3, toast_desc, &cisnull)",
          "new_text": null,
          "old_line_content": "\t\t\tchunk = DatumGetPointer(fastgetattr(ctup, 3, toast_desc, &cisnull));",
          "new_line_content": "\t\t\tHeapTuple\tctup;",
          "content_same": false
        },
        {
          "line": 4911,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!cisnull)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!cisnull);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "rbtxn_get_toptxn",
          "new_api": null,
          "old_text": "rbtxn_get_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTXN *toptxn = rbtxn_get_toptxn(txn);",
          "new_line_content": "\t\tchange->action == REORDER_BUFFER_CHANGE_DELETE ||",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "pstrdup",
          "new_api": null,
          "old_text": "pstrdup(gid)",
          "new_text": null,
          "old_line_content": "\ttxn->gid = pstrdup(gid);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 4913,
          "old_api": "VARATT_IS_SHORT",
          "new_api": null,
          "old_text": "VARATT_IS_SHORT(chunk)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(!VARATT_IS_SHORT(chunk));",
          "new_line_content": "\t\t\tctup = cchange->data.tp.newtuple;",
          "content_same": false
        },
        {
          "line": 4915,
          "old_api": "VARDATA",
          "new_api": null,
          "old_text": "VARDATA(reconstructed)",
          "new_text": null,
          "old_line_content": "\t\t\tmemcpy(VARDATA(reconstructed) + data_done,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(InvalidXLogRecPtr != lsn)",
          "new_text": null,
          "old_line_content": "\tAssert(InvalidXLogRecPtr != lsn);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 826,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&txn->changes, &change->node)",
          "new_text": null,
          "old_line_content": "\tdlist_push_tail(&txn->changes, &change->node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4924,
          "old_api": "SET_VARSIZE_COMPRESSED",
          "new_api": null,
          "old_text": "SET_VARSIZE_COMPRESSED(reconstructed, data_done + VARHDRSZ)",
          "new_text": null,
          "old_line_content": "\t\t\tSET_VARSIZE_COMPRESSED(reconstructed, data_done + VARHDRSZ);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 4926,
          "old_api": "SET_VARSIZE",
          "new_api": null,
          "old_text": "SET_VARSIZE(reconstructed, data_done + VARHDRSZ)",
          "new_text": null,
          "old_line_content": "\t\t\tSET_VARSIZE(reconstructed, data_done + VARHDRSZ);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 832,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "new_line_content": "\ttxn->nentries++;",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "ReorderBufferProcessPartialChange",
          "new_api": null,
          "old_text": "ReorderBufferProcessPartialChange(rb, txn, change, toast_insert)",
          "new_text": null,
          "old_line_content": "\tReorderBufferProcessPartialChange(rb, txn, change, toast_insert);",
          "new_line_content": "\t/* update memory accounting information */",
          "content_same": false
        },
        {
          "line": 2883,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->final_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->final_lsn != InvalidXLogRecPtr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4932,
          "old_api": "VARDATA_EXTERNAL",
          "new_api": null,
          "old_text": "VARDATA_EXTERNAL(new_datum)",
          "new_text": null,
          "old_line_content": "\t\tmemcpy(VARDATA_EXTERNAL(new_datum), &redirect_pointer,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 838,
          "old_api": "ReorderBufferCheckMemoryLimit",
          "new_api": null,
          "old_text": "ReorderBufferCheckMemoryLimit(rb)",
          "new_text": null,
          "old_line_content": "\tReorderBufferCheckMemoryLimit(rb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4935,
          "old_api": "PointerGetDatum",
          "new_api": null,
          "old_text": "PointerGetDatum(new_datum)",
          "new_text": null,
          "old_line_content": "\t\tattrs[natt] = PointerGetDatum(new_datum);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2892,
          "old_api": "ReorderBufferReplay",
          "new_api": null,
          "old_text": "ReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,\n\t\t\t\t\t\t\ttxn->xact_time.prepare_time, txn->origin_id, txn->origin_lsn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReplay(txn, rb, xid, txn->final_lsn, txn->end_lsn,",
          "new_line_content": "\t\t * important to use that so that downstream gets the accurate",
          "content_same": false
        },
        {
          "line": 4943,
          "old_api": "heap_form_tuple",
          "new_api": null,
          "old_text": "heap_form_tuple(desc, attrs, isnull)",
          "new_text": null,
          "old_line_content": "\ttmphtup = heap_form_tuple(desc, attrs, isnull);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4944,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(newtup->t_len <= MaxHeapTupleSize)",
          "new_text": null,
          "old_line_content": "\tAssert(newtup->t_len <= MaxHeapTupleSize);",
          "new_line_content": "\t * Build tuple in separate memory & copy tuple back into the tuplebuf",
          "content_same": false
        },
        {
          "line": 4945,
          "old_api": "HeapTupleHeader) ((char *) newtup + HEAPTUPLESIZE)",
          "new_api": null,
          "old_text": "HeapTupleHeader) ((char *) newtup + HEAPTUPLESIZE)",
          "new_text": null,
          "old_line_content": "\tAssert(newtup->t_data == (HeapTupleHeader) ((char *) newtup + HEAPTUPLESIZE));",
          "new_line_content": "\t * passed to the output plugin. We can't directly heap_fill_tuple() into",
          "content_same": false
        },
        {
          "line": 4947,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(newtup->t_data, tmphtup->t_data, tmphtup->t_len)",
          "new_text": null,
          "old_line_content": "\tmemcpy(newtup->t_data, tmphtup->t_data, tmphtup->t_len);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2903,
          "old_api": "commit_prepared",
          "new_api": null,
          "old_text": "rb->commit_prepared(rb, txn, commit_lsn)",
          "new_text": null,
          "old_line_content": "\t\trb->commit_prepared(rb, txn, commit_lsn);",
          "new_line_content": "\ttxn->xact_time.commit_time = commit_time;",
          "content_same": false
        },
        {
          "line": 856,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(xid != InvalidTransactionId)",
          "new_text": null,
          "old_line_content": "\t\tAssert(xid != InvalidTransactionId);",
          "new_line_content": "\tif (transactional)",
          "content_same": false
        },
        {
          "line": 2905,
          "old_api": "rollback_prepared",
          "new_api": null,
          "old_text": "rb->rollback_prepared(rb, txn, prepare_end_lsn, prepare_time)",
          "new_text": null,
          "old_line_content": "\t\trb->rollback_prepared(rb, txn, prepare_end_lsn, prepare_time);",
          "new_line_content": "\ttxn->origin_lsn = origin_lsn;",
          "content_same": false
        },
        {
          "line": 4954,
          "old_api": "RelationClose",
          "new_api": null,
          "old_text": "RelationClose(toast_rel)",
          "new_text": null,
          "old_line_content": "\tRelationClose(toast_rel);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4955,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(tmphtup)",
          "new_text": null,
          "old_line_content": "\tpfree(tmphtup);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 863,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(!snap)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!snap);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 865,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(rb->context)",
          "new_text": null,
          "old_line_content": "\t\toldcontext = MemoryContextSwitchTo(rb->context);",
          "new_line_content": "\t\t * snapshot derived later during apply (unless the change gets",
          "content_same": false
        },
        {
          "line": 4961,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(attrs)",
          "new_text": null,
          "old_line_content": "\tpfree(attrs);",
          "new_line_content": "\tfor (natt = 0; natt < desc->natts; natt++)",
          "content_same": false
        },
        {
          "line": 867,
          "old_api": "ReorderBufferGetChange",
          "new_api": null,
          "old_text": "ReorderBufferGetChange(rb)",
          "new_text": null,
          "old_line_content": "\t\tchange = ReorderBufferGetChange(rb);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 4962,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(free)",
          "new_text": null,
          "old_line_content": "\tpfree(free);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 869,
          "old_api": "pstrdup",
          "new_api": null,
          "old_text": "pstrdup(prefix)",
          "new_text": null,
          "old_line_content": "\t\tchange->data.msg.prefix = pstrdup(prefix);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4963,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(isnull)",
          "new_text": null,
          "old_line_content": "\tpfree(isnull);",
          "new_line_content": "\t\tif (free[natt])",
          "content_same": false
        },
        {
          "line": 871,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(message_size)",
          "new_text": null,
          "old_line_content": "\t\tchange->data.msg.message = palloc(message_size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4965,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(oldcontext)",
          "new_text": null,
          "old_line_content": "\tMemoryContextSwitchTo(oldcontext);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 4971,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\tReorderBufferChangeSize(change));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2931,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "new_line_content": "ReorderBufferAbort(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn,",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(snapshot_now)",
          "new_text": null,
          "old_line_content": "\t\tAssert(snapshot_now);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 887,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "new_text": null,
          "old_line_content": "\t\t\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "SetupHistoricSnapshot",
          "new_api": null,
          "old_text": "SetupHistoricSnapshot(snapshot_now, NULL)",
          "new_text": null,
          "old_line_content": "\t\tSetupHistoricSnapshot(snapshot_now, NULL);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "PG_TRY",
          "new_api": null,
          "old_text": "PG_TRY()",
          "new_text": null,
          "old_line_content": "\t\tPG_TRY();",
          "new_line_content": "\t\tif (xid != InvalidTransactionId)",
          "content_same": false
        },
        {
          "line": 4987,
          "old_api": "hash_seq_init",
          "new_api": null,
          "old_text": "hash_seq_init(&hstat, txn->toast_hash)",
          "new_text": null,
          "old_line_content": "\thash_seq_init(&hstat, txn->toast_hash);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "message",
          "new_api": null,
          "old_text": "rb->message(rb, txn, lsn, false, prefix, message_size, message)",
          "new_text": null,
          "old_line_content": "\t\t\trb->message(rb, txn, lsn, false, prefix, message_size, message);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2941,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_streamed(txn))",
          "new_line_content": "\t\treturn;",
          "content_same": false
        },
        {
          "line": 2943,
          "old_api": "stream_abort",
          "new_api": null,
          "old_text": "rb->stream_abort(rb, txn, lsn)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_abort(rb, txn, lsn);",
          "new_line_content": "\ttxn->xact_time.abort_time = abort_time;",
          "content_same": false
        },
        {
          "line": 4988,
          "old_api": "hash_seq_search",
          "new_api": null,
          "old_text": "hash_seq_search(&hstat)",
          "new_text": null,
          "old_line_content": "\twhile ((ent = (ReorderBufferToastEnt *) hash_seq_search(&hstat)) != NULL)",
          "new_line_content": "\tif (txn->toast_hash == NULL)",
          "content_same": false
        },
        {
          "line": 897,
          "old_api": "PG_CATCH",
          "new_api": null,
          "old_text": "PG_CATCH()",
          "new_text": null,
          "old_line_content": "\t\tPG_CATCH();",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "TeardownHistoricSnapshot",
          "new_api": null,
          "old_text": "TeardownHistoricSnapshot(true)",
          "new_text": null,
          "old_line_content": "\t\t\tTeardownHistoricSnapshot(true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4995,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(it, &ent->chunks)",
          "new_text": null,
          "old_line_content": "\t\tdlist_foreach_modify(it, &ent->chunks)",
          "new_line_content": "\t\tdlist_mutable_iter it;",
          "content_same": false
        },
        {
          "line": 2952,
          "old_api": "ReorderBufferImmediateInvalidation",
          "new_api": null,
          "old_text": "ReorderBufferImmediateInvalidation(rb, txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t\t   txn->invalidations)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferImmediateInvalidation(rb, txn->ninvalidations,",
          "new_line_content": "\t\t * the cache as per the current transaction's view (consider DDL's",
          "content_same": false
        },
        {
          "line": 5001,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, true)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferReturnChange(rb, change, true);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2960,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 933,
          "old_api": "SnapBuildXactNeedsSkip",
          "new_api": null,
          "old_text": "SnapBuildXactNeedsSkip(ctx->snapshot_builder, ctx->reader->EndRecPtr)",
          "new_text": null,
          "old_line_content": "\tif (SnapBuildXactNeedsSkip(ctx->snapshot_builder, ctx->reader->EndRecPtr))",
          "new_line_content": "\t * the same LSN.  We don't guarantee this association until we try to",
          "content_same": false
        },
        {
          "line": 2982,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(it, &rb->toplevel_by_lsn)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(it, &rb->toplevel_by_lsn)",
          "new_line_content": "\t * older than what possibly can be running. Once we've found the first",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(iter, &rb->toplevel_by_lsn)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(iter, &rb->toplevel_by_lsn)",
          "new_line_content": "\t * restart.",
          "content_same": false
        },
        {
          "line": 2986,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, it.cur)",
          "new_text": null,
          "old_line_content": "\t\ttxn = dlist_container(ReorderBufferTXN, node, it.cur);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 2988,
          "old_api": "TransactionIdPrecedes",
          "new_api": null,
          "old_text": "TransactionIdPrecedes(txn->xid, oldestRunningXid)",
          "new_text": null,
          "old_line_content": "\t\tif (TransactionIdPrecedes(txn->xid, oldestRunningXid))",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur_txn->first_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\tAssert(cur_txn->first_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 2990,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG2, \"aborting old transaction %u\", txn->xid)",
          "new_text": null,
          "old_line_content": "\t\t\telog(DEBUG2, \"aborting old transaction %u\", txn->xid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur_txn->first_lsn <= cur_txn->end_lsn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(cur_txn->first_lsn <= cur_txn->end_lsn);",
          "new_line_content": "\t\t/* start LSN must be set */",
          "content_same": false
        },
        {
          "line": 2994,
          "old_api": "stream_abort",
          "new_api": null,
          "old_text": "rb->stream_abort(rb, txn, InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\t\t\trb->stream_abort(rb, txn, InvalidXLogRecPtr);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 2997,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\t\t/* Notify the remote node about the crash/immediate restart. */",
          "content_same": false
        },
        {
          "line": 950,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(prev_first_lsn < cur_txn->first_lsn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(prev_first_lsn < cur_txn->first_lsn);",
          "new_line_content": "\t\tif (cur_txn->end_lsn != InvalidXLogRecPtr)",
          "content_same": false
        },
        {
          "line": 953,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(cur_txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!rbtxn_is_known_subxact(cur_txn));",
          "new_line_content": "\t\t/* Current initial LSN must be strictly higher than previous */",
          "content_same": false
        },
        {
          "line": 5054,
          "old_api": "hash_seq_init",
          "new_api": null,
          "old_text": "hash_seq_init(&hstat, tuplecid_data)",
          "new_text": null,
          "old_line_content": "\thash_seq_init(&hstat, tuplecid_data);",
          "new_line_content": "DisplayMapping(HTAB *tuplecid_data)",
          "content_same": false
        },
        {
          "line": 5055,
          "old_api": "hash_seq_search",
          "new_api": null,
          "old_text": "hash_seq_search(&hstat)",
          "new_text": null,
          "old_line_content": "\twhile ((ent = (ReorderBufferTupleCidEnt *) hash_seq_search(&hstat)) != NULL)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbase_snapshot_node,\n\t\t\t\t\t\t\t\t\t\t\t\t\titer.cur)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTXN *cur_txn = dlist_container(ReorderBufferTXN,",
          "new_line_content": "\t\tprev_first_lsn = cur_txn->first_lsn;",
          "content_same": false
        },
        {
          "line": 5057,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG3, \"mapping: node: %u/%u/%u tid: %u/%u cmin: %u, cmax: %u\",\n\t\t\t ent->key.rlocator.dbOid,\n\t\t\t ent->key.rlocator.spcOid,\n\t\t\t ent->key.rlocator.relNumber,\n\t\t\t ItemPointerGetBlockNumber(&ent->key.tid),\n\t\t\t ItemPointerGetOffsetNumber(&ent->key.tid),\n\t\t\t ent->cmin,\n\t\t\t ent->cmax\n\t\t\t)",
          "new_text": null,
          "old_line_content": "\t\telog(DEBUG3, \"mapping: node: %u/%u/%u tid: %u/%u cmin: %u, cmax: %u\",",
          "new_line_content": "\tReorderBufferTupleCidEnt *ent;",
          "content_same": false
        },
        {
          "line": 5061,
          "old_api": "ItemPointerGetBlockNumber",
          "new_api": null,
          "old_text": "ItemPointerGetBlockNumber(&ent->key.tid)",
          "new_text": null,
          "old_line_content": "\t\t\t ItemPointerGetBlockNumber(&ent->key.tid),",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 966,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur_txn->base_snapshot_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\tAssert(cur_txn->base_snapshot_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t\t\t\tbase_snapshot_node,",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(cur_txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!rbtxn_is_known_subxact(cur_txn));",
          "new_line_content": "\t\t/* current LSN must be strictly higher than previous */",
          "content_same": false
        },
        {
          "line": 3022,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 3030,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\tAssert(!rbtxn_is_streamed(txn));",
          "new_line_content": "\t/* unknown, nothing to forget */",
          "content_same": false
        },
        {
          "line": 5084,
          "old_api": "sprintf",
          "new_api": null,
          "old_text": "sprintf(path, \"%s/%s\", PG_LOGICAL_MAPPINGS_DIR, fname)",
          "new_text": null,
          "old_line_content": "\tsprintf(path, \"%s/%s\", PG_LOGICAL_MAPPINGS_DIR, fname);",
          "new_line_content": "\tchar\t\tpath[MAXPGPATH];",
          "content_same": false
        },
        {
          "line": 5085,
          "old_api": "OpenTransientFile",
          "new_api": null,
          "old_text": "OpenTransientFile(path, O_RDONLY | PG_BINARY)",
          "new_text": null,
          "old_line_content": "\tfd = OpenTransientFile(path, O_RDONLY | PG_BINARY);",
          "new_line_content": "\tint\t\t\tfd;",
          "content_same": false
        },
        {
          "line": 5087,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)))",
          "new_text": null,
          "old_line_content": "\t\tereport(ERROR,",
          "new_line_content": "\tLogicalRewriteMappingData map;",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(iter, &txn->changes)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(iter, &txn->changes)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3041,
          "old_api": "ReorderBufferImmediateInvalidation",
          "new_api": null,
          "old_text": "ReorderBufferImmediateInvalidation(rb, txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t   txn->invalidations)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferImmediateInvalidation(rb, txn->ninvalidations,",
          "new_line_content": "\t * Process cache invalidation messages if there are any. Even if we're not",
          "content_same": false
        },
        {
          "line": 5088,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 996,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tcur_change = dlist_container(ReorderBufferChange, node, iter.cur);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3044,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->ninvalidations == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->ninvalidations == 0);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(cur_change->lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\t\tAssert(cur_change->lsn != InvalidXLogRecPtr);",
          "new_line_content": "\t\tReorderBufferChange *cur_change;",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->first_lsn <= cur_change->lsn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->first_lsn <= cur_change->lsn);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3047,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\t\t\t\t\t\t\t\t\t   txn->invalidations);",
          "content_same": false
        },
        {
          "line": 5099,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&key, 0, sizeof(ReorderBufferTupleCidKey))",
          "new_text": null,
          "old_line_content": "\t\tmemset(&key, 0, sizeof(ReorderBufferTupleCidKey));",
          "new_line_content": "\t\tReorderBufferTupleCidEnt *ent;",
          "content_same": false
        },
        {
          "line": 5102,
          "old_api": "pgstat_report_wait_start",
          "new_api": null,
          "old_text": "pgstat_report_wait_start(WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ)",
          "new_text": null,
          "old_line_content": "\t\tpgstat_report_wait_start(WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5103,
          "old_api": "read",
          "new_api": null,
          "old_text": "read(fd, &map, sizeof(LogicalRewriteMappingData))",
          "new_text": null,
          "old_line_content": "\t\treadBytes = read(fd, &map, sizeof(LogicalRewriteMappingData));",
          "new_line_content": "\t\t/* be careful about padding */",
          "content_same": false
        },
        {
          "line": 3063,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 5115,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t\t\t\t\t\tpath)));",
          "content_same": false
        },
        {
          "line": 5116,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not read from file \\\"%s\\\": read %d instead of %d bytes\",\n\t\t\t\t\t\t\tpath, readBytes,\n\t\t\t\t\t\t\t(int32) sizeof(LogicalRewriteMappingData))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t errmsg(\"could not read from file \\\"%s\\\": read %d instead of %d bytes\",",
          "new_line_content": "\t\telse if (readBytes == 0)\t/* EOF */",
          "content_same": false
        },
        {
          "line": 1021,
          "old_api": "AssertTXNLsnOrder",
          "new_api": null,
          "old_text": "AssertTXNLsnOrder(rb)",
          "new_text": null,
          "old_line_content": "\tAssertTXNLsnOrder(rb);",
          "new_line_content": "ReorderBufferTXN *",
          "content_same": false
        },
        {
          "line": 1023,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&rb->toplevel_by_lsn)",
          "new_text": null,
          "old_line_content": "\tif (dlist_is_empty(&rb->toplevel_by_lsn))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3076,
          "old_api": "ReorderBufferImmediateInvalidation",
          "new_api": null,
          "old_text": "ReorderBufferImmediateInvalidation(rb, txn->ninvalidations,\n\t\t\t\t\t\t\t\t\t\t   txn->invalidations)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferImmediateInvalidation(rb, txn->ninvalidations,",
          "new_line_content": "\t * Process cache invalidation messages if there are any. Even if we're not",
          "content_same": false
        },
        {
          "line": 1029,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->first_lsn != InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->first_lsn != InvalidXLogRecPtr);",
          "new_line_content": "\t\treturn NULL;",
          "content_same": false
        },
        {
          "line": 3079,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->ninvalidations == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->ninvalidations == 0);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 5133,
          "old_api": "ItemPointerCopy",
          "new_api": null,
          "old_text": "ItemPointerCopy(&map.new_tid,\n\t\t\t\t\t\t&key.tid)",
          "new_text": null,
          "old_line_content": "\t\tItemPointerCopy(&map.new_tid,",
          "new_line_content": "\t\t/* no existing mapping, no need to update */",
          "content_same": false
        },
        {
          "line": 5137,
          "old_api": "hash_search",
          "new_api": null,
          "old_text": "hash_search(tuplecid_data, &key, HASH_ENTER, &found)",
          "new_text": null,
          "old_line_content": "\t\t\thash_search(tuplecid_data, &key, HASH_ENTER, &found);",
          "new_line_content": "\t\tkey.rlocator = map.new_locator;",
          "content_same": false
        },
        {
          "line": 3093,
          "old_api": "IsTransactionOrTransactionBlock",
          "new_api": null,
          "old_text": "IsTransactionOrTransactionBlock()",
          "new_text": null,
          "old_line_content": "\tbool\t\tuse_subtxn = IsTransactionOrTransactionBlock();",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1049,
          "old_api": "AssertTXNLsnOrder",
          "new_api": null,
          "old_text": "AssertTXNLsnOrder(rb)",
          "new_text": null,
          "old_line_content": "\tAssertTXNLsnOrder(rb);",
          "new_line_content": "TransactionId",
          "content_same": false
        },
        {
          "line": 3097,
          "old_api": "BeginInternalSubTransaction",
          "new_api": null,
          "old_text": "BeginInternalSubTransaction(\"replay\")",
          "new_text": null,
          "old_line_content": "\t\tBeginInternalSubTransaction(\"replay\");",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&rb->txns_by_base_snapshot_lsn)",
          "new_text": null,
          "old_line_content": "\tif (dlist_is_empty(&rb->txns_by_base_snapshot_lsn))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 5146,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ent->cmin == InvalidCommandId || ent->cmin == new_ent->cmin)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(ent->cmin == InvalidCommandId || ent->cmin == new_ent->cmin);",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 5147,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ent->cmax == InvalidCommandId || ent->cmax == new_ent->cmax)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(ent->cmax == InvalidCommandId || ent->cmax == new_ent->cmax);",
          "new_line_content": "\t\t\t * Make sure the existing mapping makes sense. We sometime update",
          "content_same": false
        },
        {
          "line": 3106,
          "old_api": "AbortCurrentTransaction",
          "new_api": null,
          "old_text": "AbortCurrentTransaction()",
          "new_text": null,
          "old_line_content": "\t\tAbortCurrentTransaction();",
          "new_line_content": "\t * entries will just be marked as invalid without accessing the catalog.",
          "content_same": false
        },
        {
          "line": 3109,
          "old_api": "LocalExecuteInvalidationMessage",
          "new_api": null,
          "old_text": "LocalExecuteInvalidationMessage(&invalidations[i])",
          "new_text": null,
          "old_line_content": "\t\tLocalExecuteInvalidationMessage(&invalidations[i]);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 5158,
          "old_api": "CloseTransientFile",
          "new_api": null,
          "old_text": "CloseTransientFile(fd)",
          "new_text": null,
          "old_line_content": "\tif (CloseTransientFile(fd) != 0)",
          "new_line_content": "\t\t\tnew_ent->cmax = ent->cmax;",
          "content_same": false
        },
        {
          "line": 5159,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not close file \\\"%s\\\": %m\", path)))",
          "new_text": null,
          "old_line_content": "\t\tereport(ERROR,",
          "new_line_content": "\t\t\tnew_ent->combocid = ent->combocid;",
          "content_same": false
        },
        {
          "line": 3112,
          "old_api": "RollbackAndReleaseCurrentSubTransaction",
          "new_api": null,
          "old_text": "RollbackAndReleaseCurrentSubTransaction()",
          "new_text": null,
          "old_line_content": "\t\tRollbackAndReleaseCurrentSubTransaction();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5160,
          "old_api": "errcode_for_file_access",
          "new_api": null,
          "old_text": "errcode_for_file_access()",
          "new_text": null,
          "old_line_content": "\t\t\t\t(errcode_for_file_access(),",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 5161,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not close file \\\"%s\\\": %m\", path)",
          "new_text": null,
          "old_line_content": "\t\t\t\t errmsg(\"could not close file \\\"%s\\\": %m\", path)));",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 5171,
          "old_api": "bsearch",
          "new_api": null,
          "old_text": "bsearch(&xid, xip, num,\n\t\t\t\t   sizeof(TransactionId), xidComparator)",
          "new_text": null,
          "old_line_content": "\treturn bsearch(&xid, xip, num,",
          "new_line_content": " * Check whether the TransactionId 'xid' is in the pre-sorted array 'xip'.",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, &new_top, lsn, true)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, &new_top, lsn, true);",
          "new_line_content": "\tReorderBufferTXN *txn;",
          "content_same": false
        },
        {
          "line": 1081,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, subxid, true, &new_sub, lsn, false)",
          "new_text": null,
          "old_line_content": "\tsubtxn = ReorderBufferTXNByXid(rb, subxid, true, &new_sub, lsn, false);",
          "new_line_content": "\tReorderBufferTXN *subtxn;",
          "content_same": false
        },
        {
          "line": 3130,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "new_line_content": "void",
          "content_same": false
        },
        {
          "line": 5181,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(a_p)",
          "new_text": null,
          "old_line_content": "\tRewriteMappingFile *a = (RewriteMappingFile *) lfirst(a_p);",
          "new_line_content": " * list_sort() comparator for sorting RewriteMappingFiles in LSN order.",
          "content_same": false
        },
        {
          "line": 5182,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(b_p)",
          "new_text": null,
          "old_line_content": "\tRewriteMappingFile *b = (RewriteMappingFile *) lfirst(b_p);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 5184,
          "old_api": "pg_cmp_u64",
          "new_api": null,
          "old_text": "pg_cmp_u64(a->lsn, b->lsn)",
          "new_text": null,
          "old_line_content": "\treturn pg_cmp_u64(a->lsn, b->lsn);",
          "new_line_content": "file_sort_by_lsn(const ListCell *a_p, const ListCell *b_p)",
          "content_same": false
        },
        {
          "line": 3142,
          "old_api": "ReorderBufferGetChange",
          "new_api": null,
          "old_text": "ReorderBufferGetChange(rb)",
          "new_text": null,
          "old_line_content": "\tReorderBufferChange *change = ReorderBufferGetChange(rb);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1097,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&subtxn->node)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_delete(&subtxn->node);",
          "new_line_content": "\t\t\t/*",
          "content_same": false
        },
        {
          "line": 5198,
          "old_api": "IsSharedRelation",
          "new_api": null,
          "old_text": "IsSharedRelation(relid)",
          "new_text": null,
          "old_line_content": "\tOid\t\t\tdboid = IsSharedRelation(relid) ? InvalidOid : MyDatabaseId;",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1103,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subtxn->nsubtxns == 0)",
          "new_text": null,
          "old_line_content": "\tAssert(subtxn->nsubtxns == 0);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 5200,
          "old_api": "AllocateDir",
          "new_api": null,
          "old_text": "AllocateDir(PG_LOGICAL_MAPPINGS_DIR)",
          "new_text": null,
          "old_line_content": "\tmapping_dir = AllocateDir(PG_LOGICAL_MAPPINGS_DIR);",
          "new_line_content": "\tstruct dirent *mapping_de;",
          "content_same": false
        },
        {
          "line": 5201,
          "old_api": "ReadDir",
          "new_api": null,
          "old_text": "ReadDir(mapping_dir, PG_LOGICAL_MAPPINGS_DIR)",
          "new_text": null,
          "old_line_content": "\twhile ((mapping_de = ReadDir(mapping_dir, PG_LOGICAL_MAPPINGS_DIR)) != NULL)",
          "new_line_content": "\tList\t   *files = NIL;",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&txn->subtxns, &subtxn->node)",
          "new_text": null,
          "old_line_content": "\tdlist_push_tail(&txn->subtxns, &subtxn->node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "ReorderBufferTransferSnapToParent",
          "new_api": null,
          "old_text": "ReorderBufferTransferSnapToParent(txn, subtxn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferTransferSnapToParent(txn, subtxn);",
          "new_line_content": "\t/* add to subtransaction list */",
          "content_same": false
        },
        {
          "line": 3163,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(snap != NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(snap != NULL);",
          "new_line_content": "\t\t\t\t\t\t\t XLogRecPtr lsn, Snapshot snap)",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "AssertTXNLsnOrder",
          "new_api": null,
          "old_text": "AssertTXNLsnOrder(rb)",
          "new_text": null,
          "old_line_content": "\tAssertTXNLsnOrder(rb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5212,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(mapping_de->d_name, \".\")",
          "new_text": null,
          "old_line_content": "\t\tif (strcmp(mapping_de->d_name, \".\") == 0 ||",
          "new_line_content": "\t\tXLogRecPtr\tf_lsn;",
          "content_same": false
        },
        {
          "line": 5213,
          "old_api": "strcmp",
          "new_api": null,
          "old_text": "strcmp(mapping_de->d_name, \"..\")",
          "new_text": null,
          "old_line_content": "\t\t\tstrcmp(mapping_de->d_name, \"..\") == 0)",
          "new_line_content": "\t\tuint32\t\tf_hi,",
          "content_same": false
        },
        {
          "line": 3169,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, &is_new, lsn, true)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, &is_new, lsn, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3170,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_known_subxact(txn))",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 3171,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,\n\t\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false)",
          "new_text": null,
          "old_line_content": "\t\ttxn = ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,",
          "new_line_content": "\t * Fetch the transaction to operate on.  If we know it's a subtransaction,",
          "content_same": false
        },
        {
          "line": 5220,
          "old_api": "sscanf",
          "new_api": null,
          "old_text": "sscanf(mapping_de->d_name, LOGICAL_REWRITE_FORMAT,\n\t\t\t\t   &f_dboid, &f_relid, &f_hi, &f_lo,\n\t\t\t\t   &f_mapped_xid, &f_create_xid)",
          "new_text": null,
          "old_line_content": "\t\tif (sscanf(mapping_de->d_name, LOGICAL_REWRITE_FORMAT,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3173,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->base_snapshot == NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(txn->base_snapshot == NULL);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 5223,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(ERROR, \"could not parse filename \\\"%s\\\"\", mapping_de->d_name)",
          "new_text": null,
          "old_line_content": "\t\t\telog(ERROR, \"could not parse filename \\\"%s\\\"\", mapping_de->d_name);",
          "new_line_content": "\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 3177,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&rb->txns_by_base_snapshot_lsn, &txn->base_snapshot_node)",
          "new_text": null,
          "old_line_content": "\tdlist_push_tail(&rb->txns_by_base_snapshot_lsn, &txn->base_snapshot_node);",
          "new_line_content": "\t\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false);",
          "content_same": false
        },
        {
          "line": 3179,
          "old_api": "AssertTXNLsnOrder",
          "new_api": null,
          "old_text": "AssertTXNLsnOrder(rb)",
          "new_text": null,
          "old_line_content": "\tAssertTXNLsnOrder(rb);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5236,
          "old_api": "TransactionIdDidCommit",
          "new_api": null,
          "old_text": "TransactionIdDidCommit(f_create_xid)",
          "new_text": null,
          "old_line_content": "\t\tif (!TransactionIdDidCommit(f_create_xid))",
          "new_line_content": "\t\t/* mapping for another relation */",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subtxn->toplevel_xid == txn->xid)",
          "new_text": null,
          "old_line_content": "\tAssert(subtxn->toplevel_xid == txn->xid);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 3191,
          "old_api": "ReorderBufferGetChange",
          "new_api": null,
          "old_text": "ReorderBufferGetChange(rb)",
          "new_text": null,
          "old_line_content": "\tReorderBufferChange *change = ReorderBufferGetChange(rb);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 5240,
          "old_api": "TransactionIdInArray",
          "new_api": null,
          "old_text": "TransactionIdInArray(f_mapped_xid, snapshot->subxip, snapshot->subxcnt)",
          "new_text": null,
          "old_line_content": "\t\tif (!TransactionIdInArray(f_mapped_xid, snapshot->subxip, snapshot->subxcnt))",
          "new_line_content": "\t\t/* did the creating transaction abort? */",
          "content_same": false
        },
        {
          "line": 5244,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(RewriteMappingFile))",
          "new_text": null,
          "old_line_content": "\t\tf = palloc(sizeof(RewriteMappingFile));",
          "new_line_content": "\t\t/* not for our transaction */",
          "content_same": false
        },
        {
          "line": 5246,
          "old_api": "strcpy",
          "new_api": null,
          "old_text": "strcpy(f->fname, mapping_de->d_name)",
          "new_text": null,
          "old_line_content": "\t\tstrcpy(f->fname, mapping_de->d_name);",
          "new_line_content": "\t\t\tcontinue;",
          "content_same": false
        },
        {
          "line": 5247,
          "old_api": "lappend",
          "new_api": null,
          "old_text": "lappend(files, f)",
          "new_text": null,
          "old_line_content": "\t\tfiles = lappend(files, f);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1154,
          "old_api": "SnapBuildSnapDecRefcount",
          "new_api": null,
          "old_text": "SnapBuildSnapDecRefcount(txn->base_snapshot)",
          "new_text": null,
          "old_line_content": "\t\t\t\tSnapBuildSnapDecRefcount(txn->base_snapshot);",
          "new_line_content": "\t\t\t * If the toplevel transaction already has a base snapshot but",
          "content_same": false
        },
        {
          "line": 1155,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&txn->base_snapshot_node)",
          "new_text": null,
          "old_line_content": "\t\t\t\tdlist_delete(&txn->base_snapshot_node);",
          "new_line_content": "\t\t\t * it's newer than the subxact's, purge it.",
          "content_same": false
        },
        {
          "line": 5256,
          "old_api": "lfirst",
          "new_api": null,
          "old_text": "lfirst(file)",
          "new_text": null,
          "old_line_content": "\t\tRewriteMappingFile *f = (RewriteMappingFile *) lfirst(file);",
          "new_line_content": "\t/* sort files so we apply them in LSN order */",
          "content_same": false
        },
        {
          "line": 5258,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG1, \"applying mapping: \\\"%s\\\" in %u\", f->fname,\n\t\t\t snapshot->subxip[0])",
          "new_text": null,
          "old_line_content": "\t\telog(DEBUG1, \"applying mapping: \\\"%s\\\" in %u\", f->fname,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5260,
          "old_api": "ApplyLogicalMappingFile",
          "new_api": null,
          "old_text": "ApplyLogicalMappingFile(tuplecid_data, relid, f->fname)",
          "new_text": null,
          "old_line_content": "\t\tApplyLogicalMappingFile(tuplecid_data, relid, f->fname);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1165,
          "old_api": "dlist_insert_before",
          "new_api": null,
          "old_text": "dlist_insert_before(&subtxn->base_snapshot_node,\n\t\t\t\t\t\t\t\t&txn->base_snapshot_node)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_insert_before(&subtxn->base_snapshot_node,",
          "new_line_content": "\t\t\t * adjust the list position of the top transaction in the list by",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&subtxn->base_snapshot_node)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_delete(&subtxn->base_snapshot_node);",
          "new_line_content": "\t\t\t * The subtransaction doesn't have a snapshot anymore (so it",
          "content_same": false
        },
        {
          "line": 3223,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn || change)",
          "new_text": null,
          "old_line_content": "\tAssert(txn || change);",
          "new_line_content": "\t\t\t\t\t\t\t\tReorderBufferTXN *txn,",
          "content_same": false
        },
        {
          "line": 1180,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&subtxn->base_snapshot_node)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_delete(&subtxn->base_snapshot_node);",
          "new_line_content": "\t\t}",
          "content_same": false
        },
        {
          "line": 3238,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn != NULL)",
          "new_text": null,
          "old_line_content": "\tAssert(txn != NULL);",
          "new_line_content": "\tif (sz == 0)",
          "content_same": false
        },
        {
          "line": 3244,
          "old_api": "rbtxn_get_toptxn",
          "new_api": null,
          "old_text": "rbtxn_get_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\ttoptxn = rbtxn_get_toptxn(txn);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5293,
          "old_api": "memset",
          "new_api": null,
          "old_text": "memset(&key, 0, sizeof(key))",
          "new_text": null,
          "old_line_content": "\tmemset(&key, 0, sizeof(key));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, subxid, false, NULL,\n\t\t\t\t\t\t\t\t   InvalidXLogRecPtr, false)",
          "new_text": null,
          "old_line_content": "\tsubtxn = ReorderBufferTXNByXid(rb, subxid, false, NULL,",
          "new_line_content": "\t\t\t\t\t\t TransactionId subxid, XLogRecPtr commit_lsn,",
          "content_same": false
        },
        {
          "line": 5295,
          "old_api": "BufferIsLocal",
          "new_api": null,
          "old_text": "BufferIsLocal(buffer)",
          "new_text": null,
          "old_line_content": "\tAssert(!BufferIsLocal(buffer));",
          "new_line_content": "\t\treturn false;",
          "content_same": false
        },
        {
          "line": 5301,
          "old_api": "BufferGetTag",
          "new_api": null,
          "old_text": "BufferGetTag(buffer, &key.rlocator, &forkno, &blockno)",
          "new_text": null,
          "old_line_content": "\tBufferGetTag(buffer, &key.rlocator, &forkno, &blockno);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 5304,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(forkno == MAIN_FORKNUM)",
          "new_text": null,
          "old_line_content": "\tAssert(forkno == MAIN_FORKNUM);",
          "new_line_content": "\t * other than that.",
          "content_same": false
        },
        {
          "line": 5305,
          "old_api": "ItemPointerGetBlockNumber",
          "new_api": null,
          "old_text": "ItemPointerGetBlockNumber(&htup->t_self)",
          "new_text": null,
          "old_line_content": "\tAssert(blockno == ItemPointerGetBlockNumber(&htup->t_self));",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3258,
          "old_api": "pairingheap_remove",
          "new_api": null,
          "old_text": "pairingheap_remove(rb->txn_heap, &txn->txn_node)",
          "new_text": null,
          "old_line_content": "\t\t\tpairingheap_remove(rb->txn_heap, &txn->txn_node);",
          "new_line_content": "\t\t/* Update the total size in the top transaction. */",
          "content_same": false
        },
        {
          "line": 3259,
          "old_api": "pairingheap_add",
          "new_api": null,
          "old_text": "pairingheap_add(rb->txn_heap, &txn->txn_node)",
          "new_text": null,
          "old_line_content": "\t\tpairingheap_add(rb->txn_heap, &txn->txn_node);",
          "new_line_content": "\t\ttoptxn->total_size += sz;",
          "content_same": false
        },
        {
          "line": 5307,
          "old_api": "ItemPointerCopy",
          "new_api": null,
          "old_text": "ItemPointerCopy(&htup->t_self,\n\t\t\t\t\t&key.tid)",
          "new_text": null,
          "old_line_content": "\tItemPointerCopy(&htup->t_self,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "ReorderBufferAssignChild",
          "new_api": null,
          "old_text": "ReorderBufferAssignChild(rb, xid, subxid, InvalidXLogRecPtr)",
          "new_text": null,
          "old_line_content": "\tReorderBufferAssignChild(rb, xid, subxid, InvalidXLogRecPtr);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3271,
          "old_api": "pairingheap_remove",
          "new_api": null,
          "old_text": "pairingheap_remove(rb->txn_heap, &txn->txn_node)",
          "new_text": null,
          "old_line_content": "\t\tpairingheap_remove(rb->txn_heap, &txn->txn_node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3273,
          "old_api": "pairingheap_add",
          "new_api": null,
          "old_text": "pairingheap_add(rb->txn_heap, &txn->txn_node)",
          "new_text": null,
          "old_line_content": "\t\t\tpairingheap_add(rb->txn_heap, &txn->txn_node);",
          "new_line_content": "\t\ttoptxn->total_size -= sz;",
          "content_same": false
        },
        {
          "line": 5322,
          "old_api": "UpdateLogicalMappings",
          "new_api": null,
          "old_text": "UpdateLogicalMappings(tuplecid_data, htup->t_tableOid, snapshot)",
          "new_text": null,
          "old_line_content": "\t\tUpdateLogicalMappings(tuplecid_data, htup->t_tableOid, snapshot);",
          "new_line_content": "\t * mappings while we are in here since we have to hold a lock on the",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "DatumGetInt32",
          "new_api": null,
          "old_text": "DatumGetInt32(a)",
          "new_text": null,
          "old_line_content": "\tXLogRecPtr\tpos_a = state->entries[DatumGetInt32(a)].lsn;",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1238,
          "old_api": "DatumGetInt32",
          "new_api": null,
          "old_text": "DatumGetInt32(b)",
          "new_text": null,
          "old_line_content": "\tXLogRecPtr\tpos_b = state->entries[DatumGetInt32(b)].lsn;",
          "new_line_content": "static int",
          "content_same": false
        },
        {
          "line": 3292,
          "old_api": "ReorderBufferGetChange",
          "new_api": null,
          "old_text": "ReorderBufferGetChange(rb)",
          "new_text": null,
          "old_line_content": "\tReorderBufferChange *change = ReorderBufferGetChange(rb);",
          "new_line_content": "ReorderBufferAddNewTupleCids(ReorderBuffer *rb, TransactionId xid,",
          "content_same": false
        },
        {
          "line": 3295,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "new_line_content": "\t\t\t\t\t\t\t CommandId cmax, CommandId combocid)",
          "content_same": false
        },
        {
          "line": 3306,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&txn->tuplecids, &change->node)",
          "new_text": null,
          "old_line_content": "\tdlist_push_tail(&txn->tuplecids, &change->node);",
          "new_line_content": "\tchange->data.tuplecid.combocid = combocid;",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": "AssertChangeLsnOrder",
          "new_api": null,
          "old_text": "AssertChangeLsnOrder(txn)",
          "new_text": null,
          "old_line_content": "\tAssertChangeLsnOrder(txn);",
          "new_line_content": "\tint32\t\toff;",
          "content_same": false
        },
        {
          "line": 1278,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(cur_txn_i, &txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(cur_txn_i, &txn->subtxns)",
          "new_line_content": "\t * buffer, we count the one we were directly passed.)",
          "content_same": false
        },
        {
          "line": 1282,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, cur_txn_i.cur)",
          "new_text": null,
          "old_line_content": "\t\tcur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3332,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1285,
          "old_api": "AssertChangeLsnOrder",
          "new_api": null,
          "old_text": "AssertChangeLsnOrder(cur_txn)",
          "new_text": null,
          "old_line_content": "\t\tAssertChangeLsnOrder(cur_txn);",
          "new_line_content": "\t\tReorderBufferTXN *cur_txn;",
          "content_same": false
        },
        {
          "line": 3334,
          "old_api": "MemoryContextSwitchTo",
          "new_api": null,
          "old_text": "MemoryContextSwitchTo(rb->context)",
          "new_text": null,
          "old_line_content": "\toldcontext = MemoryContextSwitchTo(rb->context);",
          "new_line_content": "\tMemoryContext oldcontext;",
          "content_same": false
        },
        {
          "line": 1293,
          "old_api": "MemoryContextAllocZero",
          "new_api": null,
          "old_text": "MemoryContextAllocZero(rb->context,\n\t\t\t\t\t\t\t   sizeof(ReorderBufferIterTXNState) +\n\t\t\t\t\t\t\t   sizeof(ReorderBufferIterTXNEntry) * nr_txns)",
          "new_text": null,
          "old_line_content": "\t\tMemoryContextAllocZero(rb->context,",
          "new_line_content": "\t\t\tnr_txns++;",
          "content_same": false
        },
        {
          "line": 3341,
          "old_api": "rbtxn_get_toptxn",
          "new_api": null,
          "old_text": "rbtxn_get_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\ttxn = rbtxn_get_toptxn(txn);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 3343,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(nmsgs > 0)",
          "new_text": null,
          "old_line_content": "\tAssert(nmsgs > 0);",
          "new_line_content": "\t * so that we can execute them all together.  See comments atop this",
          "content_same": false
        },
        {
          "line": 3350,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(SharedInvalidationMessage) * nmsgs)",
          "new_text": null,
          "old_line_content": "\t\t\tpalloc(sizeof(SharedInvalidationMessage) * nmsgs);",
          "new_line_content": "\t/* Accumulate invalidations. */",
          "content_same": false
        },
        {
          "line": 3351,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(txn->invalidations, msgs,\n\t\t\t   sizeof(SharedInvalidationMessage) * nmsgs)",
          "new_text": null,
          "old_line_content": "\t\tmemcpy(txn->invalidations, msgs,",
          "new_line_content": "\tif (txn->ninvalidations == 0)",
          "content_same": false
        },
        {
          "line": 1307,
          "old_api": "binaryheap_allocate",
          "new_api": null,
          "old_text": "binaryheap_allocate(state->nr_txns,\n\t\t\t\t\t\t\t\t\t  ReorderBufferIterCompare,\n\t\t\t\t\t\t\t\t\t  state)",
          "new_text": null,
          "old_line_content": "\tstate->heap = binaryheap_allocate(state->nr_txns,",
          "new_line_content": "\t\tstate->entries[off].file.vfd = -1;",
          "content_same": false
        },
        {
          "line": 3357,
          "old_api": "repalloc",
          "new_api": null,
          "old_text": "repalloc(txn->invalidations, sizeof(SharedInvalidationMessage) *\n\t\t\t\t\t (txn->ninvalidations + nmsgs))",
          "new_text": null,
          "old_line_content": "\t\t\trepalloc(txn->invalidations, sizeof(SharedInvalidationMessage) *",
          "new_line_content": "\t\t\t   sizeof(SharedInvalidationMessage) * nmsgs);",
          "content_same": false
        },
        {
          "line": 3360,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(txn->invalidations + txn->ninvalidations, msgs,\n\t\t\t   nmsgs * sizeof(SharedInvalidationMessage))",
          "new_text": null,
          "old_line_content": "\t\tmemcpy(txn->invalidations + txn->ninvalidations, msgs,",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3369,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(SharedInvalidationMessage) * nmsgs)",
          "new_text": null,
          "old_line_content": "\t\tpalloc(sizeof(SharedInvalidationMessage) * nmsgs);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3373,
          "old_api": "ReorderBufferQueueChange",
          "new_api": null,
          "old_text": "ReorderBufferQueueChange(rb, xid, lsn, change, false)",
          "new_text": null,
          "old_line_content": "\tReorderBufferQueueChange(rb, xid, lsn, change, false);",
          "new_line_content": "\tchange->data.inval.invalidations = (SharedInvalidationMessage *)",
          "content_same": false
        },
        {
          "line": 1326,
          "old_api": "rbtxn_is_serialized",
          "new_api": null,
          "old_text": "rbtxn_is_serialized(txn)",
          "new_text": null,
          "old_line_content": "\t\tif (rbtxn_is_serialized(txn))",
          "new_line_content": "\t/* add toplevel transaction if it contains changes */",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": "ReorderBufferSerializeTXN",
          "new_api": null,
          "old_text": "ReorderBufferSerializeTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferSerializeTXN(rb, txn);",
          "new_line_content": "\t\tReorderBufferChange *cur_change;",
          "content_same": false
        },
        {
          "line": 1330,
          "old_api": "ReorderBufferRestoreChanges",
          "new_api": null,
          "old_text": "ReorderBufferRestoreChanges(rb, txn, &state->entries[off].file,\n\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferRestoreChanges(rb, txn, &state->entries[off].file,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3388,
          "old_api": "LocalExecuteInvalidationMessage",
          "new_api": null,
          "old_text": "LocalExecuteInvalidationMessage(&msgs[i])",
          "new_text": null,
          "old_line_content": "\t\tLocalExecuteInvalidationMessage(&msgs[i]);",
          "new_line_content": "ReorderBufferExecuteInvalidations(uint32 nmsgs, SharedInvalidationMessage *msgs)",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "Int32GetDatum",
          "new_api": null,
          "old_text": "Int32GetDatum(off++)",
          "new_text": null,
          "old_line_content": "\t\tbinaryheap_add_unordered(state->heap, Int32GetDatum(off++));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1345,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(cur_txn_i, &txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(cur_txn_i, &txn->subtxns)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, cur_txn_i.cur)",
          "new_text": null,
          "old_line_content": "\t\tcur_txn = dlist_container(ReorderBufferTXN, node, cur_txn_i.cur);",
          "new_line_content": "\t/* add subtransactions if they contain changes */",
          "content_same": false
        },
        {
          "line": 3400,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, true, NULL, lsn, true);",
          "new_line_content": "ReorderBufferXidSetCatalogChanges(ReorderBuffer *rb, TransactionId xid,",
          "content_same": false
        },
        {
          "line": 3402,
          "old_api": "rbtxn_has_catalog_changes",
          "new_api": null,
          "old_text": "rbtxn_has_catalog_changes(txn)",
          "new_text": null,
          "old_line_content": "\tif (!rbtxn_has_catalog_changes(txn))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": "rbtxn_is_serialized",
          "new_api": null,
          "old_text": "rbtxn_is_serialized(cur_txn)",
          "new_text": null,
          "old_line_content": "\t\t\tif (rbtxn_is_serialized(cur_txn))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": "ReorderBufferSerializeTXN",
          "new_api": null,
          "old_text": "ReorderBufferSerializeTXN(rb, cur_txn)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferSerializeTXN(rb, cur_txn);",
          "new_line_content": "\t\t\tReorderBufferChange *cur_change;",
          "content_same": false
        },
        {
          "line": 1359,
          "old_api": "ReorderBufferRestoreChanges",
          "new_api": null,
          "old_text": "ReorderBufferRestoreChanges(rb, cur_txn,\n\t\t\t\t\t\t\t\t\t\t\t&state->entries[off].file,\n\t\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferRestoreChanges(rb, cur_txn,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3414,
          "old_api": "rbtxn_is_subtxn",
          "new_api": null,
          "old_text": "rbtxn_is_subtxn(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_subtxn(txn))",
          "new_line_content": "\t * Mark top-level transaction as having catalog changes too if one of its",
          "content_same": false
        },
        {
          "line": 3416,
          "old_api": "rbtxn_get_toptxn",
          "new_api": null,
          "old_text": "rbtxn_get_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTXN *toptxn = rbtxn_get_toptxn(txn);",
          "new_line_content": "\t * conveniently check just top-level transaction and decide whether to",
          "content_same": false
        },
        {
          "line": 1370,
          "old_api": "Int32GetDatum",
          "new_api": null,
          "old_text": "Int32GetDatum(off++)",
          "new_text": null,
          "old_line_content": "\t\t\tbinaryheap_add_unordered(state->heap, Int32GetDatum(off++));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3418,
          "old_api": "rbtxn_has_catalog_changes",
          "new_api": null,
          "old_text": "rbtxn_has_catalog_changes(toptxn)",
          "new_text": null,
          "old_line_content": "\t\tif (!rbtxn_has_catalog_changes(toptxn))",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 3440,
          "old_api": "dclist_count",
          "new_api": null,
          "old_text": "dclist_count(&rb->catchange_txns)",
          "new_text": null,
          "old_line_content": "\tif (dclist_count(&rb->catchange_txns) == 0)",
          "new_line_content": "\tdlist_iter\titer;",
          "content_same": false
        },
        {
          "line": 1395,
          "old_api": "binaryheap_first",
          "new_api": null,
          "old_text": "binaryheap_first(state->heap)",
          "new_text": null,
          "old_line_content": "\toff = DatumGetInt32(binaryheap_first(state->heap));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3444,
          "old_api": "palloc",
          "new_api": null,
          "old_text": "palloc(sizeof(TransactionId) *\n\t\t\t\t\t\t\t\t\tdclist_count(&rb->catchange_txns))",
          "new_text": null,
          "old_line_content": "\txids = (TransactionId *) palloc(sizeof(TransactionId) *",
          "new_line_content": "\t/* Quick return if the list is empty */",
          "content_same": false
        },
        {
          "line": 3446,
          "old_api": "dclist_foreach",
          "new_api": null,
          "old_text": "dclist_foreach(iter, &rb->catchange_txns)",
          "new_text": null,
          "old_line_content": "\tdclist_foreach(iter, &rb->catchange_txns)",
          "new_line_content": "\t\treturn NULL;",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&state->old_change)",
          "new_text": null,
          "old_line_content": "\tif (!dlist_is_empty(&state->old_change))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3448,
          "old_api": "dclist_container",
          "new_api": null,
          "old_text": "dclist_container(ReorderBufferTXN,\n\t\t\t\t\t\t\t\t\t\t\t\t catchange_node,\n\t\t\t\t\t\t\t\t\t\t\t\t iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTXN *txn = dclist_container(ReorderBufferTXN,",
          "new_line_content": "\t/* Initialize XID array */",
          "content_same": false
        },
        {
          "line": 1401,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change))",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node,",
          "new_line_content": "\tentry = &state->entries[off];",
          "content_same": false
        },
        {
          "line": 1402,
          "old_api": "dlist_pop_head_node",
          "new_api": null,
          "old_text": "dlist_pop_head_node(&state->old_change)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, true)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, true);",
          "new_line_content": "\t/* free memory we might have \"leaked\" in the previous *Next call */",
          "content_same": false
        },
        {
          "line": 3452,
          "old_api": "rbtxn_has_catalog_changes",
          "new_api": null,
          "old_text": "rbtxn_has_catalog_changes(txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(rbtxn_has_catalog_changes(txn));",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3459,
          "old_api": "dclist_count",
          "new_api": null,
          "old_text": "dclist_count(&rb->catchange_txns)",
          "new_text": null,
          "old_line_content": "\tAssert(xcnt == dclist_count(&rb->catchange_txns));",
          "new_line_content": "\t\txids[xcnt++] = txn->xid;",
          "content_same": false
        },
        {
          "line": 1415,
          "old_api": "dlist_has_next",
          "new_api": null,
          "old_text": "dlist_has_next(&entry->txn->changes, &entry->change->node)",
          "new_text": null,
          "old_line_content": "\tif (dlist_has_next(&entry->txn->changes, &entry->change->node))",
          "new_line_content": "\t * update heap with information about which transaction has the next",
          "content_same": false
        },
        {
          "line": 1417,
          "old_api": "dlist_next_node",
          "new_api": null,
          "old_text": "dlist_next_node(&entry->txn->changes, &change->node)",
          "new_text": null,
          "old_line_content": "\t\tdlist_node *next = dlist_next_node(&entry->txn->changes, &change->node);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, next)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_container(ReorderBufferChange, node, next);",
          "new_line_content": "\t/* there are in-memory changes */",
          "content_same": false
        },
        {
          "line": 3472,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,\n\t\t\t\t\t\t\t\tfalse)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false, NULL, InvalidXLogRecPtr,",
          "new_line_content": "bool",
          "content_same": false
        },
        {
          "line": 1425,
          "old_api": "Int32GetDatum",
          "new_api": null,
          "old_text": "Int32GetDatum(off)",
          "new_text": null,
          "old_line_content": "\t\tbinaryheap_replace_first(state->heap, Int32GetDatum(off));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1436,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&change->node)",
          "new_text": null,
          "old_line_content": "\t\tdlist_delete(&change->node);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": "dlist_push_tail",
          "new_api": null,
          "old_text": "dlist_push_tail(&state->old_change, &change->node)",
          "new_text": null,
          "old_line_content": "\t\tdlist_push_tail(&state->old_change, &change->node);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 3489,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, xid, false,\n\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false)",
          "new_text": null,
          "old_line_content": "\ttxn = ReorderBufferTXNByXid(rb, xid, false,",
          "new_line_content": "bool",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "ReorderBufferRestoreChanges",
          "new_api": null,
          "old_text": "ReorderBufferRestoreChanges(rb, entry->txn, &entry->file,\n\t\t\t\t\t\t\t\t\t\t&state->entries[off].segno)",
          "new_text": null,
          "old_line_content": "\t\tif (ReorderBufferRestoreChanges(rb, entry->txn, &entry->file,",
          "new_line_content": "\t\t * Update the total bytes processed by the txn for which we are",
          "content_same": false
        },
        {
          "line": 3497,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_known_subxact(txn))",
          "new_line_content": "\t/* transaction isn't known yet, ergo no snapshot */",
          "content_same": false
        },
        {
          "line": 3498,
          "old_api": "ReorderBufferTXNByXid",
          "new_api": null,
          "old_text": "ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,\n\t\t\t\t\t\t\t\t\tNULL, InvalidXLogRecPtr, false)",
          "new_text": null,
          "old_line_content": "\t\ttxn = ReorderBufferTXNByXid(rb, txn->toplevel_xid, false,",
          "new_line_content": "\tif (txn == NULL)",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG2, \"restored %u/%u changes from disk\",\n\t\t\t\t (uint32) entry->txn->nentries_mem,\n\t\t\t\t (uint32) entry->txn->nentries)",
          "new_text": null,
          "old_line_content": "\t\t\telog(DEBUG2, \"restored %u/%u changes from disk\",",
          "new_line_content": "\t\t\t/* successfully restored changes from disk */",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(entry->txn->nentries_mem)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(entry->txn->nentries_mem);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1461,
          "old_api": "Int32GetDatum",
          "new_api": null,
          "old_text": "Int32GetDatum(off)",
          "new_text": null,
          "old_line_content": "\t\t\tbinaryheap_replace_first(state->heap, Int32GetDatum(off));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1468,
          "old_api": "binaryheap_remove_first",
          "new_api": null,
          "old_text": "binaryheap_remove_first(state->heap)",
          "new_text": null,
          "old_line_content": "\tbinaryheap_remove_first(state->heap);",
          "new_line_content": "\t\t\treturn change;",
          "content_same": false
        },
        {
          "line": 3519,
          "old_api": "MemoryContextAlloc",
          "new_api": null,
          "old_text": "MemoryContextAlloc(rb->context, sz)",
          "new_text": null,
          "old_line_content": "\t\trb->outbuf = MemoryContextAlloc(rb->context, sz);",
          "new_line_content": "static void",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "FileClose",
          "new_api": null,
          "old_text": "FileClose(state->entries[off].file.vfd)",
          "new_text": null,
          "old_line_content": "\t\t\tFileClose(state->entries[off].file.vfd);",
          "new_line_content": "\tint32\t\toff;",
          "content_same": false
        },
        {
          "line": 3534,
          "old_api": "pairingheap_const_container",
          "new_api": null,
          "old_text": "pairingheap_const_container(ReorderBufferTXN, txn_node, a)",
          "new_text": null,
          "old_line_content": "\tconst ReorderBufferTXN *ta = pairingheap_const_container(ReorderBufferTXN, txn_node, a);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3535,
          "old_api": "pairingheap_const_container",
          "new_api": null,
          "old_text": "pairingheap_const_container(ReorderBufferTXN, txn_node, b)",
          "new_text": null,
          "old_line_content": "\tconst ReorderBufferTXN *tb = pairingheap_const_container(ReorderBufferTXN, txn_node, b);",
          "new_line_content": "/* Compare two transactions by size */",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&state->old_change)",
          "new_text": null,
          "old_line_content": "\tif (!dlist_is_empty(&state->old_change))",
          "new_line_content": "\t\tif (state->entries[off].file.vfd != -1)",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node,\n\t\t\t\t\t\t\t\t dlist_pop_head_node(&state->old_change))",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node,",
          "new_line_content": "\t/* free memory we might have \"leaked\" in the last *Next call */",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, true)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, true);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1496,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&state->old_change)",
          "new_text": null,
          "old_line_content": "\t\tAssert(dlist_is_empty(&state->old_change));",
          "new_line_content": "\t\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 3553,
          "old_api": "pairingheap_container",
          "new_api": null,
          "old_text": "pairingheap_container(ReorderBufferTXN, txn_node,\n\t\t\t\t\t\t\t\t\tpairingheap_first(rb->txn_heap))",
          "new_text": null,
          "old_line_content": "\tlargest = pairingheap_container(ReorderBufferTXN, txn_node,",
          "new_line_content": "ReorderBufferLargestTXN(ReorderBuffer *rb)",
          "content_same": false
        },
        {
          "line": 3554,
          "old_api": "pairingheap_first",
          "new_api": null,
          "old_text": "pairingheap_first(rb->txn_heap)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t\t\t\tpairingheap_first(rb->txn_heap));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3556,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(largest)",
          "new_text": null,
          "old_line_content": "\tAssert(largest);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3557,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(largest->size > 0)",
          "new_text": null,
          "old_line_content": "\tAssert(largest->size > 0);",
          "new_line_content": "\t/* Get the largest transaction from the max-heap */",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(iter, &txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(iter, &txn->subtxns)",
          "new_line_content": "\tbool\t\tfound;",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tsubtxn = dlist_container(ReorderBufferTXN, node, iter.cur);",
          "new_line_content": "\t/* cleanup subtransactions & their changes */",
          "content_same": false
        },
        {
          "line": 1526,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(subtxn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(rbtxn_is_known_subxact(subtxn));",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1527,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subtxn->nsubtxns == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(subtxn->nsubtxns == 0);",
          "new_line_content": "\t\t * Subtransactions are always associated to the toplevel TXN, even if",
          "content_same": false
        },
        {
          "line": 1529,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, subtxn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferCleanupTXN(rb, subtxn);",
          "new_line_content": "\t\t * ever recurse more than one level deep here.",
          "content_same": false
        },
        {
          "line": 1533,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(iter, &txn->changes)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(iter, &txn->changes)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "new_line_content": "\t/* cleanup changes in the txn */",
          "content_same": false
        },
        {
          "line": 1540,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->txn == txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(change->txn == txn);",
          "new_line_content": "\t\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 3595,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(iter, &rb->txns_by_base_snapshot_lsn)",
          "new_line_content": "\tdlist_iter\titer;",
          "content_same": false
        },
        {
          "line": 1548,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\t\tmem_freed += ReorderBufferChangeSize(change);",
          "new_line_content": "\t\t * Instead of updating the memory counter for individual changes, we",
          "content_same": false
        },
        {
          "line": 1550,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, false)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "new_line_content": "\t\t * counter all together below. This saves costs of maintaining the",
          "content_same": false
        },
        {
          "line": 3599,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, base_snapshot_node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\ttxn = dlist_container(ReorderBufferTXN, base_snapshot_node, iter.cur);",
          "new_line_content": "\t/* Find the largest top-level transaction having a base snapshot. */",
          "content_same": false
        },
        {
          "line": 1554,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": null,
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed)",
          "new_text": null,
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3602,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!rbtxn_is_known_subxact(txn));",
          "new_line_content": "\t\tReorderBufferTXN *txn;",
          "content_same": false
        },
        {
          "line": 1560,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(iter, &txn->tuplecids)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(iter, &txn->tuplecids)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3608,
          "old_api": "rbtxn_has_streamable_change",
          "new_api": null,
          "old_text": "rbtxn_has_streamable_change(txn)",
          "new_text": null,
          "old_line_content": "\t\t\trbtxn_has_streamable_change(txn))",
          "new_line_content": "\t\t/* base_snapshot must be set */",
          "content_same": false
        },
        {
          "line": 1564,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->txn == txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(change->txn == txn);",
          "new_line_content": "\t\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 1568,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)",
          "new_text": null,
          "old_line_content": "\t\tAssert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1570,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, true)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, true);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": "SnapBuildSnapDecRefcount",
          "new_api": null,
          "old_text": "SnapBuildSnapDecRefcount(txn->base_snapshot)",
          "new_text": null,
          "old_line_content": "\t\tSnapBuildSnapDecRefcount(txn->base_snapshot);",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&txn->base_snapshot_node)",
          "new_text": null,
          "old_line_content": "\t\tdlist_delete(&txn->base_snapshot_node);",
          "new_line_content": "\t * Cleanup the base snapshot, if set.",
          "content_same": false
        },
        {
          "line": 1587,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(rbtxn_is_streamed(txn));",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1588,
          "old_api": "ReorderBufferFreeSnap",
          "new_api": null,
          "old_text": "ReorderBufferFreeSnap(rb, txn->snapshot_now)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferFreeSnap(rb, txn->snapshot_now);",
          "new_line_content": "\t * Cleanup the snapshot for the last streamed run.",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&txn->node)",
          "new_text": null,
          "old_line_content": "\tdlist_delete(&txn->node);",
          "new_line_content": "\t * parent's list of known subxacts; this leaves the parent's nsubxacts",
          "content_same": false
        },
        {
          "line": 1601,
          "old_api": "rbtxn_has_catalog_changes",
          "new_api": null,
          "old_text": "rbtxn_has_catalog_changes(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_has_catalog_changes(txn))",
          "new_line_content": "\t * count too high, but we don't care.  Otherwise, we are deleting the TXN",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": "dclist_delete_from",
          "new_api": null,
          "old_text": "dclist_delete_from(&rb->catchange_txns, &txn->catchange_node)",
          "new_text": null,
          "old_line_content": "\t\tdclist_delete_from(&rb->catchange_txns, &txn->catchange_node);",
          "new_line_content": "\t * from the LSN-ordered list of toplevel TXNs. We remove the TXN from the",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "rbtxn_is_serialized",
          "new_api": null,
          "old_text": "rbtxn_is_serialized(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_is_serialized(txn))",
          "new_line_content": "\t/* now remove reference from buffer */",
          "content_same": false
        },
        {
          "line": 1613,
          "old_api": "ReorderBufferReturnTXN",
          "new_api": null,
          "old_text": "ReorderBufferReturnTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferReturnTXN(rb, txn);",
          "new_line_content": "\t/* remove entries spilled to disk */",
          "content_same": false
        },
        {
          "line": 3662,
          "old_api": "ReorderBufferCanStartStreaming",
          "new_api": null,
          "old_text": "ReorderBufferCanStartStreaming(rb)",
          "new_text": null,
          "old_line_content": "\t\tif (ReorderBufferCanStartStreaming(rb) &&",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3663,
          "old_api": "ReorderBufferLargestStreamableTopTXN",
          "new_api": null,
          "old_text": "ReorderBufferLargestStreamableTopTXN(rb)",
          "new_text": null,
          "old_line_content": "\t\t\t(txn = ReorderBufferLargestStreamableTopTXN(rb)) != NULL)",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 3666,
          "old_api": "rbtxn_is_toptxn",
          "new_api": null,
          "old_text": "rbtxn_is_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(txn && rbtxn_is_toptxn(txn));",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 3670,
          "old_api": "ReorderBufferStreamTXN",
          "new_api": null,
          "old_text": "ReorderBufferStreamTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferStreamTXN(rb, txn);",
          "new_line_content": "\t\t\t/* we know there has to be one, because the size is not zero */",
          "content_same": false
        },
        {
          "line": 3678,
          "old_api": "ReorderBufferLargestTXN",
          "new_api": null,
          "old_text": "ReorderBufferLargestTXN(rb)",
          "new_text": null,
          "old_line_content": "\t\t\ttxn = ReorderBufferLargestTXN(rb);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3681,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(txn);",
          "new_line_content": "\t\t\t * from memory by serializing it to disk.",
          "content_same": false
        },
        {
          "line": 1634,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(iter, &txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(iter, &txn->subtxns)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 3682,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->size > 0)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(txn->size > 0);",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 3685,
          "old_api": "ReorderBufferSerializeTXN",
          "new_api": null,
          "old_text": "ReorderBufferSerializeTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferSerializeTXN(rb, txn);",
          "new_line_content": "\t\t\t/* we know there has to be one, because the size is not zero */",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tsubtxn = dlist_container(ReorderBufferTXN, node, iter.cur);",
          "new_line_content": "\t/* cleanup subtransactions & their changes */",
          "content_same": false
        },
        {
          "line": 3692,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->size == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->size == 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1645,
          "old_api": "rbtxn_is_known_subxact",
          "new_api": null,
          "old_text": "rbtxn_is_known_subxact(subtxn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(rbtxn_is_known_subxact(subtxn));",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(subtxn->nsubtxns == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(subtxn->nsubtxns == 0);",
          "new_line_content": "\t\t * Subtransactions are always associated to the toplevel TXN, even if",
          "content_same": false
        },
        {
          "line": 3693,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->nentries_mem == 0)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->nentries_mem == 0);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "ReorderBufferTruncateTXN",
          "new_api": null,
          "old_text": "ReorderBufferTruncateTXN(rb, subtxn, txn_prepared)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTruncateTXN(rb, subtxn, txn_prepared);",
          "new_line_content": "\t\t * ever recurse more than one level deep here.",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(iter, &txn->changes)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach_modify(iter, &txn->changes)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "new_line_content": "\t/* cleanup changes in the txn */",
          "content_same": false
        },
        {
          "line": 1659,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->txn == txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(change->txn == txn);",
          "new_line_content": "\t\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 1662,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&change->node)",
          "new_text": null,
          "old_line_content": "\t\tdlist_delete(&change->node);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3714,
          "old_api": "elog",
          "new_api": null,
          "old_text": "elog(DEBUG2, \"spill %u changes in XID %u to disk\",\n\t\t (uint32) txn->nentries_mem, txn->xid)",
          "new_text": null,
          "old_line_content": "\telog(DEBUG2, \"spill %u changes in XID %u to disk\",",
          "new_line_content": "\tint\t\t\tfd = -1;",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": "ReorderBufferChangeSize",
          "new_api": null,
          "old_text": "ReorderBufferChangeSize(change)",
          "new_text": null,
          "old_line_content": "\t\tmem_freed += ReorderBufferChangeSize(change);",
          "new_line_content": "\t\t * Instead of updating the memory counter for individual changes, we",
          "content_same": false
        },
        {
          "line": 3718,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(subtxn_i, &txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(subtxn_i, &txn->subtxns)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "ReorderBufferReturnChange",
          "new_api": null,
          "old_text": "ReorderBufferReturnChange(rb, change, false)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferReturnChange(rb, change, false);",
          "new_line_content": "\t\t * counter all together below. This saves costs of maintaining the",
          "content_same": false
        },
        {
          "line": 3722,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, subtxn_i.cur)",
          "new_text": null,
          "old_line_content": "\t\tsubtxn = dlist_container(ReorderBufferTXN, node, subtxn_i.cur);",
          "new_line_content": "\t/* do the same to all child TXs */",
          "content_same": false
        },
        {
          "line": 1676,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": null,
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed)",
          "new_text": null,
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, mem_freed);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3731,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, change_i.cur)",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, change_i.cur);",
          "new_line_content": "\t/* serialize changestream */",
          "content_same": false
        },
        {
          "line": 3738,
          "old_api": "XLByteInSeg",
          "new_api": null,
          "old_text": "XLByteInSeg(change->lsn, curOpenSegNo, wal_segment_size)",
          "new_text": null,
          "old_line_content": "\t\t\t!XLByteInSeg(change->lsn, curOpenSegNo, wal_segment_size))",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1693,
          "old_api": "rbtxn_is_toptxn",
          "new_api": null,
          "old_text": "rbtxn_is_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\tif ((!txn_prepared) && (rbtxn_is_toptxn(txn) || (txn->nentries_mem != 0)))",
          "new_line_content": "\t * We do it this way because of aborts - we don't want to send aborts for",
          "content_same": false
        },
        {
          "line": 3745,
          "old_api": "XLByteToSeg",
          "new_api": null,
          "old_text": "XLByteToSeg(change->lsn, curOpenSegNo, wal_segment_size)",
          "new_text": null,
          "old_line_content": "\t\t\tXLByteToSeg(change->lsn, curOpenSegNo, wal_segment_size);",
          "new_line_content": "\t\t\tchar\t\tpath[MAXPGPATH];",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": "dlist_foreach_modify",
          "new_api": null,
          "old_text": "dlist_foreach_modify(iter, &txn->tuplecids)",
          "new_text": null,
          "old_line_content": "\t\tdlist_foreach_modify(iter, &txn->tuplecids)",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 3751,
          "old_api": "ReorderBufferSerializedPath",
          "new_api": null,
          "old_text": "ReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,\n\t\t\t\t\t\t\t\t\t\tcurOpenSegNo)",
          "new_text": null,
          "old_line_content": "\t\t\tReorderBufferSerializedPath(path, MyReplicationSlot, txn->xid,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "new_line_content": "\t\t */",
          "content_same": false
        },
        {
          "line": 3755,
          "old_api": "OpenTransientFile",
          "new_api": null,
          "old_text": "OpenTransientFile(path,\n\t\t\t\t\t\t\t\t   O_CREAT | O_WRONLY | O_APPEND | PG_BINARY)",
          "new_text": null,
          "old_line_content": "\t\t\tfd = OpenTransientFile(path,",
          "new_line_content": "\t\t\t */",
          "content_same": false
        },
        {
          "line": 1710,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->txn == txn)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(change->txn == txn);",
          "new_line_content": "\t\t\tReorderBufferChange *change;",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3759,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)))",
          "new_text": null,
          "old_line_content": "\t\t\t\tereport(ERROR,",
          "new_line_content": "\t\t\t/* open segment, create it if necessary */",
          "content_same": false
        },
        {
          "line": 3761,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not open file \\\"%s\\\": %m\", path)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", path)));",
          "new_line_content": "\t\t\t\t\t\t\t\t   O_CREAT | O_WRONLY | O_APPEND | PG_BINARY);",
          "content_same": false
        },
        {
          "line": 1714,
          "old_api": "dlist_delete",
          "new_api": null,
          "old_text": "dlist_delete(&change->node)",
          "new_text": null,
          "old_line_content": "\t\t\tdlist_delete(&change->node);",
          "new_line_content": "\t\t\t/* Check we're not mixing changes from different transactions. */",
          "content_same": false
        },
        {
          "line": 3772,
          "old_api": "ReorderBufferChangeMemoryUpdate",
          "new_api": null,
          "old_text": "ReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, size)",
          "new_text": null,
          "old_line_content": "\tReorderBufferChangeMemoryUpdate(rb, NULL, txn, false, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": "hash_destroy",
          "new_api": null,
          "old_text": "hash_destroy(txn->tuplecid_hash)",
          "new_text": null,
          "old_line_content": "\t\thash_destroy(txn->tuplecid_hash);",
          "new_line_content": "\t * memory. We could also keep the hash table and update it with new ctid",
          "content_same": false
        },
        {
          "line": 3781,
          "old_api": "rbtxn_is_serialized_clear",
          "new_api": null,
          "old_text": "rbtxn_is_serialized_clear(txn)",
          "new_text": null,
          "old_line_content": "\t\trb->spillTxns += (rbtxn_is_serialized(txn) || rbtxn_is_serialized_clear(txn)) ? 0 : 1;",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "ReorderBufferRestoreCleanup",
          "new_api": null,
          "old_text": "ReorderBufferRestoreCleanup(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferRestoreCleanup(rb, txn);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3784,
          "old_api": "UpdateDecodingStats",
          "new_api": null,
          "old_text": "UpdateDecodingStats((LogicalDecodingContext *) rb->private_data)",
          "new_text": null,
          "old_line_content": "\t\tUpdateDecodingStats((LogicalDecodingContext *) rb->private_data);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3787,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(spilled == txn->nentries_mem)",
          "new_text": null,
          "old_line_content": "\tAssert(spilled == txn->nentries_mem);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3788,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&txn->changes)",
          "new_text": null,
          "old_line_content": "\tAssert(dlist_is_empty(&txn->changes));",
          "new_line_content": "\t\t/* update the decoding stats */",
          "content_same": false
        },
        {
          "line": 3806,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sz)",
          "new_text": null,
          "old_line_content": "\tReorderBufferSerializeReserve(rb, sz);",
          "new_line_content": "\t\t\t\t\t\t\t int fd, ReorderBufferChange *change)",
          "content_same": false
        },
        {
          "line": 1760,
          "old_api": "dlist_is_empty",
          "new_api": null,
          "old_text": "dlist_is_empty(&txn->tuplecids)",
          "new_text": null,
          "old_line_content": "\tif (!rbtxn_has_catalog_changes(txn) || dlist_is_empty(&txn->tuplecids))",
          "new_line_content": "ReorderBufferBuildTupleCidHash(ReorderBuffer *rb, ReorderBufferTXN *txn)",
          "content_same": false
        },
        {
          "line": 3809,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(&ondisk->change, change, sizeof(ReorderBufferChange))",
          "new_text": null,
          "old_line_content": "\tmemcpy(&ondisk->change, change, sizeof(ReorderBufferChange));",
          "new_line_content": "\tSize\t\tsz = sizeof(ReorderBufferDiskChange);",
          "content_same": false
        },
        {
          "line": 1772,
          "old_api": "hash_create",
          "new_api": null,
          "old_text": "hash_create(\"ReorderBufferTupleCid\", txn->ntuplecids, &hash_ctl,\n\t\t\t\t\tHASH_ELEM | HASH_BLOBS | HASH_CONTEXT)",
          "new_text": null,
          "old_line_content": "\t\thash_create(\"ReorderBufferTupleCid\", txn->ntuplecids, &hash_ctl,",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(iter, &txn->tuplecids)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(iter, &txn->tuplecids)",
          "new_line_content": "\t */",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferChange, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tchange = dlist_container(ReorderBufferChange, node, iter.cur);",
          "new_line_content": "\t\tReorderBufferTupleCidKey key;",
          "content_same": false
        },
        {
          "line": 1784,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID)",
          "new_text": null,
          "old_line_content": "\t\tAssert(change->action == REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID);",
          "new_line_content": "\t\tbool\t\tfound;",
          "content_same": false
        },
        {
          "line": 1791,
          "old_api": "ItemPointerCopy",
          "new_api": null,
          "old_text": "ItemPointerCopy(&change->data.tuplecid.tid,\n\t\t\t\t\t\t&key.tid)",
          "new_text": null,
          "old_line_content": "\t\tItemPointerCopy(&change->data.tuplecid.tid,",
          "new_line_content": "\t\t/* be careful about padding */",
          "content_same": false
        },
        {
          "line": 1795,
          "old_api": "hash_search",
          "new_api": null,
          "old_text": "hash_search(txn->tuplecid_hash, &key, HASH_ENTER, &found)",
          "new_text": null,
          "old_line_content": "\t\t\thash_search(txn->tuplecid_hash, &key, HASH_ENTER, &found);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3843,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sz)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "new_line_content": "\t\t\t\t\tnewlen = newtup->t_len;",
          "content_same": false
        },
        {
          "line": 3851,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, oldtup, sizeof(HeapTupleData))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemcpy(data, oldtup, sizeof(HeapTupleData));",
          "new_line_content": "\t\t\t\t/* might have been reallocated above */",
          "content_same": false
        },
        {
          "line": 3854,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, oldtup->t_data, oldlen)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemcpy(data, oldtup->t_data, oldlen);",
          "new_line_content": "\t\t\t\tif (oldlen)",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ent->cmin == change->data.tuplecid.cmin)",
          "new_text": null,
          "old_line_content": "\t\t\tAssert(ent->cmin == change->data.tuplecid.cmin);",
          "new_line_content": "\t\t{",
          "content_same": false
        },
        {
          "line": 3860,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, newtup, sizeof(HeapTupleData))",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemcpy(data, newtup, sizeof(HeapTupleData));",
          "new_line_content": "\t\t\t\t\tdata += oldlen;",
          "content_same": false
        },
        {
          "line": 1814,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert((ent->cmax == InvalidCommandId) ||\n\t\t\t\t   ((change->data.tuplecid.cmax != InvalidCommandId) &&\n\t\t\t\t\t(change->data.tuplecid.cmax > ent->cmax)))",
          "new_text": null,
          "old_line_content": "\t\t\tAssert((ent->cmax == InvalidCommandId) ||",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3863,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, newtup->t_data, newlen)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemcpy(data, newtup->t_data, newlen);",
          "new_line_content": "\t\t\t\tif (newlen)",
          "content_same": false
        },
        {
          "line": 3871,
          "old_api": "strlen",
          "new_api": null,
          "old_text": "strlen(change->data.msg.prefix)",
          "new_text": null,
          "old_line_content": "\t\t\t\tSize\t\tprefix_size = strlen(change->data.msg.prefix) + 1;",
          "new_line_content": "\t\t\t\tbreak;",
          "content_same": false
        },
        {
          "line": 3875,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sz)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "new_line_content": "\t\t\t\tchar\t   *data;",
          "content_same": false
        },
        {
          "line": 3883,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, &prefix_size, sizeof(Size))",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(data, &prefix_size, sizeof(Size));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3885,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, change->data.msg.prefix,\n\t\t\t\t\t   prefix_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(data, change->data.msg.prefix,",
          "new_line_content": "\t\t\t\tondisk = (ReorderBufferDiskChange *) rb->outbuf;",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "MemoryContextAllocZero",
          "new_api": null,
          "old_text": "MemoryContextAllocZero(rb->context, size)",
          "new_text": null,
          "old_line_content": "\tsnap = MemoryContextAllocZero(rb->context, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1841,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(snap, orig_snap, sizeof(SnapshotData))",
          "new_text": null,
          "old_line_content": "\tmemcpy(snap, orig_snap, sizeof(SnapshotData));",
          "new_line_content": "\tsize = sizeof(SnapshotData) +",
          "content_same": false
        },
        {
          "line": 3892,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, change->data.msg.message,\n\t\t\t\t\t   change->data.msg.message_size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(data, change->data.msg.message,",
          "new_line_content": "\t\t\t\tdata += prefix_size;",
          "content_same": false
        },
        {
          "line": 1848,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(snap->xip, orig_snap->xip, sizeof(TransactionId) * snap->xcnt)",
          "new_text": null,
          "old_line_content": "\tmemcpy(snap->xip, orig_snap->xip, sizeof(TransactionId) * snap->xcnt);",
          "new_line_content": "\tsnap->copied = true;",
          "content_same": false
        },
        {
          "line": 3906,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sz)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "new_line_content": "\t\t\t\tSize\t\tinval_size = sizeof(SharedInvalidationMessage) *",
          "content_same": false
        },
        {
          "line": 1865,
          "old_api": "dlist_foreach",
          "new_api": null,
          "old_text": "dlist_foreach(iter, &txn->subtxns)",
          "new_text": null,
          "old_line_content": "\tdlist_foreach(iter, &txn->subtxns)",
          "new_line_content": "\t * Since it's an upper boundary it is safe to use it for the allocation",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, iter.cur)",
          "new_text": null,
          "old_line_content": "\t\tsub_txn = dlist_container(ReorderBufferTXN, node, iter.cur);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1875,
          "old_api": "qsort",
          "new_api": null,
          "old_text": "qsort(snap->subxip, snap->subxcnt, sizeof(TransactionId), xidComparator)",
          "new_text": null,
          "old_line_content": "\tqsort(snap->subxip, snap->subxcnt, sizeof(TransactionId), xidComparator);",
          "new_line_content": "\t\tsnap->subxip[i++] = sub_txn->xid;",
          "content_same": false
        },
        {
          "line": 3928,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sz)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "new_line_content": "\t\t\t\tsz += sizeof(SnapshotData) +",
          "content_same": false
        },
        {
          "line": 1890,
          "old_api": "pfree",
          "new_api": null,
          "old_text": "pfree(snap)",
          "new_text": null,
          "old_line_content": "\t\tpfree(snap);",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "SnapBuildSnapDecRefcount",
          "new_api": null,
          "old_text": "SnapBuildSnapDecRefcount(snap)",
          "new_text": null,
          "old_line_content": "\t\tSnapBuildSnapDecRefcount(snap);",
          "new_line_content": "ReorderBufferFreeSnap(ReorderBuffer *rb, Snapshot snap)",
          "content_same": false
        },
        {
          "line": 3945,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, snap->subxip,\n\t\t\t\t\t\t   sizeof(TransactionId) * snap->subxcnt)",
          "new_text": null,
          "old_line_content": "\t\t\t\t\tmemcpy(data, snap->subxip,",
          "new_line_content": "\t\t\t\t\tdata += sizeof(TransactionId) * snap->xcnt;",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\tAssert(rbtxn_is_streamed(txn));",
          "new_line_content": " */",
          "content_same": false
        },
        {
          "line": 1907,
          "old_api": "ReorderBufferStreamTXN",
          "new_api": null,
          "old_text": "ReorderBufferStreamTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\tReorderBufferStreamTXN(rb, txn);",
          "new_line_content": "ReorderBufferStreamCommit(ReorderBuffer *rb, ReorderBufferTXN *txn)",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "rbtxn_prepared",
          "new_api": null,
          "old_text": "rbtxn_prepared(txn)",
          "new_text": null,
          "old_line_content": "\tif (rbtxn_prepared(txn))",
          "new_line_content": "\t/* we should only call this for previously streamed transactions */",
          "content_same": false
        },
        {
          "line": 3961,
          "old_api": "ReorderBufferSerializeReserve",
          "new_api": null,
          "old_text": "ReorderBufferSerializeReserve(rb, sz)",
          "new_text": null,
          "old_line_content": "\t\t\t\tReorderBufferSerializeReserve(rb, sz);",
          "new_line_content": "\t\t\t\t/* account for the OIDs of truncated relations */",
          "content_same": false
        },
        {
          "line": 1915,
          "old_api": "stream_prepare",
          "new_api": null,
          "old_text": "rb->stream_prepare(rb, txn, txn->final_lsn)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_prepare(rb, txn, txn->final_lsn);",
          "new_line_content": "\t{",
          "content_same": false
        },
        {
          "line": 3967,
          "old_api": "memcpy",
          "new_api": null,
          "old_text": "memcpy(data, change->data.truncate.relids, size)",
          "new_text": null,
          "old_line_content": "\t\t\t\tmemcpy(data, change->data.truncate.relids, size);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1922,
          "old_api": "ReorderBufferTruncateTXN",
          "new_api": null,
          "old_text": "ReorderBufferTruncateTXN(rb, txn, true)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferTruncateTXN(rb, txn, true);",
          "new_line_content": "\t\t/*",
          "content_same": false
        },
        {
          "line": 1928,
          "old_api": "stream_commit",
          "new_api": null,
          "old_text": "rb->stream_commit(rb, txn, txn->final_lsn)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_commit(rb, txn, txn->final_lsn);",
          "new_line_content": "\t\t/* Reset the CheckXidAlive */",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": "ReorderBufferCleanupTXN",
          "new_api": null,
          "old_text": "ReorderBufferCleanupTXN(rb, txn)",
          "new_text": null,
          "old_line_content": "\t\tReorderBufferCleanupTXN(rb, txn);",
          "new_line_content": "\t\tCheckXidAlive = InvalidTransactionId;",
          "content_same": false
        },
        {
          "line": 3983,
          "old_api": "pgstat_report_wait_start",
          "new_api": null,
          "old_text": "pgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE)",
          "new_text": null,
          "old_line_content": "\tpgstat_report_wait_start(WAIT_EVENT_REORDER_BUFFER_WRITE);",
          "new_line_content": "\t}",
          "content_same": false
        },
        {
          "line": 3984,
          "old_api": "write",
          "new_api": null,
          "old_text": "write(fd, rb->outbuf, ondisk->size)",
          "new_text": null,
          "old_line_content": "\tif (write(fd, rb->outbuf, ondisk->size) != ondisk->size)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3992,
          "old_api": "ereport",
          "new_api": null,
          "old_text": "ereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not write to data file for XID %u: %m\",\n\t\t\t\t\t\ttxn->xid)))",
          "new_text": null,
          "old_line_content": "\t\tereport(ERROR,",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 3994,
          "old_api": "errmsg",
          "new_api": null,
          "old_text": "errmsg(\"could not write to data file for XID %u: %m\",\n\t\t\t\t\t\ttxn->xid)",
          "new_text": null,
          "old_line_content": "\t\t\t\t errmsg(\"could not write to data file for XID %u: %m\",",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4010,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(ondisk->change.action == change->action)",
          "new_text": null,
          "old_line_content": "\tAssert(ondisk->change.action == change->action);",
          "new_line_content": "\t * Make sure not to move it backwards.",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": "TransactionIdEquals",
          "new_api": null,
          "old_text": "TransactionIdEquals(CheckXidAlive, xid)",
          "new_text": null,
          "old_line_content": "\tif (TransactionIdEquals(CheckXidAlive, xid))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1979,
          "old_api": "TransactionIdDidCommit",
          "new_api": null,
          "old_text": "TransactionIdDidCommit(xid)",
          "new_text": null,
          "old_line_content": "\tif (!TransactionIdDidCommit(xid))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4030,
          "old_api": "SnapBuildCurrentState",
          "new_api": null,
          "old_text": "SnapBuildCurrentState(builder)",
          "new_text": null,
          "old_line_content": "\tif (SnapBuildCurrentState(builder) < SNAPBUILD_CONSISTENT)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 4038,
          "old_api": "ReorderBufferCanStream",
          "new_api": null,
          "old_text": "ReorderBufferCanStream(rb)",
          "new_text": null,
          "old_line_content": "\tif (ReorderBufferCanStream(rb) &&",
          "new_line_content": "\t/*",
          "content_same": false
        },
        {
          "line": 4039,
          "old_api": "SnapBuildXactNeedsSkip",
          "new_api": null,
          "old_text": "SnapBuildXactNeedsSkip(builder, ctx->reader->ReadRecPtr)",
          "new_text": null,
          "old_line_content": "\t\t!SnapBuildXactNeedsSkip(builder, ctx->reader->ReadRecPtr))",
          "new_line_content": "\t * We can't start streaming immediately even if the streaming is enabled",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "stream_change",
          "new_api": null,
          "old_text": "rb->stream_change(rb, txn, relation, change)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_change(rb, txn, relation, change);",
          "new_line_content": "ReorderBufferApplyChange(ReorderBuffer *rb, ReorderBufferTXN *txn,",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": "apply_change",
          "new_api": null,
          "old_text": "rb->apply_change(rb, txn, relation, change)",
          "new_text": null,
          "old_line_content": "\t\trb->apply_change(rb, txn, relation, change);",
          "new_line_content": "\t\t\t\t\t\t bool streaming)",
          "content_same": false
        },
        {
          "line": 2008,
          "old_api": "stream_truncate",
          "new_api": null,
          "old_text": "rb->stream_truncate(rb, txn, nrelations, relations, change)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_truncate(rb, txn, nrelations, relations, change);",
          "new_line_content": "ReorderBufferApplyTruncate(ReorderBuffer *rb, ReorderBufferTXN *txn,",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "apply_truncate",
          "new_api": null,
          "old_text": "rb->apply_truncate(rb, txn, nrelations, relations, change)",
          "new_text": null,
          "old_line_content": "\t\trb->apply_truncate(rb, txn, nrelations, relations, change);",
          "new_line_content": "\t\t\t\t\t\t   ReorderBufferChange *change, bool streaming)",
          "content_same": false
        },
        {
          "line": 4058,
          "old_api": "rbtxn_is_toptxn",
          "new_api": null,
          "old_text": "rbtxn_is_toptxn(txn)",
          "new_text": null,
          "old_line_content": "\tAssert(rbtxn_is_toptxn(txn));",
          "new_line_content": "\tCommandId\tcommand_id;",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "stream_message",
          "new_api": null,
          "old_text": "rb->stream_message(rb, txn, change->lsn, true,\n\t\t\t\t\t\t   change->data.msg.prefix,\n\t\t\t\t\t\t   change->data.msg.message_size,\n\t\t\t\t\t\t   change->data.msg.message)",
          "new_text": null,
          "old_line_content": "\t\trb->stream_message(rb, txn, change->lsn, true,",
          "new_line_content": "static inline void",
          "content_same": false
        },
        {
          "line": 4081,
          "old_api": "rbtxn_is_streamed",
          "new_api": null,
          "old_text": "rbtxn_is_streamed(txn)",
          "new_text": null,
          "old_line_content": "\t\tAssert(!rbtxn_is_streamed(txn));",
          "new_line_content": "\tif (txn->snapshot_now == NULL)",
          "content_same": false
        },
        {
          "line": 4084,
          "old_api": "Assert",
          "new_api": null,
          "old_text": "Assert(txn->command_id == InvalidCommandId)",
          "new_text": null,
          "old_line_content": "\t\tAssert(txn->command_id == InvalidCommandId);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 4090,
          "old_api": "dlist_container",
          "new_api": null,
          "old_text": "dlist_container(ReorderBufferTXN, node, subxact_i.cur)",
          "new_text": null,
          "old_line_content": "\t\t\tsubtxn = dlist_container(ReorderBufferTXN, node, subxact_i.cur);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "ReorderBufferCopySnap",
          "new_api": null,
          "old_text": "ReorderBufferCopySnap(rb, snapshot_now,\n\t\t\t\t\t\t\t\t\t\t\t\t  txn, command_id)",
          "new_text": null,
          "old_line_content": "\t\ttxn->snapshot_now = ReorderBufferCopySnap(rb, snapshot_now,",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 150,
      "total_additions": 653,
      "total_deletions": 653,
      "total_api_changes": 1456
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 1456,
        "non_api_lines": 11,
        "non_api_line_numbers": [
          352,
          353,
          340,
          341,
          342,
          343,
          345,
          346,
          347,
          348,
          351
        ]
      }
    },
    "api_calls_before": 869,
    "api_calls_after": 869,
    "diff_info": {
      "added_lines": 11,
      "removed_lines": 6,
      "total_diff_lines": 32
    }
  }
}