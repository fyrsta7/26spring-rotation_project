{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ceph/modified_file/e21cfa770570f7e7410b830b11edee17e80dead2",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ceph/modified_file/e21cfa770570f7e7410b830b11edee17e80dead2/before.cc",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ceph/modified_file/e21cfa770570f7e7410b830b11edee17e80dead2/after.cc",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/ceph/modified_file/e21cfa770570f7e7410b830b11edee17e80dead2/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 124,
          "old_api": "seastar::make_ready_future<bufferlist>()",
          "new_api": "then",
          "old_text": "seastar::make_ready_future<bufferlist>()",
          "new_text": "try_trap_pre(next_trap_read).then([bytes, this] {\n#endif\n    if (bytes == 0) {\n      return seastar::make_ready_future<bufferlist>();\n    }\n    r.buffer.clear();\n    r.remaining = bytes;\n    return in.consume(bufferlist_consumer{r.buffer, r.remaining}).then([this] {\n      if (r.remaining) { // throw on short reads\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay().then([this] {\n        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));\n      });\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this](auto buf) {\n    return try_trap_post(next_trap_read\n    ).then([buf = std::move(buf)]() mutable {\n      return std::move(buf);\n    });\n  })",
          "old_line_content": "      return seastar::make_ready_future<bufferlist>();",
          "new_line_content": "  return try_trap_pre(next_trap_read).then([bytes, this] {",
          "content_same": false
        },
        {
          "line": 133,
          "old_api": "then",
          "new_api": "make_error_code",
          "old_text": "inject_delay().then([this] {\n        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));\n      })",
          "new_text": "make_error_code(error::read_eof)",
          "old_line_content": "      return inject_delay().then([this] {",
          "new_line_content": "        throw std::system_error(make_error_code(error::read_eof));",
          "content_same": false
        },
        {
          "line": 154,
          "old_api": "seastar::make_ready_future<bufferptr>()",
          "new_api": "then",
          "old_text": "seastar::make_ready_future<bufferptr>()",
          "new_text": "try_trap_pre(next_trap_read).then([bytes, this] {\n#endif\n    if (bytes == 0) {\n      return seastar::make_ready_future<bufferptr>();\n    }\n    return in.read_exactly(bytes).then([bytes](auto buf) {\n      bufferptr ptr(buffer::create(buf.share()));\n      if (ptr.length() < bytes) {\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay(\n      ).then([ptr = std::move(ptr)]() mutable {\n        return seastar::make_ready_future<bufferptr>(std::move(ptr));\n      });\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this](auto ptr) {\n    return try_trap_post(next_trap_read\n    ).then([ptr = std::move(ptr)]() mutable {\n      return std::move(ptr);\n    });\n  })",
          "old_line_content": "      return seastar::make_ready_future<bufferptr>();",
          "new_line_content": "  return try_trap_pre(next_trap_read).then([bytes, this] {",
          "content_same": false
        },
        {
          "line": 157,
          "old_api": "share",
          "new_api": "seastar::make_ready_future<bufferptr>()",
          "old_text": "buf.share()",
          "new_text": "seastar::make_ready_future<bufferptr>()",
          "old_line_content": "      bufferptr ptr(buffer::create(buf.share()));",
          "new_line_content": "      return seastar::make_ready_future<bufferptr>();",
          "content_same": false
        },
        {
          "line": 159,
          "old_api": "make_error_code",
          "new_api": "read_exactly",
          "old_text": "make_error_code(error::read_eof)",
          "new_text": "in.read_exactly(bytes).then([bytes](auto buf) {\n      bufferptr ptr(buffer::create(buf.share()));\n      if (ptr.length() < bytes) {\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay(\n      ).then([ptr = std::move(ptr)]() mutable {\n        return seastar::make_ready_future<bufferptr>(std::move(ptr));\n      });\n    })",
          "old_line_content": "        throw std::system_error(make_error_code(error::read_eof));",
          "new_line_content": "    return in.read_exactly(bytes).then([bytes](auto buf) {",
          "content_same": false
        },
        {
          "line": 161,
          "old_api": "inject_failure",
          "new_api": "length",
          "old_text": "inject_failure()",
          "new_text": "ptr.length()",
          "old_line_content": "      inject_failure();",
          "new_line_content": "      if (ptr.length() < bytes) {",
          "content_same": false
        },
        {
          "line": 162,
          "old_api": "then",
          "new_api": "make_error_code",
          "old_text": "inject_delay(\n      ).then([ptr = std::move(ptr)]() mutable {\n        return seastar::make_ready_future<bufferptr>(std::move(ptr));\n      })",
          "new_text": "make_error_code(error::read_eof)",
          "old_line_content": "      return inject_delay(",
          "new_line_content": "        throw std::system_error(make_error_code(error::read_eof));",
          "content_same": false
        },
        {
          "line": 164,
          "old_api": "std::move(ptr)",
          "new_api": "inject_failure",
          "old_text": "std::move(ptr)",
          "new_text": "inject_failure()",
          "old_line_content": "        return seastar::make_ready_future<bufferptr>(std::move(ptr));",
          "new_line_content": "      inject_failure();",
          "content_same": false
        },
        {
          "line": 185,
          "old_api": "inject_failure",
          "new_api": "then",
          "old_text": "inject_failure()",
          "new_text": "try_trap_pre(next_trap_write\n  ).then([buf = std::move(buf), this]() mutable {\n#endif\n    inject_failure();\n    return inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p));\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this] {\n    return try_trap_post(next_trap_write);\n  })",
          "old_line_content": "    inject_failure();",
          "new_line_content": "  return try_trap_pre(next_trap_write",
          "content_same": false
        },
        {
          "line": 189,
          "old_api": "std::move(p)",
          "new_api": "then",
          "old_text": "std::move(p)",
          "new_text": "inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p));\n    })",
          "old_line_content": "      return out.write(std::move(p));",
          "new_line_content": "    return inject_delay(",
          "content_same": false
        },
        {
          "line": 204,
          "old_api": "flush",
          "new_api": "seastar::this_shard_id()",
          "old_text": "out.flush()",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "    return out.flush();",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 216,
          "old_api": "inject_failure",
          "new_api": "then",
          "old_text": "inject_failure()",
          "new_text": "try_trap_pre(next_trap_write\n  ).then([buf = std::move(buf), this]() mutable {\n#endif\n    inject_failure();\n    return inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p)\n      ).then([this] {\n        return out.flush();\n      });\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this] {\n    return try_trap_post(next_trap_write);\n  })",
          "old_line_content": "    inject_failure();",
          "new_line_content": "  return try_trap_pre(next_trap_write",
          "content_same": false
        },
        {
          "line": 220,
          "old_api": "std::move(p)",
          "new_api": "then",
          "old_text": "std::move(p)",
          "new_text": "inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p)\n      ).then([this] {\n        return out.flush();\n      });\n    })",
          "old_line_content": "      return out.write(std::move(p)",
          "new_line_content": "    return inject_delay(",
          "content_same": false
        },
        {
          "line": 237,
          "old_api": "shutdown_output",
          "new_api": "seastar::this_shard_id()",
          "old_text": "socket.shutdown_output()",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "  socket.shutdown_output();",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 246,
          "old_api": "what",
          "new_api": "close",
          "old_text": "e.what()",
          "new_text": "out.close().handle_exception_type([](const std::system_error& e) {\n    if (e.code() != std::errc::broken_pipe &&\n        e.code() != std::errc::connection_reset) {\n      logger().error(\"Socket::close(): unexpected error {}\", e.what());\n      ceph_abort();\n    }\n    // can happen when out is already shutdown, ignore\n  })",
          "old_line_content": "      logger().error(\"Socket::close(): unexpected error {}\", e.what());",
          "new_line_content": "  return out.close().handle_exception_type([](const std::system_error& e) {",
          "content_same": false
        },
        {
          "line": 247,
          "old_api": "ceph_abort",
          "new_api": "code",
          "old_text": "ceph_abort()",
          "new_text": "e.code()",
          "old_line_content": "      ceph_abort();",
          "new_line_content": "    if (e.code() != std::errc::broken_pipe &&",
          "content_same": false
        },
        {
          "line": 261,
          "old_api": "close",
          "new_api": "ceph_assert_always",
          "old_text": "seastar::when_all_succeed(\n    inject_delay(),\n    in.close(),\n    close_and_handle_errors(out)\n  ).then_unpack([] {\n    return seastar::make_ready_future<>();\n  }).handle_exception([](auto eptr) {\n    const char *e_what;\n    try {\n      std::rethrow_exception(eptr);\n    } catch (std::exception &e) {\n      e_what = e.what();\n    }\n    logger().error(\"Socket::close(): unexpected exception {}\", e_what);\n    ceph_abort();\n  })",
          "new_text": "ceph_assert_always(!closed)",
          "old_line_content": "  return seastar::when_all_succeed(",
          "new_line_content": "  ceph_assert_always(!closed);",
          "content_same": false
        },
        {
          "line": 264,
          "old_api": "close_and_handle_errors",
          "new_api": "close",
          "old_text": "close_and_handle_errors(out)",
          "new_text": "seastar::when_all_succeed(\n    inject_delay(),\n    in.close(),\n    close_and_handle_errors(out)\n  ).then_unpack([] {\n    return seastar::make_ready_future<>();\n  }).handle_exception([](auto eptr) {\n    const char *e_what;\n    try {\n      std::rethrow_exception(eptr);\n    } catch (std::exception &e) {\n      e_what = e.what();\n    }\n    logger().error(\"Socket::close(): unexpected exception {}\", e_what);\n    ceph_abort();\n  })",
          "old_line_content": "    close_and_handle_errors(out)",
          "new_line_content": "  return seastar::when_all_succeed(",
          "content_same": false
        },
        {
          "line": 266,
          "old_api": "seastar::make_ready_future<>()",
          "new_api": "close",
          "old_text": "seastar::make_ready_future<>()",
          "new_text": "in.close()",
          "old_line_content": "    return seastar::make_ready_future<>();",
          "new_line_content": "    in.close(),",
          "content_same": false
        },
        {
          "line": 275,
          "old_api": "ceph_abort",
          "new_api": "what",
          "old_text": "ceph_abort()",
          "new_text": "e.what()",
          "old_line_content": "    ceph_abort();",
          "new_line_content": "      e_what = e.what();",
          "content_same": false
        },
        {
          "line": 285,
          "old_api": "in4_addr",
          "new_api": "inject_failure",
          "old_text": "peer_addr.in4_addr()",
          "new_text": "inject_failure()",
          "old_line_content": "    return seastar::connect(peer_addr.in4_addr());",
          "new_line_content": "  inject_failure();",
          "content_same": false
        },
        {
          "line": 288,
          "old_api": "std::move(socket)",
          "new_api": "in4_addr",
          "old_text": "std::move(socket)",
          "new_text": "peer_addr.in4_addr()",
          "old_line_content": "      std::move(socket), side_t::connector, 0, construct_tag{});",
          "new_line_content": "    return seastar::connect(peer_addr.in4_addr());",
          "content_same": false
        },
        {
          "line": 290,
          "old_api": "fmt::ptr(ret)",
          "new_api": "std::make_unique<Socket>(\n      std::move(socket), side_t::connector, 0, construct_tag{})",
          "old_text": "fmt::ptr(ret)",
          "new_text": "std::make_unique<Socket>(\n      std::move(socket), side_t::connector, 0, construct_tag{})",
          "old_line_content": "                   peer_addr, fmt::ptr(ret));",
          "new_line_content": "    auto ret = std::make_unique<Socket>(",
          "content_same": false
        },
        {
          "line": 300,
          "old_api": "ceph_assert_always",
          "new_api": "seastar::this_shard_id()",
          "old_text": "ceph_assert_always(next_trap_read == bp_action_t::CONTINUE)",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "    ceph_assert_always(next_trap_read == bp_action_t::CONTINUE);",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 326,
          "old_api": "block",
          "new_api": "make_error_code",
          "old_text": "blocker->block()",
          "new_text": "make_error_code(error::negotiation_failure)",
          "old_line_content": "    return blocker->block();",
          "new_line_content": "    throw std::system_error(make_error_code(error::negotiation_failure));",
          "content_same": false
        },
        {
          "line": 348,
          "old_api": "ceph_abort",
          "new_api": "force_shutdown",
          "old_text": "ceph_abort(\"unexpected action from trap\")",
          "new_text": "force_shutdown()",
          "old_line_content": "    ceph_abort(\"unexpected action from trap\");",
          "new_line_content": "    force_shutdown();",
          "content_same": false
        },
        {
          "line": 376,
          "old_api": "in4_addr",
          "new_api": "debug",
          "old_text": "addr.in4_addr()",
          "new_text": "logger().debug(\"ShardedServerSocket({})::listen()...\", addr)",
          "old_line_content": "    seastar::socket_address s_addr(addr.in4_addr());",
          "new_line_content": "  logger().debug(\"ShardedServerSocket({})::listen()...\", addr);",
          "content_same": false
        },
        {
          "line": 387,
          "old_api": "code",
          "new_api": "listen_ertr::now()",
          "old_text": "e.code()",
          "new_text": "listen_ertr::now()",
          "old_line_content": "    if (e.code() == std::errc::address_in_use) {",
          "new_line_content": "    return listen_ertr::now();",
          "content_same": false
        },
        {
          "line": 393,
          "old_api": "crimson::ct_error::address_not_available::make()",
          "new_api": "code",
          "old_text": "crimson::ct_error::address_not_available::make()",
          "new_text": "e.code()",
          "old_line_content": "      return crimson::ct_error::address_not_available::make();",
          "new_line_content": "    } else if (e.code() == std::errc::address_not_available) {",
          "content_same": false
        },
        {
          "line": 396,
          "old_api": "what",
          "new_api": "crimson::ct_error::address_not_available::make()",
          "old_text": "e.what()",
          "new_text": "crimson::ct_error::address_not_available::make()",
          "old_line_content": "                   \"got unexpeted error {}\", addr, e.what());",
          "new_line_content": "      return crimson::ct_error::address_not_available::make();",
          "content_same": false
        },
        {
          "line": 407,
          "old_api": "assert",
          "new_api": "seastar::this_shard_id()",
          "old_text": "assert(ss.listener)",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "    assert(ss.listener);",
          "new_line_content": "  ceph_assert_always(seastar::this_shard_id() == primary_sid);",
          "content_same": false
        },
        {
          "line": 422,
          "old_api": "std::move(accept_result)",
          "new_api": "seastar::this_shard_id()",
          "old_text": "std::move(accept_result)",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "          auto [socket, paddr] = std::move(accept_result);",
          "new_line_content": "            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);",
          "content_same": false
        },
        {
          "line": 425,
          "old_api": "get_type",
          "new_api": "std::move(accept_result)",
          "old_text": "ss.listen_addr.get_type()",
          "new_text": "std::move(accept_result)",
          "old_line_content": "          peer_addr.set_type(ss.listen_addr.get_type());",
          "new_line_content": "          auto [socket, paddr] = std::move(accept_result);",
          "content_same": false
        },
        {
          "line": 427,
          "old_api": "std::move(socket)",
          "new_api": "as_posix_sockaddr",
          "old_text": "std::move(socket)",
          "new_text": "paddr.as_posix_sockaddr()",
          "old_line_content": "              std::move(socket), Socket::side_t::acceptor,",
          "new_line_content": "          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());",
          "content_same": false
        },
        {
          "line": 428,
          "old_api": "get_port",
          "new_api": "get_type",
          "old_text": "peer_addr.get_port()",
          "new_text": "ss.listen_addr.get_type()",
          "old_line_content": "              peer_addr.get_port(), Socket::construct_tag{});",
          "new_line_content": "          peer_addr.set_type(ss.listen_addr.get_type());",
          "content_same": false
        },
        {
          "line": 429,
          "old_api": "debug",
          "new_api": "get_port",
          "old_text": "logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid)",
          "new_text": "std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{})",
          "old_line_content": "          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"",
          "new_line_content": "          SocketRef _socket = std::make_unique<Socket>(",
          "content_same": false
        },
        {
          "line": 431,
          "old_api": "fmt::ptr(_socket)",
          "new_api": "get_port",
          "old_text": "fmt::ptr(_socket)",
          "new_text": "peer_addr.get_port()",
          "old_line_content": "                         ss.listen_addr, peer_addr, fmt::ptr(_socket),",
          "new_line_content": "              peer_addr.get_port(), Socket::construct_tag{});",
          "content_same": false
        },
        {
          "line": 436,
          "old_api": "std::move(socket)",
          "new_api": "fn_accept",
          "old_text": "std::move(socket)",
          "new_text": "seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          })",
          "old_line_content": "            return ss.fn_accept(std::move(socket), peer_addr",
          "new_line_content": "          std::ignore = seastar::with_gate(",
          "content_same": false
        },
        {
          "line": 447,
          "old_api": "ceph_abort",
          "new_api": "error",
          "old_text": "ceph_abort()",
          "new_text": "logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what)",
          "old_line_content": "              ceph_abort();",
          "new_line_content": "              logger().error(\"ShardedServerSocket({})::accept(): \"",
          "content_same": false
        },
        {
          "line": 455,
          "old_api": "what",
          "new_api": "code",
          "old_text": "e.what()",
          "new_text": "e.code()",
          "old_line_content": "                         ss.listen_addr, e.what());",
          "new_line_content": "        if (e.code() == std::errc::connection_aborted ||",
          "content_same": false
        },
        {
          "line": 480,
          "old_api": "invoke_on_all",
          "new_api": "seastar::this_shard_id()",
          "old_text": "this->container().invoke_on_all([](auto& ss) {\n    if (ss.listener) {\n      ss.listener->abort_accept();\n    }\n    return ss.shutdown_gate.close();\n  }).then([this] {\n    // destroy shards\n    return this->container().invoke_on_all([](auto& ss) {\n      assert(ss.shutdown_gate.is_closed());\n      ss.listen_addr = entity_addr_t();\n      ss.listener.reset();\n    });\n  }).then([this] {\n    // stop the sharded service: we should only construct/stop shards on #0\n    return this->container().invoke_on(0, [](auto& ss) {\n      assert(ss.service);\n      return ss.service->stop().finally([cleanup = std::move(ss.service)] {});\n    });\n  })",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "  return this->container().invoke_on_all([](auto& ss) {",
          "new_line_content": "  assert(seastar::this_shard_id() == primary_sid);",
          "content_same": false
        },
        {
          "line": 487,
          "old_api": "invoke_on_all",
          "new_api": "close",
          "old_text": "this->container().invoke_on_all([](auto& ss) {\n      assert(ss.shutdown_gate.is_closed());\n      ss.listen_addr = entity_addr_t();\n      ss.listener.reset();\n    })",
          "new_text": "ss.shutdown_gate.close()",
          "old_line_content": "    return this->container().invoke_on_all([](auto& ss) {",
          "new_line_content": "    return ss.shutdown_gate.close();",
          "content_same": false
        },
        {
          "line": 490,
          "old_api": "reset",
          "new_api": "invoke_on_all",
          "old_text": "ss.listener.reset()",
          "new_text": "this->container().invoke_on_all([](auto& ss) {\n      assert(ss.shutdown_gate.is_closed());\n      ss.listen_addr = entity_addr_t();\n      ss.listener.reset();\n    })",
          "old_line_content": "      ss.listener.reset();",
          "new_line_content": "    return this->container().invoke_on_all([](auto& ss) {",
          "content_same": false
        },
        {
          "line": 507,
          "old_api": "std::make_unique<sharded_service_t>()",
          "new_api": "seastar::this_shard_id()",
          "old_text": "std::make_unique<sharded_service_t>()",
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "    auto service = std::make_unique<sharded_service_t>();",
          "new_line_content": "  auto primary_sid = seastar::this_shard_id();",
          "content_same": false
        },
        {
          "line": 511,
          "old_api": "get",
          "new_api": "then",
          "old_text": "service.get()",
          "new_text": "service->start(\n        primary_sid, dispatch_only_on_this_shard, construct_tag{}\n    ).then([service = std::move(service)]() mutable {\n      auto p_shard = service.get();\n      p_shard->local().service = std::move(service);\n      return p_shard;\n    })",
          "old_line_content": "      auto p_shard = service.get();",
          "new_line_content": "    return service->start(",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 514,
          "old_api": null,
          "new_api": "get",
          "old_text": null,
          "new_text": "service.get()",
          "old_line_content": "    });",
          "new_line_content": "      auto p_shard = service.get();",
          "content_same": false
        },
        {
          "line": 515,
          "old_api": null,
          "new_api": "std::move(service)",
          "old_text": null,
          "new_text": "std::move(service)",
          "old_line_content": "  }).then([](auto p_shard) {",
          "new_line_content": "      p_shard->local().service = std::move(service);",
          "content_same": false
        },
        {
          "line": 519,
          "old_api": null,
          "new_api": "local",
          "old_text": null,
          "new_text": "p_shard->local()",
          "old_line_content": "",
          "new_line_content": "    return &p_shard->local();",
          "content_same": false
        },
        {
          "line": 106,
          "old_api": null,
          "new_api": "local_conf",
          "old_text": null,
          "new_text": "local_conf()",
          "old_line_content": "}",
          "new_line_content": "  if (local_conf()->ms_tcp_nodelay) {",
          "content_same": false
        },
        {
          "line": 107,
          "old_api": null,
          "new_api": "set_nodelay",
          "old_text": null,
          "new_text": "socket.set_nodelay(true)",
          "old_line_content": "",
          "new_line_content": "    socket.set_nodelay(true);",
          "content_same": false
        },
        {
          "line": 113,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "#endif",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 115,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(closed)",
          "old_line_content": "",
          "new_line_content": "  assert(closed);",
          "content_same": false
        },
        {
          "line": 122,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "#endif",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 127,
          "old_api": null,
          "new_api": "seastar::make_ready_future<bufferlist>()",
          "old_text": null,
          "new_text": "seastar::make_ready_future<bufferlist>()",
          "old_line_content": "    r.remaining = bytes;",
          "new_line_content": "      return seastar::make_ready_future<bufferlist>();",
          "content_same": false
        },
        {
          "line": 129,
          "old_api": null,
          "new_api": "clear",
          "old_text": null,
          "new_text": "r.buffer.clear()",
          "old_line_content": "      if (r.remaining) { // throw on short reads",
          "new_line_content": "    r.buffer.clear();",
          "content_same": false
        },
        {
          "line": 131,
          "old_api": null,
          "new_api": "consume",
          "old_text": null,
          "new_text": "in.consume(bufferlist_consumer{r.buffer, r.remaining}).then([this] {\n      if (r.remaining) { // throw on short reads\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay().then([this] {\n        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));\n      });\n    })",
          "old_line_content": "      }",
          "new_line_content": "    return in.consume(bufferlist_consumer{r.buffer, r.remaining}).then([this] {",
          "content_same": false
        },
        {
          "line": 135,
          "old_api": null,
          "new_api": "inject_failure",
          "old_text": null,
          "new_text": "inject_failure()",
          "old_line_content": "      });",
          "new_line_content": "      inject_failure();",
          "content_same": false
        },
        {
          "line": 136,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "inject_delay().then([this] {\n        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));\n      })",
          "old_line_content": "    });",
          "new_line_content": "      return inject_delay().then([this] {",
          "content_same": false
        },
        {
          "line": 137,
          "old_api": null,
          "new_api": "std::move(r.buffer)",
          "old_text": null,
          "new_text": "std::move(r.buffer)",
          "old_line_content": "#ifdef UNIT_TESTS_BUILT",
          "new_line_content": "        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));",
          "content_same": false
        },
        {
          "line": 142,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "try_trap_post(next_trap_read\n    ).then([buf = std::move(buf)]() mutable {\n      return std::move(buf);\n    })",
          "old_line_content": "    });",
          "new_line_content": "    return try_trap_post(next_trap_read",
          "content_same": false
        },
        {
          "line": 144,
          "old_api": null,
          "new_api": "std::move(buf)",
          "old_text": null,
          "new_text": "std::move(buf)",
          "old_line_content": "#endif",
          "new_line_content": "      return std::move(buf);",
          "content_same": false
        },
        {
          "line": 152,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "#endif",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 160,
          "old_api": null,
          "new_api": "share",
          "old_text": null,
          "new_text": "buf.share()",
          "old_line_content": "      }",
          "new_line_content": "      bufferptr ptr(buffer::create(buf.share()));",
          "content_same": false
        },
        {
          "line": 165,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "inject_delay(\n      ).then([ptr = std::move(ptr)]() mutable {\n        return seastar::make_ready_future<bufferptr>(std::move(ptr));\n      })",
          "old_line_content": "      });",
          "new_line_content": "      return inject_delay(",
          "content_same": false
        },
        {
          "line": 167,
          "old_api": null,
          "new_api": "std::move(ptr)",
          "old_text": null,
          "new_text": "std::move(ptr)",
          "old_line_content": "#ifdef UNIT_TESTS_BUILT",
          "new_line_content": "        return seastar::make_ready_future<bufferptr>(std::move(ptr));",
          "content_same": false
        },
        {
          "line": 172,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "try_trap_post(next_trap_read\n    ).then([ptr = std::move(ptr)]() mutable {\n      return std::move(ptr);\n    })",
          "old_line_content": "    });",
          "new_line_content": "    return try_trap_post(next_trap_read",
          "content_same": false
        },
        {
          "line": 174,
          "old_api": null,
          "new_api": "std::move(ptr)",
          "old_text": null,
          "new_text": "std::move(ptr)",
          "old_line_content": "#endif",
          "new_line_content": "      return std::move(ptr);",
          "content_same": false
        },
        {
          "line": 183,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "  ).then([buf = std::move(buf), this]() mutable {",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 188,
          "old_api": null,
          "new_api": "inject_failure",
          "old_text": null,
          "new_text": "inject_failure()",
          "old_line_content": "      packet p(std::move(buf));",
          "new_line_content": "    inject_failure();",
          "content_same": false
        },
        {
          "line": 192,
          "old_api": null,
          "new_api": "std::move(p)",
          "old_text": null,
          "new_text": "std::move(p)",
          "old_line_content": "  }).then([this] {",
          "new_line_content": "      return out.write(std::move(p));",
          "content_same": false
        },
        {
          "line": 196,
          "old_api": null,
          "new_api": "try_trap_post",
          "old_text": null,
          "new_text": "try_trap_post(next_trap_write)",
          "old_line_content": "}",
          "new_line_content": "    return try_trap_post(next_trap_write);",
          "content_same": false
        },
        {
          "line": 205,
          "old_api": null,
          "new_api": "inject_failure",
          "old_text": null,
          "new_text": "inject_failure()",
          "old_line_content": "  });",
          "new_line_content": "  inject_failure();",
          "content_same": false
        },
        {
          "line": 206,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "inject_delay().then([this] {\n    return out.flush();\n  })",
          "old_line_content": "}",
          "new_line_content": "  return inject_delay().then([this] {",
          "content_same": false
        },
        {
          "line": 207,
          "old_api": null,
          "new_api": "flush",
          "old_text": null,
          "new_text": "out.flush()",
          "old_line_content": "",
          "new_line_content": "    return out.flush();",
          "content_same": false
        },
        {
          "line": 214,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "  ).then([buf = std::move(buf), this]() mutable {",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 219,
          "old_api": null,
          "new_api": "inject_failure",
          "old_text": null,
          "new_text": "inject_failure()",
          "old_line_content": "      packet p(std::move(buf));",
          "new_line_content": "    inject_failure();",
          "content_same": false
        },
        {
          "line": 223,
          "old_api": null,
          "new_api": "std::move(p)",
          "old_text": null,
          "new_text": "std::move(p)",
          "old_line_content": "      });",
          "new_line_content": "      return out.write(std::move(p)",
          "content_same": false
        },
        {
          "line": 225,
          "old_api": null,
          "new_api": "flush",
          "old_text": null,
          "new_text": "out.flush()",
          "old_line_content": "#ifdef UNIT_TESTS_BUILT",
          "new_line_content": "        return out.flush();",
          "content_same": false
        },
        {
          "line": 230,
          "old_api": null,
          "new_api": "try_trap_post",
          "old_text": null,
          "new_text": "try_trap_post(next_trap_write)",
          "old_line_content": "}",
          "new_line_content": "    return try_trap_post(next_trap_write);",
          "content_same": false
        },
        {
          "line": 239,
          "old_api": null,
          "new_api": "shutdown_input",
          "old_text": null,
          "new_text": "socket.shutdown_input()",
          "old_line_content": "",
          "new_line_content": "  socket.shutdown_input();",
          "content_same": false
        },
        {
          "line": 240,
          "old_api": null,
          "new_api": "shutdown_output",
          "old_text": null,
          "new_text": "socket.shutdown_output()",
          "old_line_content": "static inline seastar::future<>",
          "new_line_content": "  socket.shutdown_output();",
          "content_same": false
        },
        {
          "line": 248,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "e.code()",
          "old_line_content": "    }",
          "new_line_content": "        e.code() != std::errc::connection_reset) {",
          "content_same": false
        },
        {
          "line": 249,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "    // can happen when out is already shutdown, ignore",
          "new_line_content": "      logger().error(\"Socket::close(): unexpected error {}\", e.what());",
          "content_same": false
        },
        {
          "line": 250,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort()",
          "old_line_content": "  });",
          "new_line_content": "      ceph_abort();",
          "content_same": false
        },
        {
          "line": 259,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "  closed = true;",
          "new_line_content": "  assert(seastar::this_shard_id() == sid);",
          "content_same": false
        },
        {
          "line": 265,
          "old_api": null,
          "new_api": "inject_delay",
          "old_text": null,
          "new_text": "inject_delay()",
          "old_line_content": "  ).then_unpack([] {",
          "new_line_content": "    inject_delay(),",
          "content_same": false
        },
        {
          "line": 267,
          "old_api": null,
          "new_api": "close_and_handle_errors",
          "old_text": null,
          "new_text": "close_and_handle_errors(out)",
          "old_line_content": "  }).handle_exception([](auto eptr) {",
          "new_line_content": "    close_and_handle_errors(out)",
          "content_same": false
        },
        {
          "line": 269,
          "old_api": null,
          "new_api": "seastar::make_ready_future<>()",
          "old_text": null,
          "new_text": "seastar::make_ready_future<>()",
          "old_line_content": "    try {",
          "new_line_content": "    return seastar::make_ready_future<>();",
          "content_same": false
        },
        {
          "line": 273,
          "old_api": null,
          "new_api": "std::rethrow_exception(eptr)",
          "old_text": null,
          "new_text": "std::rethrow_exception(eptr)",
          "old_line_content": "    }",
          "new_line_content": "      std::rethrow_exception(eptr);",
          "content_same": false
        },
        {
          "line": 277,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "logger().error(\"Socket::close(): unexpected exception {}\", e_what)",
          "old_line_content": "}",
          "new_line_content": "    logger().error(\"Socket::close(): unexpected exception {}\", e_what);",
          "content_same": false
        },
        {
          "line": 278,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort()",
          "old_line_content": "",
          "new_line_content": "    ceph_abort();",
          "content_same": false
        },
        {
          "line": 286,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "inject_delay(\n  ).then([peer_addr] {\n    return seastar::connect(peer_addr.in4_addr());\n  }).then([peer_addr](seastar::connected_socket socket) {\n    auto ret = std::make_unique<Socket>(\n      std::move(socket), side_t::connector, 0, construct_tag{});\n    logger().debug(\"Socket::connect(): connected to {}, socket {}\",\n                   peer_addr, fmt::ptr(ret));\n    return ret;\n  })",
          "old_line_content": "  }).then([peer_addr](seastar::connected_socket socket) {",
          "new_line_content": "  return inject_delay(",
          "content_same": false
        },
        {
          "line": 291,
          "old_api": null,
          "new_api": "std::move(socket)",
          "old_text": null,
          "new_text": "std::move(socket)",
          "old_line_content": "    return ret;",
          "new_line_content": "      std::move(socket), side_t::connector, 0, construct_tag{});",
          "content_same": false
        },
        {
          "line": 292,
          "old_api": null,
          "new_api": "debug",
          "old_text": null,
          "new_text": "logger().debug(\"Socket::connect(): connected to {}, socket {}\",\n                   peer_addr, fmt::ptr(ret))",
          "old_line_content": "  });",
          "new_line_content": "    logger().debug(\"Socket::connect(): connected to {}, socket {}\",",
          "content_same": false
        },
        {
          "line": 293,
          "old_api": null,
          "new_api": "fmt::ptr(ret)",
          "old_text": null,
          "new_text": "fmt::ptr(ret)",
          "old_line_content": "}",
          "new_line_content": "                   peer_addr, fmt::ptr(ret));",
          "content_same": false
        },
        {
          "line": 303,
          "old_api": null,
          "new_api": "ceph_assert_always",
          "old_text": null,
          "new_text": "ceph_assert_always(next_trap_read == bp_action_t::CONTINUE)",
          "old_line_content": "    if (next_trap_write == bp_action_t::CONTINUE) {",
          "new_line_content": "    ceph_assert_always(next_trap_read == bp_action_t::CONTINUE);",
          "content_same": false
        },
        {
          "line": 310,
          "old_api": null,
          "new_api": "ceph_assert_always",
          "old_text": null,
          "new_text": "ceph_assert_always(action == bp_action_t::FAULT || action == bp_action_t::CONTINUE)",
          "old_line_content": "    }",
          "new_line_content": "      ceph_assert_always(action == bp_action_t::FAULT || action == bp_action_t::CONTINUE);",
          "content_same": false
        },
        {
          "line": 312,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort()",
          "old_line_content": "}",
          "new_line_content": "      ceph_abort();",
          "content_same": false
        },
        {
          "line": 328,
          "old_api": null,
          "new_api": "info",
          "old_text": null,
          "new_text": "logger().info(\"[Test] got BLOCK\")",
          "old_line_content": "    trap = action;",
          "new_line_content": "    logger().info(\"[Test] got BLOCK\");",
          "content_same": false
        },
        {
          "line": 329,
          "old_api": null,
          "new_api": "block",
          "old_text": null,
          "new_text": "blocker->block()",
          "old_line_content": "    break;",
          "new_line_content": "    return blocker->block();",
          "content_same": false
        },
        {
          "line": 334,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort(\"unexpected action from trap\")",
          "old_line_content": "}",
          "new_line_content": "    ceph_abort(\"unexpected action from trap\");",
          "content_same": false
        },
        {
          "line": 336,
          "old_api": null,
          "new_api": "seastar::make_ready_future<>()",
          "old_text": null,
          "new_text": "seastar::make_ready_future<>()",
          "old_line_content": "seastar::future<>",
          "new_line_content": "  return seastar::make_ready_future<>();",
          "content_same": false
        },
        {
          "line": 347,
          "old_api": null,
          "new_api": "info",
          "old_text": null,
          "new_text": "logger().info(\"[Test] got STALL and block\")",
          "old_line_content": "   default:",
          "new_line_content": "    logger().info(\"[Test] got STALL and block\");",
          "content_same": false
        },
        {
          "line": 349,
          "old_api": null,
          "new_api": "block",
          "old_text": null,
          "new_text": "blocker->block()",
          "old_line_content": "  }",
          "new_line_content": "    return blocker->block();",
          "content_same": false
        },
        {
          "line": 351,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort(\"unexpected action from trap\")",
          "old_line_content": "}",
          "new_line_content": "    ceph_abort(\"unexpected action from trap\");",
          "content_same": false
        },
        {
          "line": 353,
          "old_api": null,
          "new_api": "seastar::make_ready_future<>()",
          "old_text": null,
          "new_text": "seastar::make_ready_future<>()",
          "old_line_content": "",
          "new_line_content": "  return seastar::make_ready_future<>();",
          "content_same": false
        },
        {
          "line": 367,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(!listener)",
          "old_line_content": "}",
          "new_line_content": "  assert(!listener);",
          "content_same": false
        },
        {
          "line": 369,
          "old_api": null,
          "new_api": "ceph_assert_always",
          "old_text": null,
          "new_text": "ceph_assert_always(!service)",
          "old_line_content": "listen_ertr::future<>",
          "new_line_content": "  ceph_assert_always(!service);",
          "content_same": false
        },
        {
          "line": 375,
          "old_api": null,
          "new_api": "seastar::this_shard_id()",
          "old_text": null,
          "new_text": "seastar::this_shard_id()",
          "old_line_content": "    ss.listen_addr = addr;",
          "new_line_content": "  ceph_assert_always(seastar::this_shard_id() == primary_sid);",
          "content_same": false
        },
        {
          "line": 377,
          "old_api": null,
          "new_api": "invoke_on_all",
          "old_text": null,
          "new_text": "this->container().invoke_on_all([addr](auto& ss) {\n    ss.listen_addr = addr;\n    seastar::socket_address s_addr(addr.in4_addr());\n    seastar::listen_options lo;\n    lo.reuse_address = true;\n    if (ss.dispatch_only_on_primary_sid) {\n      lo.set_fixed_cpu(ss.primary_sid);\n    }\n    ss.listener = seastar::listen(s_addr, lo);\n  }).then([] {\n    return listen_ertr::now();\n  }).handle_exception_type(\n    [addr](const std::system_error& e) -> listen_ertr::future<> {\n    if (e.code() == std::errc::address_in_use) {\n      logger().debug(\"ShardedServerSocket({})::listen(): address in use\", addr);\n      return crimson::ct_error::address_in_use::make();\n    } else if (e.code() == std::errc::address_not_available) {\n      logger().debug(\"ShardedServerSocket({})::listen(): address not available\",\n                     addr);\n      return crimson::ct_error::address_not_available::make();\n    }\n    logger().error(\"ShardedServerSocket({})::listen(): \"\n                   \"got unexpeted error {}\", addr, e.what());\n    ceph_abort();\n  })",
          "old_line_content": "    seastar::listen_options lo;",
          "new_line_content": "  return this->container().invoke_on_all([addr](auto& ss) {",
          "content_same": false
        },
        {
          "line": 379,
          "old_api": null,
          "new_api": "in4_addr",
          "old_text": null,
          "new_text": "addr.in4_addr()",
          "old_line_content": "    if (ss.dispatch_only_on_primary_sid) {",
          "new_line_content": "    seastar::socket_address s_addr(addr.in4_addr());",
          "content_same": false
        },
        {
          "line": 383,
          "old_api": null,
          "new_api": "set_fixed_cpu",
          "old_text": null,
          "new_text": "lo.set_fixed_cpu(ss.primary_sid)",
          "old_line_content": "  }).then([] {",
          "new_line_content": "      lo.set_fixed_cpu(ss.primary_sid);",
          "content_same": false
        },
        {
          "line": 385,
          "old_api": null,
          "new_api": "seastar::listen(s_addr, lo)",
          "old_text": null,
          "new_text": "seastar::listen(s_addr, lo)",
          "old_line_content": "  }).handle_exception_type(",
          "new_line_content": "    ss.listener = seastar::listen(s_addr, lo);",
          "content_same": false
        },
        {
          "line": 392,
          "old_api": null,
          "new_api": "crimson::ct_error::address_in_use::make()",
          "old_text": null,
          "new_text": "crimson::ct_error::address_in_use::make()",
          "old_line_content": "                     addr);",
          "new_line_content": "      return crimson::ct_error::address_in_use::make();",
          "content_same": false
        },
        {
          "line": 394,
          "old_api": null,
          "new_api": "debug",
          "old_text": null,
          "new_text": "logger().debug(\"ShardedServerSocket({})::listen(): address not available\",\n                     addr)",
          "old_line_content": "    }",
          "new_line_content": "      logger().debug(\"ShardedServerSocket({})::listen(): address not available\",",
          "content_same": false
        },
        {
          "line": 398,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "logger().error(\"ShardedServerSocket({})::listen(): \"\n                   \"got unexpeted error {}\", addr, e.what())",
          "old_line_content": "  });",
          "new_line_content": "    logger().error(\"ShardedServerSocket({})::listen(): \"",
          "content_same": false
        },
        {
          "line": 399,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "}",
          "new_line_content": "                   \"got unexpeted error {}\", addr, e.what());",
          "content_same": false
        },
        {
          "line": 400,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort()",
          "old_line_content": "",
          "new_line_content": "    ceph_abort();",
          "content_same": false
        },
        {
          "line": 408,
          "old_api": null,
          "new_api": "debug",
          "old_text": null,
          "new_text": "logger().debug(\"ShardedServerSocket({})::accept()...\", listen_addr)",
          "old_line_content": "    ss.fn_accept = _fn_accept;",
          "new_line_content": "  logger().debug(\"ShardedServerSocket({})::accept()...\", listen_addr);",
          "content_same": false
        },
        {
          "line": 409,
          "old_api": null,
          "new_api": "invoke_on_all",
          "old_text": null,
          "new_text": "this->container().invoke_on_all([_fn_accept](auto &ss) {\n    assert(ss.listener);\n    ss.fn_accept = _fn_accept;\n    // gate accepting\n    // ShardedServerSocket::shutdown() will drain the continuations in the gate\n    // so ignore the returned future\n    std::ignore = seastar::with_gate(ss.shutdown_gate, [&ss] {\n      return seastar::keep_doing([&ss] {\n        return ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        });\n      }).handle_exception_type([&ss](const std::system_error& e) {\n        if (e.code() == std::errc::connection_aborted ||\n            e.code() == std::errc::invalid_argument) {\n          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what());\n        } else {\n          throw;\n        }\n      }).handle_exception([&ss](auto eptr) {\n        const char *e_what;\n        try {\n          std::rethrow_exception(eptr);\n        } catch (std::exception &e) {\n          e_what = e.what();\n        }\n        logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what);\n        ceph_abort();\n      });\n    });\n  })",
          "old_line_content": "    // gate accepting",
          "new_line_content": "  return this->container().invoke_on_all([_fn_accept](auto &ss) {",
          "content_same": false
        },
        {
          "line": 410,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ss.listener)",
          "old_line_content": "    // ShardedServerSocket::shutdown() will drain the continuations in the gate",
          "new_line_content": "    assert(ss.listener);",
          "content_same": false
        },
        {
          "line": 415,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "seastar::with_gate(ss.shutdown_gate, [&ss] {\n      return seastar::keep_doing([&ss] {\n        return ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        });\n      }).handle_exception_type([&ss](const std::system_error& e) {\n        if (e.code() == std::errc::connection_aborted ||\n            e.code() == std::errc::invalid_argument) {\n          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what());\n        } else {\n          throw;\n        }\n      }).handle_exception([&ss](auto eptr) {\n        const char *e_what;\n        try {\n          std::rethrow_exception(eptr);\n        } catch (std::exception &e) {\n          e_what = e.what();\n        }\n        logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what);\n        ceph_abort();\n      });\n    })",
          "old_line_content": "        ).then([&ss](seastar::accept_result accept_result) {",
          "new_line_content": "    std::ignore = seastar::with_gate(ss.shutdown_gate, [&ss] {",
          "content_same": false
        },
        {
          "line": 416,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "seastar::keep_doing([&ss] {\n        return ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        });\n      }).handle_exception_type([&ss](const std::system_error& e) {\n        if (e.code() == std::errc::connection_aborted ||\n            e.code() == std::errc::invalid_argument) {\n          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what());\n        } else {\n          throw;\n        }\n      }).handle_exception([&ss](auto eptr) {\n        const char *e_what;\n        try {\n          std::rethrow_exception(eptr);\n        } catch (std::exception &e) {\n          e_what = e.what();\n        }\n        logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what);\n        ceph_abort();\n      })",
          "old_line_content": "#ifndef NDEBUG",
          "new_line_content": "      return seastar::keep_doing([&ss] {",
          "content_same": false
        },
        {
          "line": 417,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        })",
          "old_line_content": "          if (ss.dispatch_only_on_primary_sid) {",
          "new_line_content": "        return ss.listener->accept(",
          "content_same": false
        },
        {
          "line": 430,
          "old_api": null,
          "new_api": "std::move(socket)",
          "old_text": null,
          "new_text": "std::move(socket)",
          "old_line_content": "                         \"socket {}, dispatch_only_on_primary_sid = {}\",",
          "new_line_content": "              std::move(socket), Socket::side_t::acceptor,",
          "content_same": false
        },
        {
          "line": 432,
          "old_api": null,
          "new_api": "debug",
          "old_text": null,
          "new_text": "logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid)",
          "old_line_content": "                         ss.dispatch_only_on_primary_sid);",
          "new_line_content": "          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"",
          "content_same": false
        },
        {
          "line": 434,
          "old_api": null,
          "new_api": "fmt::ptr(_socket)",
          "old_text": null,
          "new_text": "fmt::ptr(_socket)",
          "old_line_content": "              ss.shutdown_gate,",
          "new_line_content": "                         ss.listen_addr, peer_addr, fmt::ptr(_socket),",
          "content_same": false
        },
        {
          "line": 439,
          "old_api": null,
          "new_api": "std::move(socket)",
          "old_text": null,
          "new_text": "std::move(socket)",
          "old_line_content": "              try {",
          "new_line_content": "            return ss.fn_accept(std::move(socket), peer_addr",
          "content_same": false
        },
        {
          "line": 443,
          "old_api": null,
          "new_api": "std::rethrow_exception(eptr)",
          "old_text": null,
          "new_text": "std::rethrow_exception(eptr)",
          "old_line_content": "              }",
          "new_line_content": "                std::rethrow_exception(eptr);",
          "content_same": false
        },
        {
          "line": 445,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "                             \"fn_accept(s, {}) got unexpected exception {}\",",
          "new_line_content": "                e_what = e.what();",
          "content_same": false
        },
        {
          "line": 450,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort()",
          "old_line_content": "        });",
          "new_line_content": "              ceph_abort();",
          "content_same": false
        },
        {
          "line": 456,
          "old_api": null,
          "new_api": "code",
          "old_text": null,
          "new_text": "e.code()",
          "old_line_content": "        } else {",
          "new_line_content": "            e.code() == std::errc::invalid_argument) {",
          "content_same": false
        },
        {
          "line": 457,
          "old_api": null,
          "new_api": "debug",
          "old_text": null,
          "new_text": "logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what())",
          "old_line_content": "          throw;",
          "new_line_content": "          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",",
          "content_same": false
        },
        {
          "line": 458,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "        }",
          "new_line_content": "                         ss.listen_addr, e.what());",
          "content_same": false
        },
        {
          "line": 465,
          "old_api": null,
          "new_api": "std::rethrow_exception(eptr)",
          "old_text": null,
          "new_text": "std::rethrow_exception(eptr)",
          "old_line_content": "        }",
          "new_line_content": "          std::rethrow_exception(eptr);",
          "content_same": false
        },
        {
          "line": 467,
          "old_api": null,
          "new_api": "what",
          "old_text": null,
          "new_text": "e.what()",
          "old_line_content": "                       \"got unexpected exception {}\", ss.listen_addr, e_what);",
          "new_line_content": "          e_what = e.what();",
          "content_same": false
        },
        {
          "line": 469,
          "old_api": null,
          "new_api": "error",
          "old_text": null,
          "new_text": "logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what)",
          "old_line_content": "      });",
          "new_line_content": "        logger().error(\"ShardedServerSocket({})::accept(): \"",
          "content_same": false
        },
        {
          "line": 471,
          "old_api": null,
          "new_api": "ceph_abort",
          "old_text": null,
          "new_text": "ceph_abort()",
          "old_line_content": "  });",
          "new_line_content": "        ceph_abort();",
          "content_same": false
        },
        {
          "line": 481,
          "old_api": null,
          "new_api": "debug",
          "old_text": null,
          "new_text": "logger().debug(\"ShardedServerSocket({})::shutdown_destroy()...\", listen_addr)",
          "old_line_content": "    if (ss.listener) {",
          "new_line_content": "  logger().debug(\"ShardedServerSocket({})::shutdown_destroy()...\", listen_addr);",
          "content_same": false
        },
        {
          "line": 483,
          "old_api": null,
          "new_api": "invoke_on_all",
          "old_text": null,
          "new_text": "this->container().invoke_on_all([](auto& ss) {\n    if (ss.listener) {\n      ss.listener->abort_accept();\n    }\n    return ss.shutdown_gate.close();\n  }).then([this] {\n    // destroy shards\n    return this->container().invoke_on_all([](auto& ss) {\n      assert(ss.shutdown_gate.is_closed());\n      ss.listen_addr = entity_addr_t();\n      ss.listener.reset();\n    });\n  }).then([this] {\n    // stop the sharded service: we should only construct/stop shards on #0\n    return this->container().invoke_on(0, [](auto& ss) {\n      assert(ss.service);\n      return ss.service->stop().finally([cleanup = std::move(ss.service)] {});\n    });\n  })",
          "old_line_content": "    }",
          "new_line_content": "  return this->container().invoke_on_all([](auto& ss) {",
          "content_same": false
        },
        {
          "line": 485,
          "old_api": null,
          "new_api": "abort_accept",
          "old_text": null,
          "new_text": "ss.listener->abort_accept()",
          "old_line_content": "  }).then([this] {",
          "new_line_content": "      ss.listener->abort_accept();",
          "content_same": false
        },
        {
          "line": 491,
          "old_api": null,
          "new_api": "is_closed",
          "old_text": null,
          "new_text": "ss.shutdown_gate.is_closed()",
          "old_line_content": "    });",
          "new_line_content": "      assert(ss.shutdown_gate.is_closed());",
          "content_same": false
        },
        {
          "line": 492,
          "old_api": null,
          "new_api": "entity_addr_t",
          "old_text": null,
          "new_text": "entity_addr_t()",
          "old_line_content": "  }).then([this] {",
          "new_line_content": "      ss.listen_addr = entity_addr_t();",
          "content_same": false
        },
        {
          "line": 493,
          "old_api": null,
          "new_api": "reset",
          "old_text": null,
          "new_text": "ss.listener.reset()",
          "old_line_content": "    // stop the sharded service: we should only construct/stop shards on #0",
          "new_line_content": "      ss.listener.reset();",
          "content_same": false
        },
        {
          "line": 497,
          "old_api": null,
          "new_api": "invoke_on",
          "old_text": null,
          "new_text": "this->container().invoke_on(0, [](auto& ss) {\n      assert(ss.service);\n      return ss.service->stop().finally([cleanup = std::move(ss.service)] {});\n    })",
          "old_line_content": "    });",
          "new_line_content": "    return this->container().invoke_on(0, [](auto& ss) {",
          "content_same": false
        },
        {
          "line": 498,
          "old_api": null,
          "new_api": "assert",
          "old_text": null,
          "new_text": "assert(ss.service)",
          "old_line_content": "  });",
          "new_line_content": "      assert(ss.service);",
          "content_same": false
        },
        {
          "line": 499,
          "old_api": null,
          "new_api": "finally",
          "old_text": null,
          "new_text": "ss.service->stop().finally([cleanup = std::move(ss.service)] {})",
          "old_line_content": "}",
          "new_line_content": "      return ss.service->stop().finally([cleanup = std::move(ss.service)] {});",
          "content_same": false
        },
        {
          "line": 509,
          "old_api": null,
          "new_api": "then",
          "old_text": null,
          "new_text": "seastar::smp::submit_to(0, [primary_sid, dispatch_only_on_this_shard] {\n    auto service = std::make_unique<sharded_service_t>();\n    return service->start(\n        primary_sid, dispatch_only_on_this_shard, construct_tag{}\n    ).then([service = std::move(service)]() mutable {\n      auto p_shard = service.get();\n      p_shard->local().service = std::move(service);\n      return p_shard;\n    });\n  }).then([](auto p_shard) {\n    return &p_shard->local();\n  })",
          "old_line_content": "        primary_sid, dispatch_only_on_this_shard, construct_tag{}",
          "new_line_content": "  return seastar::smp::submit_to(0, [primary_sid, dispatch_only_on_this_shard] {",
          "content_same": false
        },
        {
          "line": 510,
          "old_api": null,
          "new_api": "std::make_unique<sharded_service_t>()",
          "old_text": null,
          "new_text": "std::make_unique<sharded_service_t>()",
          "old_line_content": "    ).then([service = std::move(service)]() mutable {",
          "new_line_content": "    auto service = std::make_unique<sharded_service_t>();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 512,
          "old_api": "std::move(service)",
          "new_api": null,
          "old_text": "std::move(service)",
          "new_text": null,
          "old_line_content": "      p_shard->local().service = std::move(service);",
          "new_line_content": "        primary_sid, dispatch_only_on_this_shard, construct_tag{}",
          "content_same": false
        },
        {
          "line": 516,
          "old_api": "local",
          "new_api": null,
          "old_text": "p_shard->local()",
          "new_text": null,
          "old_line_content": "    return &p_shard->local();",
          "new_line_content": "      return p_shard;",
          "content_same": false
        },
        {
          "line": 110,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 112,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(closed)",
          "new_text": null,
          "old_line_content": "  assert(closed);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 119,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "seastar::future<bufferlist>",
          "content_same": false
        },
        {
          "line": 121,
          "old_api": "then",
          "new_api": null,
          "old_text": "try_trap_pre(next_trap_read).then([bytes, this] {\n#endif\n    if (bytes == 0) {\n      return seastar::make_ready_future<bufferlist>();\n    }\n    r.buffer.clear();\n    r.remaining = bytes;\n    return in.consume(bufferlist_consumer{r.buffer, r.remaining}).then([this] {\n      if (r.remaining) { // throw on short reads\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay().then([this] {\n        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));\n      });\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this](auto buf) {\n    return try_trap_post(next_trap_read\n    ).then([buf = std::move(buf)]() mutable {\n      return std::move(buf);\n    });\n  })",
          "new_text": null,
          "old_line_content": "  return try_trap_pre(next_trap_read).then([bytes, this] {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 126,
          "old_api": "clear",
          "new_api": null,
          "old_text": "r.buffer.clear()",
          "new_text": null,
          "old_line_content": "    r.buffer.clear();",
          "new_line_content": "    if (bytes == 0) {",
          "content_same": false
        },
        {
          "line": 128,
          "old_api": "consume",
          "new_api": null,
          "old_text": "in.consume(bufferlist_consumer{r.buffer, r.remaining}).then([this] {\n      if (r.remaining) { // throw on short reads\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay().then([this] {\n        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));\n      });\n    })",
          "new_text": null,
          "old_line_content": "    return in.consume(bufferlist_consumer{r.buffer, r.remaining}).then([this] {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 130,
          "old_api": "make_error_code",
          "new_api": null,
          "old_text": "make_error_code(error::read_eof)",
          "new_text": null,
          "old_line_content": "        throw std::system_error(make_error_code(error::read_eof));",
          "new_line_content": "    r.remaining = bytes;",
          "content_same": false
        },
        {
          "line": 132,
          "old_api": "inject_failure",
          "new_api": null,
          "old_text": "inject_failure()",
          "new_text": null,
          "old_line_content": "      inject_failure();",
          "new_line_content": "      if (r.remaining) { // throw on short reads",
          "content_same": false
        },
        {
          "line": 134,
          "old_api": "std::move(r.buffer)",
          "new_api": null,
          "old_text": "std::move(r.buffer)",
          "new_text": null,
          "old_line_content": "        return seastar::make_ready_future<bufferlist>(std::move(r.buffer));",
          "new_line_content": "      }",
          "content_same": false
        },
        {
          "line": 139,
          "old_api": "then",
          "new_api": null,
          "old_text": "try_trap_post(next_trap_read\n    ).then([buf = std::move(buf)]() mutable {\n      return std::move(buf);\n    })",
          "new_text": null,
          "old_line_content": "    return try_trap_post(next_trap_read",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 141,
          "old_api": "std::move(buf)",
          "new_api": null,
          "old_text": "std::move(buf)",
          "new_text": null,
          "old_line_content": "      return std::move(buf);",
          "new_line_content": "  }).then([this](auto buf) {",
          "content_same": false
        },
        {
          "line": 149,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 151,
          "old_api": "then",
          "new_api": null,
          "old_text": "try_trap_pre(next_trap_read).then([bytes, this] {\n#endif\n    if (bytes == 0) {\n      return seastar::make_ready_future<bufferptr>();\n    }\n    return in.read_exactly(bytes).then([bytes](auto buf) {\n      bufferptr ptr(buffer::create(buf.share()));\n      if (ptr.length() < bytes) {\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay(\n      ).then([ptr = std::move(ptr)]() mutable {\n        return seastar::make_ready_future<bufferptr>(std::move(ptr));\n      });\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this](auto ptr) {\n    return try_trap_post(next_trap_read\n    ).then([ptr = std::move(ptr)]() mutable {\n      return std::move(ptr);\n    });\n  })",
          "new_text": null,
          "old_line_content": "  return try_trap_pre(next_trap_read).then([bytes, this] {",
          "new_line_content": "Socket::read_exactly(size_t bytes) {",
          "content_same": false
        },
        {
          "line": 156,
          "old_api": "read_exactly",
          "new_api": null,
          "old_text": "in.read_exactly(bytes).then([bytes](auto buf) {\n      bufferptr ptr(buffer::create(buf.share()));\n      if (ptr.length() < bytes) {\n        throw std::system_error(make_error_code(error::read_eof));\n      }\n      inject_failure();\n      return inject_delay(\n      ).then([ptr = std::move(ptr)]() mutable {\n        return seastar::make_ready_future<bufferptr>(std::move(ptr));\n      });\n    })",
          "new_text": null,
          "old_line_content": "    return in.read_exactly(bytes).then([bytes](auto buf) {",
          "new_line_content": "    if (bytes == 0) {",
          "content_same": false
        },
        {
          "line": 158,
          "old_api": "length",
          "new_api": null,
          "old_text": "ptr.length()",
          "new_text": null,
          "old_line_content": "      if (ptr.length() < bytes) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 169,
          "old_api": "then",
          "new_api": null,
          "old_text": "try_trap_post(next_trap_read\n    ).then([ptr = std::move(ptr)]() mutable {\n      return std::move(ptr);\n    })",
          "new_text": null,
          "old_line_content": "    return try_trap_post(next_trap_read",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 171,
          "old_api": "std::move(ptr)",
          "new_api": null,
          "old_text": "std::move(ptr)",
          "new_text": null,
          "old_line_content": "      return std::move(ptr);",
          "new_line_content": "  }).then([this](auto ptr) {",
          "content_same": false
        },
        {
          "line": 180,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "seastar::future<>",
          "content_same": false
        },
        {
          "line": 182,
          "old_api": "then",
          "new_api": null,
          "old_text": "try_trap_pre(next_trap_write\n  ).then([buf = std::move(buf), this]() mutable {\n#endif\n    inject_failure();\n    return inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p));\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this] {\n    return try_trap_post(next_trap_write);\n  })",
          "new_text": null,
          "old_line_content": "  return try_trap_pre(next_trap_write",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 186,
          "old_api": "then",
          "new_api": null,
          "old_text": "inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p));\n    })",
          "new_text": null,
          "old_line_content": "    return inject_delay(",
          "new_line_content": "  ).then([buf = std::move(buf), this]() mutable {",
          "content_same": false
        },
        {
          "line": 193,
          "old_api": "try_trap_post",
          "new_api": null,
          "old_text": "try_trap_post(next_trap_write)",
          "new_text": null,
          "old_line_content": "    return try_trap_post(next_trap_write);",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 201,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "seastar::future<>",
          "content_same": false
        },
        {
          "line": 202,
          "old_api": "inject_failure",
          "new_api": null,
          "old_text": "inject_failure()",
          "new_text": null,
          "old_line_content": "  inject_failure();",
          "new_line_content": "Socket::flush()",
          "content_same": false
        },
        {
          "line": 203,
          "old_api": "then",
          "new_api": null,
          "old_text": "inject_delay().then([this] {\n    return out.flush();\n  })",
          "new_text": null,
          "old_line_content": "  return inject_delay().then([this] {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 211,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "seastar::future<>",
          "content_same": false
        },
        {
          "line": 213,
          "old_api": "then",
          "new_api": null,
          "old_text": "try_trap_pre(next_trap_write\n  ).then([buf = std::move(buf), this]() mutable {\n#endif\n    inject_failure();\n    return inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p)\n      ).then([this] {\n        return out.flush();\n      });\n    });\n#ifdef UNIT_TESTS_BUILT\n  }).then([this] {\n    return try_trap_post(next_trap_write);\n  })",
          "new_text": null,
          "old_line_content": "  return try_trap_pre(next_trap_write",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 217,
          "old_api": "then",
          "new_api": null,
          "old_text": "inject_delay(\n    ).then([buf = std::move(buf), this]() mutable {\n      packet p(std::move(buf));\n      return out.write(std::move(p)\n      ).then([this] {\n        return out.flush();\n      });\n    })",
          "new_text": null,
          "old_line_content": "    return inject_delay(",
          "new_line_content": "  ).then([buf = std::move(buf), this]() mutable {",
          "content_same": false
        },
        {
          "line": 222,
          "old_api": "flush",
          "new_api": null,
          "old_text": "out.flush()",
          "new_text": null,
          "old_line_content": "        return out.flush();",
          "new_line_content": "      packet p(std::move(buf));",
          "content_same": false
        },
        {
          "line": 227,
          "old_api": "try_trap_post",
          "new_api": null,
          "old_text": "try_trap_post(next_trap_write)",
          "new_text": null,
          "old_line_content": "    return try_trap_post(next_trap_write);",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 234,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 236,
          "old_api": "shutdown_input",
          "new_api": null,
          "old_text": "socket.shutdown_input()",
          "new_text": null,
          "old_line_content": "  socket.shutdown_input();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 243,
          "old_api": "close",
          "new_api": null,
          "old_text": "out.close().handle_exception_type([](const std::system_error& e) {\n    if (e.code() != std::errc::broken_pipe &&\n        e.code() != std::errc::connection_reset) {\n      logger().error(\"Socket::close(): unexpected error {}\", e.what());\n      ceph_abort();\n    }\n    // can happen when out is already shutdown, ignore\n  })",
          "new_text": null,
          "old_line_content": "  return out.close().handle_exception_type([](const std::system_error& e) {",
          "new_line_content": "static inline seastar::future<>",
          "content_same": false
        },
        {
          "line": 244,
          "old_api": "code",
          "new_api": null,
          "old_text": "e.code()",
          "new_text": null,
          "old_line_content": "    if (e.code() != std::errc::broken_pipe &&",
          "new_line_content": "close_and_handle_errors(seastar::output_stream<char>& out)",
          "content_same": false
        },
        {
          "line": 245,
          "old_api": "code",
          "new_api": null,
          "old_text": "e.code()",
          "new_text": null,
          "old_line_content": "        e.code() != std::errc::connection_reset) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 256,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "seastar::future<>",
          "content_same": false
        },
        {
          "line": 258,
          "old_api": "ceph_assert_always",
          "new_api": null,
          "old_text": "ceph_assert_always(!closed)",
          "new_text": null,
          "old_line_content": "  ceph_assert_always(!closed);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 262,
          "old_api": "inject_delay",
          "new_api": null,
          "old_text": "inject_delay()",
          "new_text": null,
          "old_line_content": "    inject_delay(),",
          "new_line_content": "  closed = true;",
          "content_same": false
        },
        {
          "line": 263,
          "old_api": "close",
          "new_api": null,
          "old_text": "in.close()",
          "new_text": null,
          "old_line_content": "    in.close(),",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 270,
          "old_api": "std::rethrow_exception(eptr)",
          "new_api": null,
          "old_text": "std::rethrow_exception(eptr)",
          "new_text": null,
          "old_line_content": "      std::rethrow_exception(eptr);",
          "new_line_content": "  }).handle_exception([](auto eptr) {",
          "content_same": false
        },
        {
          "line": 272,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "      e_what = e.what();",
          "new_line_content": "    try {",
          "content_same": false
        },
        {
          "line": 274,
          "old_api": "error",
          "new_api": null,
          "old_text": "logger().error(\"Socket::close(): unexpected exception {}\", e_what)",
          "new_text": null,
          "old_line_content": "    logger().error(\"Socket::close(): unexpected exception {}\", e_what);",
          "new_line_content": "    } catch (std::exception &e) {",
          "content_same": false
        },
        {
          "line": 282,
          "old_api": "inject_failure",
          "new_api": null,
          "old_text": "inject_failure()",
          "new_text": null,
          "old_line_content": "  inject_failure();",
          "new_line_content": "seastar::future<SocketRef>",
          "content_same": false
        },
        {
          "line": 283,
          "old_api": "then",
          "new_api": null,
          "old_text": "inject_delay(\n  ).then([peer_addr] {\n    return seastar::connect(peer_addr.in4_addr());\n  }).then([peer_addr](seastar::connected_socket socket) {\n    auto ret = std::make_unique<Socket>(\n      std::move(socket), side_t::connector, 0, construct_tag{});\n    logger().debug(\"Socket::connect(): connected to {}, socket {}\",\n                   peer_addr, fmt::ptr(ret));\n    return ret;\n  })",
          "new_text": null,
          "old_line_content": "  return inject_delay(",
          "new_line_content": "Socket::connect(const entity_addr_t &peer_addr)",
          "content_same": false
        },
        {
          "line": 287,
          "old_api": "std::make_unique<Socket>(\n      std::move(socket), side_t::connector, 0, construct_tag{})",
          "new_api": null,
          "old_text": "std::make_unique<Socket>(\n      std::move(socket), side_t::connector, 0, construct_tag{})",
          "new_text": null,
          "old_line_content": "    auto ret = std::make_unique<Socket>(",
          "new_line_content": "  ).then([peer_addr] {",
          "content_same": false
        },
        {
          "line": 289,
          "old_api": "debug",
          "new_api": null,
          "old_text": "logger().debug(\"Socket::connect(): connected to {}, socket {}\",\n                   peer_addr, fmt::ptr(ret))",
          "new_text": null,
          "old_line_content": "    logger().debug(\"Socket::connect(): connected to {}, socket {}\",",
          "new_line_content": "  }).then([peer_addr](seastar::connected_socket socket) {",
          "content_same": false
        },
        {
          "line": 297,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == sid);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 307,
          "old_api": "ceph_assert_always",
          "new_api": null,
          "old_text": "ceph_assert_always(action == bp_action_t::FAULT || action == bp_action_t::CONTINUE)",
          "new_text": null,
          "old_line_content": "      ceph_assert_always(action == bp_action_t::FAULT || action == bp_action_t::CONTINUE);",
          "new_line_content": "      next_trap_write = action;",
          "content_same": false
        },
        {
          "line": 309,
          "old_api": "ceph_abort",
          "new_api": null,
          "old_text": "ceph_abort()",
          "new_text": null,
          "old_line_content": "      ceph_abort();",
          "new_line_content": "      // do_sweep_messages() may combine multiple write events into one socket write",
          "content_same": false
        },
        {
          "line": 322,
          "old_api": "info",
          "new_api": null,
          "old_text": "logger().info(\"[Test] got FAULT\")",
          "new_text": null,
          "old_line_content": "    logger().info(\"[Test] got FAULT\");",
          "new_line_content": "   case bp_action_t::CONTINUE:",
          "content_same": false
        },
        {
          "line": 323,
          "old_api": "make_error_code",
          "new_api": null,
          "old_text": "make_error_code(error::negotiation_failure)",
          "new_text": null,
          "old_line_content": "    throw std::system_error(make_error_code(error::negotiation_failure));",
          "new_line_content": "    break;",
          "content_same": false
        },
        {
          "line": 331,
          "old_api": "ceph_abort",
          "new_api": null,
          "old_text": "ceph_abort(\"unexpected action from trap\")",
          "new_text": null,
          "old_line_content": "    ceph_abort(\"unexpected action from trap\");",
          "new_line_content": "    trap = action;",
          "content_same": false
        },
        {
          "line": 333,
          "old_api": "seastar::make_ready_future<>()",
          "new_api": null,
          "old_text": "seastar::make_ready_future<>()",
          "new_text": null,
          "old_line_content": "  return seastar::make_ready_future<>();",
          "new_line_content": "   default:",
          "content_same": false
        },
        {
          "line": 344,
          "old_api": "info",
          "new_api": null,
          "old_text": "logger().info(\"[Test] got STALL and block\")",
          "new_text": null,
          "old_line_content": "    logger().info(\"[Test] got STALL and block\");",
          "new_line_content": "   case bp_action_t::CONTINUE:",
          "content_same": false
        },
        {
          "line": 345,
          "old_api": "force_shutdown",
          "new_api": null,
          "old_text": "force_shutdown()",
          "new_text": null,
          "old_line_content": "    force_shutdown();",
          "new_line_content": "    break;",
          "content_same": false
        },
        {
          "line": 346,
          "old_api": "block",
          "new_api": null,
          "old_text": "blocker->block()",
          "new_text": null,
          "old_line_content": "    return blocker->block();",
          "new_line_content": "   case bp_action_t::STALL:",
          "content_same": false
        },
        {
          "line": 350,
          "old_api": "seastar::make_ready_future<>()",
          "new_api": null,
          "old_text": "seastar::make_ready_future<>()",
          "new_text": null,
          "old_line_content": "  return seastar::make_ready_future<>();",
          "new_line_content": "   default:",
          "content_same": false
        },
        {
          "line": 364,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(!listener)",
          "new_text": null,
          "old_line_content": "  assert(!listener);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 366,
          "old_api": "ceph_assert_always",
          "new_api": null,
          "old_text": "ceph_assert_always(!service)",
          "new_text": null,
          "old_line_content": "  ceph_assert_always(!service);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 372,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  ceph_assert_always(seastar::this_shard_id() == primary_sid);",
          "new_line_content": "listen_ertr::future<>",
          "content_same": false
        },
        {
          "line": 373,
          "old_api": "debug",
          "new_api": null,
          "old_text": "logger().debug(\"ShardedServerSocket({})::listen()...\", addr)",
          "new_text": null,
          "old_line_content": "  logger().debug(\"ShardedServerSocket({})::listen()...\", addr);",
          "new_line_content": "ShardedServerSocket::listen(entity_addr_t addr)",
          "content_same": false
        },
        {
          "line": 374,
          "old_api": "invoke_on_all",
          "new_api": null,
          "old_text": "this->container().invoke_on_all([addr](auto& ss) {\n    ss.listen_addr = addr;\n    seastar::socket_address s_addr(addr.in4_addr());\n    seastar::listen_options lo;\n    lo.reuse_address = true;\n    if (ss.dispatch_only_on_primary_sid) {\n      lo.set_fixed_cpu(ss.primary_sid);\n    }\n    ss.listener = seastar::listen(s_addr, lo);\n  }).then([] {\n    return listen_ertr::now();\n  }).handle_exception_type(\n    [addr](const std::system_error& e) -> listen_ertr::future<> {\n    if (e.code() == std::errc::address_in_use) {\n      logger().debug(\"ShardedServerSocket({})::listen(): address in use\", addr);\n      return crimson::ct_error::address_in_use::make();\n    } else if (e.code() == std::errc::address_not_available) {\n      logger().debug(\"ShardedServerSocket({})::listen(): address not available\",\n                     addr);\n      return crimson::ct_error::address_not_available::make();\n    }\n    logger().error(\"ShardedServerSocket({})::listen(): \"\n                   \"got unexpeted error {}\", addr, e.what());\n    ceph_abort();\n  })",
          "new_text": null,
          "old_line_content": "  return this->container().invoke_on_all([addr](auto& ss) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 380,
          "old_api": "set_fixed_cpu",
          "new_api": null,
          "old_text": "lo.set_fixed_cpu(ss.primary_sid)",
          "new_text": null,
          "old_line_content": "      lo.set_fixed_cpu(ss.primary_sid);",
          "new_line_content": "    seastar::listen_options lo;",
          "content_same": false
        },
        {
          "line": 382,
          "old_api": "seastar::listen(s_addr, lo)",
          "new_api": null,
          "old_text": "seastar::listen(s_addr, lo)",
          "new_text": null,
          "old_line_content": "    ss.listener = seastar::listen(s_addr, lo);",
          "new_line_content": "    if (ss.dispatch_only_on_primary_sid) {",
          "content_same": false
        },
        {
          "line": 384,
          "old_api": "listen_ertr::now()",
          "new_api": null,
          "old_text": "listen_ertr::now()",
          "new_text": null,
          "old_line_content": "    return listen_ertr::now();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 388,
          "old_api": "debug",
          "new_api": null,
          "old_text": "logger().debug(\"ShardedServerSocket({})::listen(): address in use\", addr)",
          "new_text": null,
          "old_line_content": "      logger().debug(\"ShardedServerSocket({})::listen(): address in use\", addr);",
          "new_line_content": "  }).handle_exception_type(",
          "content_same": false
        },
        {
          "line": 389,
          "old_api": "crimson::ct_error::address_in_use::make()",
          "new_api": null,
          "old_text": "crimson::ct_error::address_in_use::make()",
          "new_text": null,
          "old_line_content": "      return crimson::ct_error::address_in_use::make();",
          "new_line_content": "    [addr](const std::system_error& e) -> listen_ertr::future<> {",
          "content_same": false
        },
        {
          "line": 395,
          "old_api": "error",
          "new_api": null,
          "old_text": "logger().error(\"ShardedServerSocket({})::listen(): \"\n                   \"got unexpeted error {}\", addr, e.what())",
          "new_text": null,
          "old_line_content": "    logger().error(\"ShardedServerSocket({})::listen(): \"",
          "new_line_content": "                     addr);",
          "content_same": false
        },
        {
          "line": 397,
          "old_api": "ceph_abort",
          "new_api": null,
          "old_text": "ceph_abort()",
          "new_text": null,
          "old_line_content": "    ceph_abort();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 404,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  ceph_assert_always(seastar::this_shard_id() == primary_sid);",
          "new_line_content": "seastar::future<>",
          "content_same": false
        },
        {
          "line": 405,
          "old_api": "debug",
          "new_api": null,
          "old_text": "logger().debug(\"ShardedServerSocket({})::accept()...\", listen_addr)",
          "new_text": null,
          "old_line_content": "  logger().debug(\"ShardedServerSocket({})::accept()...\", listen_addr);",
          "new_line_content": "ShardedServerSocket::accept(accept_func_t &&_fn_accept)",
          "content_same": false
        },
        {
          "line": 406,
          "old_api": "invoke_on_all",
          "new_api": null,
          "old_text": "this->container().invoke_on_all([_fn_accept](auto &ss) {\n    assert(ss.listener);\n    ss.fn_accept = _fn_accept;\n    // gate accepting\n    // ShardedServerSocket::shutdown() will drain the continuations in the gate\n    // so ignore the returned future\n    std::ignore = seastar::with_gate(ss.shutdown_gate, [&ss] {\n      return seastar::keep_doing([&ss] {\n        return ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        });\n      }).handle_exception_type([&ss](const std::system_error& e) {\n        if (e.code() == std::errc::connection_aborted ||\n            e.code() == std::errc::invalid_argument) {\n          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what());\n        } else {\n          throw;\n        }\n      }).handle_exception([&ss](auto eptr) {\n        const char *e_what;\n        try {\n          std::rethrow_exception(eptr);\n        } catch (std::exception &e) {\n          e_what = e.what();\n        }\n        logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what);\n        ceph_abort();\n      });\n    });\n  })",
          "new_text": null,
          "old_line_content": "  return this->container().invoke_on_all([_fn_accept](auto &ss) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 412,
          "old_api": "then",
          "new_api": null,
          "old_text": "seastar::with_gate(ss.shutdown_gate, [&ss] {\n      return seastar::keep_doing([&ss] {\n        return ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        });\n      }).handle_exception_type([&ss](const std::system_error& e) {\n        if (e.code() == std::errc::connection_aborted ||\n            e.code() == std::errc::invalid_argument) {\n          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what());\n        } else {\n          throw;\n        }\n      }).handle_exception([&ss](auto eptr) {\n        const char *e_what;\n        try {\n          std::rethrow_exception(eptr);\n        } catch (std::exception &e) {\n          e_what = e.what();\n        }\n        logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what);\n        ceph_abort();\n      });\n    })",
          "new_text": null,
          "old_line_content": "    std::ignore = seastar::with_gate(ss.shutdown_gate, [&ss] {",
          "new_line_content": "    // gate accepting",
          "content_same": false
        },
        {
          "line": 413,
          "old_api": "then",
          "new_api": null,
          "old_text": "seastar::keep_doing([&ss] {\n        return ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        });\n      }).handle_exception_type([&ss](const std::system_error& e) {\n        if (e.code() == std::errc::connection_aborted ||\n            e.code() == std::errc::invalid_argument) {\n          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what());\n        } else {\n          throw;\n        }\n      }).handle_exception([&ss](auto eptr) {\n        const char *e_what;\n        try {\n          std::rethrow_exception(eptr);\n        } catch (std::exception &e) {\n          e_what = e.what();\n        }\n        logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what);\n        ceph_abort();\n      })",
          "new_text": null,
          "old_line_content": "      return seastar::keep_doing([&ss] {",
          "new_line_content": "    // ShardedServerSocket::shutdown() will drain the continuations in the gate",
          "content_same": false
        },
        {
          "line": 414,
          "old_api": "then",
          "new_api": null,
          "old_text": "ss.listener->accept(\n        ).then([&ss](seastar::accept_result accept_result) {\n#ifndef NDEBUG\n          if (ss.dispatch_only_on_primary_sid) {\n            // see seastar::listen_options::set_fixed_cpu()\n            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);\n          }\n#endif\n          auto [socket, paddr] = std::move(accept_result);\n          entity_addr_t peer_addr;\n          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());\n          peer_addr.set_type(ss.listen_addr.get_type());\n          SocketRef _socket = std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{});\n          logger().debug(\"ShardedServerSocket({})::accept(): accepted peer {}, \"\n                         \"socket {}, dispatch_only_on_primary_sid = {}\",\n                         ss.listen_addr, peer_addr, fmt::ptr(_socket),\n                         ss.dispatch_only_on_primary_sid);\n          std::ignore = seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          });\n        })",
          "new_text": null,
          "old_line_content": "        return ss.listener->accept(",
          "new_line_content": "    // so ignore the returned future",
          "content_same": false
        },
        {
          "line": 419,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "            ceph_assert_always(seastar::this_shard_id() == ss.primary_sid);",
          "new_line_content": "#ifndef NDEBUG",
          "content_same": false
        },
        {
          "line": 424,
          "old_api": "as_posix_sockaddr",
          "new_api": null,
          "old_text": "paddr.as_posix_sockaddr()",
          "new_text": null,
          "old_line_content": "          peer_addr.set_sockaddr(&paddr.as_posix_sockaddr());",
          "new_line_content": "#endif",
          "content_same": false
        },
        {
          "line": 426,
          "old_api": "get_port",
          "new_api": null,
          "old_text": "std::make_unique<Socket>(\n              std::move(socket), Socket::side_t::acceptor,\n              peer_addr.get_port(), Socket::construct_tag{})",
          "new_text": null,
          "old_line_content": "          SocketRef _socket = std::make_unique<Socket>(",
          "new_line_content": "          entity_addr_t peer_addr;",
          "content_same": false
        },
        {
          "line": 433,
          "old_api": "fn_accept",
          "new_api": null,
          "old_text": "seastar::with_gate(\n              ss.shutdown_gate,\n              [socket=std::move(_socket), peer_addr, &ss]() mutable {\n            return ss.fn_accept(std::move(socket), peer_addr\n            ).handle_exception([&ss, peer_addr](auto eptr) {\n              const char *e_what;\n              try {\n                std::rethrow_exception(eptr);\n              } catch (std::exception &e) {\n                e_what = e.what();\n              }\n              logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what);\n              ceph_abort();\n            });\n          })",
          "new_text": null,
          "old_line_content": "          std::ignore = seastar::with_gate(",
          "new_line_content": "                         \"socket {}, dispatch_only_on_primary_sid = {}\",",
          "content_same": false
        },
        {
          "line": 440,
          "old_api": "std::rethrow_exception(eptr)",
          "new_api": null,
          "old_text": "std::rethrow_exception(eptr)",
          "new_text": null,
          "old_line_content": "                std::rethrow_exception(eptr);",
          "new_line_content": "            ).handle_exception([&ss, peer_addr](auto eptr) {",
          "content_same": false
        },
        {
          "line": 442,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "                e_what = e.what();",
          "new_line_content": "              try {",
          "content_same": false
        },
        {
          "line": 444,
          "old_api": "error",
          "new_api": null,
          "old_text": "logger().error(\"ShardedServerSocket({})::accept(): \"\n                             \"fn_accept(s, {}) got unexpected exception {}\",\n                             ss.listen_addr, peer_addr, e_what)",
          "new_text": null,
          "old_line_content": "              logger().error(\"ShardedServerSocket({})::accept(): \"",
          "new_line_content": "              } catch (std::exception &e) {",
          "content_same": false
        },
        {
          "line": 452,
          "old_api": "code",
          "new_api": null,
          "old_text": "e.code()",
          "new_text": null,
          "old_line_content": "        if (e.code() == std::errc::connection_aborted ||",
          "new_line_content": "          });",
          "content_same": false
        },
        {
          "line": 453,
          "old_api": "code",
          "new_api": null,
          "old_text": "e.code()",
          "new_text": null,
          "old_line_content": "            e.code() == std::errc::invalid_argument) {",
          "new_line_content": "        });",
          "content_same": false
        },
        {
          "line": 454,
          "old_api": "debug",
          "new_api": null,
          "old_text": "logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",\n                         ss.listen_addr, e.what())",
          "new_text": null,
          "old_line_content": "          logger().debug(\"ShardedServerSocket({})::accept(): stopped ({})\",",
          "new_line_content": "      }).handle_exception_type([&ss](const std::system_error& e) {",
          "content_same": false
        },
        {
          "line": 462,
          "old_api": "std::rethrow_exception(eptr)",
          "new_api": null,
          "old_text": "std::rethrow_exception(eptr)",
          "new_text": null,
          "old_line_content": "          std::rethrow_exception(eptr);",
          "new_line_content": "      }).handle_exception([&ss](auto eptr) {",
          "content_same": false
        },
        {
          "line": 464,
          "old_api": "what",
          "new_api": null,
          "old_text": "e.what()",
          "new_text": null,
          "old_line_content": "          e_what = e.what();",
          "new_line_content": "        try {",
          "content_same": false
        },
        {
          "line": 466,
          "old_api": "error",
          "new_api": null,
          "old_text": "logger().error(\"ShardedServerSocket({})::accept(): \"\n                       \"got unexpected exception {}\", ss.listen_addr, e_what)",
          "new_text": null,
          "old_line_content": "        logger().error(\"ShardedServerSocket({})::accept(): \"",
          "new_line_content": "        } catch (std::exception &e) {",
          "content_same": false
        },
        {
          "line": 468,
          "old_api": "ceph_abort",
          "new_api": null,
          "old_text": "ceph_abort()",
          "new_text": null,
          "old_line_content": "        ceph_abort();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 477,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  assert(seastar::this_shard_id() == primary_sid);",
          "new_line_content": "seastar::future<>",
          "content_same": false
        },
        {
          "line": 478,
          "old_api": "debug",
          "new_api": null,
          "old_text": "logger().debug(\"ShardedServerSocket({})::shutdown_destroy()...\", listen_addr)",
          "new_text": null,
          "old_line_content": "  logger().debug(\"ShardedServerSocket({})::shutdown_destroy()...\", listen_addr);",
          "new_line_content": "ShardedServerSocket::shutdown_destroy()",
          "content_same": false
        },
        {
          "line": 482,
          "old_api": "abort_accept",
          "new_api": null,
          "old_text": "ss.listener->abort_accept()",
          "new_text": null,
          "old_line_content": "      ss.listener->abort_accept();",
          "new_line_content": "  // shutdown shards",
          "content_same": false
        },
        {
          "line": 484,
          "old_api": "close",
          "new_api": null,
          "old_text": "ss.shutdown_gate.close()",
          "new_text": null,
          "old_line_content": "    return ss.shutdown_gate.close();",
          "new_line_content": "    if (ss.listener) {",
          "content_same": false
        },
        {
          "line": 488,
          "old_api": "is_closed",
          "new_api": null,
          "old_text": "ss.shutdown_gate.is_closed()",
          "new_text": null,
          "old_line_content": "      assert(ss.shutdown_gate.is_closed());",
          "new_line_content": "  }).then([this] {",
          "content_same": false
        },
        {
          "line": 489,
          "old_api": "entity_addr_t",
          "new_api": null,
          "old_text": "entity_addr_t()",
          "new_text": null,
          "old_line_content": "      ss.listen_addr = entity_addr_t();",
          "new_line_content": "    // destroy shards",
          "content_same": false
        },
        {
          "line": 494,
          "old_api": "invoke_on",
          "new_api": null,
          "old_text": "this->container().invoke_on(0, [](auto& ss) {\n      assert(ss.service);\n      return ss.service->stop().finally([cleanup = std::move(ss.service)] {});\n    })",
          "new_text": null,
          "old_line_content": "    return this->container().invoke_on(0, [](auto& ss) {",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 495,
          "old_api": "assert",
          "new_api": null,
          "old_text": "assert(ss.service)",
          "new_text": null,
          "old_line_content": "      assert(ss.service);",
          "new_line_content": "  }).then([this] {",
          "content_same": false
        },
        {
          "line": 496,
          "old_api": "finally",
          "new_api": null,
          "old_text": "ss.service->stop().finally([cleanup = std::move(ss.service)] {})",
          "new_text": null,
          "old_line_content": "      return ss.service->stop().finally([cleanup = std::move(ss.service)] {});",
          "new_line_content": "    // stop the sharded service: we should only construct/stop shards on #0",
          "content_same": false
        },
        {
          "line": 504,
          "old_api": "seastar::this_shard_id()",
          "new_api": null,
          "old_text": "seastar::this_shard_id()",
          "new_text": null,
          "old_line_content": "  auto primary_sid = seastar::this_shard_id();",
          "new_line_content": "seastar::future<ShardedServerSocket*>",
          "content_same": false
        },
        {
          "line": 506,
          "old_api": "then",
          "new_api": null,
          "old_text": "seastar::smp::submit_to(0, [primary_sid, dispatch_only_on_this_shard] {\n    auto service = std::make_unique<sharded_service_t>();\n    return service->start(\n        primary_sid, dispatch_only_on_this_shard, construct_tag{}\n    ).then([service = std::move(service)]() mutable {\n      auto p_shard = service.get();\n      p_shard->local().service = std::move(service);\n      return p_shard;\n    });\n  }).then([](auto p_shard) {\n    return &p_shard->local();\n  })",
          "new_text": null,
          "old_line_content": "  return seastar::smp::submit_to(0, [primary_sid, dispatch_only_on_this_shard] {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 508,
          "old_api": "then",
          "new_api": null,
          "old_text": "service->start(\n        primary_sid, dispatch_only_on_this_shard, construct_tag{}\n    ).then([service = std::move(service)]() mutable {\n      auto p_shard = service.get();\n      p_shard->local().service = std::move(service);\n      return p_shard;\n    })",
          "new_text": null,
          "old_line_content": "    return service->start(",
          "new_line_content": "  // start the sharded service: we should only construct/stop shards on #0",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 45,
      "total_additions": 104,
      "total_deletions": 102,
      "total_api_changes": 251
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 3,
        "api_related_lines": 251,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          108
        ]
      }
    },
    "api_calls_before": 265,
    "api_calls_after": 267,
    "diff_info": {
      "added_lines": 3,
      "removed_lines": 0,
      "total_diff_lines": 15
    }
  }
}