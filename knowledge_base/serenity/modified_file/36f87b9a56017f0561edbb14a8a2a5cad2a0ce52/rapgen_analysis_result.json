{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/36f87b9a56017f0561edbb14a8a2a5cad2a0ce52",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/36f87b9a56017f0561edbb14a8a2a5cad2a0ce52/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/36f87b9a56017f0561edbb14a8a2a5cad2a0ce52/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/36f87b9a56017f0561edbb14a8a2a5cad2a0ce52/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 1687,
          "old_api": "child_count",
          "new_api": "alse;\n\n    // Each child of A equal",
          "old_text": "count = other_node->child_count();\n",
          "new_text": "alse;\n\n    // Each child of A equal",
          "old_line_content": null,
          "new_line_content": "        if (this_processing_instruction.data() != other_processing_instruction.data())",
          "content_same": true
        },
        {
          "line": 1696,
          "old_api": "e made nicer.",
          "new_api": "VERIFY(other_child);",
          "old_text": "e made nicer.",
          "new_text": "     VERIFY(other_child);",
          "old_line_content": "    size_t this_child_count = child_count();",
          "new_line_content": "    if (child_count() != other_node->child_count())",
          "content_same": false
        },
        {
          "line": 1704,
          "old_api": ";\n}\n\n// https://d",
          "new_api": "amespace\nOptional<String> Node::locate",
          "old_text": ";\n}\n\n// https://d",
          "new_text": "amespace\nOptional<String> Node::locate",
          "old_line_content": "        auto* this_child = child_at_index(i);",
          "new_line_content": "        if (!this_child->is_equal_node(other_child))",
          "content_same": false
        },
        {
          "line": 1707,
          "old_api": "const& prefix) con",
          "new_api": "{\n    // To locate a name",
          "old_text": " const& prefix) con",
          "new_text": "\n{\n    // To locate a name",
          "old_line_content": "        VERIFY(other_child);",
          "new_line_content": "        this_child = this_child->next_sibling();",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": "locate a namespace for a node using pr",
          "new_api": "refix, switch on the interf",
          "old_text": "locate a namespace for a node using pr",
          "new_text": "refix, switch on the interf",
          "old_line_content": "        if (!this_child->is_equal_node(other_child))",
          "new_line_content": "        other_child = other_child->next_sibling();",
          "content_same": false
        },
        {
          "line": 1731,
          "old_api": "space, namespace prefix is",
          "new_api": "f prefix is null",
          "old_text": "space, namespace prefix is ",
          "new_text": "f prefix is null",
          "old_line_content": "        auto& element = verify_cast<Element>(*this);",
          "new_line_content": "        if (element.namespace_uri().has_value() && element.prefix() == prefix)",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": "f prefix is null",
          "new_api": "namespace is the XMLNS namespace, na",
          "old_text": "f prefix is null",
          "new_text": "namespace is the XMLNS namespace, na",
          "old_line_content": "        if (element.namespace_uri().has_value() && element.prefix() == prefix)",
          "new_line_content": "            return element.namespace_uri()->to_string();",
          "content_same": false
        },
        {
          "line": 1738,
          "old_api": "prefix",
          "new_api": "has_value",
          "old_text": "r.prefix() == \"xmlns",
          "new_text": "prefix.has_value() &",
          "old_line_content": "        if (auto* attributes = element.attributes()) {",
          "new_line_content": "            for (size_t i = 0; i < attributes->length(); ++i) {",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": "has_value",
          "new_api": "cal_name",
          "old_text": "prefix.has_value() &",
          "new_text": "cal_name() == \"xmln",
          "old_line_content": "            for (size_t i = 0; i < attributes->length(); ++i) {",
          "new_line_content": "                auto& attr = *attributes->item(i);",
          "content_same": false
        },
        {
          "line": 1740,
          "old_api": "cal_name",
          "new_api": "auto value",
          "old_text": "cal_name() == \"xmln",
          "new_text": "         auto value ",
          "old_line_content": "                auto& attr = *attributes->item(i);",
          "new_line_content": "                if (attr.namespace_uri() == Web::Namespace::XMLNS) {",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": "auto value",
          "new_api": "}",
          "old_text": "         auto value ",
          "new_text": "           }\n    ",
          "old_line_content": "                if (attr.namespace_uri() == Web::Namespace::XMLNS) {",
          "new_line_content": "                    if ((attr.prefix() == \"xmlns\" && attr.local_name() == prefix) || (!prefix.has_value() && !attr.prefix().has_value() && attr.local_name() == \"xmlns\")) {",
          "content_same": false
        },
        {
          "line": 1742,
          "old_api": "}",
          "new_api": "ent is null,",
          "old_text": "           }\n    ",
          "new_text": "ent is null,",
          "old_line_content": "                    if ((attr.prefix() == \"xmlns\" && attr.local_name() == prefix) || (!prefix.has_value() && !attr.prefix().has_value() && attr.local_name() == \"xmlns\")) {",
          "new_line_content": "                        auto value = attr.value();",
          "content_same": false
        },
        {
          "line": 1743,
          "old_api": "ent is null,",
          "new_api": "* parent_element",
          "old_text": "ent is null,",
          "new_text": "* parent_element",
          "old_line_content": "                        auto value = attr.value();",
          "new_line_content": "                        if (!value.is_empty())",
          "content_same": false
        },
        {
          "line": 1754,
          "old_api": "(prefix);\n    }\n\n    //",
          "new_api": "(is<Document>(*this)) {",
          "old_text": "(prefix);\n    }\n\n    // ",
          "new_text": " (is<Document>(*this)) {",
          "old_line_content": "        auto* parent_element = element.parent_element();",
          "new_line_content": "        if (!element.parent_element())",
          "content_same": false
        },
        {
          "line": 1824,
          "old_api": "s document element is non-n",
          "new_api": "ll.\n        auto* document_element = verify_c",
          "old_text": "s document element is non-n",
          "new_text": "ll.\n        auto* document_element = verify_c",
          "old_line_content": "        auto& element = verify_cast<Element>(*this);",
          "new_line_content": "        return element.locate_a_namespace_prefix(namespace_);",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": "lue",
          "new_api": "s",
          "old_text": "lue());\n        for (auto const& class_name : element",
          "new_text": "s())\n       ",
          "old_line_content": "    builder.append(node_name().to_deprecated_fly_string().to_lowercase());",
          "new_line_content": "    if (is_element()) {",
          "content_same": false
        },
        {
          "line": 1899,
          "old_api": "s",
          "new_api": "_name);\n    }\n    return MUST(builder.t",
          "old_text": "s())\n       ",
          "new_text": "_name);\n    }\n    return MUST(builder.t",
          "old_line_content": "    if (is_element()) {",
          "new_line_content": "        auto const& element = static_cast<DOM::Element const&>(*this);",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": "_name);\n    }\n    return MUST(builder.t",
          "new_api": "// https://dom.spec.wh",
          "old_text": "_name);\n    }\n    return MUST(builder.t",
          "new_text": "\n\n// https://dom.spec.wh",
          "old_line_content": "        auto const& element = static_cast<DOM::Element const&>(*this);",
          "new_line_content": "        if (element.id().has_value())",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "// https://dom.spec.wh",
          "new_api": "ode::length() const",
          "old_text": "\n\n// https://dom.spec.wh",
          "new_text": "ode::length() const\n",
          "old_line_content": "        if (element.id().has_value())",
          "new_line_content": "            builder.appendff(\"#{}\", element.id().value());",
          "content_same": false
        },
        {
          "line": 1902,
          "old_api": "ode::length() const",
          "new_api": "Attr node, then retur",
          "old_text": "ode::length() const\n",
          "new_text": "Attr node, then retur",
          "old_line_content": "            builder.appendff(\"#{}\", element.id().value());",
          "new_line_content": "        for (auto const& class_name : element.class_names())",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": "Attr node, then retur",
          "new_api": "s_document_type",
          "old_text": "Attr node, then retur",
          "new_text": "s_document_type() || is_attribute()",
          "old_line_content": "        for (auto const& class_name : element.class_names())",
          "new_line_content": "            builder.appendff(\".{}\", class_name);",
          "content_same": false
        },
        {
          "line": 1917,
          "old_api": "{\n    m_paintable",
          "new_api": "ainting::Paintable const* Node::paintable() const\n{\n    return",
          "old_text": "\n{\n    m_paintable ",
          "new_text": "ainting::Paintable const* Node::paintable() const\n{\n    return",
          "old_line_content": "    if (is_character_data())",
          "new_line_content": "        return verify_cast<CharacterData>(*this).length_in_utf16_code_units();",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": "static_cast<Painting::Paintabl",
          "new_api": "pec.whatwg.",
          "old_text": " static_cast<Painting::Paintabl",
          "new_text": "pec.whatwg.",
          "old_line_content": "    if (paintable() && paintable()->is_paintable_box())",
          "new_line_content": "        return static_cast<Painting::PaintableBox const*>(paintable());",
          "content_same": false
        },
        {
          "line": 1948,
          "old_api": "String> const& attribute_name,",
          "new_api": "al<String>",
          "old_text": "String> const& attribute_name, ",
          "new_text": "al<String> ",
          "old_line_content": "    if (paintable() && paintable()->is_paintable_box())",
          "new_line_content": "        return static_cast<Painting::PaintableBox*>(paintable());",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "&& !(type == Mutati",
          "new_api": "{\n                // 1. Let mo be",
          "old_text": "       && !(type == Mutati",
          "new_text": "{\n                // 1. Let mo be ",
          "old_line_content": "                && !(type == MutationType::attributes && (!options.attributes.has_value() || !options.attributes.value()))",
          "new_line_content": "                && !(type == MutationType::attributes && options.attribute_filter.has_value() && (attribute_namespace.has_value() || !options.attribute_filter->contains_slow(attribute_name.value_or(String {}))))",
          "content_same": false
        },
        {
          "line": 1982,
          "old_api": "{\n                // 1. Let mo be",
          "new_api": "// 2. If interestedOb",
          "old_text": "{\n                // 1. Let mo be ",
          "new_text": "         // 2. If interestedOb",
          "old_line_content": "                && !(type == MutationType::attributes && options.attribute_filter.has_value() && (attribute_namespace.has_value() || !options.attribute_filter->contains_slow(attribute_name.value_or(String {}))))",
          "new_line_content": "                && !(type == MutationType::characterData && (!options.character_data.has_value() || !options.character_data.value()))",
          "content_same": false
        },
        {
          "line": 1989,
          "old_api": "s[\"characterDataOldValue\"] is true, then set int",
          "new_api": "o oldValue.\n                if ((type == Mutati",
          "old_text": "s[\"characterDataOldValue\"] is true, then set int",
          "new_text": "o oldValue.\n                if ((type == Mutati",
          "old_line_content": "                if (!interested_observers.contains(mutation_observer))",
          "new_line_content": "                    interested_observers.set(mutation_observer, {});",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "is_empty",
          "new_api": "_nodes_list = StaticNodeList::create(realm(), move(add",
          "old_text": "nterested_observers.is_empty())\n        ",
          "new_text": "_nodes_list = StaticNodeList::create(realm(), move(add",
          "old_line_content": "                if ((type == MutationType::attributes && options.attribute_old_value.has_value() && options.attribute_old_value.value()) || (type == MutationType::characterData && options.character_data_old_value.has_value() && options.character_data_old_value.value()))",
          "new_line_content": "                    interested_observers.set(mutation_observer, old_value);",
          "content_same": false
        },
        {
          "line": 2003,
          "old_api": "The MutationReco",
          "new_api": "nd namespace",
          "old_text": " The MutationReco",
          "new_text": "nd namespace\n      ",
          "old_line_content": "    auto added_nodes_list = StaticNodeList::create(realm(), move(added_nodes));",
          "new_line_content": "    auto removed_nodes_list = StaticNodeList::create(realm(), move(removed_nodes));",
          "content_same": false
        },
        {
          "line": 2010,
          "old_api": "ing",
          "new_api": "with its type set to type,",
          "old_text": "ing();\n\n        // 1. Let ",
          "new_text": "with its type set to type, ",
          "old_line_content": "        if (attribute_name.has_value())",
          "new_line_content": "            string_attribute_name = attribute_name->to_string();",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "set to namespace, oldValue set",
          "new_api": "dNodes set to addedNodes, remove",
          "old_text": " set to namespace, oldValue set",
          "new_text": "dNodes set to addedNodes, remove",
          "old_line_content": "        if (attribute_namespace.has_value())",
          "new_line_content": "            string_attribute_name = attribute_namespace->to_string();",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "(m_first_child == chil",
          "new_api": "first_child = n",
          "old_text": " (m_first_child == chil",
          "new_text": "first_child = n",
          "old_line_content": "    VERIFY(!node->m_parent);",
          "new_line_content": "    VERIFY(child->parent() == this);",
          "content_same": false
        },
        {
          "line": 2138,
          "old_api": "cument_elemen",
          "new_api": "has_child_nodes",
          "old_text": "cument_elemen",
          "new_text": "element->has_child_nodes())\n     ",
          "old_line_content": "    if (is_document()) {",
          "new_line_content": "        auto* document = static_cast<DOM::Document*>(this);",
          "content_same": false
        },
        {
          "line": 2139,
          "old_api": "has_child_nodes",
          "new_api": "ch_child",
          "old_text": "element->has_child_nodes())\n     ",
          "new_text": "ch_child([&parent](DOM::Node",
          "old_line_content": "        auto* document = static_cast<DOM::Document*>(this);",
          "new_line_content": "        auto* document_element = document->document_element();",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "ch_child",
          "new_api": "build_accessibility_tree",
          "old_text": "ch_child([&parent](DOM::Node",
          "new_text": "ld.build_accessibility_tree(parent);\n            ",
          "old_line_content": "        auto* document_element = document->document_element();",
          "new_line_content": "        if (document_element && document_element->include_in_accessibility_tree()) {",
          "content_same": false
        },
        {
          "line": 2141,
          "old_api": "build_accessibility_tree",
          "new_api": "terationDecision::Continue;",
          "old_text": "ld.build_accessibility_tree(parent);\n            ",
          "new_text": "terationDecision::Continue;\n      ",
          "old_line_content": "        if (document_element && document_element->include_in_accessibility_tree()) {",
          "new_line_content": "            parent.set_value(document_element);",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": "terationDecision::Continue;",
          "new_api": "}\n    } else if (is_element())",
          "old_text": "terationDecision::Continue;\n      ",
          "new_text": "    }\n    } else if (is_element()) ",
          "old_line_content": "            parent.set_value(document_element);",
          "new_line_content": "            if (document_element->has_child_nodes())",
          "content_same": false
        },
        {
          "line": 2143,
          "old_api": "}\n    } else if (is_element())",
          "new_api": "st* element = static_cast<DOM::Element const*>(this);\n\n        if (is<HTML::HTMLScriptElement>(element) || is<HTML::HTMLStyleElement>(element))\n            return;\n\n        if (element->include_in_",
          "old_text": "    }\n    } else if (is_element()) ",
          "new_text": "st* element = static_cast<DOM::Element const*>(this);\n\n        if (is<HTML::HTMLScriptElement>(element) || is<HTML::HTMLStyleElement>(element))\n            return;\n\n        if (element->include_in_",
          "old_line_content": "            if (document_element->has_child_nodes())",
          "new_line_content": "                document_element->for_each_child([&parent](DOM::Node& child) {",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "st* element = static_cast<DOM::Element const*>(this);\n\n        if (is<HTML::HTMLScriptElement>(element) || is<HTML::HTMLStyleElement>(element))\n            return;\n\n        if (element->include_in_",
          "new_api": "iptElement>(element) || is<HTML::HTMLS",
          "old_text": "st* element = static_cast<DOM::Element const*>(this);\n\n        if (is<HTML::HTMLScriptElement>(element) || is<HTML::HTMLStyleElement>(element))\n            return;\n\n        if (element->include_in_",
          "new_text": "iptElement>(element) || is<HTML::HTMLS",
          "old_line_content": "                document_element->for_each_child([&parent](DOM::Node& child) {",
          "new_line_content": "                    child.build_accessibility_tree(parent);",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": "aut",
          "new_api": "Node::create(&document(), this);",
          "old_text": "         aut",
          "new_text": "Node::create(&document(), this);\n     ",
          "old_line_content": "    } else if (is_element()) {",
          "new_line_content": "        auto const* element = static_cast<DOM::Element const*>(this);",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": "(DOM::Node& child) {",
          "new_api": "return It",
          "old_text": "(DOM::Node& child) {\n                   ",
          "new_text": " return It",
          "old_line_content": "        if (element->include_in_accessibility_tree()) {",
          "new_line_content": "            auto current_node = AccessibilityTreeNode::create(&document(), this);",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "return It",
          "new_api": "inue;\n                });",
          "old_text": " return It",
          "new_text": "inue;\n                });\n       ",
          "old_line_content": "            auto current_node = AccessibilityTreeNode::create(&document(), this);",
          "new_line_content": "            parent.append_child(current_node);",
          "content_same": false
        },
        {
          "line": 2157,
          "old_api": "inue;\n                });",
          "new_api": "lse if (has_child",
          "old_text": "inue;\n                });\n       ",
          "new_text": "lse if (has_child",
          "old_line_content": "            parent.append_child(current_node);",
          "new_line_content": "            if (has_child_nodes()) {",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": "lse if (has_child",
          "new_api": "build_accessibility_tree",
          "old_text": "lse if (has_child",
          "new_text": "    for_each_child([&parent](DOM::Node& child) {\n                child.build_accessibility_tree(parent);\n                return IterationDecision::Continue;\n            });\n        }\n    } els",
          "old_line_content": "            if (has_child_nodes()) {",
          "new_line_content": "                for_each_child([&current_node](DOM::Node& child) {",
          "content_same": false
        },
        {
          "line": 2164,
          "old_api": "ppend_child",
          "new_api": "build_accessibility_tree",
          "old_text": "ppend_child(Acces",
          "new_text": "::create(&document(), this));\n        if (has_child_nodes()) {\n            for_each_child([&parent](DOM::Node& child) {\n                child.build_accessibility_tree(",
          "old_line_content": "        } else if (has_child_nodes()) {",
          "new_line_content": "            for_each_child([&parent](DOM::Node& child) {",
          "content_same": false
        },
        {
          "line": 2165,
          "old_api": "build_accessibility_tree",
          "new_api": "{\n            for_each_child([&parent]",
          "old_text": "::create(&document(), this));\n        if (has_child_nodes()) {\n            for_each_child([&parent](DOM::Node& child) {\n                child.build_accessibility_tree(",
          "new_text": "{\n            for_each_child([&parent]",
          "old_line_content": "            for_each_child([&parent](DOM::Node& child) {",
          "new_line_content": "                child.build_accessibility_tree(parent);",
          "content_same": false
        },
        {
          "line": 2170,
          "old_api": "turn Iter",
          "new_api": "https://ww",
          "old_text": "turn Iter",
          "new_text": "https://ww",
          "old_line_content": "    } else if (is_text()) {",
          "new_line_content": "        parent.append_child(AccessibilityTreeNode::create(&document(), this));",
          "content_same": false
        },
        {
          "line": 2171,
          "old_api": "https://ww",
          "new_api": "2/#mapping_additi",
          "old_text": "https://ww",
          "new_text": "2/#mapping_additi",
          "old_line_content": "        parent.append_child(AccessibilityTreeNode::create(&document(), this));",
          "new_line_content": "        if (has_child_nodes()) {",
          "content_same": false
        },
        {
          "line": 2172,
          "old_api": "2/#mapping_additi",
          "new_api": "Or<String> Node::name_or_description(NameOrDescription target, Document const& document, HashTable<i32>& visited_nodes) const\n{\n    // The text alternative for a given",
          "old_text": "2/#mapping_additi",
          "new_text": "Or<String> Node::name_or_description(NameOrDescription target, Document const& document, HashTable<i32>& visited_nodes) const\n{\n    // The text alternative for a given",
          "old_line_content": "        if (has_child_nodes()) {",
          "new_line_content": "            for_each_child([&parent](DOM::Node& child) {",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "Or<String> Node::name_or_description(NameOrDescription target, Document const& document, HashTable<i32>& visited_nodes) const\n{\n    // The text alternative for a given",
          "new_api": ", Document const& document, HashTable<",
          "old_text": "Or<String> Node::name_or_description(NameOrDescription target, Document const& document, HashTable<i32>& visited_nodes) const\n{\n    // The text alternative for a given",
          "new_text": ", Document const& document, HashTable<",
          "old_line_content": "            for_each_child([&parent](DOM::Node& child) {",
          "new_line_content": "                child.build_accessibility_tree(parent);",
          "content_same": false
        },
        {
          "line": 2191,
          "old_api": "cribedby, no",
          "new_api": "host language text alternative element",
          "old_text": "cribedby, no",
          "new_text": "host language text alternative element",
          "old_line_content": "    if (is_element()) {",
          "new_line_content": "        auto const* element = static_cast<DOM::Element const*>(this);",
          "content_same": false
        },
        {
          "line": 2203,
          "old_api": "get == NameOrDescription::D",
          "new_api": "_value",
          "old_text": "get == NameOrDescription::D",
          "new_text": "_value() && Node::first_vali",
          "old_line_content": "        auto aria_labelled_by = element->aria_labelled_by();",
          "new_line_content": "        auto aria_described_by = element->aria_described_by();",
          "content_same": false
        },
        {
          "line": 2204,
          "old_api": "_value",
          "new_api": "lated text to the empty string.\n            total_accumulated",
          "old_text": "_value() && Node::first_vali",
          "new_text": "lated text to the empty string.\n            total_accumulated",
          "old_line_content": "        auto aria_described_by = element->aria_described_by();",
          "new_line_content": "        if ((target == NameOrDescription::Name && aria_labelled_by.has_value() && Node::first_valid_id(*aria_labelled_by, document).has_value())",
          "content_same": false
        },
        {
          "line": 2205,
          "old_api": "lated text to the empty string.\n            total_accumulated",
          "new_api": "tion::Name) {\n                id_list = aria_labelled_by->byte",
          "old_text": "lated text to the empty string.\n            total_accumulated",
          "new_text": "tion::Name) {\n                id_list = aria_labelled_by->byte",
          "old_line_content": "        if ((target == NameOrDescription::Name && aria_labelled_by.has_value() && Node::first_valid_id(*aria_labelled_by, document).has_value())",
          "new_line_content": "            || (target == NameOrDescription::Description && aria_described_by.has_value() && Node::first_valid_id(*aria_described_by, document).has_value())) {",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "ed textual content associa",
          "new_api": "The CSS :be",
          "old_text": "ed textual content associa",
          "new_text": " The CSS :be",
          "old_line_content": "        auto role = element->role_or_default();",
          "new_line_content": "        if (role.has_value() && ARIA::allows_name_from_content(role.value())) {",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "extual content, without a space, to the textual content of the current node.",
          "new_api": "TRY(Node::prepend_without_space(total_accumulated_text, befor",
          "old_text": "extual content, without a space, to the textual content of the current node.",
          "new_text": "              TRY(Node::prepend_without_space(total_accumulated_text, befor",
          "old_line_content": "            auto before = element->get_pseudo_element_node(CSS::Selector::PseudoElement::Type::Before);",
          "new_line_content": "            auto after = element->get_pseudo_element_node(CSS::Selector::PseudoElement::Type::After);",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": "is_flow_inside",
          "new_api": "}",
          "old_text": "e_outside() && display.is_flow_inside()) {\n         ",
          "new_text": "                 }\n     ",
          "old_line_content": "                const_cast<DOM::Document&>(document).update_layout();",
          "new_line_content": "                auto const* layout_node = child_node.layout_node();",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": "ue_id",
          "new_api": "// a. Set the curren",
          "old_text": "ue_id()))\n            ",
          "new_text": "    // a. Set the curren",
          "old_line_content": "                    auto display = layout_node->display();",
          "new_line_content": "                    if (display.is_inline_outside() && display.is_flow_inside()) {",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": "a descend",
          "new_api": "e Name or Accessible Descript",
          "old_text": "a descend",
          "new_text": "e Name or Accessible Descript",
          "old_line_content": "    if (is_text()) {",
          "new_line_content": "        if (layout_node() && layout_node()->is_text_node())",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": "e Name or Accessible Descript",
          "new_api": "oceed to 2F.i",
          "old_text": "e Name or Accessible Descript",
          "new_text": "oceed to 2F.i",
          "old_line_content": "        if (layout_node() && layout_node()->is_text_node())",
          "new_line_content": "            return verify_cast<Layout::TextNode>(layout_node())->text_for_rendering();",
          "content_same": false
        },
        {
          "line": 2312,
          "old_api": "oceed to 2F.i",
          "new_api": "ode has a Tooltip attr",
          "old_text": "oceed to 2F.i",
          "new_text": "ode has a Tooltip attr",
          "old_line_content": "            return verify_cast<Layout::TextNode>(layout_node())->text_for_rendering();",
          "new_line_content": "        return text_content().value();",
          "content_same": false
        },
        {
          "line": 2322,
          "old_api": "// After all steps are co",
          "new_api": "t is used as the accessible name or accessi",
          "old_text": "  // After all steps are co",
          "new_text": "t is used as the accessible name or accessi",
          "old_line_content": "    if (is<HTML::HTMLElement>(this)) {",
          "new_line_content": "        auto const* element = static_cast<HTML::HTMLElement const*>(this);",
          "content_same": false
        },
        {
          "line": 2323,
          "old_api": "t is used as the accessible name or accessi",
          "new_api": "ement that initi",
          "old_text": "t is used as the accessible name or accessi",
          "new_text": "ement that initi",
          "old_line_content": "        auto const* element = static_cast<HTML::HTMLElement const*>(this);",
          "new_line_content": "        auto tooltip = element->title();",
          "content_same": false
        },
        {
          "line": 2324,
          "old_api": "ement that initi",
          "new_api": "_accumulated_text.t",
          "old_text": "ement that initi",
          "new_text": "_accumulated_text.t",
          "old_line_content": "        auto tooltip = element->title();",
          "new_line_content": "        if (tooltip.has_value() && !tooltip->is_empty())",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "_accumulated_text.t",
          "new_api": "ps://www.w3.org/TR/accn",
          "old_text": "_accumulated_text.t",
          "new_text": "ps://www.w3.org/TR/accn",
          "old_line_content": "        if (tooltip.has_value() && !tooltip->is_empty())",
          "new_line_content": "            return tooltip.release_value();",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": "split_view_if",
          "new_api": "for (auto const& id : id_lis",
          "old_text": "ring_view().split_view_if(Infra::",
          "new_text": "for (auto const& id : id_lis",
          "old_line_content": "    auto const* element = static_cast<Element const*>(this);",
          "new_line_content": "    auto described_by = element->aria_described_by();",
          "content_same": false
        },
        {
          "line": 2349,
          "old_api": "for (auto const& id : id_lis",
          "new_api": "if (auto description_e",
          "old_text": "for (auto const& id : id_lis",
          "new_text": "  if (auto description_e",
          "old_line_content": "    auto described_by = element->aria_described_by();",
          "new_line_content": "    if (!described_by.has_value())",
          "content_same": false
        },
        {
          "line": 2357,
          "old_api": "if (builder.is_empt",
          "new_api": "append",
          "old_text": "     if (builder.is_empt",
          "new_text": "pend(description);\n                } else {\n                    builder.append(\" \"sv);\n                    builder.append(description);\n   ",
          "old_line_content": "        if (auto description_element = document.get_element_by_id(MUST(FlyString::from_utf8(id)))) {",
          "new_line_content": "            auto description = TRY(",
          "content_same": false
        },
        {
          "line": 2361,
          "old_api": "}\n        }",
          "new_api": "o_string",
          "old_text": "        }\n        }\n  ",
          "new_text": "o_string();\n}\n\nOpt",
          "old_line_content": "            if (!description.is_empty()) {",
          "new_line_content": "                if (builder.is_empty()) {",
          "content_same": false
        },
        {
          "line": 2362,
          "old_api": "o_string",
          "new_api": "first_valid_id",
          "old_text": "o_string();\n}\n\nOpt",
          "new_text": "first_valid_id(StringView v",
          "old_line_content": "                if (builder.is_empty()) {",
          "new_line_content": "                    builder.append(description);",
          "content_same": false
        },
        {
          "line": 2365,
          "old_api": "ist = value.split_vie",
          "new_api": "hitespace);\n    for (auto c",
          "old_text": "ist = value.split_vie",
          "new_text": "hitespace);\n    for (auto c",
          "old_line_content": "                    builder.append(\" \"sv);",
          "new_line_content": "                    builder.append(description);",
          "content_same": false
        },
        {
          "line": 2397,
          "old_api": "{};\n}\n\n// h",
          "new_api": "g/TR/accname-1.2/#ma",
          "old_text": " {};\n}\n\n// h",
          "new_text": "g/TR/accname-1.2/#ma",
          "old_line_content": "    if (x.is_empty()) {",
          "new_line_content": "        TRY(x.try_append(result));",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": "opy the result to X",
          "new_api": "empty",
          "old_text": "opy the result to X",
          "new_text": "empty()) {\n        x",
          "old_line_content": "        TRY(x.try_append(\" \"sv));",
          "new_line_content": "        TRY(x.try_append(result));",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": "return {}",
          "new_api": "s://www.w3.org/T",
          "old_text": "   return {}",
          "new_text": "s://www.w3.org/T",
          "old_line_content": "    if (x.is_empty()) {",
          "new_line_content": "        x.append(result);",
          "content_same": false
        },
        {
          "line": 2415,
          "old_api": "const& resul",
          "new_api": "- If X i",
          "old_text": " const& resul",
          "new_text": " - If X i",
          "old_line_content": "        auto temp = TRY(x.to_string());",
          "new_line_content": "        x.clear();",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "- If X i",
          "new_api": "the result to X.",
          "old_text": " - If X i",
          "new_text": "the result to X.\n   ",
          "old_line_content": "        x.clear();",
          "new_line_content": "        TRY(x.try_append(result));",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "the result to X.",
          "new_api": "()) {\n        TRY(",
          "old_text": "the result to X.\n   ",
          "new_text": "()) {\n        TRY(",
          "old_line_content": "        TRY(x.try_append(result));",
          "new_line_content": "        TRY(x.try_append(temp));",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "TRY",
          "new_api": "\"sv));\n        TRY(x",
          "old_text": "\n        TRY",
          "new_text": "\"sv));\n        TRY(x",
          "old_line_content": "    if (x.is_empty()) {",
          "new_line_content": "        TRY(x.try_append(result));",
          "content_same": false
        },
        {
          "line": 2431,
          "old_api": "ered_observer",
          "new_api": "m_reg",
          "old_text": "ered_observer",
          "new_text": "    m_reg",
          "old_line_content": "        auto temp = TRY(x.to_string());",
          "new_line_content": "        x.clear();",
          "content_same": false
        },
        {
          "line": 2432,
          "old_api": "m_reg",
          "new_api": "er_list = make<Vecto",
          "old_text": "    m_reg",
          "new_text": "er_list = make<Vecto",
          "old_line_content": "        x.clear();",
          "new_line_content": "        TRY(x.try_append(result));",
          "content_same": false
        },
        {
          "line": 2433,
          "old_api": "er_list = make<Vecto",
          "new_api": "Ptr<RegisteredObser",
          "old_text": "er_list = make<Vecto",
          "new_text": "Ptr<RegisteredObser",
          "old_line_content": "        TRY(x.try_append(result));",
          "new_line_content": "        TRY(x.try_append(\" \"sv));",
          "content_same": false
        },
        {
          "line": 2434,
          "old_api": "Ptr<RegisteredObser",
          "new_api": "_registered_observ",
          "old_text": "Ptr<RegisteredObser",
          "new_text": "_registered_observ",
          "old_line_content": "        TRY(x.try_append(\" \"sv));",
          "new_line_content": "        TRY(x.try_append(temp));",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "VERIFY(ch",
          "old_text": null,
          "new_text": " VERIFY(ch",
          "old_line_content": "    node->m_parent = this;",
          "new_line_content": "    m_last_child = node.ptr();",
          "content_same": false
        },
        {
          "line": 2056,
          "old_api": null,
          "new_api": "ng = node;",
          "old_text": null,
          "new_text": "ng = node;",
          "old_line_content": "    if (!child)",
          "new_line_content": "        return append_child_impl(move(node));",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": null,
          "new_api": "(m_first_child == chil",
          "old_text": null,
          "new_text": " (m_first_child == chil",
          "old_line_content": "",
          "new_line_content": "    VERIFY(!node->m_parent);",
          "content_same": false
        },
        {
          "line": 2077,
          "old_api": null,
          "new_api": "ious_sibling = node-",
          "old_text": null,
          "new_text": "ious_sibling = node-",
          "old_line_content": "{",
          "new_line_content": "    VERIFY(node->m_parent.ptr() == this);",
          "content_same": false
        },
        {
          "line": 2098,
          "old_api": null,
          "new_api": "onst& other) const",
          "old_text": null,
          "new_text": "onst& other) const",
          "old_line_content": "{",
          "new_line_content": "    for (auto* ancestor = other.parent(); ancestor; ancestor = ancestor->parent()) {",
          "content_same": false
        },
        {
          "line": 2107,
          "old_api": null,
          "new_api": ".spec.whatwg.org/#con",
          "old_text": null,
          "new_text": ".spec.whatwg.org/#con",
          "old_line_content": "{",
          "new_line_content": "    return &other == this || is_ancestor_of(other);",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": null,
          "new_api": "// An object A is follo",
          "old_text": null,
          "new_text": "    // An object A is follo",
          "old_line_content": "{",
          "new_line_content": "    return other.is_ancestor_of(*this);",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": null,
          "new_api": "r.\n    for (auto* node = previous_in_",
          "old_text": null,
          "new_text": "r.\n    for (auto* node = previous_in_",
          "old_line_content": "{",
          "new_line_content": "    return other.is_inclusive_ancestor_of(*this);",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": null,
          "new_api": "ocument",
          "old_text": null,
          "new_text": "ocument()) {\n        auto* do",
          "old_line_content": "    // An object A is following an object B if A and B are in the same tree and A comes after B in tree order.",
          "new_line_content": "    for (auto* node = previous_in_pre_order(); node; node = node->previous_in_pre_order()) {",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": null,
          "new_api": "de_in_accessibility_tree",
          "old_text": null,
          "new_text": "de_in_accessibility_tree()) {\n    ",
          "old_line_content": "{",
          "new_line_content": "    if (is_uninteresting_whitespace_node())",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": null,
          "new_api": "cument_elemen",
          "old_text": null,
          "new_text": "cument_elemen",
          "old_line_content": "",
          "new_line_content": "    if (is_document()) {",
          "content_same": false
        },
        {
          "line": 2148,
          "old_api": null,
          "new_api": "aut",
          "old_text": null,
          "new_text": "         aut",
          "old_line_content": "        }",
          "new_line_content": "    } else if (is_element()) {",
          "content_same": false
        },
        {
          "line": 2151,
          "old_api": null,
          "new_api": "f (has_child_nodes()) {",
          "old_text": null,
          "new_text": "f (has_child_nodes()) {\n           ",
          "old_line_content": "",
          "new_line_content": "        if (is<HTML::HTMLScriptElement>(element) || is<HTML::HTMLStyleElement>(element))",
          "content_same": false
        },
        {
          "line": 2154,
          "old_api": null,
          "new_api": "(DOM::Node& child) {",
          "old_text": null,
          "new_text": "(DOM::Node& child) {\n                   ",
          "old_line_content": "",
          "new_line_content": "        if (element->include_in_accessibility_tree()) {",
          "content_same": false
        },
        {
          "line": 2163,
          "old_api": null,
          "new_api": "ppend_child",
          "old_text": null,
          "new_text": "ppend_child(Acces",
          "old_line_content": "            }",
          "new_line_content": "        } else if (has_child_nodes()) {",
          "content_same": false
        },
        {
          "line": 2169,
          "old_api": null,
          "new_api": "turn Iter",
          "old_text": null,
          "new_text": "turn Iter",
          "old_line_content": "        }",
          "new_line_content": "    } else if (is_text()) {",
          "content_same": false
        },
        {
          "line": 2188,
          "old_api": null,
          "new_api": "-labelledby",
          "old_text": null,
          "new_text": "-labelledby",
          "old_line_content": "    StringBuilder total_accumulated_text;",
          "new_line_content": "    visited_nodes.set(unique_id());",
          "content_same": false
        },
        {
          "line": 2190,
          "old_api": null,
          "new_api": "cribedby, no",
          "old_text": null,
          "new_text": "cribedby, no",
          "old_line_content": "",
          "new_line_content": "    if (is_element()) {",
          "content_same": false
        },
        {
          "line": 2195,
          "old_api": null,
          "new_api": "edby traversa",
          "old_text": null,
          "new_text": "edby traversa",
          "old_line_content": "        // FIXME: Check for references",
          "new_line_content": "        if (element->aria_hidden() == \"true\" || !layout_node())",
          "content_same": false
        },
        {
          "line": 2202,
          "old_api": null,
          "new_api": "get == NameOrDescription::D",
          "old_text": null,
          "new_text": "get == NameOrDescription::D",
          "old_line_content": "        //   process its IDREFs in the order they occur:",
          "new_line_content": "        auto aria_labelled_by = element->aria_labelled_by();",
          "content_same": false
        },
        {
          "line": 2208,
          "old_api": null,
          "new_api": "id_list = ari",
          "old_text": null,
          "new_text": "\n                id_list = ari",
          "old_line_content": "            // i. Set the accumulated text to the empty string.",
          "new_line_content": "            total_accumulated_text.clear();",
          "content_same": false
        },
        {
          "line": 2212,
          "old_api": null,
          "new_api": "h IDREF:\n            for (auto const& id_ref : id_list) {\n                auto nod",
          "old_text": null,
          "new_text": "h IDREF:\n            for (auto const& id_ref : id_list) {\n                auto nod",
          "old_line_content": "            if (target == NameOrDescription::Name) {",
          "new_line_content": "                id_list = aria_labelled_by->bytes_as_string_view().split_view_if(Infra::is_ascii_whitespace);",
          "content_same": false
        },
        {
          "line": 1700,
          "old_api": null,
          "new_api": "t_sibling",
          "old_text": null,
          "new_text": "t_sibling();\n",
          "old_line_content": "",
          "new_line_content": "    auto* this_child = first_child();",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": null,
          "new_api": "om_utf8",
          "old_text": null,
          "new_text": "om_utf8(id_ref)));\n                if (!node)\n                    continue;\n\n      ",
          "old_line_content": "            } else {",
          "new_line_content": "                id_list = aria_described_by->bytes_as_string_view().split_view_if(Infra::is_ascii_whitespace);",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "next_sibling",
          "old_text": null,
          "new_text": "r_child->next_sibling();\n",
          "old_line_content": "    // Each child of A equals the child of B at the identical index.",
          "new_line_content": "    auto* other_child = other_node->first_child();",
          "content_same": false
        },
        {
          "line": 1703,
          "old_api": null,
          "new_api": "://dom.spec.whatwg.",
          "old_text": null,
          "new_text": "://dom.spec.whatwg.",
          "old_line_content": "    for (size_t i = 0; i < this_child_count; ++i) {",
          "new_line_content": "        VERIFY(other_child);",
          "content_same": false
        },
        {
          "line": 2218,
          "old_api": null,
          "new_api": "IDREF.\n                curre",
          "old_text": null,
          "new_text": "IDREF.\n                curre",
          "old_line_content": "            for (auto const& id_ref : id_list) {",
          "new_line_content": "                auto node = document.get_element_by_id(MUST(FlyString::from_utf8(id_ref)));",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "p 2. Set the resu",
          "old_text": null,
          "new_text": "p 2. Set the resu",
          "old_line_content": "",
          "new_line_content": "                if (visited_nodes.contains(node->unique_id()))",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": null,
          "new_api": "urn the accumulated text.\n            return total_accumul",
          "old_text": null,
          "new_text": "urn the accumulated text.\n            return total_accumul",
          "old_line_content": "                // b. Compute the text alternative of the current node beginning with step 2. Set the result to that text alternative.",
          "new_line_content": "                auto result = TRY(node->name_or_description(target, document, visited_nodes));",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": "has an aria-label attribute whose value is not the empt",
          "old_text": null,
          "new_text": "has an aria-label attribute whose value is not the empt",
          "old_line_content": "                // c. Append the result, with a space, to the accumulated text.",
          "new_line_content": "                TRY(Node::append_with_space(total_accumulated_text, result));",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": null,
          "new_api": "et == NameOrDescription::Name && e",
          "old_text": null,
          "new_text": "et == NameOrDescription::Name && e",
          "old_line_content": "            // iii. Return the accumulated text.",
          "new_line_content": "            return total_accumulated_text.to_string();",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": null,
          "new_api": ".\n        if (pref",
          "old_text": null,
          "new_text": ".\n        if (pref",
          "old_line_content": "    // Element",
          "new_line_content": "    if (is<Element>(*this)) {",
          "content_same": false
        },
        {
          "line": 2235,
          "old_api": null,
          "new_api": "// - Otherwise, return the value of aria-label.",
          "old_text": null,
          "new_text": "   // - Otherwise, return the value of aria-label.\n          ",
          "old_line_content": "        // C. Otherwise, if computing a name, and if the current node has an aria-label attribute whose value is not the empty string, nor, when trimmed of white space, is not the empty string:",
          "new_line_content": "        if (target == NameOrDescription::Name && element->aria_label().has_value() && !element->aria_label()->is_empty() && !element->aria_label()->bytes_as_string_view().is_whitespace()) {",
          "content_same": false
        },
        {
          "line": 1723,
          "old_api": null,
          "new_api": "its namespace prefix is prefix,",
          "old_text": null,
          "new_text": "its namespace prefix is prefix,",
          "old_line_content": "        if (prefix == \"xml\")",
          "new_line_content": "            return Web::Namespace::XML.to_string();",
          "content_same": false
        },
        {
          "line": 2238,
          "old_api": null,
          "new_api": "of a flat string as defined",
          "old_text": null,
          "new_text": " of a flat string as defined ",
          "old_line_content": "            // - Otherwise, return the value of aria-label.",
          "new_line_content": "            return element->aria_label().value();",
          "content_same": false
        },
        {
          "line": 1727,
          "old_api": null,
          "new_api": "prefix",
          "old_text": null,
          "new_text": "() && element.prefix() == prefix)",
          "old_line_content": "        if (prefix == \"xmlns\")",
          "new_line_content": "            return Web::Namespace::XMLNS.to_string();",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": null,
          "new_api": "space, namespace prefix is",
          "old_text": null,
          "new_text": "space, namespace prefix is ",
          "old_line_content": "        // 3. If its namespace is non-null and its namespace prefix is prefix, then return namespace.",
          "new_line_content": "        auto& element = verify_cast<Element>(*this);",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "prefix",
          "old_text": null,
          "new_text": "r.prefix() == \"xmlns",
          "old_line_content": "        //    and local name is \"xmlns\", then return its value if it is not the empty string, and null otherwise.",
          "new_line_content": "        if (auto* attributes = element.attributes()) {",
          "content_same": false
        },
        {
          "line": 2254,
          "old_api": null,
          "new_api": "ed textual content associa",
          "old_text": null,
          "new_text": "ed textual content associa",
          "old_line_content": "        // F. Otherwise, if the current node's role allows name from content, or if the current node is referenced by aria-labelledby, aria-describedby, or is a native host language text alternative element (e.g. label in HTML), or is a descendant of a native host language text alternative element:",
          "new_line_content": "        auto role = element->role_or_default();",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": null,
          "new_api": "hat have a content model.",
          "old_text": null,
          "new_text": "hat have a content model.\n    ",
          "old_line_content": "            // i. Set the accumulated text to the empty string.",
          "new_line_content": "            total_accumulated_text.clear();",
          "content_same": false
        },
        {
          "line": 2259,
          "old_api": null,
          "new_api": "extual content, without a space, to the textual content of the current node.",
          "old_text": null,
          "new_text": "extual content, without a space, to the textual content of the current node.",
          "old_line_content": "            // ii. Check for CSS generated textual content associated with the current node and include it in the accumulated text. The CSS :before and :after pseudo elements [CSS2] can provide textual content for elements that have a content model.",
          "new_line_content": "            auto before = element->get_pseudo_element_node(CSS::Selector::PseudoElement::Type::Before);",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": null,
          "new_api": "out_space",
          "old_text": null,
          "new_text": "out_space(total_accumulated_text, a",
          "old_line_content": "            if (before)",
          "new_line_content": "                TRY(Node::prepend_without_space(total_accumulated_text, before->computed_values().content().data));",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": null,
          "new_api": "(prefix);\n    }\n\n    //",
          "old_text": null,
          "new_text": "(prefix);\n    }\n\n    // ",
          "old_line_content": "        // 5. If its parent element is null, then return null.",
          "new_line_content": "        auto* parent_element = element.parent_element();",
          "content_same": false
        },
        {
          "line": 2267,
          "old_api": null,
          "new_api": "DOM::Node const& child_node) muta",
          "old_text": null,
          "new_text": " DOM::Node const& child_node) muta",
          "old_line_content": "            if (after)",
          "new_line_content": "                TRY(Node::append_without_space(total_accumulated_text, after->computed_values().content().data));",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": null,
          "new_api": "update_layout",
          "old_text": null,
          "new_text": "              return IterationDecision::Continue;\n                bool should_add_space = true;\n                const_cast<DOM::Document&>(document).update_layout();\n                auto const* layout_node = child_node.layout_node();\n                if (layout_node) {\n                    auto display = layout_node->display();\n                    if (display.is_inline_outside() && display.is_flow_inside()) {\n                        should_add_space = false;\n                    }\n                }\n\n                if (visited_nodes.contains(child_node.unique_id()))\n                    return IterationDecision::Continue;\n\n                // a. Set the current node to the child node.\n                current_node = &child_node;\n\n                // b. Compute the text alternative of the current node beginning with step 2. Set the result to that text alternative.\n                auto result = MUST(current_node->name_or_description(target, document, visited_nodes));\n\n                // Append a space character and the result of each step above to the total accumulated text.\n                // AD-HOC: Doing the space-adding here is in a different order from what the spec states.\n                if (should_add_space)\n                    total_accumulated_text.append(' ');\n                // c. Append the result to the accumulated text.\n                total_accumulated_text.append(result);\n\n                return IterationDecision::Continue;\n            });\n            // iv. Return the accumulated text.\n            return total_accumulated_text.to_string();\n            // Important: Each node in the subtree is consulted only once. If text has been collected from a descendant, but is referenced by another I",
          "old_line_content": "            // iii. For each child node of the current node:",
          "new_line_content": "            element->for_each_child([&total_accumulated_text, current_node, target, &document, &visited_nodes](",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "ement",
          "old_text": null,
          "new_text": "ement();\n        if (!document_element)\n  ",
          "old_line_content": "        // 6. Return the result of running locate a namespace on its parent element using prefix.",
          "new_line_content": "        return parent_element->locate_a_namespace(prefix);",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": null,
          "new_api": "de",
          "old_text": null,
          "new_text": "de();\n              ",
          "old_line_content": "                                        DOM::Node const& child_node) mutable {",
          "new_line_content": "                if (!child_node.is_element() && !child_node.is_text())",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": null,
          "new_api": "2. Return the resul",
          "old_text": null,
          "new_text": "2. Return the resul",
          "old_line_content": "    // Document",
          "new_line_content": "    if (is<Document>(*this)) {",
          "content_same": false
        },
        {
          "line": 2275,
          "old_api": null,
          "new_api": "is_flow_inside",
          "old_text": null,
          "new_text": "e_outside() && display.is_flow_inside()) {\n         ",
          "old_line_content": "                bool should_add_space = true;",
          "new_line_content": "                const_cast<DOM::Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": null,
          "new_api": ">locate_a_namespace(prefix);\n    }\n\n    // Docu",
          "old_text": null,
          "new_text": ">locate_a_namespace(prefix);\n    }\n\n    // Docu",
          "old_line_content": "        // 1. If its document element is null, then return null.",
          "new_line_content": "        auto* document_element = verify_cast<Document>(*this).document_element();",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": null,
          "new_api": "ue_id",
          "old_text": null,
          "new_text": "ue_id()))\n            ",
          "old_line_content": "                if (layout_node) {",
          "new_line_content": "                    auto display = layout_node->display();",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": null,
          "new_api": "Attr>(*this)) {\n        // 1. If its element",
          "old_text": null,
          "new_text": "Attr>(*this)) {\n        // 1. If its element",
          "old_line_content": "        // 2. Return the result of running locate a namespace on its document element using prefix.",
          "new_line_content": "        return document_element->locate_a_namespace(prefix);",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": null,
          "new_api": "ode beginning with ste",
          "old_text": null,
          "new_text": "ode beginning with ste",
          "old_line_content": "",
          "new_line_content": "                if (visited_nodes.contains(child_node.unique_id()))",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": null,
          "new_api": "nt",
          "old_text": null,
          "new_text": "nt();\n        if (!element)",
          "old_line_content": "    // DocumentFragment",
          "new_line_content": "    if (is<DocumentType>(*this) || is<DocumentFragment>(*this)) {",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": null,
          "new_api": "r from what the spec states.\n                if (should_add_space)",
          "old_text": null,
          "new_text": "r from what the spec states.\n                if (should_add_space)",
          "old_line_content": "                // b. Compute the text alternative of the current node beginning with step 2. Set the result to that text alternative.",
          "new_line_content": "                auto result = MUST(current_node->name_or_description(target, document, visited_nodes));",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": null,
          "new_api": "a namespace on",
          "old_text": null,
          "new_text": " a namespace on",
          "old_line_content": "    // Attr",
          "new_line_content": "    if (is<Attr>(*this)) {",
          "content_same": false
        },
        {
          "line": 1782,
          "old_api": null,
          "new_api": "// Otherwise\n    // 1. If its pare",
          "old_text": null,
          "new_text": "\n\n    // Otherwise\n    // 1. If its pare",
          "old_line_content": "        // 1. If its element is null, then return null.",
          "new_line_content": "        auto* element = verify_cast<Attr>(*this).owner_element();",
          "content_same": false
        },
        {
          "line": 2296,
          "old_api": null,
          "new_api": "ccumulated text.\n            retur",
          "old_text": null,
          "new_text": "ccumulated text.\n            retur",
          "old_line_content": "                if (should_add_space)",
          "new_line_content": "                    total_accumulated_text.append(' ');",
          "content_same": false
        },
        {
          "line": 2298,
          "old_api": null,
          "new_api": "btree is consulted only once. If text",
          "old_text": null,
          "new_text": "btree is consulted only once. If text",
          "old_line_content": "                // c. Append the result to the accumulated text.",
          "new_line_content": "                total_accumulated_text.append(result);",
          "content_same": false
        },
        {
          "line": 1787,
          "old_api": null,
          "new_api": "result of running locate a namespa",
          "old_text": null,
          "new_text": " result of running locate a namespa",
          "old_line_content": "        // 2. Return the result of running locate a namespace on its element using prefix.",
          "new_line_content": "        return element->locate_a_namespace(prefix);",
          "content_same": false
        },
        {
          "line": 2303,
          "old_api": null,
          "new_api": "nce is not followed. This is done",
          "old_text": null,
          "new_text": "nce is not followed. This is done ",
          "old_line_content": "            // iv. Return the accumulated text.",
          "new_line_content": "            return total_accumulated_text.to_string();",
          "content_same": false
        },
        {
          "line": 1792,
          "old_api": null,
          "new_api": "spec.whatwg.org/#dom-n",
          "old_text": null,
          "new_text": "spec.whatwg.org/#dom-n",
          "old_line_content": "    // 1. If its parent element is null, then return null.",
          "new_line_content": "    auto* parent_element = this->parent_element();",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": null,
          "new_api": "a descend",
          "old_text": null,
          "new_text": "a descend",
          "old_line_content": "    // G. Text Node: Otherwise, if the current node is a Text Node, return its textual contents.",
          "new_line_content": "    if (is_text()) {",
          "content_same": false
        },
        {
          "line": 1797,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": " to null.\n    if (prefix.has_value() && pr",
          "old_line_content": "    // 2. Return the result of running locate a namespace on its parent element using prefix.",
          "new_line_content": "    return parent_element->locate_a_namespace(prefix);",
          "content_same": false
        },
        {
          "line": 1804,
          "old_api": null,
          "new_api": "Node::lookup_prefi",
          "old_text": null,
          "new_text": "Node::lookup_prefi",
          "old_line_content": "    // 1. If prefix is the empty string, then set it to null.",
          "new_line_content": "    if (prefix.has_value() && prefix->is_empty())",
          "content_same": false
        },
        {
          "line": 1808,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "(!namespace_.has_value() |",
          "old_line_content": "    // 2. Return the result of running locate a namespace for this using prefix.",
          "new_line_content": "    return locate_a_namespace(prefix);",
          "content_same": false
        },
        {
          "line": 2321,
          "old_api": null,
          "new_api": "// After all steps are co",
          "old_text": null,
          "new_text": "  // After all steps are co",
          "old_line_content": "    // FIXME: Support SVG tooltips and CSS tooltips",
          "new_line_content": "    if (is<HTML::HTMLElement>(this)) {",
          "content_same": false
        },
        {
          "line": 1815,
          "old_api": null,
          "new_api": "o& element = verify_ca",
          "old_text": null,
          "new_text": "o& element = verify_ca",
          "old_line_content": "    // 1. If namespace is null or the empty string, then return null.",
          "new_line_content": "    if (!namespace_.has_value() || namespace_->is_empty())",
          "content_same": false
        },
        {
          "line": 2328,
          "old_api": null,
          "new_api": "name using the rules outlined belo",
          "old_text": null,
          "new_text": "name using the rules outlined belo",
          "old_line_content": "    // After all steps are completed, the total accumulated text is used as the accessible name or accessible description of the element that initiated the computation.",
          "new_line_content": "    return total_accumulated_text.to_string();",
          "content_same": false
        },
        {
          "line": 1821,
          "old_api": null,
          "new_api": "ocument\n    if (is",
          "old_text": null,
          "new_text": "ocument\n    if (is",
          "old_line_content": "    // Element",
          "new_line_content": "    if (is<Element>(*this)) {",
          "content_same": false
        },
        {
          "line": 1823,
          "old_api": null,
          "new_api": "s document element is non-n",
          "old_text": null,
          "new_text": "s document element is non-n",
          "old_line_content": "        // Return the result of locating a namespace prefix for it using namespace.",
          "new_line_content": "        auto& element = verify_cast<Element>(*this);",
          "content_same": false
        },
        {
          "line": 2336,
          "old_api": null,
          "new_api": "resent, user agents MUST compute the accessible description by concat",
          "old_text": null,
          "new_text": "resent, user agents MUST compute the accessible description by concat",
          "old_line_content": "    // User agents MUST compute an accessible name using the rules outlined below in the section titled Accessible Name and Description Computation.",
          "new_line_content": "    return name_or_description(NameOrDescription::Name, document, visited_nodes);",
          "content_same": false
        },
        {
          "line": 1828,
          "old_api": null,
          "new_api": "ment",
          "old_text": null,
          "new_text": "ment();\n        if ",
          "old_line_content": "    // Document",
          "new_line_content": "    if (is<Document>(*this)) {",
          "content_same": false
        },
        {
          "line": 1830,
          "old_api": null,
          "new_api": "s<DocumentType>(*this) || is<DocumentFragment>(",
          "old_text": null,
          "new_text": "s<DocumentType>(*this) || is<DocumentFragment>(",
          "old_line_content": "        // Return the result of locating a namespace prefix for its document element, if its document element is non-null; otherwise null.",
          "new_line_content": "        auto* document_element = verify_cast<Document>(*this).document_element();",
          "content_same": false
        },
        {
          "line": 2344,
          "old_api": null,
          "new_api": "StringBuilde",
          "old_text": null,
          "new_text": "StringBuilde",
          "old_line_content": "    // The text alternatives for the referenced elements are computed using a number of methods, outlined below in the section titled Accessible Name and Description Computation.",
          "new_line_content": "    if (!is_element())",
          "content_same": false
        },
        {
          "line": 1834,
          "old_api": null,
          "new_api": "s<Attr>(*this)) {\n        // Return the result of locat",
          "old_text": null,
          "new_text": "s<Attr>(*this)) {\n        // Return the result of locat",
          "old_line_content": "",
          "new_line_content": "        return document_element->locate_a_namespace_prefix(namespace_);",
          "content_same": false
        },
        {
          "line": 2347,
          "old_api": null,
          "new_api": "split_view_if",
          "old_text": null,
          "new_text": "ring_view().split_view_if(Infra::",
          "old_line_content": "",
          "new_line_content": "    auto const* element = static_cast<Element const*>(this);",
          "content_same": false
        },
        {
          "line": 1839,
          "old_api": null,
          "new_api": "auto* element = verify_",
          "old_text": null,
          "new_text": "    auto* element = verify_",
          "old_line_content": "    // DocumentFragment",
          "new_line_content": "    if (is<DocumentType>(*this) || is<DocumentFragment>(*this))",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": null,
          "new_api": "name_or_description",
          "old_text": null,
          "new_text": "              description_element->name_or_description(NameOrDescription::Desc",
          "old_line_content": "    StringBuilder builder;",
          "new_line_content": "    auto id_list = described_by->bytes_as_string_view().split_view_if(Infra::is_ascii_whitespace);",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "if (builder.is_empt",
          "old_text": null,
          "new_text": "     if (builder.is_empt",
          "old_line_content": "    for (auto const& id : id_list) {",
          "new_line_content": "        if (auto description_element = document.get_element_by_id(MUST(FlyString::from_utf8(id)))) {",
          "content_same": false
        },
        {
          "line": 1844,
          "old_api": null,
          "new_api": "return {};",
          "old_text": null,
          "new_text": "    return {};\n",
          "old_line_content": "    // Attr",
          "new_line_content": "    if (is<Attr>(*this)) {",
          "content_same": false
        },
        {
          "line": 1846,
          "old_api": null,
          "new_api": "ts parent element, if its parent element",
          "old_text": null,
          "new_text": "ts parent element, if its parent element",
          "old_line_content": "        // Return the result of locating a namespace prefix for its element, if its element is non-null; otherwise null.",
          "new_line_content": "        auto* element = verify_cast<Attr>(*this).owner_element();",
          "content_same": false
        },
        {
          "line": 2360,
          "old_api": null,
          "new_api": "}\n        }",
          "old_text": null,
          "new_text": "        }\n        }\n  ",
          "old_line_content": "                    visited_nodes));",
          "new_line_content": "            if (!description.is_empty()) {",
          "content_same": false
        },
        {
          "line": 1850,
          "old_api": null,
          "new_api": "parent_element",
          "old_text": null,
          "new_text": "parent_element();\n    if (!parent_element)\n   ",
          "old_line_content": "",
          "new_line_content": "        return element->locate_a_namespace_prefix(namespace_);",
          "content_same": false
        },
        {
          "line": 2364,
          "old_api": null,
          "new_api": "ist = value.split_vie",
          "old_text": null,
          "new_text": "ist = value.split_vie",
          "old_line_content": "                } else {",
          "new_line_content": "                    builder.append(\" \"sv);",
          "content_same": false
        },
        {
          "line": 1855,
          "old_api": null,
          "new_api": "al<String> namespace_)",
          "old_text": null,
          "new_text": "al<String> namespace_)",
          "old_line_content": "    // Return the result of locating a namespace prefix for its parent element, if its parent element is non-null; otherwise null.",
          "new_line_content": "    auto* parent_element = this->parent_element();",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "MUST",
          "old_text": null,
          "new_text": "MUST(FlyString::fro",
          "old_line_content": "    }",
          "new_line_content": "    return builder.to_string();",
          "content_same": false
        },
        {
          "line": 1859,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "set it to null.\n    if (namespace_.has_value() && nam",
          "old_line_content": "",
          "new_line_content": "    return parent_element->locate_a_namespace_prefix(namespace_);",
          "content_same": false
        },
        {
          "line": 2375,
          "old_api": null,
          "new_api": "ional_nd_te\nErrorOr<void> Node::append_without_",
          "old_text": null,
          "new_text": "ional_nd_te\nErrorOr<void> Node::append_without_",
          "old_line_content": "{",
          "new_line_content": "    auto id_list = value.split_view_if(Infra::is_ascii_whitespace);",
          "content_same": false
        },
        {
          "line": 2377,
          "old_api": null,
          "new_api": "result to X.\n    // - I",
          "old_text": null,
          "new_text": " result to X.\n    // - I",
          "old_line_content": "    for (auto const& id : id_list) {",
          "new_line_content": "        if (document.get_element_by_id(MUST(FlyString::from_utf8(id))))",
          "content_same": false
        },
        {
          "line": 1866,
          "old_api": null,
          "new_api": "space is the same as n",
          "old_text": null,
          "new_text": "space is the same as n",
          "old_line_content": "    // 1. If namespace is the empty string, then set it to null.",
          "new_line_content": "    if (namespace_.has_value() && namespace_->is_empty())",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e() const\n{\n    // An ",
          "old_line_content": "    // 2. Let defaultNamespace be the result of running locate a namespace for this using null.",
          "new_line_content": "    auto default_namespace = locate_a_namespace({});",
          "content_same": false
        },
        {
          "line": 2388,
          "old_api": null,
          "new_api": "TRY(x.try_a",
          "old_text": null,
          "new_text": "\n        TRY(x.try_a",
          "old_line_content": "    // - If X is non-empty, copy the result to the end of X.",
          "new_line_content": "    TRY(x.try_append(result));",
          "content_same": false
        },
        {
          "line": 1880,
          "old_api": null,
          "new_api": "ding root if options",
          "old_text": null,
          "new_text": "ding root if options",
          "old_line_content": "    // An element is in a document tree if its root is a document.",
          "new_line_content": "    return root().is_document();",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": null,
          "new_api": "{};\n}\n\n// h",
          "old_text": null,
          "new_text": " {};\n}\n\n// h",
          "old_line_content": "    // - If X is empty, copy the result to X.",
          "new_line_content": "    if (x.is_empty()) {",
          "content_same": false
        },
        {
          "line": 2400,
          "old_api": null,
          "new_api": "opy the result to X",
          "old_text": null,
          "new_text": "opy the result to X",
          "old_line_content": "        // - If X is non-empty, add a space to the end of X and then copy the result to X after the space.",
          "new_line_content": "        TRY(x.try_append(\" \"sv));",
          "content_same": false
        },
        {
          "line": 1888,
          "old_api": null,
          "new_api": "t",
          "old_text": null,
          "new_text": "t()) {\n        auto con",
          "old_line_content": "    if (options.composed)",
          "new_line_content": "        return shadow_including_root();",
          "content_same": false
        },
        {
          "line": 1891,
          "old_api": null,
          "new_api": "(*this",
          "old_text": null,
          "new_text": "(*this",
          "old_line_content": "    // otherwise thiss root.",
          "new_line_content": "    return root();",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": null,
          "new_api": "lue",
          "old_text": null,
          "new_text": "lue());\n        for (auto const& class_name : element",
          "old_line_content": "    StringBuilder builder;",
          "new_line_content": "    builder.append(node_name().to_deprecated_fly_string().to_lowercase());",
          "content_same": false
        },
        {
          "line": 2410,
          "old_api": null,
          "new_api": "return {}",
          "old_text": null,
          "new_text": "   return {}",
          "old_line_content": "    // - If X is empty, copy the result to X.",
          "new_line_content": "    if (x.is_empty()) {",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": null,
          "new_api": "const& resul",
          "old_text": null,
          "new_text": " const& resul",
          "old_line_content": "        // - If X is non-empty, copy the result to the start of X.",
          "new_line_content": "        auto temp = TRY(x.to_string());",
          "content_same": false
        },
        {
          "line": 1905,
          "old_api": null,
          "new_api": "// 2. If node is a",
          "old_text": null,
          "new_text": " // 2. If node is a",
          "old_line_content": "    }",
          "new_line_content": "    return MUST(builder.to_string());",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": null,
          "new_api": "e number of no",
          "old_text": null,
          "new_text": "e number of no",
          "old_line_content": "    // 1. If node is a DocumentType or Attr node, then return 0.",
          "new_line_content": "    if (is_document_type() || is_attribute())",
          "content_same": false
        },
        {
          "line": 2426,
          "old_api": null,
          "new_api": "TRY",
          "old_text": null,
          "new_text": "\n        TRY",
          "old_line_content": "    // - If X is empty, copy the result to X.",
          "new_line_content": "    if (x.is_empty()) {",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": null,
          "new_api": "{\n    m_paintable",
          "old_text": null,
          "new_text": "\n{\n    m_paintable ",
          "old_line_content": "    // 2. If node is a CharacterData node, then return nodes datas length.",
          "new_line_content": "    if (is_character_data())",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "ered_observer",
          "old_text": null,
          "new_text": "ered_observer",
          "old_line_content": "        // - If X is non-empty, copy the result to the start of X, and add a space after the copy.",
          "new_line_content": "        auto temp = TRY(x.to_string());",
          "content_same": false
        },
        {
          "line": 1920,
          "old_api": null,
          "new_api": "turn m_painta",
          "old_text": null,
          "new_text": "turn m_painta",
          "old_line_content": "    // 3. Return the number of nodes children.",
          "new_line_content": "    return child_count();",
          "content_same": false
        },
        {
          "line": 2442,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "    if (!m_registered_observer_list)",
          "new_line_content": "        m_registered_observer_list = make<Vector<JS::NonnullGCPtr<RegisteredObserver>>>();",
          "content_same": false
        },
        {
          "line": 1940,
          "old_api": null,
          "new_api": "static_cast<Painting::Paintabl",
          "old_text": null,
          "new_text": " static_cast<Painting::Paintabl",
          "old_line_content": "{",
          "new_line_content": "    if (paintable() && paintable()->is_paintable_box())",
          "content_same": false
        },
        {
          "line": 1947,
          "old_api": null,
          "new_api": "String> const& attribute_name,",
          "old_text": null,
          "new_text": "String> const& attribute_name, ",
          "old_line_content": "{",
          "new_line_content": "    if (paintable() && paintable()->is_paintable_box())",
          "content_same": false
        },
        {
          "line": 1965,
          "old_api": null,
          "new_api": "registered_obs",
          "old_text": null,
          "new_text": "registered_obs",
          "old_line_content": "    // 3. For each node in nodes, and then for each registered of nodes registered observer list:",
          "new_line_content": "    for (auto* node = this; node; node = node->parent()) {",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": null,
          "new_api": "r is false\n            //",
          "old_text": null,
          "new_text": "r is false\n            //     ",
          "old_line_content": "            // 1. Let options be registereds options.",
          "new_line_content": "            auto& options = registered_observer->options();",
          "content_same": false
        },
        {
          "line": 1980,
          "old_api": null,
          "new_api": "&& !(type == Mutati",
          "old_text": null,
          "new_text": "       && !(type == Mutati",
          "old_line_content": "            if (!(node != this && !options.subtree)",
          "new_line_content": "                && !(type == MutationType::attributes && (!options.attributes.has_value() || !options.attributes.value()))",
          "content_same": false
        },
        {
          "line": 1985,
          "old_api": null,
          "new_api": "set",
          "old_text": null,
          "new_text": ".set(mutation_observer, {});\n\n ",
          "old_line_content": "                // 1. Let mo be registereds observer.",
          "new_line_content": "                auto mutation_observer = registered_observer->observer();",
          "content_same": false
        },
        {
          "line": 1988,
          "old_api": null,
          "new_api": "s[\"characterDataOldValue\"] is true, then set int",
          "old_text": null,
          "new_text": "s[\"characterDataOldValue\"] is true, then set int",
          "old_line_content": "                // 2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to null.",
          "new_line_content": "                if (!interested_observers.contains(mutation_observer))",
          "content_same": false
        },
        {
          "line": 1992,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "nterested_observers.is_empty())\n        ",
          "old_line_content": "                // 3. If either type is \"attributes\" and options[\"attributeOldValue\"] is true, or type is \"characterData\" and options[\"characterDataOldValue\"] is true, then set interestedObservers[mo] to oldValue.",
          "new_line_content": "                if ((type == MutationType::attributes && options.attribute_old_value.has_value() && options.attribute_old_value.value()) || (type == MutationType::characterData && options.character_data_old_value.has_value() && options.character_data_old_value.value()))",
          "content_same": false
        },
        {
          "line": 1999,
          "old_api": null,
          "new_api": "ldValue of interestedObservers:",
          "old_text": null,
          "new_text": "ldValue of interestedObservers:",
          "old_line_content": "    // OPTIMIZATION: If there are no interested observers, bail without doing any more work.",
          "new_line_content": "    if (interested_observers.is_empty())",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "The MutationReco",
          "old_text": null,
          "new_text": " The MutationReco",
          "old_line_content": "",
          "new_line_content": "    auto added_nodes_list = StaticNodeList::create(realm(), move(added_nodes));",
          "content_same": false
        },
        {
          "line": 2009,
          "old_api": null,
          "new_api": "ing",
          "old_text": null,
          "new_text": "ing();\n\n        // 1. Let ",
          "old_line_content": "        Optional<String> string_attribute_name;",
          "new_line_content": "        if (attribute_name.has_value())",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": null,
          "new_api": "set to namespace, oldValue set",
          "old_text": null,
          "new_text": " set to namespace, oldValue set",
          "old_line_content": "        Optional<String> string_attribute_namespace;",
          "new_line_content": "        if (attribute_namespace.has_value())",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": null,
          "new_api": "int",
          "old_text": null,
          "new_text": "    int",
          "old_line_content": "        //    addedNodes set to addedNodes, removedNodes set to removedNodes, previousSibling set to previousSibling, and nextSibling set to nextSibling.",
          "new_line_content": "        auto record = MutationRecord::create(realm(), type, *this, added_nodes_list, removed_nodes_list, previous_sibling, next_sibling, string_attribute_name, string_attribute_namespace, /* mappedOldValue */ interested_observer.value);",
          "content_same": false
        },
        {
          "line": 2020,
          "old_api": null,
          "new_api": "added_nodes",
          "old_text": null,
          "new_text": " added_nodes",
          "old_line_content": "        // 2. Enqueue record to observers record queue.",
          "new_line_content": "        interested_observer.key->enqueue_record({}, move(record));",
          "content_same": false
        },
        {
          "line": 2024,
          "old_api": null,
          "new_api": "either ad",
          "old_text": null,
          "new_text": " either ad",
          "old_line_content": "    // 5. Queue a mutation observer microtask.",
          "new_line_content": "    Bindings::queue_mutation_observer_microtask(document());",
          "content_same": false
        },
        {
          "line": 2031,
          "old_api": null,
          "new_api": "e",
          "old_text": null,
          "new_text": "e(removed_nodes), pr",
          "old_line_content": "    // 1. Assert: either addedNodes or removedNodes is not empty.",
          "new_line_content": "    VERIFY(added_nodes.size() > 0 || removed_nodes.size() > 0);",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": " = node.ptr();\n    ",
          "old_line_content": "    // 2. Queue a mutation record of \"childList\" for target with null, null, null, addedNodes, removedNodes, previousSibling, and nextSibling.",
          "new_line_content": "    queue_mutation_record(MutationType::childList, {}, {}, {}, move(added_nodes), move(removed_nodes), previous_sibling, next_sibling);",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": null,
          "new_api": "if (!m_first_child)",
          "old_text": null,
          "new_text": " if (!m_first_child)\n  ",
          "old_line_content": "{",
          "new_line_content": "    VERIFY(!node->m_parent);",
          "content_same": false
        },
        {
          "line": 2041,
          "old_api": null,
          "new_api": "t_child = m_last_child;",
          "old_text": null,
          "new_text": "t_child = m_last_child;",
          "old_line_content": "",
          "new_line_content": "    if (!is_child_allowed(*node))",
          "content_same": false
        },
        {
          "line": 2045,
          "old_api": null,
          "new_api": "hild)\n{",
          "old_text": null,
          "new_text": "hild)\n{\n  ",
          "old_line_content": "    if (m_last_child)",
          "new_line_content": "        m_last_child->m_next_sibling = node.ptr();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2049,
          "old_api": "VERIFY(ch",
          "new_api": null,
          "old_text": " VERIFY(ch",
          "new_text": null,
          "old_line_content": "    m_last_child = node.ptr();",
          "new_line_content": "    if (!m_first_child)",
          "content_same": false
        },
        {
          "line": 2057,
          "old_api": "ng = node;",
          "new_api": null,
          "old_text": "ng = node;",
          "new_text": null,
          "old_line_content": "        return append_child_impl(move(node));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "first_child = n",
          "new_api": null,
          "old_text": "first_child = n",
          "new_text": null,
          "old_line_content": "    VERIFY(child->parent() == this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "ious_sibling = node-",
          "new_api": null,
          "old_text": "ious_sibling = node-",
          "new_text": null,
          "old_line_content": "    VERIFY(node->m_parent.ptr() == this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": "onst& other) const",
          "new_api": null,
          "old_text": "onst& other) const",
          "new_text": null,
          "old_line_content": "    for (auto* ancestor = other.parent(); ancestor; ancestor = ancestor->parent()) {",
          "new_line_content": "        if (ancestor == this)",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": ".spec.whatwg.org/#con",
          "new_api": null,
          "old_text": ".spec.whatwg.org/#con",
          "new_text": null,
          "old_line_content": "    return &other == this || is_ancestor_of(other);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2113,
          "old_api": "// An object A is follo",
          "new_api": null,
          "old_text": "    // An object A is follo",
          "new_text": null,
          "old_line_content": "    return other.is_ancestor_of(*this);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2118,
          "old_api": "r.\n    for (auto* node = previous_in_",
          "new_api": null,
          "old_text": "r.\n    for (auto* node = previous_in_",
          "new_text": null,
          "old_line_content": "    return other.is_inclusive_ancestor_of(*this);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": "ocument",
          "new_api": null,
          "old_text": "ocument()) {\n        auto* do",
          "new_text": null,
          "old_line_content": "    for (auto* node = previous_in_pre_order(); node; node = node->previous_in_pre_order()) {",
          "new_line_content": "        if (node == &other)",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "de_in_accessibility_tree",
          "new_api": null,
          "old_text": "de_in_accessibility_tree()) {\n    ",
          "new_text": null,
          "old_line_content": "    if (is_uninteresting_whitespace_node())",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2145,
          "old_api": "iptElement>(element) || is<HTML::HTMLS",
          "new_api": null,
          "old_text": "iptElement>(element) || is<HTML::HTMLS",
          "new_text": null,
          "old_line_content": "                    child.build_accessibility_tree(parent);",
          "new_line_content": "                    return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 2150,
          "old_api": "Node::create(&document(), this);",
          "new_api": null,
          "old_text": "Node::create(&document(), this);\n     ",
          "new_text": null,
          "old_line_content": "        auto const* element = static_cast<DOM::Element const*>(this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2152,
          "old_api": "f (has_child_nodes()) {",
          "new_api": null,
          "old_text": "f (has_child_nodes()) {\n           ",
          "new_text": null,
          "old_line_content": "        if (is<HTML::HTMLScriptElement>(element) || is<HTML::HTMLStyleElement>(element))",
          "new_line_content": "            return;",
          "content_same": false
        },
        {
          "line": 2160,
          "old_api": "build_accessibility_tree",
          "new_api": null,
          "old_text": "build_accessibility_tree(parent);\n           ",
          "new_text": null,
          "old_line_content": "                    child.build_accessibility_tree(*current_node);",
          "new_line_content": "                    return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 2166,
          "old_api": "{\n            for_each_child([&parent]",
          "new_api": null,
          "old_text": "{\n            for_each_child([&parent]",
          "new_text": null,
          "old_line_content": "                child.build_accessibility_tree(parent);",
          "new_line_content": "                return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 2174,
          "old_api": ", Document const& document, HashTable<",
          "new_api": null,
          "old_text": ", Document const& document, HashTable<",
          "new_text": null,
          "old_line_content": "                child.build_accessibility_tree(parent);",
          "new_line_content": "                return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 2189,
          "old_api": "-labelledby",
          "new_api": null,
          "old_text": "-labelledby",
          "new_text": null,
          "old_line_content": "    visited_nodes.set(unique_id());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2192,
          "old_api": "host language text alternative element",
          "new_api": null,
          "old_text": "host language text alternative element",
          "new_text": null,
          "old_line_content": "        auto const* element = static_cast<DOM::Element const*>(this);",
          "new_line_content": "        // 2. Compute the text alternative for the current node:",
          "content_same": false
        },
        {
          "line": 2196,
          "old_api": "edby traversa",
          "new_api": null,
          "old_text": "edby traversa",
          "new_text": null,
          "old_line_content": "        if (element->aria_hidden() == \"true\" || !layout_node())",
          "new_line_content": "            return String {};",
          "content_same": false
        },
        {
          "line": 2206,
          "old_api": "tion::Name) {\n                id_list = aria_labelled_by->byte",
          "new_api": null,
          "old_text": "tion::Name) {\n                id_list = aria_labelled_by->byte",
          "new_text": null,
          "old_line_content": "            || (target == NameOrDescription::Description && aria_described_by.has_value() && Node::first_valid_id(*aria_described_by, document).has_value())) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "id_list = ari",
          "new_api": null,
          "old_text": "\n                id_list = ari",
          "new_text": null,
          "old_line_content": "            total_accumulated_text.clear();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1697,
          "old_api": "r (size_t i = 0; i < this",
          "new_api": null,
          "old_text": "r (size_t i = 0; i < this",
          "new_text": null,
          "old_line_content": "    size_t other_child_count = other_node->child_count();",
          "new_line_content": "        return false;",
          "content_same": false
        },
        {
          "line": 2213,
          "old_api": "h IDREF:\n            for (auto const& id_ref : id_list) {\n                auto nod",
          "new_api": null,
          "old_text": "h IDREF:\n            for (auto const& id_ref : id_list) {\n                auto nod",
          "new_text": null,
          "old_line_content": "                id_list = aria_labelled_by->bytes_as_string_view().split_view_if(Infra::is_ascii_whitespace);",
          "new_line_content": "            } else {",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "om_utf8",
          "new_api": null,
          "old_text": "om_utf8(id_ref)));\n                if (!node)\n                    continue;\n\n      ",
          "new_text": null,
          "old_line_content": "                id_list = aria_described_by->bytes_as_string_view().split_view_if(Infra::is_ascii_whitespace);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 1705,
          "old_api": "amespace\nOptional<String> Nod",
          "new_api": null,
          "old_text": "amespace\nOptional<String> Nod",
          "new_text": null,
          "old_line_content": "        auto* other_child = other_node->child_at_index(i);",
          "new_line_content": "            return false;",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "a_namespace",
          "new_api": null,
          "old_text": "a_namespace(Option",
          "new_text": null,
          "old_line_content": "        VERIFY(this_child);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2219,
          "old_api": "IDREF.\n                curre",
          "new_api": null,
          "old_text": "IDREF.\n                curre",
          "new_text": null,
          "old_line_content": "                auto node = document.get_element_by_id(MUST(FlyString::from_utf8(id_ref)));",
          "new_line_content": "                if (!node)",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": "p 2. Set the resu",
          "new_api": null,
          "old_text": "p 2. Set the resu",
          "new_text": null,
          "old_line_content": "                if (visited_nodes.contains(node->unique_id()))",
          "new_line_content": "                    continue;",
          "content_same": false
        },
        {
          "line": 2228,
          "old_api": "urn the accumulated text.\n            return total_accumul",
          "new_api": null,
          "old_text": "urn the accumulated text.\n            return total_accumul",
          "new_text": null,
          "old_line_content": "                auto result = TRY(node->name_or_description(target, document, visited_nodes));",
          "new_line_content": "                // c. Append the result, with a space, to the accumulated text.",
          "content_same": false
        },
        {
          "line": 2230,
          "old_api": "has an aria-label attribute whose value is not the empt",
          "new_api": null,
          "old_text": "has an aria-label attribute whose value is not the empt",
          "new_text": null,
          "old_line_content": "                TRY(Node::append_with_space(total_accumulated_text, result));",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2233,
          "old_api": "et == NameOrDescription::Name && e",
          "new_api": null,
          "old_text": "et == NameOrDescription::Name && e",
          "new_text": null,
          "old_line_content": "            return total_accumulated_text.to_string();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1721,
          "old_api": ".\n        if (pref",
          "new_api": null,
          "old_text": ".\n        if (pref",
          "new_text": null,
          "old_line_content": "    if (is<Element>(*this)) {",
          "new_line_content": "        // 1. If prefix is \"xml\", then return the XML namespace.",
          "content_same": false
        },
        {
          "line": 2236,
          "old_api": "// - Otherwise, return the value of aria-label.",
          "new_api": null,
          "old_text": "   // - Otherwise, return the value of aria-label.\n          ",
          "new_text": null,
          "old_line_content": "        if (target == NameOrDescription::Name && element->aria_label().has_value() && !element->aria_label()->is_empty() && !element->aria_label()->bytes_as_string_view().is_whitespace()) {",
          "new_line_content": "            // TODO: - If traversal of the current node is due to recursion and the current node is an embedded control as defined in step 2E, ignore aria-label and skip to rule 2E.",
          "content_same": false
        },
        {
          "line": 1724,
          "old_api": "its namespace prefix is prefix,",
          "new_api": null,
          "old_text": "its namespace prefix is prefix,",
          "new_text": null,
          "old_line_content": "            return Web::Namespace::XML.to_string();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": "of a flat string as defined",
          "new_api": null,
          "old_text": " of a flat string as defined ",
          "new_text": null,
          "old_line_content": "            return element->aria_label().value();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 1728,
          "old_api": "prefix",
          "new_api": null,
          "old_text": "() && element.prefix() == prefix)",
          "new_text": null,
          "old_line_content": "            return Web::Namespace::XMLNS.to_string();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "namespace is the XMLNS namespace, na",
          "new_api": null,
          "old_text": "namespace is the XMLNS namespace, na",
          "new_text": null,
          "old_line_content": "            return element.namespace_uri()->to_string();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2256,
          "old_api": "The CSS :be",
          "new_api": null,
          "old_text": " The CSS :be",
          "new_text": null,
          "old_line_content": "        if (role.has_value() && ARIA::allows_name_from_content(role.value())) {",
          "new_line_content": "            // i. Set the accumulated text to the empty string.",
          "content_same": false
        },
        {
          "line": 1744,
          "old_api": "* parent_element",
          "new_api": null,
          "old_text": "* parent_element",
          "new_text": null,
          "old_line_content": "                        if (!value.is_empty())",
          "new_line_content": "                            return value;",
          "content_same": false
        },
        {
          "line": 2258,
          "old_api": "hat have a content model.",
          "new_api": null,
          "old_text": "hat have a content model.\n    ",
          "new_text": null,
          "old_line_content": "            total_accumulated_text.clear();",
          "new_line_content": "            // ii. Check for CSS generated textual content associated with the current node and include it in the accumulated text. The CSS :before and :after pseudo elements [CSS2] can provide textual content for elements that have a content model.",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "TRY(Node::prepend_without_space(total_accumulated_text, befor",
          "new_api": null,
          "old_text": "              TRY(Node::prepend_without_space(total_accumulated_text, befor",
          "new_text": null,
          "old_line_content": "            auto after = element->get_pseudo_element_node(CSS::Selector::PseudoElement::Type::After);",
          "new_line_content": "            // - For :before pseudo elements, User agents MUST prepend CSS textual content, without a space, to the textual content of the current node.",
          "content_same": false
        },
        {
          "line": 2264,
          "old_api": "out_space",
          "new_api": null,
          "old_text": "out_space(total_accumulated_text, a",
          "new_text": null,
          "old_line_content": "                TRY(Node::prepend_without_space(total_accumulated_text, before->computed_values().content().data));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1755,
          "old_api": "(is<Document>(*this)) {",
          "new_api": null,
          "old_text": " (is<Document>(*this)) {",
          "new_text": null,
          "old_line_content": "        if (!element.parent_element())",
          "new_line_content": "            return {};",
          "content_same": false
        },
        {
          "line": 2268,
          "old_api": "DOM::Node const& child_node) muta",
          "new_api": null,
          "old_text": " DOM::Node const& child_node) muta",
          "new_text": null,
          "old_line_content": "                TRY(Node::append_without_space(total_accumulated_text, after->computed_values().content().data));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2271,
          "old_api": "update_layout",
          "new_api": null,
          "old_text": "              return IterationDecision::Continue;\n                bool should_add_space = true;\n                const_cast<DOM::Document&>(document).update_layout();\n                auto const* layout_node = child_node.layout_node();\n                if (layout_node) {\n                    auto display = layout_node->display();\n                    if (display.is_inline_outside() && display.is_flow_inside()) {\n                        should_add_space = false;\n                    }\n                }\n\n                if (visited_nodes.contains(child_node.unique_id()))\n                    return IterationDecision::Continue;\n\n                // a. Set the current node to the child node.\n                current_node = &child_node;\n\n                // b. Compute the text alternative of the current node beginning with step 2. Set the result to that text alternative.\n                auto result = MUST(current_node->name_or_description(target, document, visited_nodes));\n\n                // Append a space character and the result of each step above to the total accumulated text.\n                // AD-HOC: Doing the space-adding here is in a different order from what the spec states.\n                if (should_add_space)\n                    total_accumulated_text.append(' ');\n                // c. Append the result to the accumulated text.\n                total_accumulated_text.append(result);\n\n                return IterationDecision::Continue;\n            });\n            // iv. Return the accumulated text.\n            return total_accumulated_text.to_string();\n            // Important: Each node in the subtree is consulted only once. If text has been collected from a descendant, but is referenced by another I",
          "new_text": null,
          "old_line_content": "            element->for_each_child([&total_accumulated_text, current_node, target, &document, &visited_nodes](",
          "new_line_content": "                                        DOM::Node const& child_node) mutable {",
          "content_same": false
        },
        {
          "line": 1759,
          "old_api": "ement",
          "new_api": null,
          "old_text": "ement();\n        if (!document_element)\n  ",
          "new_text": null,
          "old_line_content": "        return parent_element->locate_a_namespace(prefix);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2273,
          "old_api": "de",
          "new_api": null,
          "old_text": "de();\n              ",
          "new_text": null,
          "old_line_content": "                if (!child_node.is_element() && !child_node.is_text())",
          "new_line_content": "                    return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": "2. Return the resul",
          "new_api": null,
          "old_text": "2. Return the resul",
          "new_text": null,
          "old_line_content": "    if (is<Document>(*this)) {",
          "new_line_content": "        // 1. If its document element is null, then return null.",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "}",
          "new_api": null,
          "old_text": "                 }\n     ",
          "new_text": null,
          "old_line_content": "                auto const* layout_node = child_node.layout_node();",
          "new_line_content": "                if (layout_node) {",
          "content_same": false
        },
        {
          "line": 1765,
          "old_api": ">locate_a_namespace(prefix);\n    }\n\n    // Docu",
          "new_api": null,
          "old_text": ">locate_a_namespace(prefix);\n    }\n\n    // Docu",
          "new_text": null,
          "old_line_content": "        auto* document_element = verify_cast<Document>(*this).document_element();",
          "new_line_content": "        if (!document_element)",
          "content_same": false
        },
        {
          "line": 2280,
          "old_api": "// a. Set the curren",
          "new_api": null,
          "old_text": "    // a. Set the curren",
          "new_text": null,
          "old_line_content": "                    if (display.is_inline_outside() && display.is_flow_inside()) {",
          "new_line_content": "                        should_add_space = false;",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": "Attr>(*this)) {\n        // 1. If its element",
          "new_api": null,
          "old_text": "Attr>(*this)) {\n        // 1. If its element",
          "new_text": null,
          "old_line_content": "        return document_element->locate_a_namespace(prefix);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": "ode beginning with ste",
          "new_api": null,
          "old_text": "ode beginning with ste",
          "new_text": null,
          "old_line_content": "                if (visited_nodes.contains(child_node.unique_id()))",
          "new_line_content": "                    return IterationDecision::Continue;",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": "nt",
          "new_api": null,
          "old_text": "nt();\n        if (!element)",
          "new_text": null,
          "old_line_content": "    if (is<DocumentType>(*this) || is<DocumentFragment>(*this)) {",
          "new_line_content": "        // Return null.",
          "content_same": false
        },
        {
          "line": 2292,
          "old_api": "r from what the spec states.\n                if (should_add_space)",
          "new_api": null,
          "old_text": "r from what the spec states.\n                if (should_add_space)",
          "new_text": null,
          "old_line_content": "                auto result = MUST(current_node->name_or_description(target, document, visited_nodes));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": "a namespace on",
          "new_api": null,
          "old_text": " a namespace on",
          "new_text": null,
          "old_line_content": "    if (is<Attr>(*this)) {",
          "new_line_content": "        // 1. If its element is null, then return null.",
          "content_same": false
        },
        {
          "line": 1783,
          "old_api": "// Otherwise\n    // 1. If its pare",
          "new_api": null,
          "old_text": "\n\n    // Otherwise\n    // 1. If its pare",
          "new_text": null,
          "old_line_content": "        auto* element = verify_cast<Attr>(*this).owner_element();",
          "new_line_content": "        if (!element)",
          "content_same": false
        },
        {
          "line": 2297,
          "old_api": "ccumulated text.\n            retur",
          "new_api": null,
          "old_text": "ccumulated text.\n            retur",
          "new_text": null,
          "old_line_content": "                    total_accumulated_text.append(' ');",
          "new_line_content": "                // c. Append the result to the accumulated text.",
          "content_same": false
        },
        {
          "line": 2299,
          "old_api": "btree is consulted only once. If text",
          "new_api": null,
          "old_text": "btree is consulted only once. If text",
          "new_text": null,
          "old_line_content": "                total_accumulated_text.append(result);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1788,
          "old_api": "result of running locate a namespa",
          "new_api": null,
          "old_text": " result of running locate a namespa",
          "new_text": null,
          "old_line_content": "        return element->locate_a_namespace(prefix);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2304,
          "old_api": "nce is not followed. This is done",
          "new_api": null,
          "old_text": "nce is not followed. This is done ",
          "new_text": null,
          "old_line_content": "            return total_accumulated_text.to_string();",
          "new_line_content": "            // Important: Each node in the subtree is consulted only once. If text has been collected from a descendant, but is referenced by another IDREF in some descendant node, then that second, or subsequent, reference is not followed. This is done to avoid infinite loops.",
          "content_same": false
        },
        {
          "line": 1793,
          "old_api": "spec.whatwg.org/#dom-n",
          "new_api": null,
          "old_text": "spec.whatwg.org/#dom-n",
          "new_text": null,
          "old_line_content": "    auto* parent_element = this->parent_element();",
          "new_line_content": "    if (!parent_element)",
          "content_same": false
        },
        {
          "line": 1798,
          "old_api": "has_value",
          "new_api": null,
          "old_text": " to null.\n    if (prefix.has_value() && pr",
          "new_text": null,
          "old_line_content": "    return parent_element->locate_a_namespace(prefix);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": "ode has a Tooltip attr",
          "new_api": null,
          "old_text": "ode has a Tooltip attr",
          "new_text": null,
          "old_line_content": "        return text_content().value();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1805,
          "old_api": "Node::lookup_prefi",
          "new_api": null,
          "old_text": "Node::lookup_prefi",
          "new_text": null,
          "old_line_content": "    if (prefix.has_value() && prefix->is_empty())",
          "new_line_content": "        prefix = {};",
          "content_same": false
        },
        {
          "line": 1809,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "(!namespace_.has_value() |",
          "new_text": null,
          "old_line_content": "    return locate_a_namespace(prefix);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2326,
          "old_api": "ps://www.w3.org/TR/accn",
          "new_api": null,
          "old_text": "ps://www.w3.org/TR/accn",
          "new_text": null,
          "old_line_content": "            return tooltip.release_value();",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1816,
          "old_api": "o& element = verify_ca",
          "new_api": null,
          "old_text": "o& element = verify_ca",
          "new_text": null,
          "old_line_content": "    if (!namespace_.has_value() || namespace_->is_empty())",
          "new_line_content": "        return {};",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": "name using the rules outlined belo",
          "new_api": null,
          "old_text": "name using the rules outlined belo",
          "new_text": null,
          "old_line_content": "    return total_accumulated_text.to_string();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1822,
          "old_api": "ocument\n    if (is",
          "new_api": null,
          "old_text": "ocument\n    if (is",
          "new_text": null,
          "old_line_content": "    if (is<Element>(*this)) {",
          "new_line_content": "        // Return the result of locating a namespace prefix for it using namespace.",
          "content_same": false
        },
        {
          "line": 2337,
          "old_api": "resent, user agents MUST compute the accessible description by concat",
          "new_api": null,
          "old_text": "resent, user agents MUST compute the accessible description by concat",
          "new_text": null,
          "old_line_content": "    return name_or_description(NameOrDescription::Name, document, visited_nodes);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1825,
          "old_api": "ll.\n        auto* document_element = verify_c",
          "new_api": null,
          "old_text": "ll.\n        auto* document_element = verify_c",
          "new_text": null,
          "old_line_content": "        return element.locate_a_namespace_prefix(namespace_);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1829,
          "old_api": "ment",
          "new_api": null,
          "old_text": "ment();\n        if ",
          "new_text": null,
          "old_line_content": "    if (is<Document>(*this)) {",
          "new_line_content": "        // Return the result of locating a namespace prefix for its document element, if its document element is non-null; otherwise null.",
          "content_same": false
        },
        {
          "line": 1831,
          "old_api": "s<DocumentType>(*this) || is<DocumentFragment>(",
          "new_api": null,
          "old_text": "s<DocumentType>(*this) || is<DocumentFragment>(",
          "new_text": null,
          "old_line_content": "        auto* document_element = verify_cast<Document>(*this).document_element();",
          "new_line_content": "        if (!document_element)",
          "content_same": false
        },
        {
          "line": 2345,
          "old_api": "StringBuilde",
          "new_api": null,
          "old_text": "StringBuilde",
          "new_text": null,
          "old_line_content": "    if (!is_element())",
          "new_line_content": "        return String {};",
          "content_same": false
        },
        {
          "line": 1835,
          "old_api": "s<Attr>(*this)) {\n        // Return the result of locat",
          "new_api": null,
          "old_text": "s<Attr>(*this)) {\n        // Return the result of locat",
          "new_text": null,
          "old_line_content": "        return document_element->locate_a_namespace_prefix(namespace_);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2350,
          "old_api": "if (auto description_e",
          "new_api": null,
          "old_text": "  if (auto description_e",
          "new_text": null,
          "old_line_content": "    if (!described_by.has_value())",
          "new_line_content": "        return String {};",
          "content_same": false
        },
        {
          "line": 1840,
          "old_api": "auto* element = verify_",
          "new_api": null,
          "old_text": "    auto* element = verify_",
          "new_text": null,
          "old_line_content": "    if (is<DocumentType>(*this) || is<DocumentFragment>(*this))",
          "new_line_content": "        // Return null",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": "name_or_description",
          "new_api": null,
          "old_text": "              description_element->name_or_description(NameOrDescription::Desc",
          "new_text": null,
          "old_line_content": "    auto id_list = described_by->bytes_as_string_view().split_view_if(Infra::is_ascii_whitespace);",
          "new_line_content": "    for (auto const& id : id_list) {",
          "content_same": false
        },
        {
          "line": 1845,
          "old_api": "return {};",
          "new_api": null,
          "old_text": "    return {};\n",
          "new_text": null,
          "old_line_content": "    if (is<Attr>(*this)) {",
          "new_line_content": "        // Return the result of locating a namespace prefix for its element, if its element is non-null; otherwise null.",
          "content_same": false
        },
        {
          "line": 2359,
          "old_api": "append",
          "new_api": null,
          "old_text": "              } else {\n                    builder.append(\" \"sv);\n                    builder.append(description);\n  ",
          "new_text": null,
          "old_line_content": "                description_element->name_or_description(NameOrDescription::Description, document,",
          "new_line_content": "                    visited_nodes));",
          "content_same": false
        },
        {
          "line": 1847,
          "old_api": "ts parent element, if its parent element",
          "new_api": null,
          "old_text": "ts parent element, if its parent element",
          "new_text": null,
          "old_line_content": "        auto* element = verify_cast<Attr>(*this).owner_element();",
          "new_line_content": "        if (!element)",
          "content_same": false
        },
        {
          "line": 2363,
          "old_api": "first_valid_id",
          "new_api": null,
          "old_text": "first_valid_id(StringView v",
          "new_text": null,
          "old_line_content": "                    builder.append(description);",
          "new_line_content": "                } else {",
          "content_same": false
        },
        {
          "line": 1851,
          "old_api": "parent_element",
          "new_api": null,
          "old_text": "parent_element();\n    if (!parent_element)\n   ",
          "new_text": null,
          "old_line_content": "        return element->locate_a_namespace_prefix(namespace_);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "hitespace);\n    for (auto c",
          "new_api": null,
          "old_text": "hitespace);\n    for (auto c",
          "new_text": null,
          "old_line_content": "                    builder.append(description);",
          "new_line_content": "                }",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "al<String> namespace_)",
          "new_api": null,
          "old_text": "al<String> namespace_)",
          "new_text": null,
          "old_line_content": "    auto* parent_element = this->parent_element();",
          "new_line_content": "    if (!parent_element)",
          "content_same": false
        },
        {
          "line": 2371,
          "old_api": "MUST",
          "new_api": null,
          "old_text": "MUST(FlyString::fro",
          "new_text": null,
          "old_line_content": "    return builder.to_string();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "set it to null.\n    if (namespace_.has_value() && nam",
          "new_text": null,
          "old_line_content": "    return parent_element->locate_a_namespace_prefix(namespace_);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2376,
          "old_api": "ional_nd_te\nErrorOr<void> Node::append_without_",
          "new_api": null,
          "old_text": "ional_nd_te\nErrorOr<void> Node::append_without_",
          "new_text": null,
          "old_line_content": "    auto id_list = value.split_view_if(Infra::is_ascii_whitespace);",
          "new_line_content": "    for (auto const& id : id_list) {",
          "content_same": false
        },
        {
          "line": 2378,
          "old_api": "result to X.\n    // - I",
          "new_api": null,
          "old_text": " result to X.\n    // - I",
          "new_text": null,
          "old_line_content": "        if (document.get_element_by_id(MUST(FlyString::from_utf8(id))))",
          "new_line_content": "            return id;",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": "space is the same as n",
          "new_api": null,
          "old_text": "space is the same as n",
          "new_text": null,
          "old_line_content": "    if (namespace_.has_value() && namespace_->is_empty())",
          "new_line_content": "        namespace_ = {};",
          "content_same": false
        },
        {
          "line": 1871,
          "old_api": "e",
          "new_api": null,
          "old_text": "e() const\n{\n    // An ",
          "new_text": null,
          "old_line_content": "    auto default_namespace = locate_a_namespace({});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2389,
          "old_api": "TRY(x.try_a",
          "new_api": null,
          "old_text": "\n        TRY(x.try_a",
          "new_text": null,
          "old_line_content": "    TRY(x.try_append(result));",
          "new_line_content": "    return {};",
          "content_same": false
        },
        {
          "line": 1881,
          "old_api": "ding root if options",
          "new_api": null,
          "old_text": "ding root if options",
          "new_text": null,
          "old_line_content": "    return root().is_document();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": "g/TR/accname-1.2/#ma",
          "new_api": null,
          "old_text": "g/TR/accname-1.2/#ma",
          "new_text": null,
          "old_line_content": "        TRY(x.try_append(result));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1889,
          "old_api": "t",
          "new_api": null,
          "old_text": "t()) {\n        auto con",
          "new_text": null,
          "old_line_content": "        return shadow_including_root();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "empty",
          "new_api": null,
          "old_text": "empty()) {\n        x",
          "new_text": null,
          "old_line_content": "        TRY(x.try_append(result));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1892,
          "old_api": "(*this",
          "new_api": null,
          "old_text": "(*this",
          "new_text": null,
          "old_line_content": "    return root();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "s://www.w3.org/T",
          "new_api": null,
          "old_text": "s://www.w3.org/T",
          "new_text": null,
          "old_line_content": "        x.append(result);",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "s_document_type",
          "new_api": null,
          "old_text": "s_document_type() || is_attribute()",
          "new_text": null,
          "old_line_content": "            builder.appendff(\".{}\", class_name);",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": "()) {\n        TRY(",
          "new_api": null,
          "old_text": "()) {\n        TRY(",
          "new_text": null,
          "old_line_content": "        TRY(x.try_append(temp));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": "// 2. If node is a",
          "new_api": null,
          "old_text": " // 2. If node is a",
          "new_text": null,
          "old_line_content": "    return MUST(builder.to_string());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": "e number of no",
          "new_api": null,
          "old_text": "e number of no",
          "new_text": null,
          "old_line_content": "    if (is_document_type() || is_attribute())",
          "new_line_content": "        return 0;",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": "\"sv));\n        TRY(x",
          "new_api": null,
          "old_text": "\"sv));\n        TRY(x",
          "new_text": null,
          "old_line_content": "        TRY(x.try_append(result));",
          "new_line_content": "    } else {",
          "content_same": false
        },
        {
          "line": 1918,
          "old_api": "ainting::Paintable const* Node::paintable() const\n{\n    return",
          "new_api": null,
          "old_text": "ainting::Paintable const* Node::paintable() const\n{\n    return",
          "new_text": null,
          "old_line_content": "        return verify_cast<CharacterData>(*this).length_in_utf16_code_units();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1921,
          "old_api": "turn m_painta",
          "new_api": null,
          "old_text": "turn m_painta",
          "new_text": null,
          "old_line_content": "    return child_count();",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": "_registered_observ",
          "new_api": null,
          "old_text": "_registered_observ",
          "new_text": null,
          "old_line_content": "        TRY(x.try_append(temp));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    m_registered_observer_list->append(registered_observer);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 1942,
          "old_api": "pec.whatwg.",
          "new_api": null,
          "old_text": "pec.whatwg.",
          "new_text": null,
          "old_line_content": "        return static_cast<Painting::PaintableBox const*>(paintable());",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 1949,
          "old_api": "al<String>",
          "new_api": null,
          "old_text": "al<String> ",
          "new_text": null,
          "old_line_content": "        return static_cast<Painting::PaintableBox*>(paintable());",
          "new_line_content": "    return nullptr;",
          "content_same": false
        },
        {
          "line": 1966,
          "old_api": "registered_obs",
          "new_api": null,
          "old_text": "registered_obs",
          "new_text": null,
          "old_line_content": "    for (auto* node = this; node; node = node->parent()) {",
          "new_line_content": "        if (!node->m_registered_observer_list)",
          "content_same": false
        },
        {
          "line": 1971,
          "old_api": "r is false\n            //",
          "new_api": null,
          "old_text": "r is false\n            //     ",
          "new_text": null,
          "old_line_content": "            auto& options = registered_observer->options();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": "// 2. If interestedOb",
          "new_api": null,
          "old_text": "         // 2. If interestedOb",
          "new_text": null,
          "old_line_content": "                && !(type == MutationType::characterData && (!options.character_data.has_value() || !options.character_data.value()))",
          "new_line_content": "                && !(type == MutationType::childList && !options.child_list)) {",
          "content_same": false
        },
        {
          "line": 1986,
          "old_api": "set",
          "new_api": null,
          "old_text": ".set(mutation_observer, {});\n\n ",
          "new_text": null,
          "old_line_content": "                auto mutation_observer = registered_observer->observer();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1990,
          "old_api": "o oldValue.\n                if ((type == Mutati",
          "new_api": null,
          "old_text": "o oldValue.\n                if ((type == Mutati",
          "new_text": null,
          "old_line_content": "                    interested_observers.set(mutation_observer, {});",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "_nodes_list = StaticNodeList::create(realm(), move(add",
          "new_api": null,
          "old_text": "_nodes_list = StaticNodeList::create(realm(), move(add",
          "new_text": null,
          "old_line_content": "                    interested_observers.set(mutation_observer, old_value);",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": "ldValue of interestedObservers:",
          "new_api": null,
          "old_text": "ldValue of interestedObservers:",
          "new_text": null,
          "old_line_content": "    if (interested_observers.is_empty())",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2004,
          "old_api": "nd namespace",
          "new_api": null,
          "old_text": "nd namespace\n      ",
          "new_text": null,
          "old_line_content": "    auto removed_nodes_list = StaticNodeList::create(realm(), move(removed_nodes));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "with its type set to type,",
          "new_api": null,
          "old_text": "with its type set to type, ",
          "new_text": null,
          "old_line_content": "            string_attribute_name = attribute_name->to_string();",
          "new_line_content": "        Optional<String> string_attribute_namespace;",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": "dNodes set to addedNodes, remove",
          "new_api": null,
          "old_text": "dNodes set to addedNodes, remove",
          "new_text": null,
          "old_line_content": "            string_attribute_name = attribute_namespace->to_string();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2018,
          "old_api": "int",
          "new_api": null,
          "old_text": "    int",
          "new_text": null,
          "old_line_content": "        auto record = MutationRecord::create(realm(), type, *this, added_nodes_list, removed_nodes_list, previous_sibling, next_sibling, string_attribute_name, string_attribute_namespace, /* mappedOldValue */ interested_observer.value);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2021,
          "old_api": "added_nodes",
          "new_api": null,
          "old_text": " added_nodes",
          "new_text": null,
          "old_line_content": "        interested_observer.key->enqueue_record({}, move(record));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2025,
          "old_api": "either ad",
          "new_api": null,
          "old_text": " either ad",
          "new_text": null,
          "old_line_content": "    Bindings::queue_mutation_observer_microtask(document());",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2032,
          "old_api": "e",
          "new_api": null,
          "old_text": "e(removed_nodes), pr",
          "new_text": null,
          "old_line_content": "    VERIFY(added_nodes.size() > 0 || removed_nodes.size() > 0);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2035,
          "old_api": "ptr",
          "new_api": null,
          "old_text": " = node.ptr();\n    ",
          "new_text": null,
          "old_line_content": "    queue_mutation_record(MutationType::childList, {}, {}, {}, move(added_nodes), move(removed_nodes), previous_sibling, next_sibling);",
          "new_line_content": "}",
          "content_same": false
        },
        {
          "line": 2040,
          "old_api": "if (!m_first_child)",
          "new_api": null,
          "old_text": " if (!m_first_child)\n  ",
          "new_text": null,
          "old_line_content": "    VERIFY(!node->m_parent);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2042,
          "old_api": "t_child = m_last_child;",
          "new_api": null,
          "old_text": "t_child = m_last_child;",
          "new_text": null,
          "old_line_content": "    if (!is_child_allowed(*node))",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "hild)\n{",
          "new_api": null,
          "old_text": "hild)\n{\n  ",
          "new_text": null,
          "old_line_content": "        m_last_child->m_next_sibling = node.ptr();",
          "new_line_content": "    node->m_previous_sibling = m_last_child;",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 82,
      "total_additions": 128,
      "total_deletions": 128,
      "total_api_changes": 338
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 12,
        "api_related_lines": 338,
        "non_api_lines": 2,
        "non_api_line_numbers": [
          1698,
          1702
        ]
      }
    },
    "api_calls_before": 1187,
    "api_calls_after": 1188,
    "diff_info": {
      "added_lines": 7,
      "removed_lines": 8,
      "total_diff_lines": 33
    }
  }
}