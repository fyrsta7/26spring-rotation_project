{
  "status": "completed",
  "commit_dir": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/ba6d3aaece45081ca70d7ef6e13f022e78eb6b16",
  "file_info": {
    "before_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/ba6d3aaece45081ca70d7ef6e13f022e78eb6b16/before.cpp",
    "after_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/ba6d3aaece45081ca70d7ef6e13f022e78eb6b16/after.cpp",
    "diff_file": "/home/zyw/llm_on_code/llm_on_code_optimization/knowledge_base/serenity/modified_file/ba6d3aaece45081ca70d7ef6e13f022e78eb6b16/diff.txt"
  },
  "semgrep_analysis": {
    "is_api_change": false,
    "api_changes": {
      "replacements": [
        {
          "line": 561,
          "old_api": "elector::PseudoElement::Type>(i);\n        auto pse",
          "new_api": "puted_css_values",
          "old_text": "elector::PseudoElement::Type>(i);\n        auto pse",
          "new_text": "puted_css_values(pseudo_element);\n        auto new",
          "old_line_content": "        auto pseudo_element = static_cast<CSS::Selector::PseudoElement::Type>(i);",
          "new_line_content": "        auto pseudo_element_style = pseudo_element_computed_css_values(pseudo_element);",
          "content_same": false
        },
        {
          "line": 562,
          "old_api": "puted_css_values",
          "new_api": "pute_pseudo_element_style_if_needed",
          "old_text": "puted_css_values(pseudo_element);\n        auto new",
          "new_text": "pute_pseudo_element_style_if_needed(*this, pseudo_element);\n\n        // TODO",
          "old_line_content": "        auto pseudo_element_style = pseudo_element_computed_css_values(pseudo_element);",
          "new_line_content": "        auto new_pseudo_element_style = style_computer.compute_pseudo_element_style_if_needed(*this, pseudo_element);",
          "content_same": false
        },
        {
          "line": 572,
          "old_api": "ement_style));\n        style_c",
          "new_api": "_ancestor",
          "old_text": "ement_style));\n        style_c",
          "new_text": "_ancestor(*this);\n    };\n\n    reco",
          "old_line_content": "        set_pseudo_element_computed_css_values(pseudo_element, move(new_pseudo_element_style));",
          "new_line_content": "        style_computer.pop_ancestor(*this);",
          "content_same": false
        },
        {
          "line": 576,
          "old_api": "ne",
          "new_api": "lement_style",
          "old_text": "ne())\n        return i",
          "new_text": "lement_style(CSS::Selector::PseudoElement::Type::After);\n\n    if (invalid",
          "old_line_content": "    if (invalidation.is_none())",
          "new_line_content": "    recompute_pseudo_element_style(CSS::Selector::PseudoElement::Type::After);",
          "content_same": false
        },
        {
          "line": 582,
          "old_api": "// If",
          "new_api": "ds_to_resolve_paint_only_properties",
          "old_text": "       // If ",
          "new_text": "ds_to_resolve_paint_only_properties();\n\n    if (!invali",
          "old_line_content": "    if (!invalidation.rebuild_layout_tree && layout_node()) {",
          "new_line_content": "        document().set_needs_to_resolve_paint_only_properties();",
          "content_same": false
        },
        {
          "line": 584,
          "old_api": "ly_style",
          "new_api": "// If",
          "old_text": "ly_style(*m_computed_css_values);\n        if (inva",
          "new_text": "       // If ",
          "old_line_content": "        layout_node()->apply_style(*m_computed_css_values);",
          "new_line_content": "    if (!invalidation.rebuild_layout_tree && layout_node()) {",
          "content_same": false
        },
        {
          "line": 586,
          "old_api": "eeds_display",
          "new_api": "ly_style",
          "old_text": "eeds_display();\n\n        // Do t",
          "new_text": "ly_style(*m_computed_css_values);\n        if (inva",
          "old_line_content": "            paintable()->set_needs_display();",
          "new_line_content": "        layout_node()->apply_style(*m_computed_css_values);",
          "content_same": false
        },
        {
          "line": 591,
          "old_api": "(pseudo_element_type);\n            if (",
          "new_api": ":Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {",
          "old_text": "(pseudo_element_type);\n            if (",
          "new_text": ":Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {\n         ",
          "old_line_content": "            auto pseudo_element = get_pseudo_element(pseudo_element_type);",
          "new_line_content": "        for (auto i = 0; i < to_underlying(CSS::Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {",
          "content_same": false
        },
        {
          "line": 592,
          "old_api": "_value",
          "new_api": "elector::PseudoElement::Type>(i);\n            auto",
          "old_text": "_value() || !pseudo_elemen",
          "new_text": "elector::PseudoElement::Type>(i);\n            auto",
          "old_line_content": "            if (!pseudo_element.has_value() || !pseudo_element->layout_node)",
          "new_line_content": "            auto pseudo_element_type = static_cast<CSS::Selector::PseudoElement::Type>(i);",
          "content_same": false
        },
        {
          "line": 601,
          "old_api": "aintable",
          "new_api": "ptr",
          "old_text": "aintable())\n                ",
          "new_text": "yout_node.ptr())) {\n             ",
          "old_line_content": "                if (invalidation.repaint && node_with_style->paintable())",
          "new_line_content": "            if (auto* node_with_style = dynamic_cast<Layout::NodeWithStyle*>(pseudo_element->layout_node.ptr())) {",
          "content_same": false
        },
        {
          "line": 602,
          "old_api": "set_needs_display",
          "new_api": "pply_style",
          "old_text": "aintable()->set_needs_display();\n            }\n  ",
          "new_text": "pply_style(*pseudo_element_style);\n                ",
          "old_line_content": "                    node_with_style->paintable()->set_needs_display();",
          "new_line_content": "                node_with_style->apply_style(*pseudo_element_style);",
          "content_same": false
        },
        {
          "line": 615,
          "old_api": ":last_property_id); ++i) {\n        a",
          "new_api": "es::create();\n\n    for (auto i",
          "old_text": ":last_property_id); ++i) {\n        a",
          "new_text": "es::create();\n\n    for (auto i",
          "old_line_content": "    for (auto i = to_underlying(CSS::first_property_id); i <= to_underlying(CSS::last_property_id); ++i) {",
          "new_line_content": "    auto properties = CSS::StyleProperties::create();",
          "content_same": false
        },
        {
          "line": 617,
          "old_api": "property",
          "new_api": ":last_property_id); ++i) {\n        a",
          "old_text": "tyle->property(property_id);\n        if (!may",
          "new_text": ":last_property_id); ++i) {\n        a",
          "old_line_content": "        auto maybe_value = element_computed_style->property(property_id);",
          "new_line_content": "    for (auto i = to_underlying(CSS::first_property_id); i <= to_underlying(CSS::last_property_id); ++i) {",
          "content_same": false
        },
        {
          "line": 620,
          "old_api": "e_value",
          "new_api": "lue",
          "old_text": "e_value().value);\n    }\n\n  ",
          "new_text": "lue())\n            cont",
          "old_line_content": "        properties->set_property(property_id, maybe_value.release_value().value);",
          "new_line_content": "        if (!maybe_value.has_value())",
          "content_same": false
        },
        {
          "line": 667,
          "old_api": "// 2",
          "new_api": "// 1. Let defi",
          "old_text": "        // 2",
          "new_text": "        // 1. Let defi",
          "old_line_content": "        auto definition = document().lookup_custom_element_definition(namespace_uri(), local_name(), m_is_value);",
          "new_line_content": "    if (HTML::is_valid_custom_element_name(local_name()) || m_is_value.has_value()) {",
          "content_same": false
        },
        {
          "line": 677,
          "old_api": "any of the f",
          "new_api": "1. Let currentS",
          "old_text": " any of the f",
          "new_text": " 1. Let currentS",
          "old_line_content": "        auto current_shadow_root = shadow_root();",
          "new_line_content": "    if (is_shadow_host()) {",
          "content_same": false
        },
        {
          "line": 762,
          "old_api": ";\n    }\n    return false;\n}\n\n// http",
          "new_api": "(SelectorEngine::matche",
          "old_text": ";\n    }\n    return false;\n}\n\n// http",
          "new_text": "(SelectorEngine::matche",
          "old_line_content": "        if (SelectorEngine::matches(s, {}, *this, nullptr, {}, static_cast<ParentNode const*>(this)))",
          "new_line_content": "    auto sel = maybe_selectors.value();",
          "content_same": false
        },
        {
          "line": 823,
          "old_api": "s changed, we have to r",
          "new_api": "connected",
          "old_text": "s changed, we have to r",
          "new_text": "connected()) {\n            // NOTE: S",
          "old_line_content": "        if (context->is_connected()) {",
          "new_line_content": "        context->set_needs_style_update(true);",
          "content_same": false
        },
        {
          "line": 825,
          "old_api": "turn {};\n}\n\n// https://html.spec.whatwg",
          "new_api": "s changed, we have to r",
          "old_text": "turn {};\n}\n\n// https://html.spec.whatwg",
          "new_text": "s changed, we have to r",
          "old_line_content": "            context->document().invalidate_layout();",
          "new_line_content": "        if (context->is_connected()) {",
          "content_same": false
        },
        {
          "line": 875,
          "old_api": "SSStyleDeclaration* Element::",
          "new_api": ">set_host(this);",
          "old_text": "SSStyleDeclaration* Element::",
          "new_text": ">set_host(this);\n",
          "old_line_content": "        m_shadow_root->set_host(this);",
          "new_line_content": "    m_shadow_root = move(shadow_root);",
          "content_same": false
        },
        {
          "line": 893,
          "old_api": "ebappapis.html#q",
          "new_api": "_name = qualifie",
          "old_text": "ebappapis.html#q",
          "new_text": "_name = qualifie",
          "old_line_content": "        m_html_uppercased_qualified_name = qualified_name();",
          "new_line_content": "        m_html_uppercased_qualified_name = MUST(Infra::to_ascii_uppercase(qualified_name()));",
          "content_same": false
        },
        {
          "line": 928,
          "old_api": "or_height = fa",
          "new_api": "if (r",
          "old_text": "or_height = fa",
          "new_text": "\n        if (r",
          "old_line_content": "        if (rect->width() != 0 && rect->height() != 0) {",
          "new_line_content": "    for (auto i = 0u; i < list->length(); ++i) {",
          "content_same": false
        },
        {
          "line": 940,
          "old_api": "if (r",
          "new_api": "x",
          "old_text": "\n        if (r",
          "new_text": "x(), first_re",
          "old_line_content": "    for (auto i = 1u; i < list->length(); ++i) {",
          "new_line_content": "    auto const* first_rect = list->item(0);",
          "content_same": false
        },
        {
          "line": 941,
          "old_api": "== 0)",
          "new_api": "; ++i) {\n        aut",
          "old_text": "== 0)\n       ",
          "new_text": "; ++i) {\n        aut",
          "old_line_content": "        auto const& rect = list->item(i);",
          "new_line_content": "    auto bounding_rect = Gfx::Rect { first_rect->x(), first_rect->y(), first_rect->width(), first_rect->height() };",
          "content_same": false
        },
        {
          "line": 942,
          "old_api": "= bounding_re",
          "new_api": "if (r",
          "old_text": " = bounding_re",
          "new_text": "\n        if (r",
          "old_line_content": "        if (rect->width() == 0 || rect->height() == 0)",
          "new_line_content": "    for (auto i = 1u; i < list->length(); ++i) {",
          "content_same": false
        },
        {
          "line": 944,
          "old_api": "alm",
          "new_api": "= bounding_re",
          "old_text": "alm(), boundin",
          "new_text": " = bounding_re",
          "old_line_content": "        bounding_rect = bounding_rect.united({ rect->x(), rect->y(), rect->width(), rect->height() });",
          "new_line_content": "        if (rect->width() == 0 || rect->height() == 0)",
          "content_same": false
        },
        {
          "line": 946,
          "old_api": "cssom-view/#dom-element-getcli",
          "new_api": "alm",
          "old_text": "cssom-view/#dom-element-getcli",
          "new_text": "alm(), boundin",
          "old_line_content": "    return Geometry::DOMRect::create(realm(), bounding_rect.to_type<float>());",
          "new_line_content": "        bounding_rect = bounding_rect.united({ rect->x(), rect->y(), rect->width(), rect->height() });",
          "content_same": false
        },
        {
          "line": 975,
          "old_api": "t_scroll_offset",
          "new_api": "igable",
          "old_text": "t_scroll_offset()",
          "new_text": "igable();\n",
          "old_line_content": "    VERIFY(navigable);",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 976,
          "old_api": "transforms are resolved before it",
          "new_api": "_offset = navigable->v",
          "old_text": " transforms are resolved before it ",
          "new_text": "_offset = navigable->v",
          "old_line_content": "    auto viewport_offset = navigable->viewport_scroll_offset();",
          "new_line_content": "    auto navigable = document().navigable();",
          "content_same": false
        },
        {
          "line": 985,
          "old_api": "ine_transform",
          "new_api": "intable_box",
          "old_text": "ine_transform(paintab",
          "new_text": "intable_box()) {\n",
          "old_line_content": "    if (auto const* paintable_box = this->paintable_box()) {",
          "new_line_content": "    auto const* paintable = this->paintable();",
          "content_same": false
        },
        {
          "line": 987,
          "old_api": "Gfx::extract_2d_affine_transform(con",
          "new_api": "ine_transform",
          "old_text": "Gfx::extract_2d_affine_transform(con",
          "new_text": "ine_transform(paintab",
          "old_line_content": "        for (auto const* containing_block = paintable->containing_block(); !containing_block->is_viewport(); containing_block = containing_block->containing_block()) {",
          "new_line_content": "    if (auto const* paintable_box = this->paintable_box()) {",
          "content_same": false
        },
        {
          "line": 988,
          "old_api": "translate_by",
          "new_api": "_block = paintable->contai",
          "old_text": "scroll_offset.translate_by(co",
          "new_text": "_block = paintable->contai",
          "old_line_content": "            transform = Gfx::extract_2d_affine_transform(containing_block->transform()).multiply(transform);",
          "new_line_content": "        transform = Gfx::extract_2d_affine_transform(paintable_box->transform());",
          "content_same": false
        },
        {
          "line": 989,
          "old_api": "lute_rect = paintable_box->absolu",
          "new_api": "Gfx::extract_2d_affine_transform(con",
          "old_text": "lute_rect = paintable_box->absolu",
          "new_text": "Gfx::extract_2d_affine_transform(con",
          "old_line_content": "            scroll_offset.translate_by(containing_block->scroll_offset());",
          "new_line_content": "        for (auto const* containing_block = paintable->containing_block(); !containing_block->is_viewport(); containing_block = containing_block->containing_block()) {",
          "content_same": false
        },
        {
          "line": 995,
          "old_api": "translated",
          "new_api": ".to_type",
          "old_text": "       .translated(-scroll_offset",
          "new_text": "                         .to_type",
          "old_line_content": "                                    .translated(paintable_box->transform_origin())",
          "new_line_content": "        auto transformed_rect = transform.map(absolute_rect.translated(-paintable_box->transform_origin()).to_type<float>())",
          "content_same": false
        },
        {
          "line": 1000,
          "old_api": "bounding_rect",
          "new_api": "is<Painting::InlinePaintable>(*p",
          "old_text": "   auto absolute_rect = inline_paintable.bounding_rect();",
          "new_text": " is<Painting::InlinePaintable>(*p",
          "old_line_content": "        auto const& inline_paintable = static_cast<Painting::InlinePaintable const&>(*paintable);",
          "new_line_content": "        rects.append(Geometry::DOMRect::create(realm(), transformed_rect.to_type<float>()));",
          "content_same": false
        },
        {
          "line": 1001,
          "old_api": "e_by",
          "new_api": "inline_paintable = static_cast<Painting:",
          "old_text": "e_by(-scroll_offset);\n        ab",
          "new_text": " inline_paintable = static_cast<Painting:",
          "old_line_content": "        auto absolute_rect = inline_paintable.bounding_rect();",
          "new_line_content": "    } else if (paintable && is<Painting::InlinePaintable>(*paintable)) {",
          "content_same": false
        },
        {
          "line": 1002,
          "old_api": "translate_by",
          "new_api": "bounding_rect",
          "old_text": "t.translate_by(-viewport_offset);\n        ",
          "new_text": "   auto absolute_rect = inline_paintable.bounding_rect();",
          "old_line_content": "        absolute_rect.translate_by(-scroll_offset);",
          "new_line_content": "        auto const& inline_paintable = static_cast<Painting::InlinePaintable const&>(*paintable);",
          "content_same": false
        },
        {
          "line": 1003,
          "old_api": "nd",
          "new_api": "e_by",
          "old_text": "nd(Geometry::DOMRect::create(realm(), transf",
          "new_text": "e_by(-scroll_offset);\n        ab",
          "old_line_content": "        absolute_rect.translate_by(-viewport_offset);",
          "new_line_content": "        auto absolute_rect = inline_paintable.bounding_rect();",
          "content_same": false
        },
        {
          "line": 1004,
          "old_api": "dbgln(\"FIXME: Failed to",
          "new_api": "translate_by",
          "old_text": "       dbgln(\"FIXME: Failed to",
          "new_text": "t.translate_by(-viewport_offset);\n        ",
          "old_line_content": "        rects.append(Geometry::DOMRect::create(realm(), transform.map(absolute_rect.to_type<float>())));",
          "new_line_content": "        absolute_rect.translate_by(-scroll_offset);",
          "content_same": false
        },
        {
          "line": 1006,
          "old_api": "reate",
          "new_api": "dbgln(\"FIXME: Failed to",
          "old_text": "reate(realm(), move",
          "new_text": "       dbgln(\"FIXME: Failed to",
          "old_line_content": "        dbgln(\"FIXME: Failed to get client rects for element ({})\", debug_description());",
          "new_line_content": "        rects.append(Geometry::DOMRect::create(realm(), transform.map(absolute_rect.to_type<float>())));",
          "content_same": false
        },
        {
          "line": 1053,
          "old_api": "ure that layout is up-to-date before lookin",
          "new_api": "this) && document().in_quir",
          "old_text": "ure that layout is up-to-date before lookin",
          "new_text": "this) && document().in_quir",
          "old_line_content": "        return document().viewport_rect().width().to_int();",
          "new_line_content": "    if ((is<HTML::HTMLHtmlElement>(*this) && !document().in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1078,
          "old_api": "that layout is up-to-date before looking at",
          "new_api": ") && document().in_quirks_m",
          "old_text": " that layout is up-to-date before looking at",
          "new_text": ") && document().in_quirks_m",
          "old_line_content": "        return document().viewport_rect().height().to_int();",
          "new_line_content": "    if ((is<HTML::HTMLHtmlElement>(*this) && !document().in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1104,
          "old_api": ");\n\n    if (m_na",
          "new_api": "with_id_was_adde",
          "old_text": ");\n\n    if (m_na",
          "new_text": "with_id_was_adde",
          "old_line_content": "    if (m_id.has_value())",
          "new_line_content": "    Base::inserted();",
          "content_same": false
        },
        {
          "line": 1107,
          "old_api": "this);\n}\n\nvoid Ele",
          "new_api": "ue",
          "old_text": "this);\n}\n\nvoid Ele",
          "new_text": "ue())\n        document().element_with_name_was_",
          "old_line_content": "    if (m_name.has_value())",
          "new_line_content": "        document().element_with_id_was_added({}, *this);",
          "content_same": false
        },
        {
          "line": 1115,
          "old_api": "is);\n\n    if (m_",
          "new_api": "element_with_id_was_remo",
          "old_text": "is);\n\n    if (m_",
          "new_text": "element_with_id_was_remo",
          "old_line_content": "    if (m_id.has_value())",
          "new_line_content": "    Base::removed_from(node);",
          "content_same": false
        },
        {
          "line": 1118,
          "old_api": "*this);\n}\n\nvoid E",
          "new_api": "alue",
          "old_text": " *this);\n}\n\nvoid E",
          "new_text": "alue())\n        document().element_with_name_was_",
          "old_line_content": "    if (m_name.has_value())",
          "new_line_content": "        document().element_with_id_was_removed({}, *this);",
          "content_same": false
        },
        {
          "line": 1174,
          "old_api": "-id\"sv, unique_id()));\n        MUST(ob",
          "new_api": "ing::formatted(\"::{}\", CSS:",
          "old_text": "-id\"sv, unique_id()));\n        MUST(ob",
          "new_text": "ing::formatted(\"::{}\", CSS:",
          "old_line_content": "        MUST(object.add(\"type\"sv, \"pseudo-element\"));",
          "new_line_content": "        auto object = MUST(children_array.add_object());",
          "content_same": false
        },
        {
          "line": 1175,
          "old_api": "MUST",
          "new_api": "add",
          "old_text": "MUST(object",
          "new_text": "ject.add(\"type\"sv, \"pseudo-element\"));\n        MUS",
          "old_line_content": "        MUST(object.add(\"parent-id\"sv, unique_id()));",
          "new_line_content": "        MUST(object.add(\"name\"sv, MUST(String::formatted(\"::{}\", CSS::Selector::PseudoElement::name(static_cast<CSS::Selector::PseudoElement::Type>(i))))));",
          "content_same": false
        },
        {
          "line": 1176,
          "old_api": "}\n\n// https://html.spec.whatwg.o",
          "new_api": "-id\"sv, unique_id()));\n        MUST(ob",
          "old_text": "\n}\n\n// https://html.spec.whatwg.o",
          "new_text": "-id\"sv, unique_id()));\n        MUST(ob",
          "old_line_content": "        MUST(object.add(\"pseudo-element\"sv, i));",
          "new_line_content": "        MUST(object.add(\"type\"sv, \"pseudo-element\"));",
          "content_same": false
        },
        {
          "line": 1177,
          "old_api": "eraction.html#d",
          "new_api": "MUST",
          "old_text": "eraction.html#d",
          "new_text": "MUST(object",
          "old_line_content": "        MUST(object.finish());",
          "new_line_content": "        MUST(object.add(\"parent-id\"sv, unique_id()));",
          "content_same": false
        },
        {
          "line": 1196,
          "old_api": "return maybe_table_index.v",
          "new_api": "has_value",
          "old_text": "   return maybe_table_index.v",
          "new_text": "e_index.has_value())\n        return default_tab_ind",
          "old_line_content": "    if (!maybe_table_index.has_value())",
          "new_line_content": "    auto maybe_table_index = Web::HTML::parse_integer(get_attribute_value(HTML::AttributeNames::tabindex));",
          "content_same": false
        },
        {
          "line": 1198,
          "old_api": "teraction.html#dom-tabind",
          "new_api": "return maybe_table_index.v",
          "old_text": "teraction.html#dom-tabind",
          "new_text": "   return maybe_table_index.v",
          "old_line_content": "    return maybe_table_index.value();",
          "new_line_content": "    if (!maybe_table_index.has_value())",
          "content_same": false
        },
        {
          "line": 1224,
          "old_api": "layout_node",
          "new_api": "t_node",
          "old_text": "           && parent()->layout_node()->computed_values(",
          "new_text": "t_node()->com",
          "old_line_content": "            && parent()->layout_node()->computed_values().overflow_x() != CSS::Overflow::Visible && parent()->layout_node()->computed_values().overflow_x() != CSS::Overflow::Clip",
          "new_line_content": "    return layout_node()",
          "content_same": false
        },
        {
          "line": 1225,
          "old_api": "computed_values",
          "new_api": "overflow_x",
          "old_text": "        && (layout_node()->computed_values().overflow_x",
          "new_text": ").overflow_x() != CSS::",
          "old_line_content": "            && parent()->layout_node()->computed_values().overflow_y() != CSS::Overflow::Visible && parent()->layout_node()->computed_values().overflow_y() != CSS::Overflow::Clip)",
          "new_line_content": "        && (parent()->layout_node()",
          "content_same": false
        },
        {
          "line": 1226,
          "old_api": "computed_values",
          "new_api": "layout_node",
          "old_text": " && layout_node()->computed_values().overflow",
          "new_text": "           && parent()->layout_node()->computed_values(",
          "old_line_content": "        && (layout_node()->computed_values().overflow_x() != CSS::Overflow::Visible && layout_node()->computed_values().overflow_x() != CSS::Overflow::Clip",
          "new_line_content": "            && parent()->layout_node()->computed_values().overflow_x() != CSS::Overflow::Visible && parent()->layout_node()->computed_values().overflow_x() != CSS::Overflow::Clip",
          "content_same": false
        },
        {
          "line": 1227,
          "old_api": "ps://drafts.csswg.org/cssom-view/#dom-element",
          "new_api": "computed_values",
          "old_text": "ps://drafts.csswg.org/cssom-view/#dom-element",
          "new_text": "        && (layout_node()->computed_values().overflow_x",
          "old_line_content": "            && layout_node()->computed_values().overflow_y() != CSS::Overflow::Visible && layout_node()->computed_values().overflow_y() != CSS::Overflow::Clip);",
          "new_line_content": "            && parent()->layout_node()->computed_values().overflow_y() != CSS::Overflow::Visible && parent()->layout_node()->computed_values().overflow_y() != CSS::Overflow::Clip)",
          "content_same": false
        },
        {
          "line": 1365,
          "old_api": "{\n    // 1. Let y be the given value.\n\n    // 2.",
          "new_api": "paintable_box()->set_scroll_",
          "old_text": "\n{\n    // 1. Let y be the given value.\n\n    // 2.",
          "new_text": "    paintable_box()->set_scroll_",
          "old_line_content": "    paintable_box()->set_scroll_offset(scroll_offset);",
          "new_line_content": "    auto scroll_offset = paintable_box()->scroll_offset();",
          "content_same": false
        },
        {
          "line": 1421,
          "old_api": "m-element-scrollwidth\nint Element::scroll_width()",
          "new_api": "paintable_box",
          "old_text": "m-element-scrollwidth\nint Element::scroll_width()",
          "new_text": "paintable_box()->set_scroll_offs",
          "old_line_content": "    paintable_box()->set_scroll_offset(scroll_offset);",
          "new_line_content": "    auto scroll_offset = paintable_box()->scroll_offset();",
          "content_same": false
        },
        {
          "line": 1506,
          "old_api": "optgroup element that has a di",
          "new_api": "FormAssociatedElement const*>(this)",
          "old_text": " optgroup element that has a di",
          "new_text": "FormAssociatedElement const*>(this)",
          "old_line_content": "        VERIFY(form_associated_element);",
          "new_line_content": "    if (is<HTML::HTMLButtonElement>(this) || is<HTML::HTMLInputElement>(this) || is<HTML::HTMLSelectElement>(this) || is<HTML::HTMLTextAreaElement>(this)) {",
          "content_same": false
        },
        {
          "line": 1508,
          "old_api": "if (is<HTML::HTMLOptGroupElement",
          "new_api": "optgroup element that has a di",
          "old_text": "  if (is<HTML::HTMLOptGroupElement",
          "new_text": " optgroup element that has a di",
          "old_line_content": "        return !form_associated_element->enabled();",
          "new_line_content": "        VERIFY(form_associated_element);",
          "content_same": false
        },
        {
          "line": 1600,
          "old_api": "MException.",
          "new_api": "parent",
          "old_text": "MException.\n  ",
          "new_text": "rent.\n        context = this->parent();\n\n        // 2. If cont",
          "old_line_content": "        context = this->parent();",
          "new_line_content": "        || Infra::is_ascii_case_insensitive_match(position, \"afterend\"sv)) {",
          "content_same": false
        },
        {
          "line": 1625,
          "old_api": "namespace_uri",
          "new_api": "&& static_cast<Elem",
          "old_text": ">(*context).namespace_uri() == Namespace::HTML)) {",
          "new_text": "  && static_cast<Elem",
          "old_line_content": "            && static_cast<Element const&>(*context).local_name() == \"html\"sv",
          "new_line_content": "    if (!is<Element>(*context)",
          "content_same": false
        },
        {
          "line": 1626,
          "old_api": "e_element",
          "new_api": "local_name",
          "old_text": "e_element(document(), HTML::TagNames::body, Namespace",
          "new_text": "context).local_name() == \"html\"sv\n ",
          "old_line_content": "            && static_cast<Element const&>(*context).namespace_uri() == Namespace::HTML)) {",
          "new_line_content": "        || (context->document().document_type() == Document::Type::HTML",
          "content_same": false
        },
        {
          "line": 1627,
          "old_api": "king the f",
          "new_api": "namespace_uri",
          "old_text": "king the f",
          "new_text": ">(*context).namespace_uri() == Namespace::HTML)) {",
          "old_line_content": "        context = TRY(create_element(document(), HTML::TagNames::body, Namespace::HTML));",
          "new_line_content": "            && static_cast<Element const&>(*context).local_name() == \"html\"sv",
          "content_same": false
        },
        {
          "line": 1638,
          "old_api": "for the string \"afterbegin\"\n    else if",
          "new_api": "insert_before",
          "old_text": "for the string \"afterbegin\"\n    else if",
          "new_text": "s's parent before this.\n        parent()->insert_before(fragment,",
          "old_line_content": "        parent()->insert_before(fragment, this);",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(position, \"beforebegin\"sv)) {",
          "content_same": false
        },
        {
          "line": 1644,
          "old_api": "\"\n    else if",
          "new_api": "before its first child.\n        insert_before(fragment, first_c",
          "old_text": "\"\n    else if",
          "new_text": " before its first child.\n        insert_before(fragment, first_c",
          "old_line_content": "        insert_before(fragment, first_child());",
          "new_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"afterbegin\"sv)) {",
          "content_same": false
        },
        {
          "line": 1650,
          "old_api": "afterend\"\n    else if",
          "new_api": "TRY(append_child(fragment));\n    }\n\n    // - If position",
          "old_text": "afterend\"\n    else if ",
          "new_text": "       TRY(append_child(fragment));\n    }\n\n    // - If position",
          "old_line_content": "        TRY(append_child(fragment));",
          "new_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"beforeend\"sv)) {",
          "content_same": false
        },
        {
          "line": 1656,
          "old_api": "onOr<JS::GCPtr",
          "new_api": "parent before this's next sibling.\n        parent()->insert_b",
          "old_text": "onOr<JS::GCPtr",
          "new_text": " parent before this's next sibling.\n        parent()->insert_b",
          "old_line_content": "        parent()->insert_before(fragment, next_sibling());",
          "new_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"afterend\"sv)) {",
          "content_same": false
        },
        {
          "line": 1735,
          "old_api": "nt",
          "new_api": "parent",
          "old_text": "nt()) {\n          ",
          "new_text": " = ancestor->parent();\n    }\n\n    for (auto& scrolla",
          "old_line_content": "        ancestor = ancestor->parent();",
          "new_line_content": "        if (ancestor->paintable_box() && ancestor->paintable_box()->has_scrollable_overflow())",
          "content_same": false
        },
        {
          "line": 1858,
          "old_api": "null otherwise.\n            // FIXME: 3. Pe",
          "new_api": "atic_cast<DOM::Document&>(scr",
          "old_text": " null otherwise.\n            // FIXME: 3. Pe",
          "new_text": "atic_cast<DOM::Document&>(scr",
          "old_line_content": "            auto& document = static_cast<DOM::Document&>(scrollable_node);",
          "new_line_content": "        if (scrollable_node.is_document()) {",
          "content_same": false
        },
        {
          "line": 1895,
          "old_api": "ollIntoViewOptions>().block;",
          "new_api": "rollIntoViewOptions>().behavior;",
          "old_text": "ollIntoViewOptions>().block;\n\n   ",
          "new_text": "rollIntoViewOptions>().behavior;\n",
          "old_line_content": "        behavior = arg->get<ScrollIntoViewOptions>().behavior;",
          "new_line_content": "    if (arg.has_value() && arg->has<ScrollIntoViewOptions>()) {",
          "content_same": false
        },
        {
          "line": 1911,
          "old_api": "Y",
          "new_api": "roll the element into view",
          "old_text": "Y(scroll_an_element_into_view(*this, behavior, block, inli",
          "new_text": "roll the element into view",
          "old_line_content": "        return Error::from_string_view(\"Element has no associated box\"sv);",
          "new_line_content": "    document().update_layout();",
          "content_same": false
        },
        {
          "line": 2000,
          "old_api": "eturn.\n        if (reactions_stack.processing_the_",
          "new_api": "append",
          "old_text": "eturn.\n        if (reactions_stack.processing_the_",
          "new_text": "backup_element_queue.append(*this);\n\n        /",
          "old_line_content": "        reactions_stack.backup_element_queue.append(*this);",
          "new_line_content": "    if (reactions_stack.element_queue_stack.is_empty()) {",
          "content_same": false
        },
        {
          "line": 2013,
          "old_api": "om element reactions in reac",
          "new_api": "Bindings::WebEngineCu",
          "old_text": "om element reactions in reac",
          "new_text": "Bindings::WebEngineCu",
          "old_line_content": "            auto* custom_data = verify_cast<Bindings::WebEngineCustomData>(relevant_agent.custom_data());",
          "new_line_content": "        HTML::queue_a_microtask(&document(), JS::create_heap_function(relevant_agent.heap(), [this]() {",
          "content_same": false
        },
        {
          "line": 2060,
          "old_api": "s observed attributes does not c",
          "new_api": "attribute_name = att",
          "old_text": "s observed attributes does not c",
          "new_text": "attribute_name = att",
          "old_line_content": "        VERIFY(attribute_name_value.is_string());",
          "new_line_content": "        VERIFY(!arguments.is_empty());",
          "content_same": false
        },
        {
          "line": 2061,
          "old_api": ".\n        if (!definition->observed_attributes",
          "new_api": "g",
          "old_text": ".\n        if (!definition->observed_attributes",
          "new_text": "g();\n\n        // ",
          "old_line_content": "        auto attribute_name = attribute_name_value.as_string().utf8_string();",
          "new_line_content": "        auto& attribute_name_value = arguments.first();",
          "content_same": false
        },
        {
          "line": 2095,
          "old_api": "ribute->local_nam",
          "new_api": "JS::MarkedVect",
          "old_text": "ribute->local_nam",
          "new_text": "        JS::MarkedVect",
          "old_line_content": "        VERIFY(attribute);",
          "new_line_content": "    for (size_t attribute_index = 0; attribute_index < m_attributes->length(); ++attribute_index) {",
          "content_same": false
        },
        {
          "line": 2097,
          "old_api": "argu",
          "new_api": "ribute->local_nam",
          "old_text": "     argu",
          "new_text": "ribute->local_nam",
          "old_line_content": "        JS::MarkedVector<JS::Value> arguments { vm.heap() };",
          "new_line_content": "        VERIFY(attribute);",
          "content_same": false
        },
        {
          "line": 2099,
          "old_api": ")));\n        arguments.",
          "new_api": "argu",
          "old_text": ")));\n        arguments.",
          "new_text": "     argu",
          "old_line_content": "        arguments.append(JS::PrimitiveString::create(vm, attribute->local_name()));",
          "new_line_content": "        JS::MarkedVector<JS::Value> arguments { vm.heap() };",
          "content_same": false
        },
        {
          "line": 2101,
          "old_api": "value",
          "new_api": ")));\n        arguments.",
          "old_text": "ri().value()) : JS",
          "new_text": ")));\n        arguments.",
          "old_line_content": "        arguments.append(JS::PrimitiveString::create(vm, attribute->value()));",
          "new_line_content": "        arguments.append(JS::PrimitiveString::create(vm, attribute->local_name()));",
          "content_same": false
        },
        {
          "line": 2102,
          "old_api": "));\n    }",
          "new_api": "ri",
          "old_text": "));\n    }\n\n  ",
          "new_text": "ri().has_valu",
          "old_line_content": "        arguments.append(attribute->namespace_uri().has_value() ? JS::PrimitiveString::create(vm, attribute->namespace_uri().value()) : JS::js_null());",
          "new_line_content": "        arguments.append(JS::js_null());",
          "content_same": false
        },
        {
          "line": 2104,
          "old_api": "ctedCallback\",",
          "new_api": "));\n    }",
          "old_text": "ctedCallback\", ",
          "new_text": "));\n    }\n\n  ",
          "old_line_content": "        enqueue_a_custom_element_callback_reaction(HTML::CustomElementReactionNames::attributeChangedCallback, move(arguments));",
          "new_line_content": "        arguments.append(attribute->namespace_uri().has_value() ? JS::PrimitiveString::create(vm, attribute->namespace_uri().value()) : JS::js_null());",
          "content_same": false
        },
        {
          "line": 2110,
          "old_api": "append",
          "new_api": "CustomElementR",
          "old_text": "n_stack().append(JS::",
          "new_text": "CustomElementR",
          "old_line_content": "        enqueue_a_custom_element_callback_reaction(HTML::CustomElementReactionNames::connectedCallback, move(empty_arguments));",
          "new_line_content": "    if (is_connected()) {",
          "content_same": false
        },
        {
          "line": 2131,
          "old_api": "(!JS::same_value(construct_result, this))",
          "new_api": "release_value",
          "old_text": "(!JS::same_value(construct_result, this))",
          "new_text": "nal.release_value();\n\n        ",
          "old_line_content": "        auto construct_result = construct_result_optional.release_value();",
          "new_line_content": "        auto construct_result_optional = TRY(WebIDL::construct(constructor));",
          "content_same": false
        },
        {
          "line": 2293,
          "old_api": "{\n    // 1. If invoked",
          "new_api": "https://drafts.csswg.org/c",
          "old_text": "{\n    // 1. If invoked",
          "new_text": "https://drafts.csswg.org/c",
          "old_line_content": "    return ensure_pseudo_element(pseudo_element.value()).custom_properties;",
          "new_line_content": "    if (!pseudo_element.has_value())",
          "content_same": false
        },
        {
          "line": 2353,
          "old_api": "void Element::scroll(HTML::Scr",
          "new_api": "paintable_box()->set_scroll_",
          "old_text": "\nvoid Element::scroll(HTML::Scr",
          "new_text": "    paintable_box()->set_scroll_",
          "old_line_content": "    scroll_offset.set_y(CSSPixels::nearest_value_for(y));",
          "new_line_content": "    auto scroll_offset = paintable_box()->scroll_offset();",
          "content_same": false
        },
        {
          "line": 2354,
          "old_api": "tions options)\n{\n    // 1. If invoked with one ar",
          "new_api": "// https://drafts.csswg.org/css",
          "old_text": "tions options)\n{\n    // 1. If invoked with one ar",
          "new_text": "// https://drafts.csswg.org/css",
          "old_line_content": "    paintable_box()->set_scroll_offset(scroll_offset);",
          "new_line_content": "    scroll_offset.set_x(CSSPixels::nearest_value_for(x));",
          "content_same": false
        },
        {
          "line": 2368,
          "old_api": "converted to",
          "new_api": "://drafts.css",
          "old_text": "converted to",
          "new_text": "://drafts.css",
          "old_line_content": "    scroll(x, y);",
          "new_line_content": "    auto x = options.left.has_value() ? HTML::normalize_non_finite_values(options.left.value()) : scroll_left();",
          "content_same": false
        },
        {
          "line": 2478,
          "old_api": "org/multipage/dom.ht",
          "new_api": "r::IntersectionObserverRegistration const&",
          "old_text": "org/multipage/dom.ht",
          "new_text": "r::IntersectionObserverRegistration const& ",
          "old_line_content": "        return entry.observer.ptr() == &observer;",
          "new_line_content": "    VERIFY(m_registered_intersection_observers);",
          "content_same": false
        },
        {
          "line": 2480,
          "old_api": "ctionality Element::directiona",
          "new_api": "org/multipage/dom.ht",
          "old_text": "ctionality Element::directiona",
          "new_text": "org/multipage/dom.ht",
          "old_line_content": "    VERIFY(!registration_iterator.is_end());",
          "new_line_content": "        return entry.observer.ptr() == &observer;",
          "content_same": false
        },
        {
          "line": 2491,
          "old_api": ":Ltr;\n        // -> rtl",
          "new_api": ":",
          "old_text": ":Ltr;\n        // -> rtl\n ",
          "new_text": ":\n         ",
          "old_line_content": "        auto dir = maybe_dir.release_value();",
          "new_line_content": "    auto maybe_dir = this->dir();",
          "content_same": false
        },
        {
          "line": 2548,
          "old_api": "alue",
          "new_api": "o bidirectional_class_R = Unicode::bidirectiona",
          "old_text": "alue())\n        return Directionality::Ltr;\n\n  ",
          "new_text": "o bidirectional_class_R = Unicode::bidirectiona",
          "old_line_content": "    static auto bidirectional_class_R = Unicode::bidirectional_class_from_string(\"R\"sv);",
          "new_line_content": "    static auto bidirectional_class_L = Unicode::bidirectional_class_from_string(\"L\"sv);",
          "content_same": false
        },
        {
          "line": 2561,
          "old_api": "ss;\n                break;\n            }\n        }\n        if (!found_character_bidi_class.has_va",
          "new_api": "ss_L, bidirectio",
          "old_text": "ss;\n                break;\n            }\n        }\n        if (!found_character_bidi_class.has_va",
          "new_text": "ss_L, bidirectio",
          "old_line_content": "            if (first_is_one_of(bidi_class, bidirectional_class_L, bidirectional_class_AL, bidirectional_class_R)) {",
          "new_line_content": "        for (auto code_point : Utf8View(text_node.data())) {",
          "content_same": false
        },
        {
          "line": 2582,
          "old_api": "idirectional character type AL",
          "new_api": "VERIFY(form_associated_element);",
          "old_text": "idirectional character type AL ",
          "new_text": "        VERIFY(form_associated_element);\n       ",
          "old_line_content": "        VERIFY(form_associated_element);",
          "new_line_content": "    if (is_auto_directionality_form_associated_element()) {",
          "content_same": false
        },
        {
          "line": 2583,
          "old_api": "is no character of bidirectional",
          "new_api": "e",
          "old_text": "is no character of bidirectional",
          "new_text": "e();\n\n        // 1. If element's value contains a char",
          "old_line_content": "        auto const& value = form_associated_element->value();",
          "new_line_content": "        auto const* form_associated_element = dynamic_cast<HTML::FormAssociatedElement const*>(this);",
          "content_same": false
        },
        {
          "line": 2606,
          "old_api": "_nodes",
          "new_api": "assigned_nodes",
          "old_text": "_nodes()) {\n                // 1",
          "new_text": "& !slot.assigned_nodes().is_emp",
          "old_line_content": "        if (slot.root().is_shadow_root() && !slot.assigned_nodes().is_empty()) {",
          "new_line_content": "    if (is<HTML::HTMLSlotElement>(this)) {",
          "content_same": false
        },
        {
          "line": 2608,
          "old_api": ". If child is a Text",
          "new_api": "_nodes",
          "old_text": ". If child is a Text ",
          "new_text": "_nodes()) {\n                // 1",
          "old_line_content": "            for (auto const& child : slot.assigned_nodes()) {",
          "new_line_content": "        if (slot.root().is_shadow_root() && !slot.assigned_nodes().is_empty()) {",
          "content_same": false
        },
        {
          "line": 2647,
          "old_api": "return TraversalDecision::SkipChildr",
          "new_api": "|| (is<Element>(descendant) &&",
          "old_text": "     return TraversalDecision::SkipChildr",
          "new_text": "         || (is<Element>(descendant) &&",
          "old_line_content": "            || is<HTML::HTMLTextAreaElement>(descendant)",
          "new_line_content": "        if (is<HTML::HTMLScriptElement>(descendant)",
          "content_same": false
        },
        {
          "line": 2648,
          "old_api": "escendant is a slot element whose root is a shadow root,",
          "new_api": "dir",
          "old_text": "escendant is a slot element whose root is a shadow root, ",
          "new_text": "ment const&>(descendant).dir().has_val",
          "old_line_content": "            || (is<Element>(descendant) && static_cast<Element const&>(descendant).dir().has_value())) {",
          "new_line_content": "            || is<HTML::HTMLStyleElement>(descendant)",
          "content_same": false
        },
        {
          "line": 2655,
          "old_api": "ult = host->direction",
          "new_api": "is_shadow_root",
          "old_text": "ult = host->direction",
          "new_text": ".is_shadow_root()) {\n                ",
          "old_line_content": "            if (root.is_shadow_root()) {",
          "new_line_content": "        if (is<HTML::HTMLSlotElement>(descendant)) {",
          "content_same": false
        },
        {
          "line": 2656,
          "old_api": "alDecision::Break;\n            }\n        }",
          "new_api": "host",
          "old_text": "alDecision::Break;\n            }\n        }\n",
          "new_text": "owRoot const&>(root).host();\n                VERIFY(host);\n ",
          "old_line_content": "                auto const& host = static_cast<ShadowRoot const&>(root).host();",
          "new_line_content": "            auto const& root = static_cast<HTML::HTMLSlotElement const&>(descendant).root();",
          "content_same": false
        },
        {
          "line": 2657,
          "old_api": "descendant i",
          "new_api": "ult = host->direction",
          "old_text": "descendant i",
          "new_text": "ult = host->direction",
          "old_line_content": "                VERIFY(host);",
          "new_line_content": "            if (root.is_shadow_root()) {",
          "content_same": false
        },
        {
          "line": 2658,
          "old_api": "tinue.\n        if (!de",
          "new_api": "alDecision::Break;\n            }\n        }",
          "old_text": "tinue.\n        if (!de",
          "new_text": "alDecision::Break;\n            }\n        }\n",
          "old_line_content": "                result = host->directionality();",
          "new_line_content": "                auto const& host = static_cast<ShadowRoot const&>(root).host();",
          "content_same": false
        },
        {
          "line": 2693,
          "old_api": "s<Element>(p",
          "new_api": "directionality",
          "old_text": "s<Element>(p",
          "new_text": "directionality();\n    }\n\n  ",
          "old_line_content": "        VERIFY(host);",
          "new_line_content": "    if (is<ShadowRoot>(parent_node)) {",
          "content_same": false
        },
        {
          "line": 2694,
          "old_api": "return static_cast",
          "new_api": "ment, then return the directionality of parentNode.",
          "old_text": "    return static_cast",
          "new_text": "ment, then return the directionality of parentNode.",
          "old_line_content": "        return host->directionality();",
          "new_line_content": "        auto const& host = static_cast<ShadowRoot const&>(*parent_node).host();",
          "content_same": false
        },
        {
          "line": 2749,
          "old_api": "ceptionOr<String> Element::get_html(GetHTMLOptions cons",
          "new_api": "// htt",
          "old_text": "ceptionOr<String> Element::get_html(GetHTMLOptions cons",
          "new_text": "// htt",
          "old_line_content": "        return static_cast<DOM::ShadowRoot&>(root_node).style_sheets();",
          "new_line_content": "    auto& root_node = root();",
          "content_same": false
        },
        {
          "line": 2751,
          "old_api": "nst\n{\n    // Element's ge",
          "new_api": "ceptionOr<String> Element::get_html(GetHTMLOptions cons",
          "old_text": "nst\n{\n    // Element's ge",
          "new_text": "ceptionOr<String> Element::get_html(GetHTMLOptions cons",
          "old_line_content": "    return document().style_sheets();",
          "new_line_content": "        return static_cast<DOM::ShadowRoot&>(root_node).style_sheets();",
          "content_same": false
        },
        {
          "line": 2814,
          "old_api": "SS::Propert",
          "new_api": "unique_id(), counter.is_reversed, counter.value)",
          "old_text": "SS::Propert",
          "new_text": " unique_id(), counter.is_reversed, counter.value)",
          "old_line_content": "        ensure_counters_set().instantiate_a_counter(counter.name, unique_id(), counter.is_reversed, counter.value);",
          "new_line_content": "    auto counter_reset = style.counter_data(CSS::PropertyID::CounterReset);",
          "content_same": false
        },
        {
          "line": 2819,
          "old_api": "for (au",
          "new_api": ".name, unique_id(), *counter.value);\n\n    // 4. Count",
          "old_text": "    for (au",
          "new_text": ".name, unique_id(), *counter.value);\n\n    // 4. Count",
          "old_line_content": "        ensure_counters_set().increment_a_counter(counter.name, unique_id(), *counter.value);",
          "new_line_content": "    auto counter_increment = style.counter_data(CSS::PropertyID::CounterIncrement);",
          "content_same": false
        },
        {
          "line": 2824,
          "old_api": "ttps://draf",
          "new_api": ", *counter.value);\n\n    // 5. Counter values ar",
          "old_text": "ttps://draf",
          "new_text": ", *counter.value);\n\n    // 5. Counter values ar",
          "old_line_content": "        ensure_counters_set().set_a_counter(counter.name, unique_id(), *counter.value);",
          "new_line_content": "    auto counter_set = style.counter_data(CSS::PropertyID::CounterSet);",
          "content_same": false
        },
        {
          "line": 2851,
          "old_api": "// 3. Let sibling counters be the C",
          "new_api": "ent_element",
          "old_text": " // 3. Let sibling counters be the C",
          "new_text": "ent_element()->counters_",
          "old_line_content": "    if (parent->has_non_empty_counters_set()) {",
          "new_line_content": "            element_counters = make<CSS::CountersSet>();",
          "content_same": false
        },
        {
          "line": 2853,
          "old_api": "CSS counters set otherwise.",
          "new_api": "// 3. Let sibling counters be the C",
          "old_text": "CSS counters set otherwise.\n    ",
          "new_text": " // 3. Let sibling counters be the C",
          "old_line_content": "        *element_counters = *parent_element()->counters_set();",
          "new_line_content": "    if (parent->has_non_empty_counters_set()) {",
          "content_same": false
        },
        {
          "line": 2862,
          "old_api": "_value",
          "new_api": "const& counter : sibling_counters.cou",
          "old_text": "_value())\n               ",
          "new_text": "const& counter : sibling_counters.cou",
          "old_line_content": "        ensure_element_counters();",
          "new_line_content": "    if (auto* const sibling = previous_sibling_of_type<Element>(); sibling && sibling->has_non_empty_counters_set()) {",
          "content_same": false
        },
        {
          "line": 2863,
          "old_api": "r);\n        }\n    }\n\n    //",
          "new_api": "last_counter_with_name",
          "old_text": "r);\n        }\n    }\n\n    //",
          "new_text": "ounters->last_counter_with_name(counter",
          "old_line_content": "        for (auto const& counter : sibling_counters.counters()) {",
          "new_line_content": "        auto& sibling_counters = sibling->counters_set().release_value();",
          "content_same": false
        },
        {
          "line": 2864,
          "old_api": "be the CSS counters set of the element immediately preceding eleme",
          "new_api": "_value",
          "old_text": "be the CSS counters set of the element immediately preceding eleme",
          "new_text": "_value())\n               ",
          "old_line_content": "            if (!element_counters->last_counter_with_name(counter.name).has_value())",
          "new_line_content": "        ensure_element_counters();",
          "content_same": false
        },
        {
          "line": 2865,
          "old_api": "//    For each source counter of v",
          "new_api": "r);\n        }\n    }\n\n    //",
          "old_text": "    //    For each source counter of v",
          "new_text": "r);\n        }\n    }\n\n    //",
          "old_line_content": "                element_counters->append_copy(counter);",
          "new_line_content": "        for (auto const& counter : sibling_counters.counters()) {",
          "content_same": false
        },
        {
          "line": 2877,
          "old_api": "maybe_existing_counter->value = source_counter.value;\n            }\n        }\n    }\n\n    VER",
          "new_api": "ounters->counter_with_same_name_and_crea",
          "old_text": "                    maybe_existing_counter->value = source_counter.value;\n            }\n        }\n    }\n\n    VER",
          "new_text": "ounters->counter_with_same_name_and_crea",
          "old_line_content": "                auto maybe_existing_counter = element_counters->counter_with_same_name_and_creator(source_counter.name, source_counter.originating_element_id);",
          "new_line_content": "            auto& value_source = previous->counters_set().release_value();",
          "content_same": false
        },
        {
          "line": 2878,
          "old_api": "is_empty",
          "new_api": "ing_element_id);",
          "old_text": "|| !element_counters->is_empty());",
          "new_text": "ing_element_id);\n      ",
          "old_line_content": "                if (maybe_existing_counter.has_value())",
          "new_line_content": "            for (auto const& source_counter : value_source.counters()) {",
          "content_same": false
        }
      ],
      "additions": [
        {
          "line": 2048,
          "old_api": null,
          "new_api": "end",
          "old_text": null,
          "new_text": "ifecycle_callbacks().end())\n        return;\n\n    if (",
          "old_line_content": "    // 3. If callback is null, then return.",
          "new_line_content": "    auto callback_iterator = definition->lifecycle_callbacks().find(callback_name);",
          "content_same": false
        },
        {
          "line": 2051,
          "old_api": null,
          "new_api": "tributeChangedCallback\", then:\n    if (",
          "old_text": null,
          "new_text": "tributeChangedCallback\", then:\n    if (",
          "old_line_content": "",
          "new_line_content": "    if (callback_iterator == definition->lifecycle_callbacks().end())",
          "content_same": false
        },
        {
          "line": 2062,
          "old_api": null,
          "new_api": "s observed attributes does not c",
          "old_text": null,
          "new_text": "s observed attributes does not c",
          "old_line_content": "",
          "new_line_content": "        VERIFY(attribute_name_value.is_string());",
          "content_same": false
        },
        {
          "line": 2063,
          "old_api": null,
          "new_api": ".\n        if (!definition->observed_attributes",
          "old_text": null,
          "new_text": ".\n        if (!definition->observed_attributes",
          "old_line_content": "        // 2. If definition's observed attributes does not contain attributeName, then return.",
          "new_line_content": "        auto attribute_name = attribute_name_value.as_string().utf8_string();",
          "content_same": false
        },
        {
          "line": 2066,
          "old_api": null,
          "new_api": "custom element reaction queue, with callback function callback",
          "old_text": null,
          "new_text": " custom element reaction queue, with callback function callback",
          "old_line_content": "    }",
          "new_line_content": "        if (!definition->observed_attributes().contains_slow(attribute_name))",
          "content_same": false
        },
        {
          "line": 2071,
          "old_api": null,
          "new_api": "ement_queue",
          "old_text": null,
          "new_text": "ement_queue();\n",
          "old_line_content": "    // 6. Enqueue an element on the appropriate element queue given element.",
          "new_line_content": "    ensure_custom_element_reaction_queue().append(CustomElementCallbackReaction { .callback = callback_iterator->value, .arguments = move(arguments) });",
          "content_same": false
        },
        {
          "line": 2074,
          "old_api": null,
          "new_api": "ement\nJS::ThrowCompletionOr<void> Element::upgrade_el",
          "old_text": null,
          "new_text": "ement\nJS::ThrowCompletionOr<void> Element::upgrade_el",
          "old_line_content": "",
          "new_line_content": "    enqueue_an_element_on_the_appropriate_element_queue();",
          "content_same": false
        },
        {
          "line": 2080,
          "old_api": null,
          "new_api": "if (m_custom_",
          "old_text": null,
          "new_text": "if (m_custom_",
          "old_line_content": "",
          "new_line_content": "    auto& realm = this->realm();",
          "content_same": false
        },
        {
          "line": 2081,
          "old_api": null,
          "new_api": "CustomElem",
          "old_text": null,
          "new_text": "CustomElem",
          "old_line_content": "    // 1. If element's custom element state is not \"undefined\" or \"uncustomized\", then return.",
          "new_line_content": "    auto& vm = this->vm();",
          "content_same": false
        },
        {
          "line": 2096,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "ts.append(JS::PrimitiveString::crea",
          "old_line_content": "",
          "new_line_content": "        auto const* attribute = m_attributes->item(attribute_index);",
          "content_same": false
        },
        {
          "line": 2103,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "ri().value()) : JS",
          "old_line_content": "",
          "new_line_content": "        arguments.append(JS::PrimitiveString::create(vm, attribute->value()));",
          "content_same": false
        },
        {
          "line": 2106,
          "old_api": null,
          "new_api": "ctedCallback\",",
          "old_text": null,
          "new_text": "ctedCallback\", ",
          "old_line_content": "",
          "new_line_content": "        enqueue_a_custom_element_callback_reaction(HTML::CustomElementReactionNames::attributeChangedCallback, move(arguments));",
          "content_same": false
        },
        {
          "line": 2111,
          "old_api": null,
          "new_api": "}",
          "old_text": null,
          "new_text": "   }\n\n   ",
          "old_line_content": "    }",
          "new_line_content": "        JS::MarkedVector<JS::Value> empty_arguments { vm.heap() };",
          "content_same": false
        },
        {
          "line": 2112,
          "old_api": null,
          "new_api": "append",
          "old_text": null,
          "new_text": "n_stack().append(JS::",
          "old_line_content": "",
          "new_line_content": "        enqueue_a_custom_element_callback_reaction(HTML::CustomElementReactionNames::connectedCallback, move(empty_arguments));",
          "content_same": false
        },
        {
          "line": 2116,
          "old_api": null,
          "new_api": "/ 8. Run the followin",
          "old_text": null,
          "new_text": "/ 8. Run the followin",
          "old_line_content": "    // 7. Let C be definition's constructor.",
          "new_line_content": "    custom_element_definition->construction_stack().append(JS::make_handle(this));",
          "content_same": false
        },
        {
          "line": 2119,
          "old_api": null,
          "new_api": "ustom_element = [&]() -> JS::ThrowComple",
          "old_text": null,
          "new_text": "ustom_element = [&]() -> JS::ThrowComple",
          "old_line_content": "    // 8. Run the following substeps while catching any exceptions:",
          "new_line_content": "    auto& constructor = custom_element_definition->constructor();",
          "content_same": false
        },
        {
          "line": 2124,
          "old_api": null,
          "new_api": "and the cust",
          "old_text": null,
          "new_text": " and the cust",
          "old_line_content": "",
          "new_line_content": "        if (custom_element_definition->disable_shadow() && shadow_root())",
          "content_same": false
        },
        {
          "line": 2125,
          "old_api": null,
          "new_api": ";\n\n        // 2. Set element's custom element state to \"precustomized\".\n        m_custom_element_state = CustomElementState::Precustomized;",
          "old_text": null,
          "new_text": ";\n\n        // 2. Set element's custom element state to \"precustomized\".\n        m_custom_element_state = CustomElementState::Precustomized;\n\n",
          "old_line_content": "        // 2. Set element's custom element state to \"precustomized\".",
          "new_line_content": "            return JS::throw_completion(WebIDL::NotSupportedError::create(realm, \"Custom element definition disables shadow DOM and the custom element has a shadow root\"_fly_string));",
          "content_same": false
        },
        {
          "line": 2132,
          "old_api": null,
          "new_api": "(constructResult, element) is false,",
          "old_text": null,
          "new_text": "(constructResult, element) is false, ",
          "old_line_content": "",
          "new_line_content": "        VERIFY(construct_result_optional.has_value());",
          "content_same": false
        },
        {
          "line": 2133,
          "old_api": null,
          "new_api": "(!JS::same_value(construct_result, this))",
          "old_text": null,
          "new_text": "(!JS::same_value(construct_result, this))",
          "old_line_content": "        // 4. If SameValue(constructResult, element) is false, then throw a TypeError.",
          "new_line_content": "        auto construct_result = construct_result_optional.release_value();",
          "content_same": false
        },
        {
          "line": 2136,
          "old_api": null,
          "new_api": "erent element from the custom element\"",
          "old_text": null,
          "new_text": "erent element from the custom element\"",
          "old_line_content": "",
          "new_line_content": "        if (!JS::same_value(construct_result, this))",
          "content_same": false
        },
        {
          "line": 2137,
          "old_api": null,
          "new_api": "{};\n    };\n\n    auto maybe_exception = attempt_to_construct_custom_element();\n\n    // Then, perform the following substep, r",
          "old_text": null,
          "new_text": "{};\n    };\n\n    auto maybe_exception = attempt_to_construct_custom_element();\n\n    // Then, perform the following substep, r",
          "old_line_content": "        return {};",
          "new_line_content": "            return vm.throw_completion<JS::TypeError>(\"Constructing the custom element returned a different element from the custom element\"sv);",
          "content_same": false
        },
        {
          "line": 2142,
          "old_api": null,
          "new_api": "r not:\n    // 1. Remove the last entr",
          "old_text": null,
          "new_text": "r not:\n    // 1. Remove the last entr",
          "old_line_content": "    // Then, perform the following substep, regardless of whether the above steps threw an exception or not:",
          "new_line_content": "    auto maybe_exception = attempt_to_construct_custom_element();",
          "content_same": false
        },
        {
          "line": 2146,
          "old_api": null,
          "new_api": "is_throw_completion",
          "old_text": null,
          "new_text": "tion.is_throw_completion()) {\n        // 1. Set element's c",
          "old_line_content": "    // Finally, if the above steps threw an exception, then:",
          "new_line_content": "    (void)custom_element_definition->construction_stack().take_last();",
          "content_same": false
        },
        {
          "line": 2149,
          "old_api": null,
          "new_api": "nullptr;\n\n        // 2. Empty element",
          "old_text": null,
          "new_text": "nullptr;\n\n        // 2. Empty element",
          "old_line_content": "        m_custom_element_definition = nullptr;",
          "new_line_content": "    if (maybe_exception.is_throw_completion()) {",
          "content_same": false
        },
        {
          "line": 2155,
          "old_api": null,
          "new_api": "release_error",
          "old_text": null,
          "new_text": "on.release_error();\n    }\n\n    // FIXME:",
          "old_line_content": "        // 3. Rethrow the exception (thus terminating this algorithm).",
          "new_line_content": "            m_custom_element_reaction_queue->clear();",
          "content_same": false
        },
        {
          "line": 2158,
          "old_api": null,
          "new_api": "orm owner of element. If elemen",
          "old_text": null,
          "new_text": "orm owner of element. If elemen",
          "old_line_content": "",
          "new_line_content": "        return maybe_exception.release_error();",
          "content_same": false
        },
        {
          "line": 2175,
          "old_api": null,
          "new_api": "if (definiti",
          "old_text": null,
          "new_text": "if (definiti",
          "old_line_content": "    // 2. If definition is not null, then enqueue a custom element upgrade reaction given element and definition.",
          "new_line_content": "    auto definition = document().lookup_custom_element_definition(namespace_uri(), local_name(), m_is_value);",
          "content_same": false
        },
        {
          "line": 2179,
          "old_api": null,
          "new_api": "t\n{\n    // An element whose custom element state is \"u",
          "old_text": null,
          "new_text": "t\n{\n    // An element whose custom element state is \"u",
          "old_line_content": "",
          "new_line_content": "        enqueue_a_custom_element_upgrade_reaction(*definition);",
          "content_same": false
        },
        {
          "line": 2211,
          "old_api": null,
          "new_api": "++i)",
          "old_text": null,
          "new_text": " ++i)\n     ",
          "old_line_content": "",
          "new_line_content": "    m_qualified_name.set_prefix(move(value));",
          "content_same": false
        },
        {
          "line": 2216,
          "old_api": null,
          "new_api": "const&)> callback) con",
          "old_text": null,
          "new_text": "const&)> callback) con",
          "old_line_content": "}",
          "new_line_content": "    for (size_t i = 0; i < m_attributes->length(); ++i)",
          "content_same": false
        },
        {
          "line": 2217,
          "old_api": null,
          "new_api": "te",
          "old_text": null,
          "new_text": "te([&callback](Attr c",
          "old_line_content": "",
          "new_line_content": "        callback(*m_attributes->item(i));",
          "content_same": false
        },
        {
          "line": 2222,
          "old_api": null,
          "new_api": "t::layout_node()\n{\n    return static_cast<Layout::NodeWithStyle*>(Node::layout_node());\n}\n\nJS::GCPtr<L",
          "old_text": null,
          "new_text": "t::layout_node()\n{\n    return static_cast<Layout::NodeWithStyle*>(Node::layout_node());\n}\n\nJS::GCPtr<L",
          "old_line_content": "    });",
          "new_line_content": "    for_each_attribute([&callback](Attr const& attr) {",
          "content_same": false
        },
        {
          "line": 2223,
          "old_api": null,
          "new_api": "de",
          "old_text": null,
          "new_text": "de());\n}\n\nJS",
          "old_line_content": "}",
          "new_line_content": "        callback(attr.name(), attr.value());",
          "content_same": false
        },
        {
          "line": 2229,
          "old_api": null,
          "new_api": ">(Node::layout_node",
          "old_text": null,
          "new_text": ">(Node::layout_node",
          "old_line_content": "",
          "new_line_content": "    return static_cast<Layout::NodeWithStyle*>(Node::layout_node());",
          "content_same": false
        },
        {
          "line": 2234,
          "old_api": null,
          "new_api": "st\n{\n    return m_a",
          "old_text": null,
          "new_text": "st\n{\n    return m_a",
          "old_line_content": "",
          "new_line_content": "    return static_cast<Layout::NodeWithStyle const*>(Node::layout_node());",
          "content_same": false
        },
        {
          "line": 2239,
          "old_api": null,
          "new_api": "lues",
          "old_text": null,
          "new_text": "lues(RefPtr<CSS::StylePr",
          "old_line_content": "",
          "new_line_content": "    return !m_attributes->is_empty();",
          "content_same": false
        },
        {
          "line": 2244,
          "old_api": null,
          "new_api": "computed_css_values_",
          "old_text": null,
          "new_text": "  computed_css_values_",
          "old_line_content": "",
          "new_line_content": "    return m_attributes->length();",
          "content_same": false
        },
        {
          "line": 2249,
          "old_api": null,
          "new_api": "element, Re",
          "old_text": null,
          "new_text": "element, Re",
          "old_line_content": "}",
          "new_line_content": "    m_computed_css_values = move(style);",
          "content_same": false
        },
        {
          "line": 2250,
          "old_api": null,
          "new_api": "SS::StyleProperties> style)\n{",
          "old_text": null,
          "new_text": "SS::StyleProperties> style)\n{",
          "old_line_content": "",
          "new_line_content": "    computed_css_values_changed();",
          "content_same": false
        },
        {
          "line": 2257,
          "old_api": null,
          "new_api": "o_element =",
          "old_text": null,
          "new_text": "o_element =",
          "old_line_content": "",
          "new_line_content": "    ensure_pseudo_element(pseudo_element).computed_css_values = move(style);",
          "content_same": false
        },
        {
          "line": 2262,
          "old_api": null,
          "new_api": "Element::PseudoElement&>",
          "old_text": null,
          "new_text": "Element::PseudoElement&>",
          "old_line_content": "        return pseudo_element->computed_css_values;",
          "new_line_content": "    auto pseudo_element = get_pseudo_element(type);",
          "content_same": false
        },
        {
          "line": 2263,
          "old_api": null,
          "new_api": "get_pseudo_element",
          "old_text": null,
          "new_text": "get_pseudo_element(CSS::Se",
          "old_line_content": "    return nullptr;",
          "new_line_content": "    if (pseudo_element.has_value())",
          "content_same": false
        },
        {
          "line": 2272,
          "old_api": null,
          "new_api": "_element_data)",
          "old_text": null,
          "new_text": "_element_data)\n    ",
          "old_line_content": "",
          "new_line_content": "    return m_pseudo_element_data->at(to_underlying(type));",
          "content_same": false
        },
        {
          "line": 2278,
          "old_api": null,
          "new_api": "r::PseudoElement::Type> p",
          "old_text": null,
          "new_text": "r::PseudoElement::Type> p",
          "old_line_content": "}",
          "new_line_content": "        m_pseudo_element_data = make<PseudoElementData>();",
          "content_same": false
        },
        {
          "line": 2279,
          "old_api": null,
          "new_api": "StyleProperty> cust",
          "old_text": null,
          "new_text": "StyleProperty> cust",
          "old_line_content": "",
          "new_line_content": "    return m_pseudo_element_data->at(to_underlying(type));",
          "content_same": false
        },
        {
          "line": 2284,
          "old_api": null,
          "new_api": "value",
          "old_text": null,
          "new_text": "t.value()).custom_properti",
          "old_line_content": "        return;",
          "new_line_content": "    if (!pseudo_element.has_value()) {",
          "content_same": false
        },
        {
          "line": 2285,
          "old_api": null,
          "new_api": "ashMap<FlyString, CSS::",
          "old_text": null,
          "new_text": "ashMap<FlyString, CSS::",
          "old_line_content": "    }",
          "new_line_content": "        m_custom_properties = move(custom_properties);",
          "content_same": false
        },
        {
          "line": 2288,
          "old_api": null,
          "new_api": "pseudo_element) const\n{",
          "old_text": null,
          "new_text": "pseudo_element) const\n{",
          "old_line_content": "",
          "new_line_content": "    ensure_pseudo_element(pseudo_element.value()).custom_properties = move(custom_properties);",
          "content_same": false
        },
        {
          "line": 2295,
          "old_api": null,
          "new_api": "{\n    // 1. If invoked",
          "old_text": null,
          "new_text": "{\n    // 1. If invoked",
          "old_line_content": "",
          "new_line_content": "    return ensure_pseudo_element(pseudo_element.value()).custom_properties;",
          "content_same": false
        },
        {
          "line": 2309,
          "old_api": null,
          "new_api": "document",
          "old_text": null,
          "new_text": "to& document = this->document();\n\n  ",
          "old_line_content": "",
          "new_line_content": "    x = HTML::normalize_non_finite_values(x);",
          "content_same": false
        },
        {
          "line": 2310,
          "old_api": null,
          "new_api": "document is not the active document",
          "old_text": null,
          "new_text": " document is not the active document",
          "old_line_content": "    // 3. Let document be the elements node document.",
          "new_line_content": "    y = HTML::normalize_non_finite_values(y);",
          "content_same": false
        },
        {
          "line": 2313,
          "old_api": null,
          "new_api": ". Let window be",
          "old_text": null,
          "new_text": ". Let window be ",
          "old_line_content": "    // 4. If document is not the active document, terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 2316,
          "old_api": null,
          "new_api": "ew",
          "old_text": null,
          "new_text": "ew();\n\n    // 6. If ",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 2320,
          "old_api": null,
          "new_api": "lement and document is",
          "old_text": null,
          "new_text": "lement and document is ",
          "old_line_content": "    // 6. If window is null, terminate these steps.",
          "new_line_content": "    auto* window = document.default_view();",
          "content_same": false
        },
        {
          "line": 2327,
          "old_api": null,
          "new_api": "// 8. If the element is",
          "old_text": null,
          "new_text": "  // 8. If the element is",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 2331,
          "old_api": null,
          "new_api": "cond argument, and termi",
          "old_text": null,
          "new_text": "cond argument, and termi",
          "old_line_content": "    // 8. If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.",
          "new_line_content": "    document.update_layout();",
          "content_same": false
        },
        {
          "line": 2334,
          "old_api": null,
          "new_api": "ent, document is in quirks",
          "old_text": null,
          "new_text": "ent, document is in quirks ",
          "old_line_content": "        return;",
          "new_line_content": "    if (document.document_element() == this) {",
          "content_same": false
        },
        {
          "line": 2335,
          "old_api": null,
          "new_api": "ially scrollable,",
          "old_text": null,
          "new_text": "ially scrollable, ",
          "old_line_content": "    }",
          "new_line_content": "        window->scroll(window->scroll_x(), y);",
          "content_same": false
        },
        {
          "line": 2341,
          "old_api": null,
          "new_api": "ement has no associated scr",
          "old_text": null,
          "new_text": "ement has no associated scr",
          "old_line_content": "        return;",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable()) {",
          "content_same": false
        },
        {
          "line": 2342,
          "old_api": null,
          "new_api": "or the element has n",
          "old_text": null,
          "new_text": "or the element has n",
          "old_line_content": "    }",
          "new_line_content": "        window->scroll(x, y);",
          "content_same": false
        },
        {
          "line": 2348,
          "old_api": null,
          "new_api": "options.\n    //",
          "old_text": null,
          "new_text": "options.\n    //",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 2355,
          "old_api": null,
          "new_api": "void Element::scroll(HTML::Scr",
          "old_text": null,
          "new_text": "\nvoid Element::scroll(HTML::Scr",
          "old_line_content": "}",
          "new_line_content": "    scroll_offset.set_y(CSSPixels::nearest_value_for(y));",
          "content_same": false
        },
        {
          "line": 2356,
          "old_api": null,
          "new_api": "tions options)\n{\n    // 1. If invoked with one ar",
          "old_text": null,
          "new_text": "tions options)\n{\n    // 1. If invoked with one ar",
          "old_line_content": "",
          "new_line_content": "    paintable_box()->set_scroll_offset(scroll_offset);",
          "content_same": false
        },
        {
          "line": 2369,
          "old_api": null,
          "new_api": "t options be",
          "old_text": null,
          "new_text": "t options be",
          "old_line_content": "}",
          "new_line_content": "    auto y = options.top.has_value() ? HTML::normalize_non_finite_values(options.top.value()) : scroll_top();",
          "content_same": false
        },
        {
          "line": 2370,
          "old_api": null,
          "new_api": "converted to",
          "old_text": null,
          "new_text": "converted to",
          "old_line_content": "",
          "new_line_content": "    scroll(x, y);",
          "content_same": false
        },
        {
          "line": 2386,
          "old_api": null,
          "new_api": "options be the ar",
          "old_text": null,
          "new_text": " options be the ar",
          "old_line_content": "",
          "new_line_content": "    scroll_by(options);",
          "content_same": false
        },
        {
          "line": 2394,
          "old_api": null,
          "new_api": "the left dictionary member.\n    options.left =",
          "old_text": null,
          "new_text": "the left dictionary member.\n    options.left = ",
          "old_line_content": "",
          "new_line_content": "    auto left = HTML::normalize_non_finite_values(options.left);",
          "content_same": false
        },
        {
          "line": 2395,
          "old_api": null,
          "new_api": "eft;\n\n    // 4. Add the value of scrollTop to",
          "old_text": null,
          "new_text": "eft;\n\n    // 4. Add the value of scrollTop to ",
          "old_line_content": "    // 3. Add the value of scrollLeft to the left dictionary member.",
          "new_line_content": "    auto top = HTML::normalize_non_finite_values(options.top);",
          "content_same": false
        },
        {
          "line": 2398,
          "old_api": null,
          "new_api": "croll",
          "old_text": null,
          "new_text": "croll() metho",
          "old_line_content": "    // 4. Add the value of scrollTop to the top dictionary member.",
          "new_line_content": "    options.left = scroll_left() + left;",
          "content_same": false
        },
        {
          "line": 2401,
          "old_api": null,
          "new_api": "g.org/cssom-",
          "old_text": null,
          "new_text": "g.org/cssom-",
          "old_line_content": "    // 5. Act as if the scroll() method was invoked with options as the only argument.",
          "new_line_content": "    options.top = scroll_top() + top;",
          "content_same": false
        },
        {
          "line": 2404,
          "old_api": null,
          "new_api": "options)\n{",
          "old_text": null,
          "new_text": "options)\n{\n    ",
          "old_line_content": "",
          "new_line_content": "    scroll(options);",
          "content_same": false
        },
        {
          "line": 2411,
          "old_api": null,
          "new_api": "f an ancestor of this in t",
          "old_text": null,
          "new_text": "f an ancestor of this in t",
          "old_line_content": "    // 1. If this does not have an associated box, return false.",
          "new_line_content": "    document().update_layout();",
          "content_same": false
        },
        {
          "line": 2414,
          "old_api": null,
          "new_api": "ment = parent_e",
          "old_text": null,
          "new_text": "ment = parent_e",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 2418,
          "old_api": null,
          "new_api": "}\n\n    // AD-HOC: Si",
          "old_text": null,
          "new_text": "\n    }\n\n    // AD-HOC: Si",
          "old_line_content": "            return false;",
          "new_line_content": "    for (auto* element = parent_element(); element; element = element->parent_element()) {",
          "content_same": false
        },
        {
          "line": 2419,
          "old_api": null,
          "new_api": "the steps use the options, we can return early if we",
          "old_text": null,
          "new_text": "the steps use the options, we can return early if we",
          "old_line_content": "    }",
          "new_line_content": "        if (element->computed_css_values()->content_visibility() == CSS::ContentVisibility::Hidden)",
          "content_same": false
        },
        {
          "line": 2424,
          "old_api": null,
          "new_api": "r an ancestor of th",
          "old_text": null,
          "new_text": "r an ancestor of th",
          "old_line_content": "",
          "new_line_content": "    if (!options.has_value())",
          "content_same": false
        },
        {
          "line": 2429,
          "old_api": null,
          "new_api": "f either the visibilityPr",
          "old_text": null,
          "new_text": "f either the visibilityPr",
          "old_line_content": "                return false;",
          "new_line_content": "        for (auto* element = this; element; element = element->parent_element()) {",
          "content_same": false
        },
        {
          "line": 2430,
          "old_api": null,
          "new_api": "isibilityCSS dictionary members of option",
          "old_text": null,
          "new_text": "isibilityCSS dictionary members of option",
          "old_line_content": "        }",
          "new_line_content": "            if (element->computed_css_values()->opacity() == 0.0f)",
          "content_same": false
        },
        {
          "line": 2437,
          "old_api": null,
          "new_api": "of options is true and an ancestor",
          "old_text": null,
          "new_text": "of options is true and an ancestor ",
          "old_line_content": "    }",
          "new_line_content": "        if (computed_css_values()->visibility() == CSS::Visibility::Hidden)",
          "content_same": false
        },
        {
          "line": 2445,
          "old_api": null,
          "new_api": "false;\n        }\n    }",
          "old_text": null,
          "new_text": "false;\n        }\n    }\n\n ",
          "old_line_content": "                return false;",
          "new_line_content": "        for (auto* element = this; element; element = element->parent_element()) {",
          "content_same": false
        },
        {
          "line": 2446,
          "old_api": null,
          "new_api": ".\n    return true;\n}\n\nbool Element::id_reference_exi",
          "old_text": null,
          "new_text": ".\n    return true;\n}\n\nbool Element::id_reference_exi",
          "old_line_content": "        }",
          "new_line_content": "            if (element->computed_css_values()->content_visibility() == CSS::ContentVisibility::Auto)",
          "content_same": false
        },
        {
          "line": 2457,
          "old_api": null,
          "new_api": "nObserver::IntersectionObserverRegistratio",
          "old_text": null,
          "new_text": "nObserver::IntersectionObserverRegistratio",
          "old_line_content": "",
          "new_line_content": "    return document().get_element_by_id(id_reference);",
          "content_same": false
        },
        {
          "line": 2463,
          "old_api": null,
          "new_api": "nt::unregister_intersection_observer(Badge<IntersectionObserver::Inter",
          "old_text": null,
          "new_text": "nt::unregister_intersection_observer(Badge<IntersectionObserver::Inter",
          "old_line_content": "}",
          "new_line_content": "        m_registered_intersection_observers = make<Vector<IntersectionObserver::IntersectionObserverRegistration>>();",
          "content_same": false
        },
        {
          "line": 2464,
          "old_api": null,
          "new_api": "erver::Intersectio",
          "old_text": null,
          "new_text": "erver::Intersectio",
          "old_line_content": "",
          "new_line_content": "    m_registered_intersection_observers->append(move(registration));",
          "content_same": false
        },
        {
          "line": 2471,
          "old_api": null,
          "new_api": "rn entry.observer == observer;\n    });\n}\n\nIntersectionObserver::IntersectionObserverRegistration& Element::get_intersection_observer_registration(Badge<DOM::Document>, IntersectionObserver::I",
          "old_text": null,
          "new_text": "rn entry.observer == observer;\n    });\n}\n\nIntersectionObserver::IntersectionObserverRegistration& Element::get_intersection_observer_registration(Badge<DOM::Document>, IntersectionObserver::I",
          "old_line_content": "    });",
          "new_line_content": "    m_registered_intersection_observers->remove_first_matching([&observer](IntersectionObserver::IntersectionObserverRegistration const& entry) {",
          "content_same": false
        },
        {
          "line": 2479,
          "old_api": null,
          "new_api": "ptr",
          "old_text": null,
          "new_text": "ver.ptr() == &observer;\n    });\n    VERIFY(!registration_iterator.is_end());\n    return *registration_iterator;\n}\n\n// https://html.spec.whatwg.org/multipage/dom.html#the-directionality",
          "old_line_content": "    });",
          "new_line_content": "    auto registration_iterator = m_registered_intersection_observers->find_if([&observer](IntersectionObserver::IntersectionObserverRegistration const& entry) {",
          "content_same": false
        },
        {
          "line": 2482,
          "old_api": null,
          "new_api": "ctionality Element::directiona",
          "old_text": null,
          "new_text": "ctionality Element::directiona",
          "old_line_content": "}",
          "new_line_content": "    VERIFY(!registration_iterator.is_end());",
          "content_same": false
        },
        {
          "line": 2492,
          "old_api": null,
          "new_api": "rn 'ltr'.",
          "old_text": null,
          "new_text": "rn 'ltr'.\n           ",
          "old_line_content": "        switch (dir) {",
          "new_line_content": "    if (maybe_dir.has_value()) {",
          "content_same": false
        },
        {
          "line": 2493,
          "old_api": null,
          "new_api": ":Ltr;\n        // -> rtl",
          "old_text": null,
          "new_text": ":Ltr;\n        // -> rtl\n ",
          "old_line_content": "        // -> ltr",
          "new_line_content": "        auto dir = maybe_dir.release_value();",
          "content_same": false
        },
        {
          "line": 2506,
          "old_api": null,
          "new_api": "::Ltr;\n\n            /",
          "old_text": null,
          "new_text": "::Ltr;\n\n            /",
          "old_line_content": "            // 2. If result is null, then return 'ltr'.",
          "new_line_content": "            auto result = auto_directionality();",
          "content_same": false
        },
        {
          "line": 2509,
          "old_api": null,
          "new_api": "}\n    // -> undef",
          "old_text": null,
          "new_text": " }\n    // -> undef",
          "old_line_content": "",
          "new_line_content": "            if (!result.has_value())",
          "content_same": false
        },
        {
          "line": 2513,
          "old_api": null,
          "new_api": "1. Let result be t",
          "old_text": null,
          "new_text": "    1. Let result be t",
          "old_line_content": "    }",
          "new_line_content": "            return result.release_value();",
          "content_same": false
        },
        {
          "line": 2517,
          "old_api": null,
          "new_api": "2. If result is nu",
          "old_text": null,
          "new_text": "   2. If result is nu",
          "old_line_content": "    // FIXME: If element is a bdi element:",
          "new_line_content": "    VERIFY(!maybe_dir.has_value());",
          "content_same": false
        },
        {
          "line": 2525,
          "old_api": null,
          "new_api": "return Directionality::Ltr;\n    }\n\n    // Otherwise:\n    //",
          "old_text": null,
          "new_text": "  return Directionality::Ltr;\n    }\n\n    // Otherwise:\n    // ",
          "old_line_content": "        return Directionality::Ltr;",
          "new_line_content": "    if (is<HTML::HTMLInputElement>(this) && static_cast<HTML::HTMLInputElement const&>(*this).type_state() == HTML::HTMLInputElement::TypeAttributeState::Telephone) {",
          "content_same": false
        },
        {
          "line": 2532,
          "old_api": null,
          "new_api": "nality_form_associated_",
          "old_text": null,
          "new_text": "nality_form_associated_",
          "old_line_content": "",
          "new_line_content": "    return parent_directionality();",
          "content_same": false
        },
        {
          "line": 2541,
          "old_api": null,
          "new_api": "_state",
          "old_text": null,
          "new_text": "_state(), HTML::HTMLInputElement::T",
          "old_line_content": "}",
          "new_line_content": "    return is<HTML::HTMLTextAreaElement>(this)",
          "content_same": false
        },
        {
          "line": 2542,
          "old_api": null,
          "new_api": "tate::Text, HTML::HTMLInputElement::TypeAttributeState::Search",
          "old_text": null,
          "new_text": "tate::Text, HTML::HTMLInputElement::TypeAttributeState::Search",
          "old_line_content": "",
          "new_line_content": "        || (is<HTML::HTMLInputElement>(this) && first_is_one_of(static_cast<HTML::HTMLInputElement const&>(*this).type_state(), HTML::HTMLInputElement::TypeAttributeState::Hidden, HTML::HTMLInputElement::TypeAttributeState::Text, HTML::HTMLInputElement::TypeAttributeState::Search, HTML::HTMLInputElement::TypeAttributeState::Telephone, HTML::HTMLInputElement::TypeAttributeState::URL, HTML::HTMLInputElement::TypeAttributeState::Email, HTML::HTMLInputElement::TypeAttributeState::Password, HTML::HTMLInputElement::TypeAttributeState::SubmitButton, HTML::HTMLInputElement::TypeAttributeState::ResetButton, HTML::HTMLInputElement::TypeAttributeState::Button));",
          "content_same": false
        },
        {
          "line": 2549,
          "old_api": null,
          "new_api": "Assume 'ltr' if Unicode data generation is disa",
          "old_text": null,
          "new_text": " Assume 'ltr' if Unicode data generation is disa",
          "old_line_content": "",
          "new_line_content": "    static auto bidirectional_class_AL = Unicode::bidirectional_class_from_string(\"AL\"sv);",
          "content_same": false
        },
        {
          "line": 2550,
          "old_api": null,
          "new_api": "alue",
          "old_text": null,
          "new_text": "alue())\n        return Directionality::Ltr;\n\n  ",
          "old_line_content": "    // AD-HOC: Assume 'ltr' if Unicode data generation is disabled.",
          "new_line_content": "    static auto bidirectional_class_R = Unicode::bidirectional_class_from_string(\"R\"sv);",
          "content_same": false
        },
        {
          "line": 2553,
          "old_api": null,
          "new_api": "auto text_node_directionality =",
          "old_text": null,
          "new_text": "  auto text_node_directionality =",
          "old_line_content": "",
          "new_line_content": "    if (!bidirectional_class_L.has_value())",
          "content_same": false
        },
        {
          "line": 2562,
          "old_api": null,
          "new_api": ")) {\n                found_character_bid",
          "old_text": null,
          "new_text": ")) {\n                found_character_bid",
          "old_line_content": "                found_character_bidi_class = bidi_class;",
          "new_line_content": "            auto bidi_class = Unicode::bidirectional_class(code_point);",
          "content_same": false
        },
        {
          "line": 2563,
          "old_api": null,
          "new_api": "ss;\n                break;\n            }\n        }\n        if (!found_character_bidi_class.has_va",
          "old_text": null,
          "new_text": "ss;\n                break;\n            }\n        }\n        if (!found_character_bidi_class.has_va",
          "old_line_content": "                break;",
          "new_line_content": "            if (first_is_one_of(bidi_class, bidirectional_class_L, bidirectional_class_AL, bidirectional_class_R)) {",
          "content_same": false
        },
        {
          "line": 2568,
          "old_api": null,
          "new_api": "if (first_is_one_of(*found_cha",
          "old_text": null,
          "new_text": "        if (first_is_one_of(*found_cha",
          "old_line_content": "",
          "new_line_content": "        if (!found_character_bidi_class.has_value())",
          "content_same": false
        },
        {
          "line": 2572,
          "old_api": null,
          "new_api": "ePoint is of bidirectional character type L, then return 'ltr'.\n        // NOTE: codePoint",
          "old_text": null,
          "new_text": "ePoint is of bidirectional character type L, then return 'ltr'.\n        // NOTE: codePoint ",
          "old_line_content": "",
          "new_line_content": "        if (first_is_one_of(*found_character_bidi_class, bidirectional_class_AL, bidirectional_class_R))",
          "content_same": false
        },
        {
          "line": 2577,
          "old_api": null,
          "new_api": "orm-associated element:\n    if (is_auto_directionality_form_",
          "old_text": null,
          "new_text": "orm-associated element:\n    if (is_auto_directionality_form_",
          "old_line_content": "    };",
          "new_line_content": "        VERIFY(*found_character_bidi_class == bidirectional_class_L);",
          "content_same": false
        },
        {
          "line": 2584,
          "old_api": null,
          "new_api": "idirectional character type AL",
          "old_text": null,
          "new_text": "idirectional character type AL ",
          "old_line_content": "",
          "new_line_content": "        VERIFY(form_associated_element);",
          "content_same": false
        },
        {
          "line": 2585,
          "old_api": null,
          "new_api": "is no character of bidirectional",
          "old_text": null,
          "new_text": "is no character of bidirectional",
          "old_line_content": "        // 1. If element's value contains a character of bidirectional character type AL or R,",
          "new_line_content": "        auto const& value = form_associated_element->value();",
          "content_same": false
        },
        {
          "line": 2589,
          "old_api": null,
          "new_api": "break;",
          "old_text": null,
          "new_text": "      break;\n  ",
          "old_line_content": "            if (bidi_class == bidirectional_class_L)",
          "new_line_content": "        for (auto code_point : Utf8View(value)) {",
          "content_same": false
        },
        {
          "line": 2590,
          "old_api": null,
          "new_api": "ctional_class_AL || bidi_class == bidire",
          "old_text": null,
          "new_text": "ctional_class_AL || bidi_class == bidire",
          "old_line_content": "                break;",
          "new_line_content": "            auto bidi_class = Unicode::bidirectional_class(code_point);",
          "content_same": false
        },
        {
          "line": 2598,
          "old_api": null,
          "new_api": "se root is a sha",
          "old_text": null,
          "new_text": "se root is a sha",
          "old_line_content": "",
          "new_line_content": "        if (value.is_empty())",
          "content_same": false
        },
        {
          "line": 2607,
          "old_api": null,
          "new_api": "each node child of element's assigned nodes:",
          "old_text": null,
          "new_text": "each node child of element's assigned nodes:\n   ",
          "old_line_content": "            // 1 . For each node child of element's assigned nodes:",
          "new_line_content": "        auto const& slot = static_cast<HTML::HTMLSlotElement const&>(*this);",
          "content_same": false
        },
        {
          "line": 2610,
          "old_api": null,
          "new_api": ". If child is a Text",
          "old_text": null,
          "new_text": ". If child is a Text ",
          "old_line_content": "                Optional<Directionality> child_direction;",
          "new_line_content": "            for (auto const& child : slot.assigned_nodes()) {",
          "content_same": false
        },
        {
          "line": 566,
          "old_api": null,
          "new_api": "nvalidation",
          "old_text": null,
          "new_text": "nvalidation(*pseudo_element_style, *new_pseudo_element_style);\n        } else i",
          "old_line_content": "        if (pseudo_element_style && new_pseudo_element_style) {",
          "new_line_content": "            invalidation |= compute_required_invalidation(*pseudo_element_style, *new_pseudo_element_style);",
          "content_same": false
        },
        {
          "line": 2615,
          "old_api": null,
          "new_api": "else",
          "old_text": null,
          "new_text": "            else",
          "old_line_content": "",
          "new_line_content": "                if (child->is_text())",
          "content_same": false
        },
        {
          "line": 568,
          "old_api": null,
          "new_api": "idationAfterStyleChange::full();\n        }",
          "old_text": null,
          "new_text": "idationAfterStyleChange::full();\n        }\n\n     ",
          "old_line_content": "        } else if (pseudo_element_style || new_pseudo_element_style) {",
          "new_line_content": "            invalidation = CSS::RequiredInvalidationAfterStyleChange::full();",
          "content_same": false
        },
        {
          "line": 2616,
          "old_api": null,
          "new_api": "VERIFY(child->",
          "old_text": null,
          "new_text": "                  VERIFY(child->",
          "old_line_content": "                // 3. Otherwise:",
          "new_line_content": "                    child_direction = text_node_directionality(static_cast<Text const&>(*child));",
          "content_same": false
        },
        {
          "line": 571,
          "old_api": null,
          "new_api": "ement_style));\n        style_c",
          "old_text": null,
          "new_text": "ement_style));\n        style_c",
          "old_line_content": "",
          "new_line_content": "        set_pseudo_element_computed_css_values(pseudo_element, move(new_pseudo_element_style));",
          "content_same": false
        },
        {
          "line": 2621,
          "old_api": null,
          "new_api": "<HTML::HTMLElement",
          "old_text": null,
          "new_text": "<HTML::HTMLElement ",
          "old_line_content": "                    // 2. Set childDirection to the auto directionality of child.",
          "new_line_content": "                    VERIFY(child->is_element());",
          "content_same": false
        },
        {
          "line": 575,
          "old_api": null,
          "new_api": "lement_style",
          "old_text": null,
          "new_text": "lement_style(CSS::Selector::PseudoElement::Type::Before);\n    recompute_ps",
          "old_line_content": "",
          "new_line_content": "    recompute_pseudo_element_style(CSS::Selector::PseudoElement::Type::Before);",
          "content_same": false
        },
        {
          "line": 2624,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "ildDirection.\n                if (child_direction.has_value())\n   ",
          "old_line_content": "",
          "new_line_content": "                    child_direction = static_cast<HTML::HTMLElement const&>(*this).auto_directionality();",
          "content_same": false
        },
        {
          "line": 578,
          "old_api": null,
          "new_api": "ne",
          "old_text": null,
          "new_text": "ne())\n        return i",
          "old_line_content": "",
          "new_line_content": "    if (invalidation.is_none())",
          "content_same": false
        },
        {
          "line": 2628,
          "old_api": null,
          "new_api": "}\n\n    // 3. For each nod",
          "old_text": null,
          "new_text": "  }\n\n    // 3. For each nod",
          "old_line_content": "            }",
          "new_line_content": "                if (child_direction.has_value())",
          "content_same": false
        },
        {
          "line": 587,
          "old_api": null,
          "new_api": "pain",
          "old_text": null,
          "new_text": "       pain",
          "old_line_content": "",
          "new_line_content": "        if (invalidation.repaint && paintable())",
          "content_same": false
        },
        {
          "line": 588,
          "old_api": null,
          "new_api": "eeds_display",
          "old_text": null,
          "new_text": "eeds_display();\n\n        // Do t",
          "old_line_content": "        // Do the same for pseudo-elements.",
          "new_line_content": "            paintable()->set_needs_display();",
          "content_same": false
        },
        {
          "line": 2639,
          "old_api": null,
          "new_api": "dir",
          "old_text": null,
          "new_text": "  // - FIXME: a bdi element\n        // - a script element\n        // - a style element\n        // - a textarea element\n        // - an element whose dir attribute is not in the undefined state\n        // then continue.\n        if (is<HTML::HTMLScriptElement>(descendant)\n            || is<HTML::HTMLStyleElement>(descendant)\n            || is<HTML::HTMLTextAreaElement>(descendant)\n            || (is<Element>(descendant) && static_cast<Element const&>(descendant).dir().has_value())) {\n            return TraversalDecision::SkipChildrenAndContinue;\n        }\n\n        // 2. If descendant is a slot element whose root is a shadow root, then return the directionality of that shadow root's host.\n        if (is<HTML::HTMLSlotElement>(descendant)) {\n            auto const& root = static_cast<HTML::HTMLSlotElement const&>(descendant).root();\n            if (root.is_shadow_root()) {\n                auto const& host = static_cast<ShadowRoot const&>(root).host();\n                VERIFY(host);\n                result = host->directionality();\n                return TraversalDecision::Break;\n            }\n        }\n\n        // 3. If descendant is not a Text node, then continue.\n        if (!descendant.is_text())\n            return TraversalDecision::Continue;\n\n        // 4. Let result be the text node directionality of descendant.\n        result = text_node_directionality(static_cast<Text const&>(descendant));\n\n        // 5. If result is not null, then return result.\n        if (result.has_value())\n            return TraversalDecision::Break;\n\n        return TraversalDecision::Continue;\n    });\n\n    if (result.has_value())\n        return result;\n\n    // 4. Return null.\n    return {};\n}\n\n// https://html.spec.whatwg.org/multipage/dom.html#parent-",
          "old_line_content": "        // - FIXME: a bdi element",
          "new_line_content": "    for_each_in_subtree([&](auto& descendant) {",
          "content_same": false
        },
        {
          "line": 593,
          "old_api": null,
          "new_api": "(pseudo_element_type);\n            if (",
          "old_text": null,
          "new_text": "(pseudo_element_type);\n            if (",
          "old_line_content": "                continue;",
          "new_line_content": "            auto pseudo_element = get_pseudo_element(pseudo_element_type);",
          "content_same": false
        },
        {
          "line": 594,
          "old_api": null,
          "new_api": "_value",
          "old_text": null,
          "new_text": "_value() || !pseudo_elemen",
          "old_line_content": "",
          "new_line_content": "            if (!pseudo_element.has_value() || !pseudo_element->layout_node)",
          "content_same": false
        },
        {
          "line": 597,
          "old_api": null,
          "new_api": "puted_css_values",
          "old_text": null,
          "new_text": "puted_css_values(pseudo_element_type);\n            if (",
          "old_line_content": "                continue;",
          "new_line_content": "            auto pseudo_element_style = pseudo_element_computed_css_values(pseudo_element_type);",
          "content_same": false
        },
        {
          "line": 2649,
          "old_api": null,
          "new_api": "return TraversalDecision::SkipChildr",
          "old_text": null,
          "new_text": "     return TraversalDecision::SkipChildr",
          "old_line_content": "            return TraversalDecision::SkipChildrenAndContinue;",
          "new_line_content": "            || is<HTML::HTMLTextAreaElement>(descendant)",
          "content_same": false
        },
        {
          "line": 2650,
          "old_api": null,
          "new_api": "escendant is a slot element whose root is a shadow root,",
          "old_text": null,
          "new_text": "escendant is a slot element whose root is a shadow root, ",
          "old_line_content": "        }",
          "new_line_content": "            || (is<Element>(descendant) && static_cast<Element const&>(descendant).dir().has_value())) {",
          "content_same": false
        },
        {
          "line": 603,
          "old_api": null,
          "new_api": "aintable",
          "old_text": null,
          "new_text": "aintable())\n                ",
          "old_line_content": "            }",
          "new_line_content": "                if (invalidation.repaint && node_with_style->paintable())",
          "content_same": false
        },
        {
          "line": 604,
          "old_api": null,
          "new_api": "set_needs_display",
          "old_text": null,
          "new_text": "aintable()->set_needs_display();\n            }\n  ",
          "old_line_content": "        }",
          "new_line_content": "                    node_with_style->paintable()->set_needs_display();",
          "content_same": false
        },
        {
          "line": 2659,
          "old_api": null,
          "new_api": "descendant i",
          "old_text": null,
          "new_text": "descendant i",
          "old_line_content": "                return TraversalDecision::Break;",
          "new_line_content": "                VERIFY(host);",
          "content_same": false
        },
        {
          "line": 2660,
          "old_api": null,
          "new_api": "tinue.\n        if (!de",
          "old_text": null,
          "new_text": "tinue.\n        if (!de",
          "old_line_content": "            }",
          "new_line_content": "                result = host->directionality();",
          "content_same": false
        },
        {
          "line": 614,
          "old_api": null,
          "new_api": "yleDeclaration::create(*this, type);\n    auto propert",
          "old_text": null,
          "new_text": "yleDeclaration::create(*this, type);\n    auto propert",
          "old_line_content": "",
          "new_line_content": "    auto element_computed_style = CSS::ResolvedCSSStyleDeclaration::create(*this, type);",
          "content_same": false
        },
        {
          "line": 2666,
          "old_api": null,
          "new_api": "ult = text_node_dire",
          "old_text": null,
          "new_text": "ult = text_node_dire",
          "old_line_content": "",
          "new_line_content": "        if (!descendant.is_text())",
          "content_same": false
        },
        {
          "line": 619,
          "old_api": null,
          "new_api": "property",
          "old_text": null,
          "new_text": "tyle->property(property_id);\n        if (!may",
          "old_line_content": "            continue;",
          "new_line_content": "        auto maybe_value = element_computed_style->property(property_id);",
          "content_same": false
        },
        {
          "line": 622,
          "old_api": null,
          "new_api": "e_value",
          "old_text": null,
          "new_text": "e_value().value);\n    }\n\n  ",
          "old_line_content": "",
          "new_line_content": "        properties->set_property(property_id, maybe_value.release_value().value);",
          "content_same": false
        },
        {
          "line": 2670,
          "old_api": null,
          "new_api": "salDecision::Break;\n\n        return",
          "old_text": null,
          "new_text": "salDecision::Break;\n\n        return ",
          "old_line_content": "        // 5. If result is not null, then return result.",
          "new_line_content": "        result = text_node_directionality(static_cast<Text const&>(descendant));",
          "content_same": false
        },
        {
          "line": 2673,
          "old_api": null,
          "new_api": "return result;",
          "old_text": null,
          "new_text": " return result;\n\n ",
          "old_line_content": "",
          "new_line_content": "        if (result.has_value())",
          "content_same": false
        },
        {
          "line": 2679,
          "old_api": null,
          "new_api": "ity\nElement::Direc",
          "old_text": null,
          "new_text": "ity\nElement::Direc",
          "old_line_content": "",
          "new_line_content": "    if (result.has_value())",
          "content_same": false
        },
        {
          "line": 632,
          "old_api": null,
          "new_api": "reset_animated_properties",
          "old_text": null,
          "new_text": "ues->reset_animated_properties();\n}\n\nDOMTokenList*",
          "old_line_content": "",
          "new_line_content": "    m_computed_css_values->reset_animated_properties();",
          "content_same": false
        },
        {
          "line": 638,
          "old_api": null,
          "new_api": "te",
          "old_text": null,
          "new_text": "te(*this, HTML::AttributeNames::class_);\n    return m_cla",
          "old_line_content": "}",
          "new_line_content": "        m_class_list = DOMTokenList::create(*this, HTML::AttributeNames::class_);",
          "content_same": false
        },
        {
          "line": 2690,
          "old_api": null,
          "new_api": "{\n        auto cons",
          "old_text": null,
          "new_text": "{\n        auto cons",
          "old_line_content": "    // 2. If parentNode is a shadow root, then return the directionality of parentNode's host.",
          "new_line_content": "    auto const* parent_node = this->parent_node();",
          "content_same": false
        },
        {
          "line": 2695,
          "old_api": null,
          "new_api": "s<Element>(p",
          "old_text": null,
          "new_text": "s<Element>(p",
          "old_line_content": "    }",
          "new_line_content": "        VERIFY(host);",
          "content_same": false
        },
        {
          "line": 648,
          "old_api": null,
          "new_api": "tom_element_name",
          "old_text": null,
          "new_text": "tom_element_name(name)\n        && !name.",
          "old_line_content": "        return false;",
          "new_line_content": "    if (!HTML::is_valid_custom_element_name(name)",
          "content_same": false
        },
        {
          "line": 649,
          "old_api": null,
          "new_api": "ticle\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\")) {\n        return",
          "old_text": null,
          "new_text": "ticle\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\")) {\n        return",
          "old_line_content": "    }",
          "new_line_content": "        && !name.is_one_of(\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\")) {",
          "content_same": false
        },
        {
          "line": 2696,
          "old_api": null,
          "new_api": "return static_cast",
          "old_text": null,
          "new_text": "    return static_cast",
          "old_line_content": "",
          "new_line_content": "        return host->directionality();",
          "content_same": false
        },
        {
          "line": 2700,
          "old_api": null,
          "new_api": "tr;\n}\n\n// https://dom.sp",
          "old_text": null,
          "new_text": "tr;\n}\n\n// https://dom.sp",
          "old_line_content": "",
          "new_line_content": "    if (is<Element>(parent_node))",
          "content_same": false
        },
        {
          "line": 2701,
          "old_api": null,
          "new_api": "f-for-concept-element-attributes-change-ext\nvoid Element:",
          "old_text": null,
          "new_text": "f-for-concept-element-attributes-change-ext\nvoid Element:",
          "old_line_content": "    // 4. Return 'ltr'.",
          "new_line_content": "        return static_cast<Element const&>(*parent_node).directionality();",
          "content_same": false
        },
        {
          "line": 659,
          "old_api": null,
          "new_api": "amespace::HTML)",
          "old_text": null,
          "new_text": "amespace::HTML)",
          "old_line_content": "",
          "new_line_content": "    if (namespace_uri() != Namespace::HTML)",
          "content_same": false
        },
        {
          "line": 660,
          "old_api": null,
          "new_api": "namespa",
          "old_text": null,
          "new_text": "namespa",
          "old_line_content": "    // 2. If elements local name is not a valid shadow host name, then throw a \"NotSupportedError\" DOMException.",
          "new_line_content": "        return WebIDL::NotSupportedError::create(realm(), \"Element's namespace is not the HTML namespace\"_fly_string);",
          "content_same": false
        },
        {
          "line": 663,
          "old_api": null,
          "new_api": "return WebI",
          "old_text": null,
          "new_text": " return WebI",
          "old_line_content": "",
          "new_line_content": "    if (!is_valid_shadow_host_name(local_name()))",
          "content_same": false
        },
        {
          "line": 664,
          "old_api": null,
          "new_api": "cal nam",
          "old_text": null,
          "new_text": "cal nam",
          "old_line_content": "    // 3. If elements local name is a valid custom element name, or elements is value is not null, then:",
          "new_line_content": "        return WebIDL::NotSupportedError::create(realm(), \"Element's local name is not a valid shadow host name\"_fly_string);",
          "content_same": false
        },
        {
          "line": 2711,
          "old_api": null,
          "new_api": "ll and oldValue is the",
          "old_text": null,
          "new_text": "ll and oldValue is the",
          "old_line_content": "        if (value == old_value)",
          "new_line_content": "    if (local_name == HTML::AttributeNames::slot && !namespace_.has_value()) {",
          "content_same": false
        },
        {
          "line": 669,
          "old_api": null,
          "new_api": "// 2",
          "old_text": null,
          "new_text": "        // 2",
          "old_line_content": "        // 2. If definition is not null and definitions disable shadow is true, then throw a \"NotSupportedError\" DOMException.",
          "new_line_content": "        auto definition = document().lookup_custom_element_definition(namespace_uri(), local_name(), m_is_value);",
          "content_same": false
        },
        {
          "line": 2717,
          "old_api": null,
          "new_api": "value == String {",
          "old_text": null,
          "new_text": "value == String {",
          "old_line_content": "",
          "new_line_content": "        if (!value.has_value() && old_value == String {})",
          "content_same": false
        },
        {
          "line": 672,
          "old_api": null,
          "new_api": "return WebIDL::N",
          "old_text": null,
          "new_text": "            return WebIDL::N",
          "old_line_content": "    }",
          "new_line_content": "        if (definition && definition->disable_shadow())",
          "content_same": false
        },
        {
          "line": 673,
          "old_api": null,
          "new_api": "ow root",
          "old_text": null,
          "new_text": "ow root",
          "old_line_content": "",
          "new_line_content": "            return WebIDL::NotSupportedError::create(realm(), \"Cannot attach a shadow root to a custom element that has disabled shadow roots\"_fly_string);",
          "content_same": false
        },
        {
          "line": 2721,
          "old_api": null,
          "new_api": "has_value",
          "old_text": null,
          "new_text": "lue.has_value() || va",
          "old_line_content": "",
          "new_line_content": "        if (value == String {} && !old_value.has_value())",
          "content_same": false
        },
        {
          "line": 2725,
          "old_api": null,
          "new_api": "e);\n\n        // 6",
          "old_text": null,
          "new_text": "e);\n\n        // 6",
          "old_line_content": "        // 5. Otherwise, set elements name to value.",
          "new_line_content": "        if (!value.has_value() || value->is_empty())",
          "content_same": false
        },
        {
          "line": 2726,
          "old_api": null,
          "new_api": "s assigned, then run a",
          "old_text": null,
          "new_text": "s assigned, then run a",
          "old_line_content": "        else",
          "new_line_content": "            set_slottable_name({});",
          "content_same": false
        },
        {
          "line": 679,
          "old_api": null,
          "new_api": "any of the f",
          "old_text": null,
          "new_text": " any of the f",
          "old_line_content": "        // 2. If any of the following are true:",
          "new_line_content": "        auto current_shadow_root = shadow_root();",
          "content_same": false
        },
        {
          "line": 2729,
          "old_api": null,
          "new_api": "gned_slot_internal",
          "old_text": null,
          "new_text": "gned_slot_internal())\n    ",
          "old_line_content": "        // 6. If element is assigned, then run assign slottables for elements assigned slot.",
          "new_line_content": "            set_slottable_name(*value);",
          "content_same": false
        },
        {
          "line": 2732,
          "old_api": null,
          "new_api": "his });\n    }\n}\n\nauto El",
          "old_text": null,
          "new_text": "his });\n    }\n}\n\nauto El",
          "old_line_content": "",
          "new_line_content": "        if (auto assigned_slot = assigned_slot_internal())",
          "content_same": false
        },
        {
          "line": 685,
          "old_api": null,
          "new_api": "{\n            return WebID",
          "old_text": null,
          "new_text": " {\n            return WebID",
          "old_line_content": "        }",
          "new_line_content": "        if (!current_shadow_root->declarative() || current_shadow_root->mode() != mode) {",
          "content_same": false
        },
        {
          "line": 686,
          "old_api": null,
          "new_api": "w host\"",
          "old_text": null,
          "new_text": "w host\"",
          "old_line_content": "",
          "new_line_content": "            return WebIDL::NotSupportedError::create(realm(), \"Element already is a shadow host\"_fly_string);",
          "content_same": false
        },
        {
          "line": 2733,
          "old_api": null,
          "new_api": "custom_element_reaction_queue",
          "old_text": null,
          "new_text": "custom_element_reaction_queue() -",
          "old_line_content": "        // 7. Run assign a slot for element.",
          "new_line_content": "            assign_slottables(*assigned_slot);",
          "content_same": false
        },
        {
          "line": 2736,
          "old_api": null,
          "new_api": "t_reaction_queue)\n        m_custom_elemen",
          "old_text": null,
          "new_text": "t_reaction_queue)\n        m_custom_elemen",
          "old_line_content": "}",
          "new_line_content": "        assign_a_slot(JS::NonnullGCPtr { *this });",
          "content_same": false
        },
        {
          "line": 691,
          "old_api": null,
          "new_api": "en",
          "old_text": null,
          "new_text": "en();\n\n        //    2. Set currentShadowR",
          "old_line_content": "        //    2. Set currentShadowRoots declarative to false.",
          "new_line_content": "        current_shadow_root->remove_all_children();",
          "content_same": false
        },
        {
          "line": 694,
          "old_api": null,
          "new_api": "se);\n\n        //    3. Return.\n        retu",
          "old_text": null,
          "new_text": "se);\n\n        //    3. Return.\n        retu",
          "old_line_content": "        //    3. Return.",
          "new_line_content": "        current_shadow_root->set_declarative(false);",
          "content_same": false
        },
        {
          "line": 2743,
          "old_api": null,
          "new_api": "o& root_node = root();\n    if (is<",
          "old_text": null,
          "new_text": "o& root_node = root();\n    if (is<",
          "old_line_content": "}",
          "new_line_content": "        m_custom_element_reaction_queue = make<CustomElementReactionQueue>();",
          "content_same": false
        },
        {
          "line": 701,
          "old_api": null,
          "new_api": "hadows de",
          "old_text": null,
          "new_text": "hadows de",
          "old_line_content": "    // 6. Set shadows delegates focus to delegatesFocus\".",
          "new_line_content": "    auto shadow = heap().allocate<ShadowRoot>(realm(), document(), *this, mode);",
          "content_same": false
        },
        {
          "line": 2750,
          "old_api": null,
          "new_api": "spec.whatwg.org/#dom-element-g",
          "old_text": null,
          "new_text": "spec.whatwg.org/#dom-element-g",
          "old_line_content": "",
          "new_line_content": "    if (is<DOM::ShadowRoot>(root_node))",
          "content_same": false
        },
        {
          "line": 704,
          "old_api": null,
          "new_api": ";\n\n    // 7. If elements custom element sta",
          "old_text": null,
          "new_text": ";\n\n    // 7. If elements custom element sta",
          "old_line_content": "    // 7. If elements custom element state is \"precustomized\" or \"custom\", then set shadows available to element internals to true.",
          "new_line_content": "    shadow->set_delegates_focus(delegates_focus);",
          "content_same": false
        },
        {
          "line": 2753,
          "old_api": null,
          "new_api": "nst\n{\n    // Element's ge",
          "old_text": null,
          "new_text": "nst\n{\n    // Element's ge",
          "old_line_content": "",
          "new_line_content": "    return document().style_sheets();",
          "content_same": false
        },
        {
          "line": 708,
          "old_api": null,
          "new_api": ";\n\n    // 8. Set shadows slot assignment to slo",
          "old_text": null,
          "new_text": ";\n\n    // 8. Set shadows slot assignment to slo",
          "old_line_content": "    // 8. Set shadows slot assignment to slotAssignment.",
          "new_line_content": "        shadow->set_available_to_element_internals(true);",
          "content_same": false
        },
        {
          "line": 711,
          "old_api": null,
          "new_api": "// 9. Set shadows declarative to false.",
          "old_text": null,
          "new_text": " // 9. Set shadows declarative to false.\n  ",
          "old_line_content": "    // 9. Set shadows declarative to false.",
          "new_line_content": "    shadow->set_slot_assignment(slot_assignment);",
          "content_same": false
        },
        {
          "line": 714,
          "old_api": null,
          "new_api": "ows clonable to clonable.",
          "old_text": null,
          "new_text": "ows clonable to clonable.\n   ",
          "old_line_content": "    // 10. Set shadows clonable to clonable.",
          "new_line_content": "    shadow->set_declarative(false);",
          "content_same": false
        },
        {
          "line": 2762,
          "old_api": null,
          "new_api": "arser::SerializableShadowRoots::No,\n        options.shadow_roots);\n}\n\n// https://html.spec.whatwg.org/#dom-element-sethtmlunsafe\nWebIDL::ExceptionOr<void> Element::set_html_unsafe(StringView html)\n{\n    // FIXME: 1. Let complia",
          "old_text": null,
          "new_text": "arser::SerializableShadowRoots::No,\n        options.shadow_roots);\n}\n\n// https://html.spec.whatwg.org/#dom-element-sethtmlunsafe\nWebIDL::ExceptionOr<void> Element::set_html_unsafe(StringView html)\n{\n    // FIXME: 1. Let complia",
          "old_line_content": "        options.serializable_shadow_roots ? HTML::HTMLParser::SerializableShadowRoots::Yes : HTML::HTMLParser::SerializableShadowRoots::No,",
          "new_line_content": "    return HTML::HTMLParser::serialize_html_fragment(",
          "content_same": false
        },
        {
          "line": 717,
          "old_api": null,
          "new_api": "s serializable to serializabl",
          "old_text": null,
          "new_text": "s serializable to serializabl",
          "old_line_content": "    // 11. Set shadows serializable to serializable.",
          "new_line_content": "    shadow->set_clonable(clonable);",
          "content_same": false
        },
        {
          "line": 720,
          "old_api": null,
          "new_api": "elements shadow root to shadow.\n    s",
          "old_text": null,
          "new_text": "elements shadow root to shadow.\n    s",
          "old_line_content": "    // 12. Set elements shadow root to shadow.",
          "new_line_content": "    shadow->set_serializable(serializable);",
          "content_same": false
        },
        {
          "line": 723,
          "old_api": null,
          "new_api": "spec.whatwg.org/#dom-el",
          "old_text": null,
          "new_text": "spec.whatwg.org/#dom-el",
          "old_line_content": "}",
          "new_line_content": "    set_shadow_root(shadow);",
          "content_same": false
        },
        {
          "line": 2775,
          "old_api": null,
          "new_api": "s, and compliantHTML. FIXME: Use com",
          "old_text": null,
          "new_text": "s, and compliantHTML. FIXME: Use com",
          "old_line_content": "",
          "new_line_content": "    if (is<HTML::HTMLTemplateElement>(*this))",
          "content_same": false
        },
        {
          "line": 2776,
          "old_api": null,
          "new_api": "unsafely_set_html",
          "old_text": null,
          "new_text": "(target->unsafely_set_html(*this, html));\n\n    return {};\n}\n\n",
          "old_line_content": "    // 3. Unsafe set HTML given target, this, and compliantHTML. FIXME: Use compliantHTML.",
          "new_line_content": "        target = verify_cast<HTML::HTMLTemplateElement>(*this).content().ptr();",
          "content_same": false
        },
        {
          "line": 731,
          "old_api": null,
          "new_api": "izable, init.delegates_focus, init.slot_assignment));\n\n    // 2. Return thiss shadow root.\n    return JS::No",
          "old_text": null,
          "new_text": "izable, init.delegates_focus, init.slot_assignment));\n\n    // 2. Return thiss shadow root.\n    return JS::No",
          "old_line_content": "    // 2. Return thiss shadow root.",
          "new_line_content": "    TRY(attach_a_shadow_root(init.mode, init.clonable, init.serializable, init.delegates_focus, init.slot_assignment));",
          "content_same": false
        },
        {
          "line": 2779,
          "old_api": null,
          "new_api": ";\n    return *m_counters_set;\n}\n\nCSS::",
          "old_text": null,
          "new_text": ";\n    return *m_counters_set;\n}\n\nCSS::",
          "old_line_content": "    return {};",
          "new_line_content": "    TRY(target->unsafely_set_html(*this, html));",
          "content_same": false
        },
        {
          "line": 734,
          "old_api": null,
          "new_api": "ent-shadowroo",
          "old_text": null,
          "new_text": "ent-shadowroo",
          "old_line_content": "",
          "new_line_content": "    return JS::NonnullGCPtr { *shadow_root() };",
          "content_same": false
        },
        {
          "line": 744,
          "old_api": null,
          "new_api": "turn nullptr;",
          "old_text": null,
          "new_text": "turn nullptr;\n",
          "old_line_content": "",
          "new_line_content": "    if (shadow == nullptr || shadow->mode() == Bindings::ShadowRootMode::Closed)",
          "content_same": false
        },
        {
          "line": 2794,
          "old_api": null,
          "new_api": "es& style)\n{\n    // Reso",
          "old_text": null,
          "new_text": "es& style)\n{\n    // Reso",
          "old_line_content": "}",
          "new_line_content": "        m_counters_set = make<CSS::CountersSet>();",
          "content_same": false
        },
        {
          "line": 755,
          "old_api": null,
          "new_api": "failure, then throw a \"Synt",
          "old_text": null,
          "new_text": "failure, then throw a \"Synt",
          "old_line_content": "    // 2. If s is failure, then throw a \"SyntaxError\" DOMException.",
          "new_line_content": "    auto maybe_selectors = parse_selector(CSS::Parser::ParsingContext(static_cast<ParentNode&>(const_cast<Element&>(*this))), selectors);",
          "content_same": false
        },
        {
          "line": 2804,
          "old_api": null,
          "new_api": "ith display set to",
          "old_text": null,
          "new_text": "ith display set to",
          "old_line_content": "    // https://drafts.csswg.org/css-lists-3/#counters-without-boxes",
          "new_line_content": "    inherit_counters();",
          "content_same": false
        },
        {
          "line": 758,
          "old_api": null,
          "new_api": "r::create(realm(), \"Failed",
          "old_text": null,
          "new_text": "r::create(realm(), \"Failed ",
          "old_line_content": "",
          "new_line_content": "    if (!maybe_selectors.has_value())",
          "content_same": false
        },
        {
          "line": 759,
          "old_api": null,
          "new_api": "the re",
          "old_text": null,
          "new_text": " the re",
          "old_line_content": "    // 3. If the result of match a selector against an element, using s, this, and scoping root this, returns success, then return true; otherwise, return false.",
          "new_line_content": "        return WebIDL::SyntaxError::create(realm(), \"Failed to parse selector\"_fly_string);",
          "content_same": false
        },
        {
          "line": 2810,
          "old_api": null,
          "new_api": "CounterReset);\n    for (a",
          "old_text": null,
          "new_text": "CounterReset);\n    for (a",
          "old_line_content": "",
          "new_line_content": "    if (style.display().is_none())",
          "content_same": false
        },
        {
          "line": 764,
          "old_api": null,
          "new_api": ";\n    }\n    return false;\n}\n\n// http",
          "old_text": null,
          "new_text": ";\n    }\n    return false;\n}\n\n// http",
          "old_line_content": "    }",
          "new_line_content": "        if (SelectorEngine::matches(s, {}, *this, nullptr, {}, static_cast<ParentNode const*>(this)))",
          "content_same": false
        },
        {
          "line": 2816,
          "old_api": null,
          "new_api": "SS::Propert",
          "old_text": null,
          "new_text": "SS::Propert",
          "old_line_content": "    // 3. Counter values are incremented (counter-increment).",
          "new_line_content": "        ensure_counters_set().instantiate_a_counter(counter.name, unique_id(), counter.is_reversed, counter.value);",
          "content_same": false
        },
        {
          "line": 2821,
          "old_api": null,
          "new_api": "for (au",
          "old_text": null,
          "new_text": "    for (au",
          "old_line_content": "    // 4. Counter values are explicitly set (counter-set).",
          "new_line_content": "        ensure_counters_set().increment_a_counter(counter.name, unique_id(), *counter.value);",
          "content_same": false
        },
        {
          "line": 774,
          "old_api": null,
          "new_api": "failure, then throw a \"Synt",
          "old_text": null,
          "new_text": "failure, then throw a \"Synt",
          "old_line_content": "    // 2. If s is failure, then throw a \"SyntaxError\" DOMException.",
          "new_line_content": "    auto maybe_selectors = parse_selector(CSS::Parser::ParsingContext(static_cast<ParentNode&>(const_cast<Element&>(*this))), selectors);",
          "content_same": false
        },
        {
          "line": 777,
          "old_api": null,
          "new_api": "r::create(realm(), \"Failed",
          "old_text": null,
          "new_text": "r::create(realm(), \"Failed ",
          "old_line_content": "",
          "new_line_content": "    if (!maybe_selectors.has_value())",
          "content_same": false
        },
        {
          "line": 778,
          "old_api": null,
          "new_api": "ches_se",
          "old_text": null,
          "new_text": "ches_se",
          "old_line_content": "    auto matches_selectors = [this](CSS::SelectorList const& selector_list, Element const* element) {",
          "new_line_content": "        return WebIDL::SyntaxError::create(realm(), \"Failed to parse selector\"_fly_string);",
          "content_same": false
        },
        {
          "line": 2826,
          "old_api": null,
          "new_api": "ttps://draf",
          "old_text": null,
          "new_text": "ttps://draf",
          "old_line_content": "    // 5. Counter values are used (counter()/counters()).",
          "new_line_content": "        ensure_counters_set().set_a_counter(counter.name, unique_id(), *counter.value);",
          "content_same": false
        },
        {
          "line": 783,
          "old_api": null,
          "new_api": "his))\n                return true;\n        }\n        return false;",
          "old_text": null,
          "new_text": "his))\n                return true;\n        }\n        return false;",
          "old_line_content": "        }",
          "new_line_content": "            if (SelectorEngine::matches(selector, {}, *element, nullptr, {}, this))",
          "content_same": false
        },
        {
          "line": 789,
          "old_api": null,
          "new_api": "iss inclusive ancestors that a",
          "old_text": null,
          "new_text": "iss inclusive ancestors that a",
          "old_line_content": "    // 3. Let elements be thiss inclusive ancestors that are elements, in reverse tree order.",
          "new_line_content": "    auto const selector_list = maybe_selectors.release_value();",
          "content_same": false
        },
        {
          "line": 2837,
          "old_api": null,
          "new_api": "tr;\n        retu",
          "old_text": null,
          "new_text": "tr;\n        retu",
          "old_line_content": "        // NOTE: We represent an empty counters set with `m_counters_set = nullptr`.",
          "new_line_content": "    auto* parent = parent_element();",
          "content_same": false
        },
        {
          "line": 792,
          "old_api": null,
          "new_api": "ctor_list, element))",
          "old_text": null,
          "new_text": "ctor_list, element))\n    ",
          "old_line_content": "            continue;",
          "new_line_content": "    for (auto* element = this; element; element = element->parent_element()) {",
          "content_same": false
        },
        {
          "line": 793,
          "old_api": null,
          "new_api": "return element;\n    }\n\n    // 5",
          "old_text": null,
          "new_text": "\n\n        return element;\n    }\n\n    // 5",
          "old_line_content": "",
          "new_line_content": "        if (!matches_selectors(selector_list, element))",
          "content_same": false
        },
        {
          "line": 2854,
          "old_api": null,
          "new_api": "eceding sibling (if it h",
          "old_text": null,
          "new_text": "eceding sibling (if it h",
          "old_line_content": "    }",
          "new_line_content": "        element_counters = make<CSS::CountersSet>();",
          "content_same": false
        },
        {
          "line": 2855,
          "old_api": null,
          "new_api": "CSS counters set otherwise.",
          "old_text": null,
          "new_text": "CSS counters set otherwise.\n    ",
          "old_line_content": "",
          "new_line_content": "        *element_counters = *parent_element()->counters_set();",
          "content_same": false
        },
        {
          "line": 812,
          "old_api": null,
          "new_api": ". If context is a template element, then set context",
          "old_text": null,
          "new_text": ". If context is a template element, then set context",
          "old_line_content": "    // 4. If context is a template element, then set context to the template element's template contents (a DocumentFragment).",
          "new_line_content": "    auto fragment = TRY(verify_cast<Element>(*context).parse_fragment(value));",
          "content_same": false
        },
        {
          "line": 815,
          "old_api": null,
          "new_api": "y_cast<HTML::HTMLTemplateElement>(*cont",
          "old_text": null,
          "new_text": "y_cast<HTML::HTMLTemplateElement>(*cont",
          "old_line_content": "",
          "new_line_content": "    if (is<HTML::HTMLTemplateElement>(*context))",
          "content_same": false
        },
        {
          "line": 816,
          "old_api": null,
          "new_api": "// 5. Replace all with fragment within context.\n    conte",
          "old_text": null,
          "new_text": " // 5. Replace all with fragment within context.\n    conte",
          "old_line_content": "    // 5. Replace all with fragment within context.",
          "new_line_content": "        context = verify_cast<HTML::HTMLTemplateElement>(*context).content();",
          "content_same": false
        },
        {
          "line": 2866,
          "old_api": null,
          "new_api": "be the CSS counters set of the element immediately preceding eleme",
          "old_text": null,
          "new_text": "be the CSS counters set of the element immediately preceding eleme",
          "old_line_content": "        }",
          "new_line_content": "            if (!element_counters->last_counter_with_name(counter.name).has_value())",
          "content_same": false
        },
        {
          "line": 819,
          "old_api": null,
          "new_api": "e style & layout for <template",
          "old_text": null,
          "new_text": "e style & layout for <template",
          "old_line_content": "    // NOTE: We don't invalidate style & layout for <template> elements since they don't affect rendering.",
          "new_line_content": "    context->replace_all(fragment);",
          "content_same": false
        },
        {
          "line": 2867,
          "old_api": null,
          "new_api": "//    For each source counter of v",
          "old_text": null,
          "new_text": "    //    For each source counter of v",
          "old_line_content": "    }",
          "new_line_content": "                element_counters->append_copy(counter);",
          "content_same": false
        },
        {
          "line": 822,
          "old_api": null,
          "new_api": "needs_style_update",
          "old_text": null,
          "new_text": "needs_style_update(true);\n\n        if (",
          "old_line_content": "",
          "new_line_content": "    if (!is<HTML::HTMLTemplateElement>(*context)) {",
          "content_same": false
        },
        {
          "line": 2874,
          "old_api": null,
          "new_api": "nters) {\n            auto& value_sourc",
          "old_text": null,
          "new_text": "nters) {\n            auto& value_sourc",
          "old_line_content": "        if (element_counters) {",
          "new_line_content": "    if (auto* const previous = previous_element_in_pre_order(); previous && previous->has_non_empty_counters_set()) {",
          "content_same": false
        },
        {
          "line": 827,
          "old_api": null,
          "new_api": "turn {};\n}\n\n// https://html.spec.whatwg",
          "old_text": null,
          "new_text": "turn {};\n}\n\n// https://html.spec.whatwg",
          "old_line_content": "    }",
          "new_line_content": "            context->document().invalidate_layout();",
          "content_same": false
        },
        {
          "line": 2879,
          "old_api": null,
          "new_api": "maybe_existing_counter->value = source_counter.value;\n            }\n        }\n    }\n\n    VER",
          "old_text": null,
          "new_text": "                    maybe_existing_counter->value = source_counter.value;\n            }\n        }\n    }\n\n    VER",
          "old_line_content": "                    maybe_existing_counter->value = source_counter.value;",
          "new_line_content": "                auto maybe_existing_counter = element_counters->counter_with_same_name_and_creator(source_counter.name, source_counter.originating_element_id);",
          "content_same": false
        },
        {
          "line": 2880,
          "old_api": null,
          "new_api": "is_empty",
          "old_text": null,
          "new_text": "|| !element_counters->is_empty());",
          "old_line_content": "            }",
          "new_line_content": "                if (maybe_existing_counter.has_value())",
          "content_same": false
        },
        {
          "line": 837,
          "old_api": null,
          "new_api": "Element::is_focused() const\n{\n    return document().fo",
          "old_text": null,
          "new_text": "Element::is_focused() const\n{\n    return document().fo",
          "old_line_content": "",
          "new_line_content": "    return serialize_fragment(DOMParsing::RequireWellFormed::Yes);",
          "content_same": false
        },
        {
          "line": 2886,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "}",
          "new_line_content": "    VERIFY(!element_counters || !element_counters->is_empty());",
          "content_same": false
        },
        {
          "line": 2887,
          "old_api": null,
          "new_api": "",
          "old_text": null,
          "new_text": "",
          "old_line_content": "",
          "new_line_content": "    m_counters_set = move(element_counters);",
          "content_same": false
        },
        {
          "line": 842,
          "old_api": null,
          "new_api": "() const\n{\n    return docume",
          "old_text": null,
          "new_text": "() const\n{\n    return docume",
          "old_line_content": "",
          "new_line_content": "    return document().focused_element() == this;",
          "content_same": false
        },
        {
          "line": 847,
          "old_api": null,
          "new_api": ") const\n{\n    return docume",
          "old_text": null,
          "new_text": ") const\n{\n    return docume",
          "old_line_content": "",
          "new_line_content": "    return document().active_element() == this;",
          "content_same": false
        },
        {
          "line": 852,
          "old_api": null,
          "new_api": "wg.org/#document-element\nbo",
          "old_text": null,
          "new_text": "wg.org/#document-element\nbo",
          "old_line_content": "",
          "new_line_content": "    return document().target_element() == this;",
          "content_same": false
        },
        {
          "line": 859,
          "old_api": null,
          "new_api": "st\nbool El",
          "old_text": null,
          "new_text": "st\nbool El",
          "old_line_content": "",
          "new_line_content": "    return parent() == &document();",
          "content_same": false
        },
        {
          "line": 874,
          "old_api": null,
          "new_api": "w_root);\n    if (m_shadow_root)",
          "old_text": null,
          "new_text": "w_root);\n    if (m_shadow_root)\n",
          "old_line_content": "    if (m_shadow_root)",
          "new_line_content": "        m_shadow_root->set_host(nullptr);",
          "content_same": false
        },
        {
          "line": 877,
          "old_api": null,
          "new_api": "SSStyleDeclaration* Element::",
          "old_text": null,
          "new_text": "SSStyleDeclaration* Element::",
          "old_line_content": "}",
          "new_line_content": "        m_shadow_root->set_host(this);",
          "content_same": false
        },
        {
          "line": 878,
          "old_api": null,
          "new_api": "for_bindings",
          "old_text": null,
          "new_text": "for_bindings()\n{\n ",
          "old_line_content": "",
          "new_line_content": "    invalidate_style();",
          "content_same": false
        },
        {
          "line": 884,
          "old_api": null,
          "new_api": "return m_inline_style;\n}\n\n// https://dom.spec.whatwg.org/#",
          "old_text": null,
          "new_text": "  return m_inline_style;\n}\n\n// https://dom.spec.whatwg.org/#",
          "old_line_content": "}",
          "new_line_content": "        m_inline_style = CSS::ElementInlineCSSStyleDeclaration::create(*this, {}, {});",
          "content_same": false
        },
        {
          "line": 892,
          "old_api": null,
          "new_api": "ml_uppercased_qualified_na",
          "old_text": null,
          "new_text": "ml_uppercased_qualified_na",
          "old_line_content": "    else",
          "new_line_content": "    if (namespace_uri() == Namespace::HTML && document().document_type() == Document::Type::HTML)",
          "content_same": false
        },
        {
          "line": 895,
          "old_api": null,
          "new_api": "ebappapis.html#q",
          "old_text": null,
          "new_text": "ebappapis.html#q",
          "old_line_content": "",
          "new_line_content": "        m_html_uppercased_qualified_name = qualified_name();",
          "content_same": false
        },
        {
          "line": 901,
          "old_api": null,
          "new_api": "ax.html#voi",
          "old_text": null,
          "new_text": "ax.html#voi",
          "old_line_content": "",
          "new_line_content": "    return queue_a_task(source, HTML::main_thread_event_loop(), document(), JS::create_heap_function(heap(), move(steps)));",
          "content_same": false
        },
        {
          "line": 907,
          "old_api": null,
          "new_api": "e, HTML::TagNames::br, HTML::TagNames::col, HTML::TagNames::embed, HTML::TagNames::hr, HTML::TagNames::img, HTML::TagNames::input, HTML::TagNames::link, HTML::TagNames::meta, HTML::TagNames::param, HTML::TagNames::source, HTML::TagNames::track, HTML::TagNames::wbr);\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#seri",
          "old_text": null,
          "new_text": "e, HTML::TagNames::br, HTML::TagNames::col, HTML::TagNames::embed, HTML::TagNames::hr, HTML::TagNames::img, HTML::TagNames::input, HTML::TagNames::link, HTML::TagNames::meta, HTML::TagNames::param, HTML::TagNames::source, HTML::TagNames::track, HTML::TagNames::wbr);\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#seri",
          "old_line_content": "",
          "new_line_content": "    return local_name().is_one_of(HTML::TagNames::area, HTML::TagNames::base, HTML::TagNames::br, HTML::TagNames::col, HTML::TagNames::embed, HTML::TagNames::hr, HTML::TagNames::img, HTML::TagNames::input, HTML::TagNames::link, HTML::TagNames::meta, HTML::TagNames::param, HTML::TagNames::source, HTML::TagNames::track, HTML::TagNames::wbr);",
          "content_same": false
        },
        {
          "line": 913,
          "old_api": null,
          "new_api": ":bgsound, HTML::TagNames::frame, HTML::TagNames::keygen);\n}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-getboun",
          "old_text": null,
          "new_text": ":bgsound, HTML::TagNames::frame, HTML::TagNames::keygen);\n}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-getboun",
          "old_line_content": "",
          "new_line_content": "    return is_void_element() || local_name().is_one_of(HTML::TagNames::basefont, HTML::TagNames::bgsound, HTML::TagNames::frame, HTML::TagNames::keygen);",
          "content_same": false
        },
        {
          "line": 920,
          "old_api": null,
          "new_api": "Rect object whose",
          "old_text": null,
          "new_text": "Rect object whose ",
          "old_line_content": "    // 2. If the list is empty return a DOMRect object whose x, y, width and height members are zero.",
          "new_line_content": "    auto list = get_client_rects();",
          "content_same": false
        },
        {
          "line": 923,
          "old_api": null,
          "new_api": "_impl",
          "old_text": null,
          "new_text": "_impl(realm(),",
          "old_line_content": "",
          "new_line_content": "    if (list->length() == 0)",
          "content_same": false
        },
        {
          "line": 924,
          "old_api": null,
          "new_api": "rors",
          "old_text": null,
          "new_text": "rors();",
          "old_line_content": "    // 3. If all rectangles in list have zero width or height, return the first rectangle in list.",
          "new_line_content": "        return Geometry::DOMRect::construct_impl(realm(), 0, 0, 0, 0).release_value_but_fixme_should_propagate_errors();",
          "content_same": false
        },
        {
          "line": 929,
          "old_api": null,
          "new_api": "!= 0) {",
          "old_text": null,
          "new_text": "!= 0) {\n     ",
          "old_line_content": "            all_rectangle_has_zero_width_or_height = false;",
          "new_line_content": "        auto const& rect = list->item(i);",
          "content_same": false
        },
        {
          "line": 930,
          "old_api": null,
          "new_api": "or_height = fa",
          "old_text": null,
          "new_text": "or_height = fa",
          "old_line_content": "            break;",
          "new_line_content": "        if (rect->width() != 0 && rect->height() != 0) {",
          "content_same": false
        },
        {
          "line": 936,
          "old_api": null,
          "new_api": "describing th",
          "old_text": null,
          "new_text": "describing th",
          "old_line_content": "    // 4. Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in",
          "new_line_content": "        return JS::NonnullGCPtr { *const_cast<Geometry::DOMRect*>(list->item(0)) };",
          "content_same": false
        },
        {
          "line": 943,
          "old_api": null,
          "new_api": "== 0)",
          "old_text": null,
          "new_text": "== 0)\n       ",
          "old_line_content": "            continue;",
          "new_line_content": "        auto const& rect = list->item(i);",
          "content_same": false
        },
        {
          "line": 948,
          "old_api": null,
          "new_api": "cssom-view/#dom-element-getcli",
          "old_text": null,
          "new_text": "cssom-view/#dom-element-getcli",
          "old_line_content": "",
          "new_line_content": "    return Geometry::DOMRect::create(realm(), bounding_rect.to_type<float>());",
          "content_same": false
        },
        {
          "line": 957,
          "old_api": null,
          "new_api": "it was inv",
          "old_text": null,
          "new_text": "it was inv",
          "old_line_content": "    // 1. If the element on which it was invoked does not have an associated layout box return an empty DOMRectList",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 961,
          "old_api": null,
          "new_api": "m",
          "old_text": null,
          "new_text": "m(), move(rec",
          "old_line_content": "",
          "new_line_content": "    if (!layout_node())",
          "content_same": false
        },
        {
          "line": 962,
          "old_api": null,
          "new_api": "SVG layout",
          "old_text": null,
          "new_text": " SVG layout",
          "old_line_content": "    // FIXME: 2. If the element has an associated SVG layout box return a DOMRectList object containing a single",
          "new_line_content": "        return Geometry::DOMRectList::create(realm(), move(rects));",
          "content_same": false
        },
        {
          "line": 977,
          "old_api": null,
          "new_api": "t_scroll_offset",
          "old_text": null,
          "new_text": "t_scroll_offset()",
          "old_line_content": "",
          "new_line_content": "    VERIFY(navigable);",
          "content_same": false
        },
        {
          "line": 978,
          "old_api": null,
          "new_api": "transforms are resolved before it",
          "old_text": null,
          "new_text": " transforms are resolved before it ",
          "old_line_content": "    // NOTE: Make sure CSS transforms are resolved before it is used to calculate the rect position.",
          "new_line_content": "    auto viewport_offset = navigable->viewport_scroll_offset();",
          "content_same": false
        },
        {
          "line": 981,
          "old_api": null,
          "new_api": "Gfx:",
          "old_text": null,
          "new_text": "\n\n    Gfx:",
          "old_line_content": "    Gfx::AffineTransform transform;",
          "new_line_content": "    const_cast<Document&>(document()).update_paint_and_hit_testing_properties_if_needed();",
          "content_same": false
        },
        {
          "line": 990,
          "old_api": null,
          "new_api": "translate_by",
          "old_text": null,
          "new_text": "scroll_offset.translate_by(co",
          "old_line_content": "        }",
          "new_line_content": "            transform = Gfx::extract_2d_affine_transform(containing_block->transform()).multiply(transform);",
          "content_same": false
        },
        {
          "line": 991,
          "old_api": null,
          "new_api": "lute_rect = paintable_box->absolu",
          "old_text": null,
          "new_text": "lute_rect = paintable_box->absolu",
          "old_line_content": "",
          "new_line_content": "            scroll_offset.translate_by(containing_block->scroll_offset());",
          "content_same": false
        },
        {
          "line": 994,
          "old_api": null,
          "new_api": "map",
          "old_text": null,
          "new_text": "med_rect = transform.map(absolute_rect.tr",
          "old_line_content": "                                    .to_type<CSSPixels>()",
          "new_line_content": "        auto absolute_rect = paintable_box->absolute_border_box_rect();",
          "content_same": false
        },
        {
          "line": 997,
          "old_api": null,
          "new_api": "translated",
          "old_text": null,
          "new_text": "       .translated(-scroll_offset",
          "old_line_content": "                                    .translated(-viewport_offset);",
          "new_line_content": "                                    .translated(paintable_box->transform_origin())",
          "content_same": false
        },
        {
          "line": 1005,
          "old_api": null,
          "new_api": "nd",
          "old_text": null,
          "new_text": "nd(Geometry::DOMRect::create(realm(), transf",
          "old_line_content": "    } else if (paintable) {",
          "new_line_content": "        absolute_rect.translate_by(-viewport_offset);",
          "content_same": false
        },
        {
          "line": 1008,
          "old_api": null,
          "new_api": "reate",
          "old_text": null,
          "new_text": "reate(realm(), move",
          "old_line_content": "",
          "new_line_content": "        dbgln(\"FIXME: Failed to get client rects for element ({})\", debug_description());",
          "content_same": false
        },
        {
          "line": 1011,
          "old_api": null,
          "new_api": "Ensure that",
          "old_text": null,
          "new_text": "Ensure that",
          "old_line_content": "",
          "new_line_content": "    return Geometry::DOMRectList::create(realm(), move(rects));",
          "content_same": false
        },
        {
          "line": 1017,
          "old_api": null,
          "new_api": "sociated C",
          "old_text": null,
          "new_text": "sociated C",
          "old_line_content": "    // 1. If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 1020,
          "old_api": null,
          "new_api": "d value of the",
          "old_text": null,
          "new_text": "d value of the ",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1026,
          "old_api": null,
          "new_api": "}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientl",
          "old_text": null,
          "new_text": "}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientl",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->computed_values().border_top().width.to_int();",
          "content_same": false
        },
        {
          "line": 1033,
          "old_api": null,
          "new_api": "sociated C",
          "old_text": null,
          "new_text": "sociated C",
          "old_line_content": "    // 1. If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 1036,
          "old_api": null,
          "new_api": "d value of the",
          "old_text": null,
          "new_text": "d value of the ",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1042,
          "old_api": null,
          "new_api": "}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientw",
          "old_text": null,
          "new_text": "\n}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientw",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->computed_values().border_left().width.to_int();",
          "content_same": false
        },
        {
          "line": 1054,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "ect().width().to_int();\n   ",
          "old_line_content": "    }",
          "new_line_content": "        || (is<HTML::HTMLBodyElement>(*this) && document().in_quirks_mode())) {",
          "content_same": false
        },
        {
          "line": 1055,
          "old_api": null,
          "new_api": "ure that layout is up-to-date before lookin",
          "old_text": null,
          "new_text": "ure that layout is up-to-date before lookin",
          "old_line_content": "",
          "new_line_content": "        return document().viewport_rect().width().to_int();",
          "content_same": false
        },
        {
          "line": 1059,
          "old_api": null,
          "new_api": "ated CSS l",
          "old_text": null,
          "new_text": "ated CSS l",
          "old_line_content": "    // 1. If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 1062,
          "old_api": null,
          "new_api": "e padding edge",
          "old_text": null,
          "new_text": "e padding edge ",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1067,
          "old_api": null,
          "new_api": "https://drafts.csswg.org/cssom-view/#dom-element-clientheigh",
          "old_text": null,
          "new_text": " https://drafts.csswg.org/cssom-view/#dom-element-clientheigh",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->absolute_padding_box_rect().width().to_int();",
          "content_same": false
        },
        {
          "line": 1079,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": ").height().to_int();\n    }\n",
          "old_line_content": "    }",
          "new_line_content": "        || (is<HTML::HTMLBodyElement>(*this) && document().in_quirks_mode())) {",
          "content_same": false
        },
        {
          "line": 1080,
          "old_api": null,
          "new_api": "that layout is up-to-date before looking at",
          "old_text": null,
          "new_text": " that layout is up-to-date before looking at",
          "old_line_content": "",
          "new_line_content": "        return document().viewport_rect().height().to_int();",
          "content_same": false
        },
        {
          "line": 1084,
          "old_api": null,
          "new_api": "CSS layou",
          "old_text": null,
          "new_text": " CSS layou",
          "old_line_content": "    // 1. If the element has no associated CSS layout box or if the CSS layout box is inline, return zero.",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 1087,
          "old_api": null,
          "new_api": "adding edge exc",
          "old_text": null,
          "new_text": "adding edge exc",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1092,
          "old_api": null,
          "new_api": "tps://drafts.csswg.org/cssom-view/#dom-element-currentcsszoom",
          "old_text": null,
          "new_text": "tps://drafts.csswg.org/cssom-view/#dom-element-currentcsszoom\n",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->absolute_padding_box_rect().height().to_int();",
          "content_same": false
        },
        {
          "line": 1098,
          "old_api": null,
          "new_api": "void Element::inserted()\n{\n    Base::inserted();",
          "old_text": null,
          "new_text": "\n\nvoid Element::inserted()\n{\n    Base::inserted();\n\n ",
          "old_line_content": "}",
          "new_line_content": "    dbgln(\"FIXME: Implement Element::current_css_zoom()\");",
          "content_same": false
        },
        {
          "line": 1106,
          "old_api": null,
          "new_api": ");\n\n    if (m_na",
          "old_text": null,
          "new_text": ");\n\n    if (m_na",
          "old_line_content": "",
          "new_line_content": "    if (m_id.has_value())",
          "content_same": false
        },
        {
          "line": 1109,
          "old_api": null,
          "new_api": "this);\n}\n\nvoid Ele",
          "old_text": null,
          "new_text": "this);\n}\n\nvoid Ele",
          "old_line_content": "}",
          "new_line_content": "    if (m_name.has_value())",
          "content_same": false
        },
        {
          "line": 1110,
          "old_api": null,
          "new_api": "ved_from",
          "old_text": null,
          "new_text": "ved_from(Node* node)\n{\n    Base::removed_from(nod",
          "old_line_content": "",
          "new_line_content": "        document().element_with_name_was_added({}, *this);",
          "content_same": false
        },
        {
          "line": 1117,
          "old_api": null,
          "new_api": "is);\n\n    if (m_",
          "old_text": null,
          "new_text": "is);\n\n    if (m_",
          "old_line_content": "",
          "new_line_content": "    if (m_id.has_value())",
          "content_same": false
        },
        {
          "line": 1120,
          "old_api": null,
          "new_api": "*this);\n}\n\nvoid E",
          "old_text": null,
          "new_text": " *this);\n}\n\nvoid E",
          "old_line_content": "}",
          "new_line_content": "    if (m_name.has_value())",
          "content_same": false
        },
        {
          "line": 1121,
          "old_api": null,
          "new_api": "ildren_changed",
          "old_text": null,
          "new_text": "ildren_changed()\n{\n    Node::children_changed();\n  ",
          "old_line_content": "",
          "new_line_content": "        document().element_with_name_was_removed({}, *this);",
          "content_same": false
        },
        {
          "line": 1126,
          "old_api": null,
          "new_api": "ent::set_pseudo_element_",
          "old_text": null,
          "new_text": "ent::set_pseudo_element_",
          "old_line_content": "}",
          "new_line_content": "    Node::children_changed();",
          "content_same": false
        },
        {
          "line": 1127,
          "old_api": null,
          "new_api": "adge<Layout::TreeBuilder>, C",
          "old_text": null,
          "new_text": "adge<Layout::TreeBuilder>, C",
          "old_line_content": "",
          "new_line_content": "    set_needs_style_update(true);",
          "content_same": false
        },
        {
          "line": 1132,
          "old_api": null,
          "new_api": "_value",
          "old_text": null,
          "new_text": "_value() && !pseudo_element_node)\n",
          "old_line_content": "        return;",
          "new_line_content": "    auto existing_pseudo_element = get_pseudo_element(pseudo_element);",
          "content_same": false
        },
        {
          "line": 1133,
          "old_api": null,
          "new_api": "urn;\n\n    ensure_pseudo_element(pse",
          "old_text": null,
          "new_text": "urn;\n\n    ensure_pseudo_element(pse",
          "old_line_content": "",
          "new_line_content": "    if (!existing_pseudo_element.has_value() && !pseudo_element_node)",
          "content_same": false
        },
        {
          "line": 1136,
          "old_api": null,
          "new_api": "get_pseudo_element_node",
          "old_text": null,
          "new_text": "get_pseudo_element_node(C",
          "old_line_content": "",
          "new_line_content": "    ensure_pseudo_element(pseudo_element).layout_node = move(pseudo_element_node);",
          "content_same": false
        },
        {
          "line": 1141,
          "old_api": null,
          "new_api": "return nullptr;\n}\n\nbool",
          "old_text": null,
          "new_text": "return nullptr;\n}\n\nbool ",
          "old_line_content": "    return nullptr;",
          "new_line_content": "    if (auto element_data = get_pseudo_element(pseudo_element); element_data.has_value())",
          "content_same": false
        },
        {
          "line": 1170,
          "old_api": null,
          "new_api": "_pseudo_element_data)[i].layo",
          "old_text": null,
          "new_text": "_pseudo_element_data)[i].layo",
          "old_line_content": "        if (!pseudo_element)",
          "new_line_content": "    for (size_t i = 0; i < m_pseudo_element_data->size(); ++i) {",
          "content_same": false
        },
        {
          "line": 1178,
          "old_api": null,
          "new_api": "}\n\n// https://html.spec.whatwg.o",
          "old_text": null,
          "new_text": "\n}\n\n// https://html.spec.whatwg.o",
          "old_line_content": "    }",
          "new_line_content": "        MUST(object.add(\"pseudo-element\"sv, i));",
          "content_same": false
        },
        {
          "line": 1179,
          "old_api": null,
          "new_api": "eraction.html#d",
          "old_text": null,
          "new_text": "eraction.html#d",
          "old_line_content": "}",
          "new_line_content": "        MUST(object.finish());",
          "content_same": false
        },
        {
          "line": 1199,
          "old_api": null,
          "new_api": "ps://html.spec.whatwg.org",
          "old_text": null,
          "new_text": "ps://html.spec.whatwg.org",
          "old_line_content": "}",
          "new_line_content": "        return default_tab_index_value();",
          "content_same": false
        },
        {
          "line": 1200,
          "old_api": null,
          "new_api": "teraction.html#dom-tabind",
          "old_text": null,
          "new_text": "teraction.html#dom-tabind",
          "old_line_content": "",
          "new_line_content": "    return maybe_table_index.value();",
          "content_same": false
        },
        {
          "line": 1206,
          "old_api": null,
          "new_api": "otentially-scrollable\nboo",
          "old_text": null,
          "new_text": "otentially-scrollable\nboo",
          "old_line_content": "",
          "new_line_content": "    MUST(set_attribute(HTML::AttributeNames::tabindex, MUST(String::number(tab_index))));",
          "content_same": false
        },
        {
          "line": 1213,
          "old_api": null,
          "new_api": "dy element",
          "old_text": null,
          "new_text": "dy element",
          "old_line_content": "    // An element body (which will be the body element) is potentially scrollable if all of the following conditions are true:",
          "new_line_content": "    const_cast<Document&>(document()).update_layout();",
          "content_same": false
        },
        {
          "line": 1216,
          "old_api": null,
          "new_api": "the body element, the body element",
          "old_text": null,
          "new_text": "the body element, the body element ",
          "old_line_content": "    // Since this should always be the body element, the body element must have a <html> element parent. See Document::body().",
          "new_line_content": "    VERIFY(is<HTML::HTMLBodyElement>(this) || is<HTML::HTMLFrameSetElement>(this));",
          "content_same": false
        },
        {
          "line": 1219,
          "old_api": null,
          "new_api": "ements",
          "old_text": null,
          "new_text": "ements ",
          "old_line_content": "    // - body has an associated box.",
          "new_line_content": "    VERIFY(parent());",
          "content_same": false
        },
        {
          "line": 1228,
          "old_api": null,
          "new_api": "computed_values",
          "old_text": null,
          "new_text": " && layout_node()->computed_values().overflow",
          "old_line_content": "}",
          "new_line_content": "        && (layout_node()->computed_values().overflow_x() != CSS::Overflow::Visible && layout_node()->computed_values().overflow_x() != CSS::Overflow::Clip",
          "content_same": false
        },
        {
          "line": 1229,
          "old_api": null,
          "new_api": "ps://drafts.csswg.org/cssom-view/#dom-element",
          "old_text": null,
          "new_text": "ps://drafts.csswg.org/cssom-view/#dom-element",
          "old_line_content": "",
          "new_line_content": "            && layout_node()->computed_values().overflow_y() != CSS::Overflow::Visible && layout_node()->computed_values().overflow_y() != CSS::Overflow::Clip);",
          "content_same": false
        },
        {
          "line": 1236,
          "old_api": null,
          "new_api": "nd terminate the",
          "old_text": null,
          "new_text": "nd terminate the",
          "old_line_content": "    // 2. If document is not the active document, return zero and terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 1239,
          "old_api": null,
          "new_api": "cuments defaultView",
          "old_text": null,
          "new_text": "cuments defaultView",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 1243,
          "old_api": null,
          "new_api": "se steps.\n    if (!wind",
          "old_text": null,
          "new_text": "se steps.\n    if (!wind",
          "old_line_content": "    // 4. If window is null, return zero and terminate these steps.",
          "new_line_content": "    auto* window = document.default_view();",
          "content_same": false
        },
        {
          "line": 1250,
          "old_api": null,
          "new_api": "p-to-date before looking",
          "old_text": null,
          "new_text": "p-to-date before looking ",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1254,
          "old_api": null,
          "new_api": "ot element return the value of scrollY on windo",
          "old_text": null,
          "new_text": "ot element return the value of scrollY on windo",
          "old_line_content": "    // 6. If the element is the root element return the value of scrollY on window.",
          "new_line_content": "    const_cast<Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1257,
          "old_api": null,
          "new_api": "f the element is the body e",
          "old_text": null,
          "new_text": "f the element is the body e",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this)",
          "content_same": false
        },
        {
          "line": 1258,
          "old_api": null,
          "new_api": "irks mode, and the",
          "old_text": null,
          "new_text": "irks mode, and the",
          "old_line_content": "    // 7. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollY on window.",
          "new_line_content": "        return window->scroll_y();",
          "content_same": false
        },
        {
          "line": 1261,
          "old_api": null,
          "new_api": "ement does not have any ass",
          "old_text": null,
          "new_text": "ement does not have any ass",
          "old_line_content": "",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "content_same": false
        },
        {
          "line": 1262,
          "old_api": null,
          "new_api": "rn zero and termin",
          "old_text": null,
          "new_text": "rn zero and termin",
          "old_line_content": "    // 8. If the element does not have any associated box, return zero and terminate these steps.",
          "new_line_content": "        return window->scroll_y();",
          "content_same": false
        },
        {
          "line": 1265,
          "old_api": null,
          "new_api": "ling area at th",
          "old_text": null,
          "new_text": "ling area at th",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1270,
          "old_api": null,
          "new_api": "onst\n{\n    // 1. Let document be the elements n",
          "old_text": null,
          "new_text": "onst\n{\n    // 1. Let document be the elements n",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->scroll_offset().y().to_double();",
          "content_same": false
        },
        {
          "line": 1276,
          "old_api": null,
          "new_api": "erminate these s",
          "old_text": null,
          "new_text": "erminate these s",
          "old_line_content": "    // 2. If document is not the active document, return zero and terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 1279,
          "old_api": null,
          "new_api": "nts defaultView att",
          "old_text": null,
          "new_text": "nts defaultView att",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 1283,
          "old_api": null,
          "new_api": "teps.\n    if (!window)",
          "old_text": null,
          "new_text": "teps.\n    if (!window)\n",
          "old_line_content": "    // 4. If window is null, return zero and terminate these steps.",
          "new_line_content": "    auto* window = document.default_view();",
          "content_same": false
        },
        {
          "line": 1290,
          "old_api": null,
          "new_api": "-date before looking at m",
          "old_text": null,
          "new_text": "-date before looking at m",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1294,
          "old_api": null,
          "new_api": "lement return the value of scrollX on window.",
          "old_text": null,
          "new_text": "lement return the value of scrollX on window.\n ",
          "old_line_content": "    // 6. If the element is the root element return the value of scrollX on window.",
          "new_line_content": "    const_cast<Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1297,
          "old_api": null,
          "new_api": "e element is the body eleme",
          "old_text": null,
          "new_text": "e element is the body eleme",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this)",
          "content_same": false
        },
        {
          "line": 1298,
          "old_api": null,
          "new_api": "mode, and the ele",
          "old_text": null,
          "new_text": " mode, and the ele",
          "old_line_content": "    // 7. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollX on window.",
          "new_line_content": "        return window->scroll_x();",
          "content_same": false
        },
        {
          "line": 1301,
          "old_api": null,
          "new_api": "t does not have any associa",
          "old_text": null,
          "new_text": "t does not have any associa",
          "old_line_content": "",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "content_same": false
        },
        {
          "line": 1302,
          "old_api": null,
          "new_api": "ero and terminate",
          "old_text": null,
          "new_text": "ero and terminate ",
          "old_line_content": "    // 8. If the element does not have any associated box, return zero and terminate these steps.",
          "new_line_content": "        return window->scroll_x();",
          "content_same": false
        },
        {
          "line": 1305,
          "old_api": null,
          "new_api": "area at the al",
          "old_text": null,
          "new_text": " area at the al",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1310,
          "old_api": null,
          "new_api": "iew/#dom-element-scrollleft\nvoid Element::set_sc",
          "old_text": null,
          "new_text": "iew/#dom-element-scrollleft\nvoid Element::set_sc",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->scroll_offset().x().to_double();",
          "content_same": false
        },
        {
          "line": 1319,
          "old_api": null,
          "new_api": "ment.\n    auto& document = this->doc",
          "old_text": null,
          "new_text": "ment.\n    auto& document = this->doc",
          "old_line_content": "    // 3. Let document be the elements node document.",
          "new_line_content": "    x = HTML::normalize_non_finite_values(x);",
          "content_same": false
        },
        {
          "line": 1322,
          "old_api": null,
          "new_api": ".\n    if (!docum",
          "old_text": null,
          "new_text": ".\n    if (!docum",
          "old_line_content": "    // 4. If document is not the active document, terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 1325,
          "old_api": null,
          "new_api": "aultView attribute.",
          "old_text": null,
          "new_text": "aultView attribute.\n",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 1329,
          "old_api": null,
          "new_api": "w)\n        return;",
          "old_text": null,
          "new_text": "w)\n        return;\n\n   ",
          "old_line_content": "    // 6. If window is null, terminate these steps.",
          "new_line_content": "    auto* window = document.default_view();",
          "content_same": false
        },
        {
          "line": 1336,
          "old_api": null,
          "new_api": "fore looking at metrics o",
          "old_text": null,
          "new_text": "fore looking at metrics o",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1340,
          "old_api": null,
          "new_api": "nt invoke scroll() on window with x as first ar",
          "old_text": null,
          "new_text": "nt invoke scroll() on window with x as first ar",
          "old_line_content": "    // 8. If the element is the root element invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.",
          "new_line_content": "    const_cast<Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1343,
          "old_api": null,
          "new_api": "return;\n    }\n\n    // 9.",
          "old_text": null,
          "new_text": "  return;\n    }\n\n    // 9. ",
          "old_line_content": "        return;",
          "new_line_content": "    if (document.document_element() == this) {",
          "content_same": false
        },
        {
          "line": 1344,
          "old_api": null,
          "new_api": "cument is in quirk",
          "old_text": null,
          "new_text": "cument is in quirk",
          "old_line_content": "    }",
          "new_line_content": "        window->scroll(x, window->scroll_y());",
          "content_same": false
        },
        {
          "line": 1349,
          "old_api": null,
          "new_api": ";\n    }\n\n    // 10. If the",
          "old_text": null,
          "new_text": ";\n    }\n\n    // 10. If the ",
          "old_line_content": "        return;",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable()) {",
          "content_same": false
        },
        {
          "line": 1350,
          "old_api": null,
          "new_api": "ciated box, the el",
          "old_text": null,
          "new_text": "ciated box, the el",
          "old_line_content": "    }",
          "new_line_content": "        window->scroll(x, window->scroll_y());",
          "content_same": false
        },
        {
          "line": 1355,
          "old_api": null,
          "new_api": "())\n        ret",
          "old_text": null,
          "new_text": "())\n        ret",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1358,
          "old_api": null,
          "new_api": "lement has no overflow.\n\n    // 11. Scroll the elem",
          "old_text": null,
          "new_text": "lement has no overflow.\n\n    // 11. Scroll the elem",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box()->layout_box().is_scroll_container())",
          "content_same": false
        },
        {
          "line": 1366,
          "old_api": null,
          "new_api": "void Element::set_scroll_top(do",
          "old_text": null,
          "new_text": "void Element::set_scroll_top(do",
          "old_line_content": "}",
          "new_line_content": "    scroll_offset.set_x(CSSPixels::nearest_value_for(x));",
          "content_same": false
        },
        {
          "line": 1367,
          "old_api": null,
          "new_api": "{\n    // 1. Let y be the given value.\n\n    // 2.",
          "old_text": null,
          "new_text": "\n{\n    // 1. Let y be the given value.\n\n    // 2.",
          "old_line_content": "",
          "new_line_content": "    paintable_box()->set_scroll_offset(scroll_offset);",
          "content_same": false
        },
        {
          "line": 1375,
          "old_api": null,
          "new_api": ".\n    auto& document = this->documen",
          "old_text": null,
          "new_text": ".\n    auto& document = this->documen",
          "old_line_content": "    // 3. Let document be the elements node document.",
          "new_line_content": "    y = HTML::normalize_non_finite_values(y);",
          "content_same": false
        },
        {
          "line": 1378,
          "old_api": null,
          "new_api": "if (!document.",
          "old_text": null,
          "new_text": "  if (!document.",
          "old_line_content": "    // 4. If document is not the active document, terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 1381,
          "old_api": null,
          "new_api": "View attribute.",
          "old_text": null,
          "new_text": "View attribute.\n    ",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 1385,
          "old_api": null,
          "new_api": "return;\n\n    //",
          "old_text": null,
          "new_text": "       return;\n\n    // ",
          "old_line_content": "    // 6. If window is null, terminate these steps.",
          "new_line_content": "    auto* window = document.default_view();",
          "content_same": false
        },
        {
          "line": 1392,
          "old_api": null,
          "new_api": "looking at metrics or sc",
          "old_text": null,
          "new_text": " looking at metrics or sc",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1396,
          "old_api": null,
          "new_api": "nvoke scroll() on window with scrollX on window",
          "old_text": null,
          "new_text": "nvoke scroll() on window with scrollX on window",
          "old_line_content": "    // 8. If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.",
          "new_line_content": "    const_cast<Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1399,
          "old_api": null,
          "new_api": "turn;\n    }\n\n    // 9. If t",
          "old_text": null,
          "new_text": "turn;\n    }\n\n    // 9. If t",
          "old_line_content": "        return;",
          "new_line_content": "    if (document.document_element() == this) {",
          "content_same": false
        },
        {
          "line": 1400,
          "old_api": null,
          "new_api": "ument is in quirks",
          "old_text": null,
          "new_text": "ument is in quirks",
          "old_line_content": "    }",
          "new_line_content": "        window->scroll(window->scroll_x(), y);",
          "content_same": false
        },
        {
          "line": 1405,
          "old_api": null,
          "new_api": "}\n\n    // 10. If the elem",
          "old_text": null,
          "new_text": "  }\n\n    // 10. If the elem",
          "old_line_content": "        return;",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable()) {",
          "content_same": false
        },
        {
          "line": 1406,
          "old_api": null,
          "new_api": "iated box, the ele",
          "old_text": null,
          "new_text": "iated box, the ele",
          "old_line_content": "    }",
          "new_line_content": "        window->scroll(window->scroll_x(), y);",
          "content_same": false
        },
        {
          "line": 1411,
          "old_api": null,
          "new_api": "return;",
          "old_text": null,
          "new_text": "        return;",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1414,
          "old_api": null,
          "new_api": "nt has no overflow.\n\n    // 11. Scroll the element",
          "old_text": null,
          "new_text": "nt has no overflow.\n\n    // 11. Scroll the element ",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box()->layout_box().is_scroll_container())",
          "content_same": false
        },
        {
          "line": 1422,
          "old_api": null,
          "new_api": "ttps://drafts.csswg.org/cssom-v",
          "old_text": null,
          "new_text": "ttps://drafts.csswg.org/cssom-v",
          "old_line_content": "}",
          "new_line_content": "    scroll_offset.set_y(CSSPixels::nearest_value_for(y));",
          "content_same": false
        },
        {
          "line": 1423,
          "old_api": null,
          "new_api": "m-element-scrollwidth\nint Element::scroll_width()",
          "old_text": null,
          "new_text": "m-element-scrollwidth\nint Element::scroll_width()",
          "old_line_content": "",
          "new_line_content": "    paintable_box()->set_scroll_offset(scroll_offset);",
          "content_same": false
        },
        {
          "line": 1430,
          "old_api": null,
          "new_api": "se steps.\n    if",
          "old_text": null,
          "new_text": "se steps.\n    if",
          "old_line_content": "    // 2. If document is not the active document, return zero and terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 1433,
          "old_api": null,
          "new_api": "ing at metrics.",
          "old_text": null,
          "new_text": "ing at metrics.\n    ",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 1437,
          "old_api": null,
          "new_api": "viewport excluding the width of the scroll bar",
          "old_text": null,
          "new_text": " viewport excluding the width of the scroll bar",
          "old_line_content": "    // 3. Let viewport width be the width of the viewport excluding the width of the scroll bar, if any,",
          "new_line_content": "    const_cast<Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1441,
          "old_api": null,
          "new_api": "width",
          "old_text": null,
          "new_text": "size().width().to_int();\n\n    // 4. If th",
          "old_line_content": "",
          "new_line_content": "    auto viewport_width = document.viewport_rect().width().to_int();",
          "content_same": false
        },
        {
          "line": 1442,
          "old_api": null,
          "new_api": "ocument is not in quirks mode\n    //    retur",
          "old_text": null,
          "new_text": "ocument is not in quirks mode\n    //    retur",
          "old_line_content": "    // 4. If the element is the root element and document is not in quirks mode",
          "new_line_content": "    auto viewport_scroll_width = document.navigable()->size().width().to_int();",
          "content_same": false
        },
        {
          "line": 1446,
          "old_api": null,
          "new_api": "f the element is the body",
          "old_text": null,
          "new_text": "f the element is the body",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && !document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1447,
          "old_api": null,
          "new_api": "t is in quirks mode and the element is not",
          "old_text": null,
          "new_text": "t is in quirks mode and the element is not",
          "old_line_content": "    // 5. If the element is the body element, document is in quirks mode and the element is not potentially scrollable,",
          "new_line_content": "        return max(viewport_scroll_width, viewport_width);",
          "content_same": false
        },
        {
          "line": 1451,
          "old_api": null,
          "new_api": "If the element does not ha",
          "old_text": null,
          "new_text": " If the element does not ha",
          "old_line_content": "",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "content_same": false
        },
        {
          "line": 1452,
          "old_api": null,
          "new_api": "box return zero and terminate these steps",
          "old_text": null,
          "new_text": " box return zero and terminate these steps",
          "old_line_content": "    // 6. If the element does not have any associated box return zero and terminate these steps.",
          "new_line_content": "        return max(viewport_scroll_width, viewport_width);",
          "content_same": false
        },
        {
          "line": 1455,
          "old_api": null,
          "new_api": "return painta",
          "old_text": null,
          "new_text": "  return painta",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1459,
          "old_api": null,
          "new_api": "view/#dom-element-scrollheight\nint Element::scroll_height() c",
          "old_text": null,
          "new_text": "view/#dom-element-scrollheight\nint Element::scroll_height() c",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->scrollable_overflow_rect()->width().to_int();",
          "content_same": false
        },
        {
          "line": 1466,
          "old_api": null,
          "new_api": "teps.\n    if (!d",
          "old_text": null,
          "new_text": "teps.\n    if (!d",
          "old_line_content": "    // 2. If document is not the active document, return zero and terminate these steps.",
          "new_line_content": "    auto& document = this->document();",
          "content_same": false
        },
        {
          "line": 1469,
          "old_api": null,
          "new_api": "at metrics.\n    cons",
          "old_text": null,
          "new_text": "at metrics.\n    cons",
          "old_line_content": "",
          "new_line_content": "    if (!document.is_active())",
          "content_same": false
        },
        {
          "line": 1473,
          "old_api": null,
          "new_api": "iewport excluding the height of the scroll bar,",
          "old_text": null,
          "new_text": "iewport excluding the height of the scroll bar,",
          "old_line_content": "    // 3. Let viewport height be the height of the viewport excluding the height of the scroll bar, if any,",
          "new_line_content": "    const_cast<Document&>(document).update_layout();",
          "content_same": false
        },
        {
          "line": 1477,
          "old_api": null,
          "new_api": "height",
          "old_text": null,
          "new_text": "ze().height().to_int();\n\n    // 4. If the ",
          "old_line_content": "",
          "new_line_content": "    auto viewport_height = document.viewport_rect().height().to_int();",
          "content_same": false
        },
        {
          "line": 1478,
          "old_api": null,
          "new_api": "ment is not in quirks mode\n    //    return ma",
          "old_text": null,
          "new_text": "ment is not in quirks mode\n    //    return ma",
          "old_line_content": "    // 4. If the element is the root element and document is not in quirks mode",
          "new_line_content": "    auto viewport_scroll_height = document.navigable()->size().height().to_int();",
          "content_same": false
        },
        {
          "line": 1482,
          "old_api": null,
          "new_api": "the element is the body e",
          "old_text": null,
          "new_text": "the element is the body e",
          "old_line_content": "",
          "new_line_content": "    if (document.document_element() == this && !document.in_quirks_mode())",
          "content_same": false
        },
        {
          "line": 1483,
          "old_api": null,
          "new_api": "is in quirks mode and the element is not pot",
          "old_text": null,
          "new_text": "is in quirks mode and the element is not pot",
          "old_line_content": "    // 5. If the element is the body element, document is in quirks mode and the element is not potentially scrollable,",
          "new_line_content": "        return max(viewport_scroll_height, viewport_height);",
          "content_same": false
        },
        {
          "line": 1487,
          "old_api": null,
          "new_api": "f the element does not have",
          "old_text": null,
          "new_text": "f the element does not have",
          "old_line_content": "",
          "new_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "content_same": false
        },
        {
          "line": 1488,
          "old_api": null,
          "new_api": "ox return zero and terminate these steps.",
          "old_text": null,
          "new_text": "ox return zero and terminate these steps.\n  ",
          "old_line_content": "    // 6. If the element does not have any associated box return zero and terminate these steps.",
          "new_line_content": "        return max(viewport_scroll_height, viewport_height);",
          "content_same": false
        },
        {
          "line": 1491,
          "old_api": null,
          "new_api": "eturn paintable",
          "old_text": null,
          "new_text": "eturn paintable",
          "old_line_content": "",
          "new_line_content": "    if (!paintable_box())",
          "content_same": false
        },
        {
          "line": 1495,
          "old_api": null,
          "new_api": "page/semantics-other.html#concept-element-disabled\nbool Elemen",
          "old_text": null,
          "new_text": "page/semantics-other.html#concept-element-disabled\nbool Elemen",
          "old_line_content": "",
          "new_line_content": "    return paintable_box()->scrollable_overflow_rect()->height().to_int();",
          "content_same": false
        },
        {
          "line": 1507,
          "old_api": null,
          "new_api": "enabled",
          "old_text": null,
          "new_text": "  return !form_associated_element->enabled();\n    }\n\n ",
          "old_line_content": "",
          "new_line_content": "        auto const* form_associated_element = dynamic_cast<HTML::FormAssociatedElement const*>(this);",
          "content_same": false
        },
        {
          "line": 1510,
          "old_api": null,
          "new_api": "if (is<HTML::HTMLOptGroupElement",
          "old_text": null,
          "new_text": "  if (is<HTML::HTMLOptGroupElement",
          "old_line_content": "",
          "new_line_content": "        return !form_associated_element->enabled();",
          "content_same": false
        },
        {
          "line": 1514,
          "old_api": null,
          "new_api": "// - an option element that is disa",
          "old_text": null,
          "new_text": "// - an option element that is disa",
          "old_line_content": "",
          "new_line_content": "    if (is<HTML::HTMLOptGroupElement>(this))",
          "content_same": false
        },
        {
          "line": 1515,
          "old_api": null,
          "new_api": "TML::HTMLOptionElement>(this))\n        return",
          "old_text": null,
          "new_text": "TML::HTMLOptionElement>(this))\n        return",
          "old_line_content": "    // - an option element that is disabled",
          "new_line_content": "        return has_attribute(HTML::AttributeNames::disabled);",
          "content_same": false
        },
        {
          "line": 1518,
          "old_api": null,
          "new_api": "abled",
          "old_text": null,
          "new_text": "abled();\n\n    // - a fieldset ele",
          "old_line_content": "",
          "new_line_content": "    if (is<HTML::HTMLOptionElement>(this))",
          "content_same": false
        },
        {
          "line": 1519,
          "old_api": null,
          "new_api": "sabled fieldset\n    if (is<HTML::HTMLFieldSetElement>(this))",
          "old_text": null,
          "new_text": "sabled fieldset\n    if (is<HTML::HTMLFieldSetElement>(this))\n",
          "old_line_content": "    // - a fieldset element that is a disabled fieldset",
          "new_line_content": "        return static_cast<HTML::HTMLOptionElement const&>(*this).disabled();",
          "content_same": false
        },
        {
          "line": 1522,
          "old_api": null,
          "new_api": "is_disabled",
          "old_text": null,
          "new_text": ".is_disabled();\n\n    // FIXME: - a ",
          "old_line_content": "",
          "new_line_content": "    if (is<HTML::HTMLFieldSetElement>(this))",
          "content_same": false
        },
        {
          "line": 1523,
          "old_api": null,
          "new_api": "ustom element that is disabled\n    return false;\n}\n\n// https://htm",
          "old_text": null,
          "new_text": "ustom element that is disabled\n    return false;\n}\n\n// https://htm",
          "old_line_content": "    // FIXME: - a form-associated custom element that is disabled",
          "new_line_content": "        return static_cast<HTML::HTMLFieldSetElement const&>(*this).is_disabled();",
          "content_same": false
        },
        {
          "line": 1536,
          "old_api": null,
          "new_api": "// 3. Let new children",
          "old_text": null,
          "new_text": "\n    // 3. Let new children ",
          "old_line_content": "    }",
          "new_line_content": "    if (document().is_xml_document()) {",
          "content_same": false
        },
        {
          "line": 1537,
          "old_api": null,
          "new_api": "t of invoking algorithm given markup, with context set t",
          "old_text": null,
          "new_text": "t of invoking algorithm given markup, with context set t",
          "old_line_content": "",
          "new_line_content": "        dbgln(\"FIXME: Handle fragment parsing of XML documents\");",
          "content_same": false
        },
        {
          "line": 1541,
          "old_api": null,
          "new_api": "a new DocumentFragment whose node document is context's node document.",
          "old_text": null,
          "new_text": "a new DocumentFragment whose node document is context's node document.\n    ",
          "old_line_content": "    // 4. Let fragment be a new DocumentFragment whose node document is context's node document.",
          "new_line_content": "    auto new_children = algorithm(*this, markup, HTML::HTMLParser::AllowDeclarativeShadowRoots::No);",
          "content_same": false
        },
        {
          "line": 1544,
          "old_api": null,
          "new_api": "ld : new_c",
          "old_text": null,
          "new_text": "ld : new_c",
          "old_line_content": "    // 5. Append each Node in new children to fragment (in tree order).",
          "new_line_content": "    auto fragment = realm().heap().allocate<DOM::DocumentFragment>(realm(), document());",
          "content_same": false
        },
        {
          "line": 1549,
          "old_api": null,
          "new_api": "e/dynamic-markup-insertion.htm",
          "old_text": null,
          "new_text": "e/dynamic-markup-insertion.htm",
          "old_line_content": "",
          "new_line_content": "        (void)TRY(fragment->append_child(*child));",
          "content_same": false
        },
        {
          "line": 1558,
          "old_api": null,
          "new_api": "html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-outerhtml\nWebID",
          "old_text": null,
          "new_text": "html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-outerhtml\nWebID",
          "old_line_content": "",
          "new_line_content": "    return serialize_fragment(DOMParsing::RequireWellFormed::Yes, FragmentSerializationMode::Outer);",
          "content_same": false
        },
        {
          "line": 1567,
          "old_api": null,
          "new_api": "nodes created",
          "old_text": null,
          "new_text": " nodes created",
          "old_line_content": "    // 3. If parent is null, return. There would be no way to obtain a reference to the nodes created even if the remaining steps were run.",
          "new_line_content": "    auto* parent = this->parent();",
          "content_same": false
        },
        {
          "line": 1574,
          "old_api": null,
          "new_api": "ter HTML on document\"",
          "old_text": null,
          "new_text": "ter HTML on document\"",
          "old_line_content": "",
          "new_line_content": "    if (parent->is_document())",
          "content_same": false
        },
        {
          "line": 1575,
          "old_api": null,
          "new_api": "t paren",
          "old_text": null,
          "new_text": "t paren",
          "old_line_content": "    // 5. If parent is a DocumentFragment, set parent to the result of creating an element given this's node document, body, and the HTML namespace.",
          "new_line_content": "        return WebIDL::NoModificationAllowedError::create(realm(), \"Cannot set outer HTML on document\"_fly_string);",
          "content_same": false
        },
        {
          "line": 1578,
          "old_api": null,
          "new_api": "mespace::HTML));\n\n    // 6. Le",
          "old_text": null,
          "new_text": "mespace::HTML));\n\n    // 6. Le",
          "old_line_content": "",
          "new_line_content": "    if (parent->is_document_fragment())",
          "content_same": false
        },
        {
          "line": 1579,
          "old_api": null,
          "new_api": "he fragmen",
          "old_text": null,
          "new_text": "he fragmen",
          "old_line_content": "    // 6. Let fragment be the result of invoking the fragment parsing algorithm steps given parent and compliantString. FIXME: Use compliantString.",
          "new_line_content": "        parent = TRY(create_element(document(), HTML::TagNames::body, Namespace::HTML));",
          "content_same": false
        },
        {
          "line": 1582,
          "old_api": null,
          "new_api": "replace_child",
          "old_text": null,
          "new_text": "s parent.\n    TRY(parent->replace_child(fragment, *",
          "old_line_content": "    // 6. Replace this with fragment within this's parent.",
          "new_line_content": "    auto fragment = TRY(verify_cast<Element>(*parent).parse_fragment(value));",
          "content_same": false
        },
        {
          "line": 1585,
          "old_api": null,
          "new_api": "namic-markup-insertion.html#the-insert",
          "old_text": null,
          "new_text": "namic-markup-insertion.html#the-insert",
          "old_line_content": "    return {};",
          "new_line_content": "    TRY(parent->replace_child(fragment, *this));",
          "content_same": false
        },
        {
          "line": 1599,
          "old_api": null,
          "new_api": "itive_match",
          "old_text": null,
          "new_text": "itive_match(position, \"afterend\"sv)) {\n        // 1. Set context ",
          "old_line_content": "        // 1. Set context to this's parent.",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(position, \"beforebegin\"sv)",
          "content_same": false
        },
        {
          "line": 1602,
          "old_api": null,
          "new_api": "MException.",
          "old_text": null,
          "new_text": "MException.\n  ",
          "old_line_content": "        // 2. If context is null or a Document, throw a \"NoModificationAllowedError\" DOMException.",
          "new_line_content": "        context = this->parent();",
          "content_same": false
        },
        {
          "line": 1605,
          "old_api": null,
          "new_api": "jacentHTML: context is",
          "old_text": null,
          "new_text": "jacentHTML: context is",
          "old_line_content": "    }",
          "new_line_content": "        if (!context || context->is_document())",
          "content_same": false
        },
        {
          "line": 1606,
          "old_api": null,
          "new_api": "an ASCI",
          "old_text": null,
          "new_text": "an ASCI",
          "old_line_content": "    // - If position is an ASCII case-insensitive match for the string \"afterbegin\"",
          "new_line_content": "            return WebIDL::NoModificationAllowedError::create(realm(), \"insertAdjacentHTML: context is null or a Document\"_fly_string);",
          "content_same": false
        },
        {
          "line": 1610,
          "old_api": null,
          "new_api": "tive_match",
          "old_text": null,
          "new_text": "tive_match(position, \"beforeend\"sv)) {\n        // Set context to",
          "old_line_content": "        // Set context to this.",
          "new_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"afterbegin\"sv)",
          "content_same": false
        },
        {
          "line": 1611,
          "old_api": null,
          "new_api": "context = this;\n    }\n    // Otherwise\n    else {\n        //",
          "old_text": null,
          "new_text": "   context = this;\n    }\n    // Otherwise\n    else {\n        //",
          "old_line_content": "        context = this;",
          "new_line_content": "        || Infra::is_ascii_case_insensitive_match(position, \"beforeend\"sv)) {",
          "content_same": false
        },
        {
          "line": 1618,
          "old_api": null,
          "new_api": "an Ele",
          "old_text": null,
          "new_text": " an Ele",
          "old_line_content": "",
          "new_line_content": "        return WebIDL::SyntaxError::create(realm(), \"insertAdjacentHTML: invalid position argument\"_fly_string);",
          "content_same": false
        },
        {
          "line": 1628,
          "old_api": null,
          "new_api": "e_element",
          "old_text": null,
          "new_text": "e_element(document(), HTML::TagNames::body, Namespace",
          "old_line_content": "    }",
          "new_line_content": "            && static_cast<Element const&>(*context).namespace_uri() == Namespace::HTML)) {",
          "content_same": false
        },
        {
          "line": 1629,
          "old_api": null,
          "new_api": "king the f",
          "old_text": null,
          "new_text": "king the f",
          "old_line_content": "",
          "new_line_content": "        context = TRY(create_element(document(), HTML::TagNames::body, Namespace::HTML));",
          "content_same": false
        },
        {
          "line": 1633,
          "old_api": null,
          "new_api": "list:\n\n    // - If position is an ASCII case-insensi",
          "old_text": null,
          "new_text": " list:\n\n    // - If position is an ASCII case-insensi",
          "old_line_content": "    // 5. Use the first matching item from this list:",
          "new_line_content": "    auto fragment = TRY(verify_cast<Element>(*context).parse_fragment(string));",
          "content_same": false
        },
        {
          "line": 1640,
          "old_api": null,
          "new_api": "for the string \"afterbegin\"\n    else if",
          "old_text": null,
          "new_text": "for the string \"afterbegin\"\n    else if",
          "old_line_content": "",
          "new_line_content": "        parent()->insert_before(fragment, this);",
          "content_same": false
        },
        {
          "line": 1646,
          "old_api": null,
          "new_api": "\"\n    else if",
          "old_text": null,
          "new_text": "\"\n    else if",
          "old_line_content": "",
          "new_line_content": "        insert_before(fragment, first_child());",
          "content_same": false
        },
        {
          "line": 1652,
          "old_api": null,
          "new_api": "afterend\"\n    else if",
          "old_text": null,
          "new_text": "afterend\"\n    else if ",
          "old_line_content": "",
          "new_line_content": "        TRY(append_child(fragment));",
          "content_same": false
        },
        {
          "line": 1658,
          "old_api": null,
          "new_api": "onOr<JS::GCPtr",
          "old_text": null,
          "new_text": "onOr<JS::GCPtr",
          "old_line_content": "    return {};",
          "new_line_content": "        parent()->insert_before(fragment, next_sibling());",
          "content_same": false
        },
        {
          "line": 1667,
          "old_api": null,
          "new_api": "If elements parent is null, return null.\n        if (!parent",
          "old_text": null,
          "new_text": " If elements parent is null, return null.\n        if (!parent",
          "old_line_content": "        // If elements parent is null, return null.",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"beforebegin\"sv)) {",
          "content_same": false
        },
        {
          "line": 1670,
          "old_api": null,
          "new_api": "ode into",
          "old_text": null,
          "new_text": "ode into",
          "old_line_content": "",
          "new_line_content": "        if (!parent())",
          "content_same": false
        },
        {
          "line": 1674,
          "old_api": null,
          "new_api": "// -> \"a",
          "old_text": null,
          "new_text": "  // -> \"a",
          "old_line_content": "",
          "new_line_content": "        return JS::GCPtr<Node> { TRY(parent()->pre_insert(move(node), this)) };",
          "content_same": false
        },
        {
          "line": 1677,
          "old_api": null,
          "new_api": "n the result of pre-inserting node into element before elemen",
          "old_text": null,
          "new_text": "n the result of pre-inserting node into element before elemen",
          "old_line_content": "        // Return the result of pre-inserting node into element before elements first child.",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"afterbegin\"sv)) {",
          "content_same": false
        },
        {
          "line": 1680,
          "old_api": null,
          "new_api": "> \"beforeend\"",
          "old_text": null,
          "new_text": "> \"beforeend\"",
          "old_line_content": "",
          "new_line_content": "        return JS::GCPtr<Node> { TRY(pre_insert(move(node), first_child())) };",
          "content_same": false
        },
        {
          "line": 1683,
          "old_api": null,
          "new_api": "e result of pre-inserting node into element before null.",
          "old_text": null,
          "new_text": "e result of pre-inserting node into element before null.\n   ",
          "old_line_content": "        // Return the result of pre-inserting node into element before null.",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"beforeend\"sv)) {",
          "content_same": false
        },
        {
          "line": 1686,
          "old_api": null,
          "new_api": "// -> \"af",
          "old_text": null,
          "new_text": " // -> \"af",
          "old_line_content": "",
          "new_line_content": "        return JS::GCPtr<Node> { TRY(pre_insert(move(node), nullptr)) };",
          "content_same": false
        },
        {
          "line": 1689,
          "old_api": null,
          "new_api": "s parent is null, return null.\n        if (!parent())",
          "old_text": null,
          "new_text": "s parent is null, return null.\n        if (!parent())\n     ",
          "old_line_content": "        // If elements parent is null, return null.",
          "new_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"afterend\"sv)) {",
          "content_same": false
        },
        {
          "line": 1692,
          "old_api": null,
          "new_api": "to eleme",
          "old_text": null,
          "new_text": "to eleme",
          "old_line_content": "",
          "new_line_content": "        if (!parent())",
          "content_same": false
        },
        {
          "line": 1696,
          "old_api": null,
          "new_api": "rror::create(r",
          "old_text": null,
          "new_text": "rror::create(r",
          "old_line_content": "",
          "new_line_content": "        return JS::GCPtr<Node> { TRY(parent()->pre_insert(move(node), next_sibling())) };",
          "content_same": false
        },
        {
          "line": 1701,
          "old_api": null,
          "new_api": "where)));\n}\n\n// https://dom.spec.whatwg.org/#dom-element-insertadjacentelement\nWebIDL::ExceptionOr<JS::GCPtr<Element>> Ele",
          "old_text": null,
          "new_text": "where)));\n}\n\n// https://dom.spec.whatwg.org/#dom-element-insertadjacentelement\nWebIDL::ExceptionOr<JS::GCPtr<Element>> Ele",
          "old_line_content": "",
          "new_line_content": "    return WebIDL::SyntaxError::create(realm(), MUST(String::formatted(\"Unknown position '{}'. Must be one of 'beforebegin', 'afterbegin', 'beforeend' or 'afterend'\"sv, where)));",
          "content_same": false
        },
        {
          "line": 1708,
          "old_api": null,
          "new_api": "JS::GCPtr<Element> { verify_cas",
          "old_text": null,
          "new_text": "JS::GCPtr<Element> { verify_cas",
          "old_line_content": "        return JS::GCPtr<Element> { nullptr };",
          "new_line_content": "    auto returned_node = TRY(insert_adjacent(where, element));",
          "content_same": false
        },
        {
          "line": 1711,
          "old_api": null,
          "new_api": "ceptionOr<void> Element::insert_adja",
          "old_text": null,
          "new_text": "ceptionOr<void> Element::insert_adja",
          "old_line_content": "",
          "new_line_content": "    return JS::GCPtr<Element> { verify_cast<Element>(*returned_node) };",
          "content_same": false
        },
        {
          "line": 1718,
          "old_api": null,
          "new_api": "nothing be",
          "old_text": null,
          "new_text": "nothing be",
          "old_line_content": "    // 2. Run insert adjacent, given this, where, and text.",
          "new_line_content": "    auto text = heap().allocate<DOM::Text>(realm(), document(), data);",
          "content_same": false
        },
        {
          "line": 1722,
          "old_api": null,
          "new_api": "-into-view\nstatic ErrorOr<vo",
          "old_text": null,
          "new_text": "-into-view\nstatic ErrorOr<vo",
          "old_line_content": "}",
          "new_line_content": "    (void)TRY(insert_adjacent(where, text));",
          "content_same": false
        },
        {
          "line": 1732,
          "old_api": null,
          "new_api": "&& ancestor->p",
          "old_text": null,
          "new_text": " && ancestor->p",
          "old_line_content": "    while (ancestor) {",
          "new_line_content": "    auto ancestor = target.parent();",
          "content_same": false
        },
        {
          "line": 1736,
          "old_api": null,
          "new_api": "ollable_nodes) {\n        if (!scro",
          "old_text": null,
          "new_text": "ollable_nodes) {\n        if (!scro",
          "old_line_content": "    }",
          "new_line_content": "            scrollable_nodes.append(*ancestor);",
          "content_same": false
        },
        {
          "line": 1737,
          "old_api": null,
          "new_api": "nt",
          "old_text": null,
          "new_text": "nt()) {\n          ",
          "old_line_content": "",
          "new_line_content": "        ancestor = ancestor->parent();",
          "content_same": false
        },
        {
          "line": 1741,
          "old_api": null,
          "new_api": "continue;\n        }",
          "old_text": null,
          "new_text": "      continue;\n        }\n\n  ",
          "old_line_content": "            continue;",
          "new_line_content": "        if (!scrollable_node.is_document()) {",
          "content_same": false
        },
        {
          "line": 1748,
          "old_api": null,
          "new_api": "initial containing block\n        CS",
          "old_text": null,
          "new_text": "initial containing block\n        CS",
          "old_line_content": "        }",
          "new_line_content": "        if (target.document().origin() != scrollable_node.document().origin()) {",
          "content_same": false
        },
        {
          "line": 1753,
          "old_api": null,
          "new_api": "e return value of invoking Elements",
          "old_text": null,
          "new_text": "e return value of invoking Elements\n     ",
          "old_line_content": "        // 2. Let target bounding border box be the box represented by the return value of invoking Elements",
          "new_line_content": "        CSSPixelRect scrolling_box = scrollable_node.document().viewport_rect();",
          "content_same": false
        },
        {
          "line": 1758,
          "old_api": null,
          "new_api": "on of scrolling box, and",
          "old_text": null,
          "new_text": "on of scrolling box, and\n        ",
          "old_line_content": "        // 3. Let scrolling box edge A be the beginning edge in the block flow direction of scrolling box, and",
          "new_line_content": "        auto target_bounding_border_box = target.get_bounding_client_rect();",
          "content_same": false
        },
        {
          "line": 1763,
          "old_api": null,
          "new_api": "ng box edge B be the ending edge",
          "old_text": null,
          "new_text": "ng box edge B be the ending edge ",
          "old_line_content": "",
          "new_line_content": "        CSSPixels element_edge_a = CSSPixels::nearest_value_for(target_bounding_border_box->top());",
          "content_same": false
        },
        {
          "line": 1764,
          "old_api": null,
          "new_api": ", and let\n        /",
          "old_text": null,
          "new_text": ", and let\n        /",
          "old_line_content": "        // 4. Let scrolling box edge B be the ending edge in the block flow direction of scrolling box, and let",
          "new_line_content": "        CSSPixels scrolling_box_edge_a = scrolling_box.top();",
          "content_same": false
        },
        {
          "line": 1769,
          "old_api": null,
          "new_api": "olling box edge C be the beginning e",
          "old_text": null,
          "new_text": "olling box edge C be the beginning e",
          "old_line_content": "",
          "new_line_content": "        CSSPixels element_edge_b = CSSPixels::nearest_value_for(target_bounding_border_box->bottom());",
          "content_same": false
        },
        {
          "line": 1770,
          "old_api": null,
          "new_api": "g box, and\n        //",
          "old_text": null,
          "new_text": "g box, and\n        // ",
          "old_line_content": "        // 5. Let scrolling box edge C be the beginning edge in the inline base direction of scrolling box, and",
          "new_line_content": "        CSSPixels scrolling_box_edge_b = scrolling_box.bottom();",
          "content_same": false
        },
        {
          "line": 1775,
          "old_api": null,
          "new_api": "box edge D be the ending edge in",
          "old_text": null,
          "new_text": " box edge D be the ending edge in ",
          "old_line_content": "",
          "new_line_content": "        CSSPixels element_edge_c = CSSPixels::nearest_value_for(target_bounding_border_box->left());",
          "content_same": false
        },
        {
          "line": 1776,
          "old_api": null,
          "new_api": "and let element",
          "old_text": null,
          "new_text": "and let element\n    ",
          "old_line_content": "        // 6. Let scrolling box edge D be the ending edge in the inline base direction of scrolling box, and let element",
          "new_line_content": "        CSSPixels scrolling_box_edge_c = scrolling_box.left();",
          "content_same": false
        },
        {
          "line": 1780,
          "old_api": null,
          "new_api": "eight be the distance between eleme",
          "old_text": null,
          "new_text": "eight be the distance between eleme",
          "old_line_content": "",
          "new_line_content": "        CSSPixels element_edge_d = CSSPixels::nearest_value_for(target_bounding_border_box->right());",
          "content_same": false
        },
        {
          "line": 1781,
          "old_api": null,
          "new_api": "els element_height =",
          "old_text": null,
          "new_text": "els element_height = ",
          "old_line_content": "        // 7. Let element height be the distance between element edge A and element edge B.",
          "new_line_content": "        CSSPixels scrolling_box_edge_d = scrolling_box.right();",
          "content_same": false
        },
        {
          "line": 1796,
          "old_api": null,
          "new_api": "element edge A with scrolling box edge A.\n            if (block == Bindings::ScrollLogicalPosition::Start) {\n                y = element_edge_a;\n            }\n            // 2. Otherwise, if block is \"end\", then align element edge B with scrolling box edge B.\n            else if (block == Bindings::ScrollLogicalPosition::End) {\n                y = element_edge_a + element_height - scrolling_box_height;\n            }\n            // 3. Otherwise, if block is \"center\", then align the center of target bounding border box with the center of scrolling box in scrolling boxs block flow direction.\n            else if (block == Bindings::ScrollLogicalPosition::Center) {\n                y = element_edge_a + (element_height / 2) - (scrolling_box_height / 2);\n            }\n            // 4. Otherwise, block is \"nearest\":\n            else {\n                // If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n                if (element_edge_a <= 0 && element_edge_b >= scrolling_box_height) {\n                    // Do nothing.\n                }\n                // If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n                else if ((element_edge_a <= 0 && element_height < scrolling_box_height) || (element_edge_b >= scrolling_box_height && element_height > scrolling_box_height)) {\n                    // Align element edge A with scrolling box edge A.\n                    y = element_edge_a;\n                }\n                // If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n                else if ((element_edge_b >= scrolling_box_height && element_height < scrolling_box_height) || (element_edge_a <= 0 && element_height > scrolling_box_height)) {\n                    // Align element edge B with scrolling box edge B.\n                    y = element_edge_a + element_height - scrolling_box_height;\n                }\n            }\n\n            if (inline_ == Bindings::ScrollLogicalPosition::Nearest) {\n                // If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n                if (element_edge_c <= 0 && element_edge_d >= scrolling_box_width) {\n                    // Do nothing.\n                }\n                // If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n                else if ((element_edge_c <= 0 && element_width < scrolling_box_width) || (element_edge_d >= scrolling_box_width && element_width > scrolling_box_width)) {\n                    // Align element edge C with scrolling box edge C.\n                    x = element_edge_c;\n                }\n                // If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n                else if ((element_edge_d >= scrolling_box_width && element_width < scrolling_box_width) || (element_edge_c <= 0 && element_width > scrolling_box_width)) {\n                    // Align element edge D with scrolling box edge D.\n                    x = element_edge_d + element_width - scrolling_box_width;\n                }\n            }\n\n            return CSSPixelPoint { x, y };\n        }();\n\n        // FIXME: 12. If position is the same as scrolling boxs current scroll position, and scrolling box does not\n        //",
          "old_text": null,
          "new_text": " element edge A with scrolling box edge A.\n            if (block == Bindings::ScrollLogicalPosition::Start) {\n                y = element_edge_a;\n            }\n            // 2. Otherwise, if block is \"end\", then align element edge B with scrolling box edge B.\n            else if (block == Bindings::ScrollLogicalPosition::End) {\n                y = element_edge_a + element_height - scrolling_box_height;\n            }\n            // 3. Otherwise, if block is \"center\", then align the center of target bounding border box with the center of scrolling box in scrolling boxs block flow direction.\n            else if (block == Bindings::ScrollLogicalPosition::Center) {\n                y = element_edge_a + (element_height / 2) - (scrolling_box_height / 2);\n            }\n            // 4. Otherwise, block is \"nearest\":\n            else {\n                // If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n                if (element_edge_a <= 0 && element_edge_b >= scrolling_box_height) {\n                    // Do nothing.\n                }\n                // If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n                else if ((element_edge_a <= 0 && element_height < scrolling_box_height) || (element_edge_b >= scrolling_box_height && element_height > scrolling_box_height)) {\n                    // Align element edge A with scrolling box edge A.\n                    y = element_edge_a;\n                }\n                // If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n                else if ((element_edge_b >= scrolling_box_height && element_height < scrolling_box_height) || (element_edge_a <= 0 && element_height > scrolling_box_height)) {\n                    // Align element edge B with scrolling box edge B.\n                    y = element_edge_a + element_height - scrolling_box_height;\n                }\n            }\n\n            if (inline_ == Bindings::ScrollLogicalPosition::Nearest) {\n                // If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n                if (element_edge_c <= 0 && element_edge_d >= scrolling_box_width) {\n                    // Do nothing.\n                }\n                // If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n                else if ((element_edge_c <= 0 && element_width < scrolling_box_width) || (element_edge_d >= scrolling_box_width && element_width > scrolling_box_width)) {\n                    // Align element edge C with scrolling box edge C.\n                    x = element_edge_c;\n                }\n                // If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n                else if ((element_edge_d >= scrolling_box_width && element_width < scrolling_box_width) || (element_edge_c <= 0 && element_width > scrolling_box_width)) {\n                    // Align element edge D with scrolling box edge D.\n                    x = element_edge_d + element_width - scrolling_box_width;\n                }\n            }\n\n            return CSSPixelPoint { x, y };\n        }();\n\n        // FIXME: 12. If position is the same as scrolling boxs current scroll position, and scrolling box does not\n        //  ",
          "old_line_content": "            CSSPixels y = 0;",
          "new_line_content": "        auto position = [&]() -> CSSPixelPoint {",
          "content_same": false
        },
        {
          "line": 1860,
          "old_api": null,
          "new_api": "null otherwise.\n            // FIXME: 3. Pe",
          "old_text": null,
          "new_text": " null otherwise.\n            // FIXME: 3. Pe",
          "old_line_content": "            // FIXME: 2. Let root element be documents root element, if there is one, or null otherwise.",
          "new_line_content": "            auto& document = static_cast<DOM::Document&>(scrollable_node);",
          "content_same": false
        },
        {
          "line": 1869,
          "old_api": null,
          "new_api": "iated with an ele",
          "old_text": null,
          "new_text": "iated with an ele",
          "old_line_content": "        }",
          "new_line_content": "            position.set_y(position.y() + scrolling_box.y());",
          "content_same": false
        },
        {
          "line": 1870,
          "old_api": null,
          "new_api": "se {\n            // FIXME: Perform a scroll of the element",
          "old_text": null,
          "new_text": "se {\n            // FIXME: Perform a scroll of the element",
          "old_line_content": "        // If scrolling box is associated with an element",
          "new_line_content": "            document.navigable()->perform_scroll_of_viewport(position);",
          "content_same": false
        },
        {
          "line": 1897,
          "old_api": null,
          "new_api": "ollIntoViewOptions>().block;",
          "old_text": null,
          "new_text": "ollIntoViewOptions>().block;\n\n   ",
          "old_line_content": "        // 2. Set block to the block dictionary member of options.",
          "new_line_content": "        behavior = arg->get<ScrollIntoViewOptions>().behavior;",
          "content_same": false
        },
        {
          "line": 1900,
          "old_api": null,
          "new_api": "rollIntoViewOptions>().inline_;",
          "old_text": null,
          "new_text": "rollIntoViewOptions>().inline_;\n ",
          "old_line_content": "        // 3. Set inline to the inline dictionary member of options.",
          "new_line_content": "        block = arg->get<ScrollIntoViewOptions>().block;",
          "content_same": false
        },
        {
          "line": 1903,
          "old_api": null,
          "new_api": "&& arg->has<bool>() && arg->get<",
          "old_text": null,
          "new_text": " && arg->has<bool>() && arg->get<",
          "old_line_content": "    // 5. Otherwise, if arg is false, then set block to \"end\".",
          "new_line_content": "        inline_ = arg->get<ScrollIntoViewOptions>().inline_;",
          "content_same": false
        },
        {
          "line": 1906,
          "old_api": null,
          "new_api": "ted box, or is n",
          "old_text": null,
          "new_text": "ted box, or is n",
          "old_line_content": "    }",
          "new_line_content": "    else if (arg.has_value() && arg->has<bool>() && arg->get<bool>() == false) {",
          "content_same": false
        },
        {
          "line": 1912,
          "old_api": null,
          "new_api": "ior, block, a",
          "old_text": null,
          "new_text": "ior, block, a",
          "old_line_content": "",
          "new_line_content": "    if (!layout_node())",
          "content_same": false
        },
        {
          "line": 1913,
          "old_api": null,
          "new_api": "Y",
          "old_text": null,
          "new_text": "Y(scroll_an_element_into_view(*this, behavior, block, inli",
          "old_line_content": "    // 7. Scroll the element into view with behavior, block, and inline.",
          "new_line_content": "        return Error::from_string_view(\"Element has no associated box\"sv);",
          "content_same": false
        },
        {
          "line": 1916,
          "old_api": null,
          "new_api": "rings the element to the users attention.\n}\n\nvoid Element::",
          "old_text": null,
          "new_text": "rings the element to the users attention.\n}\n\nvoid Element::",
          "old_line_content": "    return {};",
          "new_line_content": "    TRY(scroll_an_element_into_view(*this, behavior, block, inline_));",
          "content_same": false
        },
        {
          "line": 1929,
          "old_api": null,
          "new_api": "e following elemen",
          "old_text": null,
          "new_text": "e following elemen",
          "old_line_content": "",
          "new_line_content": "    invalidate_style();",
          "content_same": false
        },
        {
          "line": 1938,
          "old_api": null,
          "new_api": "on is conditi",
          "old_text": null,
          "new_text": "on is conditi",
          "old_line_content": "",
          "new_line_content": "    if (!layout_node())",
          "content_same": false
        },
        {
          "line": 1943,
          "old_api": null,
          "new_api": "luded from the ac",
          "old_text": null,
          "new_text": "luded from the ac",
          "old_line_content": "        return true;",
          "new_line_content": "    auto role = role_or_default();",
          "content_same": false
        },
        {
          "line": 1972,
          "old_api": null,
          "new_api": "g:\n    // Elements that are curre",
          "old_text": null,
          "new_text": "g:\n    // Elements that are curre",
          "old_line_content": "    // Elements that are not hidden and may fire an accessibility API event, including:",
          "new_line_content": "    if (exclude_from_accessibility_tree())",
          "content_same": false
        },
        {
          "line": 1976,
          "old_api": null,
          "new_api": "have an expl",
          "old_text": null,
          "new_text": "have an expl",
          "old_line_content": "    // TODO: Elements that are a valid target of an aria-activedescendant attribute.",
          "new_line_content": "    if (is_focused())",
          "content_same": false
        },
        {
          "line": 1983,
          "old_api": null,
          "new_api": "via a WAI-ARI",
          "old_text": null,
          "new_text": "via a WAI-ARI",
          "old_line_content": "",
          "new_line_content": "    if ((role_or_default().has_value() || has_global_aria_attribute()) && aria_hidden() != \"true\")",
          "content_same": false
        },
        {
          "line": 1995,
          "old_api": null,
          "new_api": "ions_stack = custom_data->c",
          "old_text": null,
          "new_text": "ions_stack = custom_data->c",
          "old_line_content": "    auto& reactions_stack = custom_data->custom_element_reactions_stack;",
          "new_line_content": "    auto& relevant_agent = HTML::relevant_agent(*this);",
          "content_same": false
        },
        {
          "line": 1996,
          "old_api": null,
          "new_api": "then:\n    if (reactions_sta",
          "old_text": null,
          "new_text": " then:\n    if (reactions_sta",
          "old_line_content": "",
          "new_line_content": "    auto* custom_data = verify_cast<Bindings::WebEngineCustomData>(relevant_agent.custom_data());",
          "content_same": false
        },
        {
          "line": 2002,
          "old_api": null,
          "new_api": "eturn.\n        if (reactions_stack.processing_the_",
          "old_text": null,
          "new_text": "eturn.\n        if (reactions_stack.processing_the_",
          "old_line_content": "        // 2. If reactionsStack's processing the backup element queue flag is set, then return.",
          "new_line_content": "        reactions_stack.backup_element_queue.append(*this);",
          "content_same": false
        },
        {
          "line": 2014,
          "old_api": null,
          "new_api": "auto& reactions_stack",
          "old_text": null,
          "new_text": "     auto& reactions_stack ",
          "old_line_content": "            auto& reactions_stack = custom_data->custom_element_reactions_stack;",
          "new_line_content": "            auto& relevant_agent = HTML::relevant_agent(*this);",
          "content_same": false
        },
        {
          "line": 2015,
          "old_api": null,
          "new_api": "om element reactions in reac",
          "old_text": null,
          "new_text": "om element reactions in reac",
          "old_line_content": "",
          "new_line_content": "            auto* custom_data = verify_cast<Bindings::WebEngineCustomData>(relevant_agent.custom_data());",
          "content_same": false
        },
        {
          "line": 2019,
          "old_api": null,
          "new_api": "up element queue flag.\n            reactions_stack.processing_the_backup_elemen",
          "old_text": null,
          "new_text": "up element queue flag.\n            reactions_stack.processing_the_backup_elemen",
          "old_line_content": "            // 2. Unset reactionsStack's processing the backup element queue flag.",
          "new_line_content": "            Bindings::invoke_custom_element_reactions(reactions_stack.backup_element_queue);",
          "content_same": false
        },
        {
          "line": 2029,
          "old_api": null,
          "new_api": "-upgrade-reaction\nvoid Element::enqueue_a_custom_e",
          "old_text": null,
          "new_text": "-upgrade-reaction\nvoid Element::enqueue_a_custom_e",
          "old_line_content": "",
          "new_line_content": "    custom_data->current_element_queue().append(*this);",
          "content_same": false
        },
        {
          "line": 2036,
          "old_api": null,
          "new_api": "/ 2. Enqueue an element on the appropriate element queue given element.\n    enqueue_an_element_on_the_appropriate_element_queue();\n}",
          "old_text": null,
          "new_text": "/ 2. Enqueue an element on the appropriate element queue given element.\n    enqueue_an_element_on_the_appropriate_element_queue();\n}\n\n",
          "old_line_content": "    // 2. Enqueue an element on the appropriate element queue given element.",
          "new_line_content": "    ensure_custom_element_reaction_queue().append(CustomElementUpgradeReaction { .custom_element_definition = custom_element_definition });",
          "content_same": false
        },
        {
          "line": 2039,
          "old_api": null,
          "new_api": "ame, JS::MarkedVector<JS::Value> arguments)\n{\n    //",
          "old_text": null,
          "new_text": "ame, JS::MarkedVector<JS::Value> arguments)\n{\n    // ",
          "old_line_content": "",
          "new_line_content": "    enqueue_an_element_on_the_appropriate_element_queue();",
          "content_same": false
        }
      ],
      "deletions": [
        {
          "line": 2049,
          "old_api": "tributeChangedCallback\", then:\n    if (",
          "new_api": null,
          "old_text": "tributeChangedCallback\", then:\n    if (",
          "new_text": null,
          "old_line_content": "    if (callback_iterator == definition->lifecycle_callbacks().end())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2058,
          "old_api": "attribute_name = att",
          "new_api": null,
          "old_text": "attribute_name = att",
          "new_text": null,
          "old_line_content": "        VERIFY(!arguments.is_empty());",
          "new_line_content": "    if (callback_name == HTML::CustomElementReactionNames::attributeChangedCallback) {",
          "content_same": false
        },
        {
          "line": 2059,
          "old_api": "g",
          "new_api": null,
          "old_text": "g();\n\n        // ",
          "new_text": null,
          "old_line_content": "        auto& attribute_name_value = arguments.first();",
          "new_line_content": "        // 1. Let attributeName be the first element of args.",
          "content_same": false
        },
        {
          "line": 2064,
          "old_api": "custom element reaction queue, with callback function callback",
          "new_api": null,
          "old_text": " custom element reaction queue, with callback function callback",
          "new_text": null,
          "old_line_content": "        if (!definition->observed_attributes().contains_slow(attribute_name))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2069,
          "old_api": "ement_queue",
          "new_api": null,
          "old_text": "ement_queue();\n",
          "new_text": null,
          "old_line_content": "    ensure_custom_element_reaction_queue().append(CustomElementCallbackReaction { .callback = callback_iterator->value, .arguments = move(arguments) });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2072,
          "old_api": "ement\nJS::ThrowCompletionOr<void> Element::upgrade_el",
          "new_api": null,
          "old_text": "ement\nJS::ThrowCompletionOr<void> Element::upgrade_el",
          "new_text": null,
          "old_line_content": "    enqueue_an_element_on_the_appropriate_element_queue();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2078,
          "old_api": "if (m_custom_",
          "new_api": null,
          "old_text": "if (m_custom_",
          "new_text": null,
          "old_line_content": "    auto& realm = this->realm();",
          "new_line_content": "JS::ThrowCompletionOr<void> Element::upgrade_element(JS::NonnullGCPtr<HTML::CustomElementDefinition> custom_element_definition)",
          "content_same": false
        },
        {
          "line": 2079,
          "old_api": "CustomElem",
          "new_api": null,
          "old_text": "CustomElem",
          "new_text": null,
          "old_line_content": "    auto& vm = this->vm();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2093,
          "old_api": "JS::MarkedVect",
          "new_api": null,
          "old_text": "        JS::MarkedVect",
          "new_text": null,
          "old_line_content": "    for (size_t attribute_index = 0; attribute_index < m_attributes->length(); ++attribute_index) {",
          "new_line_content": "    // 4. For each attribute in element's attribute list, in order, enqueue a custom element callback reaction with element, callback name \"attributeChangedCallback\",",
          "content_same": false
        },
        {
          "line": 2094,
          "old_api": "append",
          "new_api": null,
          "old_text": "ts.append(JS::PrimitiveString::crea",
          "new_text": null,
          "old_line_content": "        auto const* attribute = m_attributes->item(attribute_index);",
          "new_line_content": "    //    and an argument list containing attribute's local name, null, attribute's value, and attribute's namespace.",
          "content_same": false
        },
        {
          "line": 2100,
          "old_api": "ri",
          "new_api": null,
          "old_text": "ri().has_valu",
          "new_text": null,
          "old_line_content": "        arguments.append(JS::js_null());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2108,
          "old_api": "CustomElementR",
          "new_api": null,
          "old_text": "CustomElementR",
          "new_text": null,
          "old_line_content": "    if (is_connected()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2109,
          "old_api": "}",
          "new_api": null,
          "old_text": "   }\n\n   ",
          "new_text": null,
          "old_line_content": "        JS::MarkedVector<JS::Value> empty_arguments { vm.heap() };",
          "new_line_content": "    // 5. If element is connected, then enqueue a custom element callback reaction with element, callback name \"connectedCallback\", and an empty argument list.",
          "content_same": false
        },
        {
          "line": 2114,
          "old_api": "/ 8. Run the followin",
          "new_api": null,
          "old_text": "/ 8. Run the followin",
          "new_text": null,
          "old_line_content": "    custom_element_definition->construction_stack().append(JS::make_handle(this));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2117,
          "old_api": "ustom_element = [&]() -> JS::ThrowComple",
          "new_api": null,
          "old_text": "ustom_element = [&]() -> JS::ThrowComple",
          "new_text": null,
          "old_line_content": "    auto& constructor = custom_element_definition->constructor();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2122,
          "old_api": "and the cust",
          "new_api": null,
          "old_text": " and the cust",
          "new_text": null,
          "old_line_content": "        if (custom_element_definition->disable_shadow() && shadow_root())",
          "new_line_content": "    auto attempt_to_construct_custom_element = [&]() -> JS::ThrowCompletionOr<void> {",
          "content_same": false
        },
        {
          "line": 2123,
          "old_api": ";\n\n        // 2. Set element's custom element state to \"precustomized\".\n        m_custom_element_state = CustomElementState::Precustomized;",
          "new_api": null,
          "old_text": ";\n\n        // 2. Set element's custom element state to \"precustomized\".\n        m_custom_element_state = CustomElementState::Precustomized;\n\n",
          "new_text": null,
          "old_line_content": "            return JS::throw_completion(WebIDL::NotSupportedError::create(realm, \"Custom element definition disables shadow DOM and the custom element has a shadow root\"_fly_string));",
          "new_line_content": "        // 1. If definition's disable shadow is true and element's shadow root is non-null, then throw a \"NotSupportedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 2129,
          "old_api": "release_value",
          "new_api": null,
          "old_text": "nal.release_value();\n\n        ",
          "new_text": null,
          "old_line_content": "        auto construct_result_optional = TRY(WebIDL::construct(constructor));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2130,
          "old_api": "(constructResult, element) is false,",
          "new_api": null,
          "old_text": "(constructResult, element) is false, ",
          "new_text": null,
          "old_line_content": "        VERIFY(construct_result_optional.has_value());",
          "new_line_content": "        // 3. Let constructResult be the result of constructing C, with no arguments.",
          "content_same": false
        },
        {
          "line": 2134,
          "old_api": "erent element from the custom element\"",
          "new_api": null,
          "old_text": "erent element from the custom element\"",
          "new_text": null,
          "old_line_content": "        if (!JS::same_value(construct_result, this))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2135,
          "old_api": "{};\n    };\n\n    auto maybe_exception = attempt_to_construct_custom_element();\n\n    // Then, perform the following substep, r",
          "new_api": null,
          "old_text": "{};\n    };\n\n    auto maybe_exception = attempt_to_construct_custom_element();\n\n    // Then, perform the following substep, r",
          "new_text": null,
          "old_line_content": "            return vm.throw_completion<JS::TypeError>(\"Constructing the custom element returned a different element from the custom element\"sv);",
          "new_line_content": "        // 4. If SameValue(constructResult, element) is false, then throw a TypeError.",
          "content_same": false
        },
        {
          "line": 2140,
          "old_api": "r not:\n    // 1. Remove the last entr",
          "new_api": null,
          "old_text": "r not:\n    // 1. Remove the last entr",
          "new_text": null,
          "old_line_content": "    auto maybe_exception = attempt_to_construct_custom_element();",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 2144,
          "old_api": "is_throw_completion",
          "new_api": null,
          "old_text": "tion.is_throw_completion()) {\n        // 1. Set element's c",
          "new_text": null,
          "old_line_content": "    (void)custom_element_definition->construction_stack().take_last();",
          "new_line_content": "    // Then, perform the following substep, regardless of whether the above steps threw an exception or not:",
          "content_same": false
        },
        {
          "line": 2147,
          "old_api": "nullptr;\n\n        // 2. Empty element",
          "new_api": null,
          "old_text": "nullptr;\n\n        // 2. Empty element",
          "new_text": null,
          "old_line_content": "    if (maybe_exception.is_throw_completion()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2153,
          "old_api": "release_error",
          "new_api": null,
          "old_text": "on.release_error();\n    }\n\n    // FIXME:",
          "new_text": null,
          "old_line_content": "            m_custom_element_reaction_queue->clear();",
          "new_line_content": "        // 2. Empty element's custom element reaction queue.",
          "content_same": false
        },
        {
          "line": 2156,
          "old_api": "orm owner of element. If elemen",
          "new_api": null,
          "old_text": "orm owner of element. If elemen",
          "new_text": null,
          "old_line_content": "        return maybe_exception.release_error();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2173,
          "old_api": "if (definiti",
          "new_api": null,
          "old_text": "if (definiti",
          "new_text": null,
          "old_line_content": "    auto definition = document().lookup_custom_element_definition(namespace_uri(), local_name(), m_is_value);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2177,
          "old_api": "t\n{\n    // An element whose custom element state is \"u",
          "new_api": null,
          "old_text": "t\n{\n    // An element whose custom element state is \"u",
          "new_text": null,
          "old_line_content": "        enqueue_a_custom_element_upgrade_reaction(*definition);",
          "new_line_content": "    // 2. If definition is not null, then enqueue a custom element upgrade reaction given element and definition.",
          "content_same": false
        },
        {
          "line": 2209,
          "old_api": "++i)",
          "new_api": null,
          "old_text": " ++i)\n     ",
          "new_text": null,
          "old_line_content": "    m_qualified_name.set_prefix(move(value));",
          "new_line_content": "void Element::set_prefix(Optional<FlyString> value)",
          "content_same": false
        },
        {
          "line": 2214,
          "old_api": "const&)> callback) con",
          "new_api": null,
          "old_text": "const&)> callback) con",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < m_attributes->length(); ++i)",
          "new_line_content": "void Element::for_each_attribute(Function<void(Attr const&)> callback) const",
          "content_same": false
        },
        {
          "line": 2215,
          "old_api": "te",
          "new_api": null,
          "old_text": "te([&callback](Attr c",
          "new_text": null,
          "old_line_content": "        callback(*m_attributes->item(i));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2220,
          "old_api": "t::layout_node()\n{\n    return static_cast<Layout::NodeWithStyle*>(Node::layout_node());\n}\n\nJS::GCPtr<L",
          "new_api": null,
          "old_text": "t::layout_node()\n{\n    return static_cast<Layout::NodeWithStyle*>(Node::layout_node());\n}\n\nJS::GCPtr<L",
          "new_text": null,
          "old_line_content": "    for_each_attribute([&callback](Attr const& attr) {",
          "new_line_content": "void Element::for_each_attribute(Function<void(FlyString const&, String const&)> callback) const",
          "content_same": false
        },
        {
          "line": 2221,
          "old_api": "de",
          "new_api": null,
          "old_text": "de());\n}\n\nJS",
          "new_text": null,
          "old_line_content": "        callback(attr.name(), attr.value());",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2227,
          "old_api": ">(Node::layout_node",
          "new_api": null,
          "old_text": ">(Node::layout_node",
          "new_text": null,
          "old_line_content": "    return static_cast<Layout::NodeWithStyle*>(Node::layout_node());",
          "new_line_content": "JS::GCPtr<Layout::NodeWithStyle> Element::layout_node()",
          "content_same": false
        },
        {
          "line": 2232,
          "old_api": "st\n{\n    return m_a",
          "new_api": null,
          "old_text": "st\n{\n    return m_a",
          "new_text": null,
          "old_line_content": "    return static_cast<Layout::NodeWithStyle const*>(Node::layout_node());",
          "new_line_content": "JS::GCPtr<Layout::NodeWithStyle const> Element::layout_node() const",
          "content_same": false
        },
        {
          "line": 2237,
          "old_api": "lues",
          "new_api": null,
          "old_text": "lues(RefPtr<CSS::StylePr",
          "new_text": null,
          "old_line_content": "    return !m_attributes->is_empty();",
          "new_line_content": "bool Element::has_attributes() const",
          "content_same": false
        },
        {
          "line": 2242,
          "old_api": "computed_css_values_",
          "new_api": null,
          "old_text": "  computed_css_values_",
          "new_text": null,
          "old_line_content": "    return m_attributes->length();",
          "new_line_content": "size_t Element::attribute_list_size() const",
          "content_same": false
        },
        {
          "line": 2247,
          "old_api": "element, Re",
          "new_api": null,
          "old_text": "element, Re",
          "new_text": null,
          "old_line_content": "    m_computed_css_values = move(style);",
          "new_line_content": "void Element::set_computed_css_values(RefPtr<CSS::StyleProperties> style)",
          "content_same": false
        },
        {
          "line": 2248,
          "old_api": "SS::StyleProperties> style)\n{",
          "new_api": null,
          "old_text": "SS::StyleProperties> style)\n{",
          "new_text": null,
          "old_line_content": "    computed_css_values_changed();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2255,
          "old_api": "o_element =",
          "new_api": null,
          "old_text": "o_element =",
          "new_text": null,
          "old_line_content": "    ensure_pseudo_element(pseudo_element).computed_css_values = move(style);",
          "new_line_content": "    if (!m_pseudo_element_data && !style)",
          "content_same": false
        },
        {
          "line": 2260,
          "old_api": "Element::PseudoElement&>",
          "new_api": null,
          "old_text": "Element::PseudoElement&>",
          "new_text": null,
          "old_line_content": "    auto pseudo_element = get_pseudo_element(type);",
          "new_line_content": "RefPtr<CSS::StyleProperties> Element::pseudo_element_computed_css_values(CSS::Selector::PseudoElement::Type type)",
          "content_same": false
        },
        {
          "line": 2261,
          "old_api": "get_pseudo_element",
          "new_api": null,
          "old_text": "get_pseudo_element(CSS::Se",
          "new_text": null,
          "old_line_content": "    if (pseudo_element.has_value())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2270,
          "old_api": "_element_data)",
          "new_api": null,
          "old_text": "_element_data)\n    ",
          "new_text": null,
          "old_line_content": "    return m_pseudo_element_data->at(to_underlying(type));",
          "new_line_content": "    if (!m_pseudo_element_data)",
          "content_same": false
        },
        {
          "line": 2276,
          "old_api": "r::PseudoElement::Type> p",
          "new_api": null,
          "old_text": "r::PseudoElement::Type> p",
          "new_text": null,
          "old_line_content": "        m_pseudo_element_data = make<PseudoElementData>();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2277,
          "old_api": "StyleProperty> cust",
          "new_api": null,
          "old_text": "StyleProperty> cust",
          "new_text": null,
          "old_line_content": "    return m_pseudo_element_data->at(to_underlying(type));",
          "new_line_content": "    if (!m_pseudo_element_data)",
          "content_same": false
        },
        {
          "line": 2282,
          "old_api": "value",
          "new_api": null,
          "old_text": "t.value()).custom_properti",
          "new_text": null,
          "old_line_content": "    if (!pseudo_element.has_value()) {",
          "new_line_content": "void Element::set_custom_properties(Optional<CSS::Selector::PseudoElement::Type> pseudo_element, HashMap<FlyString, CSS::StyleProperty> custom_properties)",
          "content_same": false
        },
        {
          "line": 2283,
          "old_api": "ashMap<FlyString, CSS::",
          "new_api": null,
          "old_text": "ashMap<FlyString, CSS::",
          "new_text": null,
          "old_line_content": "        m_custom_properties = move(custom_properties);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2286,
          "old_api": "pseudo_element) const\n{",
          "new_api": null,
          "old_text": "pseudo_element) const\n{",
          "new_text": null,
          "old_line_content": "    ensure_pseudo_element(pseudo_element.value()).custom_properties = move(custom_properties);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 2291,
          "old_api": "https://drafts.csswg.org/c",
          "new_api": null,
          "old_text": "https://drafts.csswg.org/c",
          "new_text": null,
          "old_line_content": "    if (!pseudo_element.has_value())",
          "new_line_content": "HashMap<FlyString, CSS::StyleProperty> const& Element::custom_properties(Optional<CSS::Selector::PseudoElement::Type> pseudo_element) const",
          "content_same": false
        },
        {
          "line": 2307,
          "old_api": "document",
          "new_api": null,
          "old_text": "to& document = this->document();\n\n  ",
          "new_text": null,
          "old_line_content": "    x = HTML::normalize_non_finite_values(x);",
          "new_line_content": "    //     4. Let the left dictionary member of options have the value x.",
          "content_same": false
        },
        {
          "line": 2308,
          "old_api": "document is not the active document",
          "new_api": null,
          "old_text": " document is not the active document",
          "new_text": null,
          "old_line_content": "    y = HTML::normalize_non_finite_values(y);",
          "new_line_content": "    //     5. Let the top dictionary member of options have the value y.",
          "content_same": false
        },
        {
          "line": 2311,
          "old_api": ". Let window be",
          "new_api": null,
          "old_text": ". Let window be ",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2314,
          "old_api": "ew",
          "new_api": null,
          "old_text": "ew();\n\n    // 6. If ",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2318,
          "old_api": "lement and document is",
          "new_api": null,
          "old_text": "lement and document is ",
          "new_text": null,
          "old_line_content": "    auto* window = document.default_view();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2325,
          "old_api": "// 8. If the element is",
          "new_api": null,
          "old_text": "  // 8. If the element is",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2329,
          "old_api": "cond argument, and termi",
          "new_api": null,
          "old_text": "cond argument, and termi",
          "new_text": null,
          "old_line_content": "    document.update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2332,
          "old_api": "ent, document is in quirks",
          "new_api": null,
          "old_text": "ent, document is in quirks ",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2333,
          "old_api": "ially scrollable,",
          "new_api": null,
          "old_text": "ially scrollable, ",
          "new_text": null,
          "old_line_content": "        window->scroll(window->scroll_x(), y);",
          "new_line_content": "    // 8. If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.",
          "content_same": false
        },
        {
          "line": 2339,
          "old_api": "ement has no associated scr",
          "new_api": null,
          "old_text": "ement has no associated scr",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable()) {",
          "new_line_content": "    // 9. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window",
          "content_same": false
        },
        {
          "line": 2340,
          "old_api": "or the element has n",
          "new_api": null,
          "old_text": "or the element has n",
          "new_text": null,
          "old_line_content": "        window->scroll(x, y);",
          "new_line_content": "    //    with options as the only argument, and terminate these steps.",
          "content_same": false
        },
        {
          "line": 2346,
          "old_api": "options.\n    //",
          "new_api": null,
          "old_text": "options.\n    //",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "    // 10. If the element does not have any associated box, the element has no associated scrolling box, or the element has no overflow, terminate these steps.",
          "content_same": false
        },
        {
          "line": 2351,
          "old_api": "paintable_box()->set_scroll_",
          "new_api": null,
          "old_text": "    paintable_box()->set_scroll_",
          "new_text": null,
          "old_line_content": "    auto scroll_offset = paintable_box()->scroll_offset();",
          "new_line_content": "    // 11. Scroll the element to x,y, with the scroll behavior being the value of the behavior dictionary member of options.",
          "content_same": false
        },
        {
          "line": 2352,
          "old_api": "// https://drafts.csswg.org/css",
          "new_api": null,
          "old_text": "// https://drafts.csswg.org/css",
          "new_text": null,
          "old_line_content": "    scroll_offset.set_x(CSSPixels::nearest_value_for(x));",
          "new_line_content": "    // FIXME: Implement this in terms of calling \"scroll the element\".",
          "content_same": false
        },
        {
          "line": 2366,
          "old_api": "://drafts.css",
          "new_api": null,
          "old_text": "://drafts.css",
          "new_text": null,
          "old_line_content": "    auto x = options.left.has_value() ? HTML::normalize_non_finite_values(options.left.value()) : scroll_left();",
          "new_line_content": "    //     4. Let y be the value of the top dictionary member of options, if present, or the elements current scroll position on the y axis otherwise.",
          "content_same": false
        },
        {
          "line": 2367,
          "old_api": "t options be",
          "new_api": null,
          "old_text": "t options be",
          "new_text": null,
          "old_line_content": "    auto y = options.top.has_value() ? HTML::normalize_non_finite_values(options.top.value()) : scroll_top();",
          "new_line_content": "    // NOTE: remaining steps performed by Element::scroll(double x, double y)",
          "content_same": false
        },
        {
          "line": 2384,
          "old_api": "options be the ar",
          "new_api": null,
          "old_text": " options be the ar",
          "new_text": null,
          "old_line_content": "    scroll_by(options);",
          "new_line_content": "    options.left = x;",
          "content_same": false
        },
        {
          "line": 2392,
          "old_api": "the left dictionary member.\n    options.left =",
          "new_api": null,
          "old_text": "the left dictionary member.\n    options.left = ",
          "new_text": null,
          "old_line_content": "    auto left = HTML::normalize_non_finite_values(options.left);",
          "new_line_content": "    // 1. Let options be the argument.",
          "content_same": false
        },
        {
          "line": 2393,
          "old_api": "eft;\n\n    // 4. Add the value of scrollTop to",
          "new_api": null,
          "old_text": "eft;\n\n    // 4. Add the value of scrollTop to ",
          "new_text": null,
          "old_line_content": "    auto top = HTML::normalize_non_finite_values(options.top);",
          "new_line_content": "    // 2. Normalize non-finite values for left and top dictionary members of options, if present.",
          "content_same": false
        },
        {
          "line": 2396,
          "old_api": "croll",
          "new_api": null,
          "old_text": "croll() metho",
          "new_text": null,
          "old_line_content": "    options.left = scroll_left() + left;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2399,
          "old_api": "g.org/cssom-",
          "new_api": null,
          "old_text": "g.org/cssom-",
          "new_text": null,
          "old_line_content": "    options.top = scroll_top() + top;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2402,
          "old_api": "options)\n{",
          "new_api": null,
          "old_text": "options)\n{\n    ",
          "new_text": null,
          "old_line_content": "    scroll(options);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2409,
          "old_api": "f an ancestor of this in t",
          "new_api": null,
          "old_text": "f an ancestor of this in t",
          "new_text": null,
          "old_line_content": "    document().update_layout();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2412,
          "old_api": "ment = parent_e",
          "new_api": null,
          "old_text": "ment = parent_e",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2416,
          "old_api": "}\n\n    // AD-HOC: Si",
          "new_api": null,
          "old_text": "\n    }\n\n    // AD-HOC: Si",
          "new_text": null,
          "old_line_content": "    for (auto* element = parent_element(); element; element = element->parent_element()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2417,
          "old_api": "the steps use the options, we can return early if we",
          "new_api": null,
          "old_text": "the steps use the options, we can return early if we",
          "new_text": null,
          "old_line_content": "        if (element->computed_css_values()->content_visibility() == CSS::ContentVisibility::Hidden)",
          "new_line_content": "    // 2. If an ancestor of this in the flat tree has content-visibility: hidden, return false.",
          "content_same": false
        },
        {
          "line": 2422,
          "old_api": "r an ancestor of th",
          "new_api": null,
          "old_text": "r an ancestor of th",
          "new_text": null,
          "old_line_content": "    if (!options.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2427,
          "old_api": "f either the visibilityPr",
          "new_api": null,
          "old_text": "f either the visibilityPr",
          "new_text": null,
          "old_line_content": "        for (auto* element = this; element; element = element->parent_element()) {",
          "new_line_content": "    // 3. If either the opacityProperty or the checkOpacity dictionary members of options are true, and this, or an ancestor of this in the flat tree, has a computed opacity value of 0, return false.",
          "content_same": false
        },
        {
          "line": 2428,
          "old_api": "isibilityCSS dictionary members of option",
          "new_api": null,
          "old_text": "isibilityCSS dictionary members of option",
          "new_text": null,
          "old_line_content": "            if (element->computed_css_values()->opacity() == 0.0f)",
          "new_line_content": "    if (options->opacity_property || options->check_opacity) {",
          "content_same": false
        },
        {
          "line": 2435,
          "old_api": "of options is true and an ancestor",
          "new_api": null,
          "old_text": "of options is true and an ancestor ",
          "new_text": null,
          "old_line_content": "        if (computed_css_values()->visibility() == CSS::Visibility::Hidden)",
          "new_line_content": "    // 4. If either the visibilityProperty or the checkVisibilityCSS dictionary members of options are true, and this is invisible, return false.",
          "content_same": false
        },
        {
          "line": 2443,
          "old_api": "false;\n        }\n    }",
          "new_api": null,
          "old_text": "false;\n        }\n    }\n\n ",
          "new_text": null,
          "old_line_content": "        for (auto* element = this; element; element = element->parent_element()) {",
          "new_line_content": "    auto const skipped_contents_due_to_content_visibility_auto = false;",
          "content_same": false
        },
        {
          "line": 2444,
          "old_api": ".\n    return true;\n}\n\nbool Element::id_reference_exi",
          "new_api": null,
          "old_text": ".\n    return true;\n}\n\nbool Element::id_reference_exi",
          "new_text": null,
          "old_line_content": "            if (element->computed_css_values()->content_visibility() == CSS::ContentVisibility::Auto)",
          "new_line_content": "    if (options->content_visibility_auto && skipped_contents_due_to_content_visibility_auto) {",
          "content_same": false
        },
        {
          "line": 2455,
          "old_api": "nObserver::IntersectionObserverRegistratio",
          "new_api": null,
          "old_text": "nObserver::IntersectionObserverRegistratio",
          "new_text": null,
          "old_line_content": "    return document().get_element_by_id(id_reference);",
          "new_line_content": "bool Element::id_reference_exists(String const& id_reference) const",
          "content_same": false
        },
        {
          "line": 2461,
          "old_api": "nt::unregister_intersection_observer(Badge<IntersectionObserver::Inter",
          "new_api": null,
          "old_text": "nt::unregister_intersection_observer(Badge<IntersectionObserver::Inter",
          "new_text": null,
          "old_line_content": "        m_registered_intersection_observers = make<Vector<IntersectionObserver::IntersectionObserverRegistration>>();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2462,
          "old_api": "erver::Intersectio",
          "new_api": null,
          "old_text": "erver::Intersectio",
          "new_text": null,
          "old_line_content": "    m_registered_intersection_observers->append(move(registration));",
          "new_line_content": "    if (!m_registered_intersection_observers)",
          "content_same": false
        },
        {
          "line": 2469,
          "old_api": "rn entry.observer == observer;\n    });\n}\n\nIntersectionObserver::IntersectionObserverRegistration& Element::get_intersection_observer_registration(Badge<DOM::Document>, IntersectionObserver::I",
          "new_api": null,
          "old_text": "rn entry.observer == observer;\n    });\n}\n\nIntersectionObserver::IntersectionObserverRegistration& Element::get_intersection_observer_registration(Badge<DOM::Document>, IntersectionObserver::I",
          "new_text": null,
          "old_line_content": "    m_registered_intersection_observers->remove_first_matching([&observer](IntersectionObserver::IntersectionObserverRegistration const& entry) {",
          "new_line_content": "    if (!m_registered_intersection_observers)",
          "content_same": false
        },
        {
          "line": 2476,
          "old_api": "r::IntersectionObserverRegistration const&",
          "new_api": null,
          "old_text": "r::IntersectionObserverRegistration const& ",
          "new_text": null,
          "old_line_content": "    VERIFY(m_registered_intersection_observers);",
          "new_line_content": "IntersectionObserver::IntersectionObserverRegistration& Element::get_intersection_observer_registration(Badge<DOM::Document>, IntersectionObserver::IntersectionObserver const& observer)",
          "content_same": false
        },
        {
          "line": 2477,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "ver.ptr() == &observer;\n    });\n    VERIFY(!registration_iterator.is_end());\n    return *registration_iterator;\n}\n\n// https://html.spec.whatwg.org/multipage/dom.html#the-directionality",
          "new_text": null,
          "old_line_content": "    auto registration_iterator = m_registered_intersection_observers->find_if([&observer](IntersectionObserver::IntersectionObserverRegistration const& entry) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2489,
          "old_api": ":",
          "new_api": null,
          "old_text": ":\n         ",
          "new_text": null,
          "old_line_content": "    auto maybe_dir = this->dir();",
          "new_line_content": "    // The directionality of an element (any element, not just an HTML element) is either 'ltr' or 'rtl'.",
          "content_same": false
        },
        {
          "line": 2490,
          "old_api": "rn 'ltr'.",
          "new_api": null,
          "old_text": "rn 'ltr'.\n           ",
          "new_text": null,
          "old_line_content": "    if (maybe_dir.has_value()) {",
          "new_line_content": "    // To compute the directionality given an element element, switch on element's dir attribute state:",
          "content_same": false
        },
        {
          "line": 2504,
          "old_api": "::Ltr;\n\n            /",
          "new_api": null,
          "old_text": "::Ltr;\n\n            /",
          "new_text": null,
          "old_line_content": "            auto result = auto_directionality();",
          "new_line_content": "        case Dir::Auto:",
          "content_same": false
        },
        {
          "line": 2507,
          "old_api": "}\n    // -> undef",
          "new_api": null,
          "old_text": " }\n    // -> undef",
          "new_text": null,
          "old_line_content": "            if (!result.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2511,
          "old_api": "1. Let result be t",
          "new_api": null,
          "old_text": "    1. Let result be t",
          "new_text": null,
          "old_line_content": "            return result.release_value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2515,
          "old_api": "2. If result is nu",
          "new_api": null,
          "old_text": "   2. If result is nu",
          "new_text": null,
          "old_line_content": "    VERIFY(!maybe_dir.has_value());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2523,
          "old_api": "return Directionality::Ltr;\n    }\n\n    // Otherwise:\n    //",
          "new_api": null,
          "old_text": "  return Directionality::Ltr;\n    }\n\n    // Otherwise:\n    // ",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLInputElement>(this) && static_cast<HTML::HTMLInputElement const&>(*this).type_state() == HTML::HTMLInputElement::TypeAttributeState::Telephone) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2530,
          "old_api": "nality_form_associated_",
          "new_api": null,
          "old_text": "nality_form_associated_",
          "new_text": null,
          "old_line_content": "    return parent_directionality();",
          "new_line_content": "    // Otherwise:",
          "content_same": false
        },
        {
          "line": 2539,
          "old_api": "_state",
          "new_api": null,
          "old_text": "_state(), HTML::HTMLInputElement::T",
          "new_text": null,
          "old_line_content": "    return is<HTML::HTMLTextAreaElement>(this)",
          "new_line_content": "    // input elements whose type attribute is in the Hidden, Text, Search, Telephone, URL, Email, Password, Submit Button, Reset Button, or Button state,",
          "content_same": false
        },
        {
          "line": 2540,
          "old_api": "tate::Text, HTML::HTMLInputElement::TypeAttributeState::Search",
          "new_api": null,
          "old_text": "tate::Text, HTML::HTMLInputElement::TypeAttributeState::Search",
          "new_text": null,
          "old_line_content": "        || (is<HTML::HTMLInputElement>(this) && first_is_one_of(static_cast<HTML::HTMLInputElement const&>(*this).type_state(), HTML::HTMLInputElement::TypeAttributeState::Hidden, HTML::HTMLInputElement::TypeAttributeState::Text, HTML::HTMLInputElement::TypeAttributeState::Search, HTML::HTMLInputElement::TypeAttributeState::Telephone, HTML::HTMLInputElement::TypeAttributeState::URL, HTML::HTMLInputElement::TypeAttributeState::Email, HTML::HTMLInputElement::TypeAttributeState::Password, HTML::HTMLInputElement::TypeAttributeState::SubmitButton, HTML::HTMLInputElement::TypeAttributeState::ResetButton, HTML::HTMLInputElement::TypeAttributeState::Button));",
          "new_line_content": "    // and textarea elements.",
          "content_same": false
        },
        {
          "line": 2546,
          "old_api": "o bidirectional_class_R = Unicode::bidirectiona",
          "new_api": null,
          "old_text": "o bidirectional_class_R = Unicode::bidirectiona",
          "new_text": null,
          "old_line_content": "    static auto bidirectional_class_L = Unicode::bidirectional_class_from_string(\"L\"sv);",
          "new_line_content": "Optional<Element::Directionality> Element::auto_directionality() const",
          "content_same": false
        },
        {
          "line": 2547,
          "old_api": "Assume 'ltr' if Unicode data generation is disa",
          "new_api": null,
          "old_text": " Assume 'ltr' if Unicode data generation is disa",
          "new_text": null,
          "old_line_content": "    static auto bidirectional_class_AL = Unicode::bidirectional_class_from_string(\"AL\"sv);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2551,
          "old_api": "auto text_node_directionality =",
          "new_api": null,
          "old_text": "  auto text_node_directionality =",
          "new_text": null,
          "old_line_content": "    if (!bidirectional_class_L.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2559,
          "old_api": "ss_L, bidirectio",
          "new_api": null,
          "old_text": "ss_L, bidirectio",
          "new_text": null,
          "old_line_content": "        for (auto code_point : Utf8View(text_node.data())) {",
          "new_line_content": "        // 2. Let codePoint be the first code point in text's data whose bidirectional character type is L, AL, or R.",
          "content_same": false
        },
        {
          "line": 2560,
          "old_api": ")) {\n                found_character_bid",
          "new_api": null,
          "old_text": ")) {\n                found_character_bid",
          "new_text": null,
          "old_line_content": "            auto bidi_class = Unicode::bidirectional_class(code_point);",
          "new_line_content": "        Optional<Unicode::BidirectionalClass> found_character_bidi_class;",
          "content_same": false
        },
        {
          "line": 2566,
          "old_api": "if (first_is_one_of(*found_cha",
          "new_api": null,
          "old_text": "        if (first_is_one_of(*found_cha",
          "new_text": null,
          "old_line_content": "        if (!found_character_bidi_class.has_value())",
          "new_line_content": "            }",
          "content_same": false
        },
        {
          "line": 2570,
          "old_api": "ePoint is of bidirectional character type L, then return 'ltr'.\n        // NOTE: codePoint",
          "new_api": null,
          "old_text": "ePoint is of bidirectional character type L, then return 'ltr'.\n        // NOTE: codePoint ",
          "new_text": null,
          "old_line_content": "        if (first_is_one_of(*found_character_bidi_class, bidirectional_class_AL, bidirectional_class_R))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2575,
          "old_api": "orm-associated element:\n    if (is_auto_directionality_form_",
          "new_api": null,
          "old_text": "orm-associated element:\n    if (is_auto_directionality_form_",
          "new_text": null,
          "old_line_content": "        VERIFY(*found_character_bidi_class == bidirectional_class_L);",
          "new_line_content": "        // 4. If codePoint is of bidirectional character type L, then return 'ltr'.",
          "content_same": false
        },
        {
          "line": 2580,
          "old_api": "VERIFY(form_associated_element);",
          "new_api": null,
          "old_text": "        VERIFY(form_associated_element);\n       ",
          "new_text": null,
          "old_line_content": "    if (is_auto_directionality_form_associated_element()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2581,
          "old_api": "e",
          "new_api": null,
          "old_text": "e();\n\n        // 1. If element's value contains a char",
          "new_text": null,
          "old_line_content": "        auto const* form_associated_element = dynamic_cast<HTML::FormAssociatedElement const*>(this);",
          "new_line_content": "    // 1. If element is an auto-directionality form-associated element:",
          "content_same": false
        },
        {
          "line": 2587,
          "old_api": "break;",
          "new_api": null,
          "old_text": "      break;\n  ",
          "new_text": null,
          "old_line_content": "        for (auto code_point : Utf8View(value)) {",
          "new_line_content": "        // 1. If element's value contains a character of bidirectional character type AL or R,",
          "content_same": false
        },
        {
          "line": 2588,
          "old_api": "ctional_class_AL || bidi_class == bidire",
          "new_api": null,
          "old_text": "ctional_class_AL || bidi_class == bidire",
          "new_text": null,
          "old_line_content": "            auto bidi_class = Unicode::bidirectional_class(code_point);",
          "new_line_content": "        //    and there is no character of bidirectional character type L anywhere before it in the element's value, then return 'rtl'.",
          "content_same": false
        },
        {
          "line": 2596,
          "old_api": "se root is a sha",
          "new_api": null,
          "old_text": "se root is a sha",
          "new_text": null,
          "old_line_content": "        if (value.is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2604,
          "old_api": "assigned_nodes",
          "new_api": null,
          "old_text": "& !slot.assigned_nodes().is_emp",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLSlotElement>(this)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2605,
          "old_api": "each node child of element's assigned nodes:",
          "new_api": null,
          "old_text": "each node child of element's assigned nodes:\n   ",
          "new_text": null,
          "old_line_content": "        auto const& slot = static_cast<HTML::HTMLSlotElement const&>(*this);",
          "new_line_content": "    // 2. If element is a slot element whose root is a shadow root and element's assigned nodes are not empty:",
          "content_same": false
        },
        {
          "line": 558,
          "old_api": ":Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {\n        s",
          "new_api": null,
          "old_text": ":Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {\n        s",
          "new_text": null,
          "old_line_content": "    for (auto i = 0; i < to_underlying(CSS::Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {",
          "new_line_content": "    auto recompute_pseudo_element_style = [&](CSS::Selector::PseudoElement::Type pseudo_element) {",
          "content_same": false
        },
        {
          "line": 563,
          "old_api": "pute_pseudo_element_style_if_needed",
          "new_api": null,
          "old_text": "pute_pseudo_element_style_if_needed(*this, pseudo_element);\n\n        // TODO",
          "new_text": null,
          "old_line_content": "        auto new_pseudo_element_style = style_computer.compute_pseudo_element_style_if_needed(*this, pseudo_element);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2613,
          "old_api": "else",
          "new_api": null,
          "old_text": "            else",
          "new_text": null,
          "old_line_content": "                if (child->is_text())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2614,
          "old_api": "VERIFY(child->",
          "new_api": null,
          "old_text": "                  VERIFY(child->",
          "new_text": null,
          "old_line_content": "                    child_direction = text_node_directionality(static_cast<Text const&>(*child));",
          "new_line_content": "                // 2. If child is a Text node, then set childDirection to the text node directionality of child.",
          "content_same": false
        },
        {
          "line": 567,
          "old_api": "nvalidation",
          "new_api": null,
          "old_text": "nvalidation(*pseudo_element_style, *new_pseudo_element_style);\n        } else i",
          "new_text": null,
          "old_line_content": "            invalidation |= compute_required_invalidation(*pseudo_element_style, *new_pseudo_element_style);",
          "new_line_content": "        } else if (pseudo_element_style || new_pseudo_element_style) {",
          "content_same": false
        },
        {
          "line": 569,
          "old_api": "idationAfterStyleChange::full();\n        }",
          "new_api": null,
          "old_text": "idationAfterStyleChange::full();\n        }\n\n     ",
          "new_text": null,
          "old_line_content": "            invalidation = CSS::RequiredInvalidationAfterStyleChange::full();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 2619,
          "old_api": "<HTML::HTMLElement",
          "new_api": null,
          "old_text": "<HTML::HTMLElement ",
          "new_text": null,
          "old_line_content": "                    VERIFY(child->is_element());",
          "new_line_content": "                else {",
          "content_same": false
        },
        {
          "line": 573,
          "old_api": "_ancestor",
          "new_api": null,
          "old_text": "_ancestor(*this);\n    }\n\n    if (i",
          "new_text": null,
          "old_line_content": "        style_computer.pop_ancestor(*this);",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 2622,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "ildDirection.\n                if (child_direction.has_value())\n   ",
          "new_text": null,
          "old_line_content": "                    child_direction = static_cast<HTML::HTMLElement const&>(*this).auto_directionality();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2626,
          "old_api": "}\n\n    // 3. For each nod",
          "new_api": null,
          "old_text": "  }\n\n    // 3. For each nod",
          "new_text": null,
          "old_line_content": "                if (child_direction.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 580,
          "old_api": "ds_to_resolve_paint_only_properties",
          "new_api": null,
          "old_text": "ds_to_resolve_paint_only_properties();\n\n    if (!invali",
          "new_text": null,
          "old_line_content": "        document().set_needs_to_resolve_paint_only_properties();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 585,
          "old_api": "pain",
          "new_api": null,
          "old_text": "       pain",
          "new_text": null,
          "old_line_content": "        if (invalidation.repaint && paintable())",
          "new_line_content": "        // If we're keeping the layout tree, we can just apply the new style to the existing layout tree.",
          "content_same": false
        },
        {
          "line": 589,
          "old_api": ":Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {",
          "new_api": null,
          "old_text": ":Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {\n         ",
          "new_text": null,
          "old_line_content": "        for (auto i = 0; i < to_underlying(CSS::Selector::PseudoElement::Type::KnownPseudoElementCount); i++) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 590,
          "old_api": "elector::PseudoElement::Type>(i);\n            auto",
          "new_api": null,
          "old_text": "elector::PseudoElement::Type>(i);\n            auto",
          "new_text": null,
          "old_line_content": "            auto pseudo_element_type = static_cast<CSS::Selector::PseudoElement::Type>(i);",
          "new_line_content": "        // Do the same for pseudo-elements.",
          "content_same": false
        },
        {
          "line": 2637,
          "old_api": "dir",
          "new_api": null,
          "old_text": "  // - FIXME: a bdi element\n        // - a script element\n        // - a style element\n        // - a textarea element\n        // - an element whose dir attribute is not in the undefined state\n        // then continue.\n        if (is<HTML::HTMLScriptElement>(descendant)\n            || is<HTML::HTMLStyleElement>(descendant)\n            || is<HTML::HTMLTextAreaElement>(descendant)\n            || (is<Element>(descendant) && static_cast<Element const&>(descendant).dir().has_value())) {\n            return TraversalDecision::SkipChildrenAndContinue;\n        }\n\n        // 2. If descendant is a slot element whose root is a shadow root, then return the directionality of that shadow root's host.\n        if (is<HTML::HTMLSlotElement>(descendant)) {\n            auto const& root = static_cast<HTML::HTMLSlotElement const&>(descendant).root();\n            if (root.is_shadow_root()) {\n                auto const& host = static_cast<ShadowRoot const&>(root).host();\n                VERIFY(host);\n                result = host->directionality();\n                return TraversalDecision::Break;\n            }\n        }\n\n        // 3. If descendant is not a Text node, then continue.\n        if (!descendant.is_text())\n            return TraversalDecision::Continue;\n\n        // 4. Let result be the text node directionality of descendant.\n        result = text_node_directionality(static_cast<Text const&>(descendant));\n\n        // 5. If result is not null, then return result.\n        if (result.has_value())\n            return TraversalDecision::Break;\n\n        return TraversalDecision::Continue;\n    });\n\n    if (result.has_value())\n        return result;\n\n    // 4. Return null.\n    return {};\n}\n\n// https://html.spec.whatwg.org/multipage/dom.html#parent-",
          "new_text": null,
          "old_line_content": "    for_each_in_subtree([&](auto& descendant) {",
          "new_line_content": "    // 3. For each node descendant of element's descendants, in tree order:",
          "content_same": false
        },
        {
          "line": 595,
          "old_api": "puted_css_values",
          "new_api": null,
          "old_text": "puted_css_values(pseudo_element_type);\n            if (",
          "new_text": null,
          "old_line_content": "            auto pseudo_element_style = pseudo_element_computed_css_values(pseudo_element_type);",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 2645,
          "old_api": "|| (is<Element>(descendant) &&",
          "new_api": null,
          "old_text": "         || (is<Element>(descendant) &&",
          "new_text": null,
          "old_line_content": "        if (is<HTML::HTMLScriptElement>(descendant)",
          "new_line_content": "        // - an element whose dir attribute is not in the undefined state",
          "content_same": false
        },
        {
          "line": 2646,
          "old_api": "dir",
          "new_api": null,
          "old_text": "ment const&>(descendant).dir().has_val",
          "new_text": null,
          "old_line_content": "            || is<HTML::HTMLStyleElement>(descendant)",
          "new_line_content": "        // then continue.",
          "content_same": false
        },
        {
          "line": 599,
          "old_api": "ptr",
          "new_api": null,
          "old_text": "yout_node.ptr())) {\n             ",
          "new_text": null,
          "old_line_content": "            if (auto* node_with_style = dynamic_cast<Layout::NodeWithStyle*>(pseudo_element->layout_node.ptr())) {",
          "new_line_content": "                continue;",
          "content_same": false
        },
        {
          "line": 600,
          "old_api": "pply_style",
          "new_api": null,
          "old_text": "pply_style(*pseudo_element_style);\n                ",
          "new_text": null,
          "old_line_content": "                node_with_style->apply_style(*pseudo_element_style);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2653,
          "old_api": "is_shadow_root",
          "new_api": null,
          "old_text": ".is_shadow_root()) {\n                ",
          "new_text": null,
          "old_line_content": "        if (is<HTML::HTMLSlotElement>(descendant)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2654,
          "old_api": "host",
          "new_api": null,
          "old_text": "owRoot const&>(root).host();\n                VERIFY(host);\n ",
          "new_text": null,
          "old_line_content": "            auto const& root = static_cast<HTML::HTMLSlotElement const&>(descendant).root();",
          "new_line_content": "        // 2. If descendant is a slot element whose root is a shadow root, then return the directionality of that shadow root's host.",
          "content_same": false
        },
        {
          "line": 612,
          "old_api": "yleDeclaration::create(*this, type);\n    auto propert",
          "new_api": null,
          "old_text": "yleDeclaration::create(*this, type);\n    auto propert",
          "new_text": null,
          "old_line_content": "    auto element_computed_style = CSS::ResolvedCSSStyleDeclaration::create(*this, type);",
          "new_line_content": "NonnullRefPtr<CSS::StyleProperties> Element::resolved_css_values(Optional<CSS::Selector::PseudoElement::Type> type)",
          "content_same": false
        },
        {
          "line": 613,
          "old_api": "es::create();\n\n    for (auto i",
          "new_api": null,
          "old_text": "es::create();\n\n    for (auto i",
          "new_text": null,
          "old_line_content": "    auto properties = CSS::StyleProperties::create();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2664,
          "old_api": "ult = text_node_dire",
          "new_api": null,
          "old_text": "ult = text_node_dire",
          "new_text": null,
          "old_line_content": "        if (!descendant.is_text())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 618,
          "old_api": "lue",
          "new_api": null,
          "old_text": "lue())\n            cont",
          "new_text": null,
          "old_line_content": "        if (!maybe_value.has_value())",
          "new_line_content": "        auto property_id = (CSS::PropertyID)i;",
          "content_same": false
        },
        {
          "line": 2668,
          "old_api": "salDecision::Break;\n\n        return",
          "new_api": null,
          "old_text": "salDecision::Break;\n\n        return ",
          "new_text": null,
          "old_line_content": "        result = text_node_directionality(static_cast<Text const&>(descendant));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2671,
          "old_api": "return result;",
          "new_api": null,
          "old_text": " return result;\n\n ",
          "new_text": null,
          "old_line_content": "        if (result.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2677,
          "old_api": "ity\nElement::Direc",
          "new_api": null,
          "old_text": "ity\nElement::Direc",
          "new_text": null,
          "old_line_content": "    if (result.has_value())",
          "new_line_content": "    });",
          "content_same": false
        },
        {
          "line": 630,
          "old_api": "reset_animated_properties",
          "new_api": null,
          "old_text": "ues->reset_animated_properties();\n}\n\nDOMTokenList*",
          "new_text": null,
          "old_line_content": "    m_computed_css_values->reset_animated_properties();",
          "new_line_content": "    if (!m_computed_css_values)",
          "content_same": false
        },
        {
          "line": 636,
          "old_api": "te",
          "new_api": null,
          "old_text": "te(*this, HTML::AttributeNames::class_);\n    return m_cla",
          "new_text": null,
          "old_line_content": "        m_class_list = DOMTokenList::create(*this, HTML::AttributeNames::class_);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2688,
          "old_api": "{\n        auto cons",
          "new_api": null,
          "old_text": "{\n        auto cons",
          "new_text": null,
          "old_line_content": "    auto const* parent_node = this->parent_node();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2691,
          "old_api": "directionality",
          "new_api": null,
          "old_text": "directionality();\n    }\n\n  ",
          "new_text": null,
          "old_line_content": "    if (is<ShadowRoot>(parent_node)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2692,
          "old_api": "ment, then return the directionality of parentNode.",
          "new_api": null,
          "old_text": "ment, then return the directionality of parentNode.",
          "new_text": null,
          "old_line_content": "        auto const& host = static_cast<ShadowRoot const&>(*parent_node).host();",
          "new_line_content": "    // 2. If parentNode is a shadow root, then return the directionality of parentNode's host.",
          "content_same": false
        },
        {
          "line": 646,
          "old_api": "tom_element_name",
          "new_api": null,
          "old_text": "tom_element_name(name)\n        && !name.",
          "new_text": null,
          "old_line_content": "    if (!HTML::is_valid_custom_element_name(name)",
          "new_line_content": "    // - a valid custom element name",
          "content_same": false
        },
        {
          "line": 647,
          "old_api": "ticle\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\")) {\n        return",
          "new_api": null,
          "old_text": "ticle\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\")) {\n        return",
          "new_text": null,
          "old_line_content": "        && !name.is_one_of(\"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", \"span\")) {",
          "new_line_content": "    // - \"article\", \"aside\", \"blockquote\", \"body\", \"div\", \"footer\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"main\", \"nav\", \"p\", \"section\", or \"span\"",
          "content_same": false
        },
        {
          "line": 2698,
          "old_api": "tr;\n}\n\n// https://dom.sp",
          "new_api": null,
          "old_text": "tr;\n}\n\n// https://dom.sp",
          "new_text": null,
          "old_line_content": "    if (is<Element>(parent_node))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2699,
          "old_api": "f-for-concept-element-attributes-change-ext\nvoid Element:",
          "new_api": null,
          "old_text": "f-for-concept-element-attributes-change-ext\nvoid Element:",
          "new_text": null,
          "old_line_content": "        return static_cast<Element const&>(*parent_node).directionality();",
          "new_line_content": "    // 3. If parentNode is an element, then return the directionality of parentNode.",
          "content_same": false
        },
        {
          "line": 657,
          "old_api": "amespace::HTML)",
          "new_api": null,
          "old_text": "amespace::HTML)",
          "new_text": null,
          "old_line_content": "    if (namespace_uri() != Namespace::HTML)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 658,
          "old_api": "namespa",
          "new_api": null,
          "old_text": "namespa",
          "new_text": null,
          "old_line_content": "        return WebIDL::NotSupportedError::create(realm(), \"Element's namespace is not the HTML namespace\"_fly_string);",
          "new_line_content": "    // 1. If elements namespace is not the HTML namespace, then throw a \"NotSupportedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 661,
          "old_api": "return WebI",
          "new_api": null,
          "old_text": " return WebI",
          "new_text": null,
          "old_line_content": "    if (!is_valid_shadow_host_name(local_name()))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 662,
          "old_api": "cal nam",
          "new_api": null,
          "old_text": "cal nam",
          "new_text": null,
          "old_line_content": "        return WebIDL::NotSupportedError::create(realm(), \"Element's local name is not a valid shadow host name\"_fly_string);",
          "new_line_content": "    // 2. If elements local name is not a valid shadow host name, then throw a \"NotSupportedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 2709,
          "old_api": "ll and oldValue is the",
          "new_api": null,
          "old_text": "ll and oldValue is the",
          "new_text": null,
          "old_line_content": "    if (local_name == HTML::AttributeNames::slot && !namespace_.has_value()) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 665,
          "old_api": "// 1. Let defi",
          "new_api": null,
          "old_text": "        // 1. Let defi",
          "new_text": null,
          "old_line_content": "    if (HTML::is_valid_custom_element_name(local_name()) || m_is_value.has_value()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2715,
          "old_api": "value == String {",
          "new_api": null,
          "old_text": "value == String {",
          "new_text": null,
          "old_line_content": "        if (!value.has_value() && old_value == String {})",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 670,
          "old_api": "return WebIDL::N",
          "new_api": null,
          "old_text": "            return WebIDL::N",
          "new_text": null,
          "old_line_content": "        if (definition && definition->disable_shadow())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 671,
          "old_api": "ow root",
          "new_api": null,
          "old_text": "ow root",
          "new_text": null,
          "old_line_content": "            return WebIDL::NotSupportedError::create(realm(), \"Cannot attach a shadow root to a custom element that has disabled shadow roots\"_fly_string);",
          "new_line_content": "        // 2. If definition is not null and definitions disable shadow is true, then throw a \"NotSupportedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 2719,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "lue.has_value() || va",
          "new_text": null,
          "old_line_content": "        if (value == String {} && !old_value.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 675,
          "old_api": "1. Let currentS",
          "new_api": null,
          "old_text": " 1. Let currentS",
          "new_text": null,
          "old_line_content": "    if (is_shadow_host()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2723,
          "old_api": "e);\n\n        // 6",
          "new_api": null,
          "old_text": "e);\n\n        // 6",
          "new_text": null,
          "old_line_content": "        if (!value.has_value() || value->is_empty())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2724,
          "old_api": "s assigned, then run a",
          "new_api": null,
          "old_text": "s assigned, then run a",
          "new_text": null,
          "old_line_content": "            set_slottable_name({});",
          "new_line_content": "        // 4. If value is null or the empty string, then set elements name to the empty string.",
          "content_same": false
        },
        {
          "line": 2727,
          "old_api": "gned_slot_internal",
          "new_api": null,
          "old_text": "gned_slot_internal())\n    ",
          "new_text": null,
          "old_line_content": "            set_slottable_name(*value);",
          "new_line_content": "        // 5. Otherwise, set elements name to value.",
          "content_same": false
        },
        {
          "line": 2730,
          "old_api": "his });\n    }\n}\n\nauto El",
          "new_api": null,
          "old_text": "his });\n    }\n}\n\nauto El",
          "new_text": null,
          "old_line_content": "        if (auto assigned_slot = assigned_slot_internal())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 683,
          "old_api": "{\n            return WebID",
          "new_api": null,
          "old_text": " {\n            return WebID",
          "new_text": null,
          "old_line_content": "        if (!current_shadow_root->declarative() || current_shadow_root->mode() != mode) {",
          "new_line_content": "        // - currentShadowRoots mode is not mode,",
          "content_same": false
        },
        {
          "line": 684,
          "old_api": "w host\"",
          "new_api": null,
          "old_text": "w host\"",
          "new_text": null,
          "old_line_content": "            return WebIDL::NotSupportedError::create(realm(), \"Element already is a shadow host\"_fly_string);",
          "new_line_content": "        // then throw a \"NotSupportedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 2731,
          "old_api": "custom_element_reaction_queue",
          "new_api": null,
          "old_text": "custom_element_reaction_queue() -",
          "new_text": null,
          "old_line_content": "            assign_slottables(*assigned_slot);",
          "new_line_content": "        // 6. If element is assigned, then run assign slottables for elements assigned slot.",
          "content_same": false
        },
        {
          "line": 2734,
          "old_api": "t_reaction_queue)\n        m_custom_elemen",
          "new_api": null,
          "old_text": "t_reaction_queue)\n        m_custom_elemen",
          "new_text": null,
          "old_line_content": "        assign_a_slot(JS::NonnullGCPtr { *this });",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 689,
          "old_api": "en",
          "new_api": null,
          "old_text": "en();\n\n        //    2. Set currentShadowR",
          "new_text": null,
          "old_line_content": "        current_shadow_root->remove_all_children();",
          "new_line_content": "        // 3. Otherwise:",
          "content_same": false
        },
        {
          "line": 692,
          "old_api": "se);\n\n        //    3. Return.\n        retu",
          "new_api": null,
          "old_text": "se);\n\n        //    3. Return.\n        retu",
          "new_text": null,
          "old_line_content": "        current_shadow_root->set_declarative(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2741,
          "old_api": "o& root_node = root();\n    if (is<",
          "new_api": null,
          "old_text": "o& root_node = root();\n    if (is<",
          "new_text": null,
          "old_line_content": "        m_custom_element_reaction_queue = make<CustomElementReactionQueue>();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 699,
          "old_api": "hadows de",
          "new_api": null,
          "old_text": "hadows de",
          "new_text": null,
          "old_line_content": "    auto shadow = heap().allocate<ShadowRoot>(realm(), document(), *this, mode);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2747,
          "old_api": "// htt",
          "new_api": null,
          "old_text": "// htt",
          "new_text": null,
          "old_line_content": "    auto& root_node = root();",
          "new_line_content": "CSS::StyleSheetList& Element::document_or_shadow_root_style_sheets()",
          "content_same": false
        },
        {
          "line": 2748,
          "old_api": "spec.whatwg.org/#dom-element-g",
          "new_api": null,
          "old_text": "spec.whatwg.org/#dom-element-g",
          "new_text": null,
          "old_line_content": "    if (is<DOM::ShadowRoot>(root_node))",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 702,
          "old_api": ";\n\n    // 7. If elements custom element sta",
          "new_api": null,
          "old_text": ";\n\n    // 7. If elements custom element sta",
          "new_text": null,
          "old_line_content": "    shadow->set_delegates_focus(delegates_focus);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 706,
          "old_api": ";\n\n    // 8. Set shadows slot assignment to slo",
          "new_api": null,
          "old_text": ";\n\n    // 8. Set shadows slot assignment to slo",
          "new_text": null,
          "old_line_content": "        shadow->set_available_to_element_internals(true);",
          "new_line_content": "    // 7. If elements custom element state is \"precustomized\" or \"custom\", then set shadows available to element internals to true.",
          "content_same": false
        },
        {
          "line": 709,
          "old_api": "// 9. Set shadows declarative to false.",
          "new_api": null,
          "old_text": " // 9. Set shadows declarative to false.\n  ",
          "new_text": null,
          "old_line_content": "    shadow->set_slot_assignment(slot_assignment);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 712,
          "old_api": "ows clonable to clonable.",
          "new_api": null,
          "old_text": "ows clonable to clonable.\n   ",
          "new_text": null,
          "old_line_content": "    shadow->set_declarative(false);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2760,
          "old_api": "arser::SerializableShadowRoots::No,\n        options.shadow_roots);\n}\n\n// https://html.spec.whatwg.org/#dom-element-sethtmlunsafe\nWebIDL::ExceptionOr<void> Element::set_html_unsafe(StringView html)\n{\n    // FIXME: 1. Let complia",
          "new_api": null,
          "old_text": "arser::SerializableShadowRoots::No,\n        options.shadow_roots);\n}\n\n// https://html.spec.whatwg.org/#dom-element-sethtmlunsafe\nWebIDL::ExceptionOr<void> Element::set_html_unsafe(StringView html)\n{\n    // FIXME: 1. Let complia",
          "new_text": null,
          "old_line_content": "    return HTML::HTMLParser::serialize_html_fragment(",
          "new_line_content": "    // of HTML fragment serialization algorithm with this,",
          "content_same": false
        },
        {
          "line": 715,
          "old_api": "s serializable to serializabl",
          "new_api": null,
          "old_text": "s serializable to serializabl",
          "new_text": null,
          "old_line_content": "    shadow->set_clonable(clonable);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 718,
          "old_api": "elements shadow root to shadow.\n    s",
          "new_api": null,
          "old_text": "elements shadow root to shadow.\n    s",
          "new_text": null,
          "old_line_content": "    shadow->set_serializable(serializable);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 721,
          "old_api": "spec.whatwg.org/#dom-el",
          "new_api": null,
          "old_text": "spec.whatwg.org/#dom-el",
          "new_text": null,
          "old_line_content": "    set_shadow_root(shadow);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2773,
          "old_api": "s, and compliantHTML. FIXME: Use com",
          "new_api": null,
          "old_text": "s, and compliantHTML. FIXME: Use com",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLTemplateElement>(*this))",
          "new_line_content": "    // 2. Let target be this's template contents if this is a template element; otherwise this.",
          "content_same": false
        },
        {
          "line": 2774,
          "old_api": "unsafely_set_html",
          "new_api": null,
          "old_text": "(target->unsafely_set_html(*this, html));\n\n    return {};\n}\n\n",
          "new_text": null,
          "old_line_content": "        target = verify_cast<HTML::HTMLTemplateElement>(*this).content().ptr();",
          "new_line_content": "    DOM::Node* target = this;",
          "content_same": false
        },
        {
          "line": 729,
          "old_api": "izable, init.delegates_focus, init.slot_assignment));\n\n    // 2. Return thiss shadow root.\n    return JS::No",
          "new_api": null,
          "old_text": "izable, init.delegates_focus, init.slot_assignment));\n\n    // 2. Return thiss shadow root.\n    return JS::No",
          "new_text": null,
          "old_line_content": "    TRY(attach_a_shadow_root(init.mode, init.clonable, init.serializable, init.delegates_focus, init.slot_assignment));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2777,
          "old_api": ";\n    return *m_counters_set;\n}\n\nCSS::",
          "new_api": null,
          "old_text": ";\n    return *m_counters_set;\n}\n\nCSS::",
          "new_text": null,
          "old_line_content": "    TRY(target->unsafely_set_html(*this, html));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 732,
          "old_api": "ent-shadowroo",
          "new_api": null,
          "old_text": "ent-shadowroo",
          "new_text": null,
          "old_line_content": "    return JS::NonnullGCPtr { *shadow_root() };",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 742,
          "old_api": "turn nullptr;",
          "new_api": null,
          "old_text": "turn nullptr;\n",
          "new_text": null,
          "old_line_content": "    if (shadow == nullptr || shadow->mode() == Bindings::ShadowRootMode::Closed)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2792,
          "old_api": "es& style)\n{\n    // Reso",
          "new_api": null,
          "old_text": "es& style)\n{\n    // Reso",
          "new_text": null,
          "old_line_content": "        m_counters_set = make<CSS::CountersSet>();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 753,
          "old_api": "failure, then throw a \"Synt",
          "new_api": null,
          "old_text": "failure, then throw a \"Synt",
          "new_text": null,
          "old_line_content": "    auto maybe_selectors = parse_selector(CSS::Parser::ParsingContext(static_cast<ParentNode&>(const_cast<Element&>(*this))), selectors);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2802,
          "old_api": "ith display set to",
          "new_api": null,
          "old_text": "ith display set to",
          "new_text": null,
          "old_line_content": "    inherit_counters();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 756,
          "old_api": "r::create(realm(), \"Failed",
          "new_api": null,
          "old_text": "r::create(realm(), \"Failed ",
          "new_text": null,
          "old_line_content": "    if (!maybe_selectors.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 757,
          "old_api": "the re",
          "new_api": null,
          "old_text": " the re",
          "new_text": null,
          "old_line_content": "        return WebIDL::SyntaxError::create(realm(), \"Failed to parse selector\"_fly_string);",
          "new_line_content": "    // 2. If s is failure, then throw a \"SyntaxError\" DOMException.",
          "content_same": false
        },
        {
          "line": 760,
          "old_api": "(SelectorEngine::matche",
          "new_api": null,
          "old_text": "(SelectorEngine::matche",
          "new_text": null,
          "old_line_content": "    auto sel = maybe_selectors.value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2808,
          "old_api": "CounterReset);\n    for (a",
          "new_api": null,
          "old_text": "CounterReset);\n    for (a",
          "new_text": null,
          "old_line_content": "    if (style.display().is_none())",
          "new_line_content": "    // or a pseudo-element with content set to none) cannot set, reset, or increment a counter.",
          "content_same": false
        },
        {
          "line": 2812,
          "old_api": "unique_id(), counter.is_reversed, counter.value)",
          "new_api": null,
          "old_text": " unique_id(), counter.is_reversed, counter.value)",
          "new_text": null,
          "old_line_content": "    auto counter_reset = style.counter_data(CSS::PropertyID::CounterReset);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2817,
          "old_api": ".name, unique_id(), *counter.value);\n\n    // 4. Count",
          "new_api": null,
          "old_text": ".name, unique_id(), *counter.value);\n\n    // 4. Count",
          "new_text": null,
          "old_line_content": "    auto counter_increment = style.counter_data(CSS::PropertyID::CounterIncrement);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 772,
          "old_api": "failure, then throw a \"Synt",
          "new_api": null,
          "old_text": "failure, then throw a \"Synt",
          "new_text": null,
          "old_line_content": "    auto maybe_selectors = parse_selector(CSS::Parser::ParsingContext(static_cast<ParentNode&>(const_cast<Element&>(*this))), selectors);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2822,
          "old_api": ", *counter.value);\n\n    // 5. Counter values ar",
          "new_api": null,
          "old_text": ", *counter.value);\n\n    // 5. Counter values ar",
          "new_text": null,
          "old_line_content": "    auto counter_set = style.counter_data(CSS::PropertyID::CounterSet);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 775,
          "old_api": "r::create(realm(), \"Failed",
          "new_api": null,
          "old_text": "r::create(realm(), \"Failed ",
          "new_text": null,
          "old_line_content": "    if (!maybe_selectors.has_value())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 776,
          "old_api": "ches_se",
          "new_api": null,
          "old_text": "ches_se",
          "new_text": null,
          "old_line_content": "        return WebIDL::SyntaxError::create(realm(), \"Failed to parse selector\"_fly_string);",
          "new_line_content": "    // 2. If s is failure, then throw a \"SyntaxError\" DOMException.",
          "content_same": false
        },
        {
          "line": 781,
          "old_api": "his))\n                return true;\n        }\n        return false;",
          "new_api": null,
          "old_text": "his))\n                return true;\n        }\n        return false;",
          "new_text": null,
          "old_line_content": "            if (SelectorEngine::matches(selector, {}, *element, nullptr, {}, this))",
          "new_line_content": "        // 4. For each element in elements, if match a selector against an element, using s, element, and scoping root this, returns success, return element.",
          "content_same": false
        },
        {
          "line": 787,
          "old_api": "iss inclusive ancestors that a",
          "new_api": null,
          "old_text": "iss inclusive ancestors that a",
          "new_text": null,
          "old_line_content": "    auto const selector_list = maybe_selectors.release_value();",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 2835,
          "old_api": "tr;\n        retu",
          "new_api": null,
          "old_text": "tr;\n        retu",
          "new_text": null,
          "old_line_content": "    auto* parent = parent_element();",
          "new_line_content": "    // 1. If element is the root of its document tree, the element has an initially-empty CSS counters set.",
          "content_same": false
        },
        {
          "line": 790,
          "old_api": "ctor_list, element))",
          "new_api": null,
          "old_text": "ctor_list, element))\n    ",
          "new_text": null,
          "old_line_content": "    for (auto* element = this; element; element = element->parent_element()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 791,
          "old_api": "return element;\n    }\n\n    // 5",
          "new_api": null,
          "old_text": "\n\n        return element;\n    }\n\n    // 5",
          "new_text": null,
          "old_line_content": "        if (!matches_selectors(selector_list, element))",
          "new_line_content": "    // 3. Let elements be thiss inclusive ancestors that are elements, in reverse tree order.",
          "content_same": false
        },
        {
          "line": 2849,
          "old_api": "ent_element",
          "new_api": null,
          "old_text": "ent_element()->counters_",
          "new_text": null,
          "old_line_content": "            element_counters = make<CSS::CountersSet>();",
          "new_line_content": "    auto ensure_element_counters = [&]() {",
          "content_same": false
        },
        {
          "line": 2852,
          "old_api": "eceding sibling (if it h",
          "new_api": null,
          "old_text": "eceding sibling (if it h",
          "new_text": null,
          "old_line_content": "        element_counters = make<CSS::CountersSet>();",
          "new_line_content": "    };",
          "content_same": false
        },
        {
          "line": 810,
          "old_api": ". If context is a template element, then set context",
          "new_api": null,
          "old_text": ". If context is a template element, then set context",
          "new_text": null,
          "old_line_content": "    auto fragment = TRY(verify_cast<Element>(*context).parse_fragment(value));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2860,
          "old_api": "const& counter : sibling_counters.cou",
          "new_api": null,
          "old_text": "const& counter : sibling_counters.cou",
          "new_text": null,
          "old_line_content": "    if (auto* const sibling = previous_sibling_of_type<Element>(); sibling && sibling->has_non_empty_counters_set()) {",
          "new_line_content": "    //    For each counter of sibling counters, if element counters does not already contain a counter with",
          "content_same": false
        },
        {
          "line": 813,
          "old_api": "y_cast<HTML::HTMLTemplateElement>(*cont",
          "new_api": null,
          "old_text": "y_cast<HTML::HTMLTemplateElement>(*cont",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLTemplateElement>(*context))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 814,
          "old_api": "// 5. Replace all with fragment within context.\n    conte",
          "new_api": null,
          "old_text": " // 5. Replace all with fragment within context.\n    conte",
          "new_text": null,
          "old_line_content": "        context = verify_cast<HTML::HTMLTemplateElement>(*context).content();",
          "new_line_content": "    // 4. If context is a template element, then set context to the template element's template contents (a DocumentFragment).",
          "content_same": false
        },
        {
          "line": 2861,
          "old_api": "last_counter_with_name",
          "new_api": null,
          "old_text": "ounters->last_counter_with_name(counter",
          "new_text": null,
          "old_line_content": "        auto& sibling_counters = sibling->counters_set().release_value();",
          "new_line_content": "    //    the same name, append a copy of counter to element counters.",
          "content_same": false
        },
        {
          "line": 817,
          "old_api": "e style & layout for <template",
          "new_api": null,
          "old_text": "e style & layout for <template",
          "new_text": null,
          "old_line_content": "    context->replace_all(fragment);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 820,
          "old_api": "needs_style_update",
          "new_api": null,
          "old_text": "needs_style_update(true);\n\n        if (",
          "new_text": null,
          "old_line_content": "    if (!is<HTML::HTMLTemplateElement>(*context)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 821,
          "old_api": "connected",
          "new_api": null,
          "old_text": "connected()) {\n            // NOTE: S",
          "new_text": null,
          "old_line_content": "        context->set_needs_style_update(true);",
          "new_line_content": "    // NOTE: We don't invalidate style & layout for <template> elements since they don't affect rendering.",
          "content_same": false
        },
        {
          "line": 2872,
          "old_api": "nters) {\n            auto& value_sourc",
          "new_api": null,
          "old_text": "nters) {\n            auto& value_sourc",
          "new_text": null,
          "old_line_content": "    if (auto* const previous = previous_element_in_pre_order(); previous && previous->has_non_empty_counters_set()) {",
          "new_line_content": "    //    For each source counter of value source, if element counters contains a counter with the same name",
          "content_same": false
        },
        {
          "line": 2875,
          "old_api": "ounters->counter_with_same_name_and_crea",
          "new_api": null,
          "old_text": "ounters->counter_with_same_name_and_crea",
          "new_text": null,
          "old_line_content": "            auto& value_source = previous->counters_set().release_value();",
          "new_line_content": "        // NOTE: If element_counters is empty (AKA null) then we can skip this since nothing will match.",
          "content_same": false
        },
        {
          "line": 2876,
          "old_api": "ing_element_id);",
          "new_api": null,
          "old_text": "ing_element_id);\n      ",
          "new_text": null,
          "old_line_content": "            for (auto const& source_counter : value_source.counters()) {",
          "new_line_content": "        if (element_counters) {",
          "content_same": false
        },
        {
          "line": 835,
          "old_api": "Element::is_focused() const\n{\n    return document().fo",
          "new_api": null,
          "old_text": "Element::is_focused() const\n{\n    return document().fo",
          "new_text": null,
          "old_line_content": "    return serialize_fragment(DOMParsing::RequireWellFormed::Yes);",
          "new_line_content": "WebIDL::ExceptionOr<String> Element::inner_html() const",
          "content_same": false
        },
        {
          "line": 2884,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    VERIFY(!element_counters || !element_counters->is_empty());",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 2885,
          "old_api": "",
          "new_api": null,
          "old_text": "",
          "new_text": null,
          "old_line_content": "    m_counters_set = move(element_counters);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 840,
          "old_api": "() const\n{\n    return docume",
          "new_api": null,
          "old_text": "() const\n{\n    return docume",
          "new_text": null,
          "old_line_content": "    return document().focused_element() == this;",
          "new_line_content": "bool Element::is_focused() const",
          "content_same": false
        },
        {
          "line": 845,
          "old_api": ") const\n{\n    return docume",
          "new_api": null,
          "old_text": ") const\n{\n    return docume",
          "new_text": null,
          "old_line_content": "    return document().active_element() == this;",
          "new_line_content": "bool Element::is_active() const",
          "content_same": false
        },
        {
          "line": 850,
          "old_api": "wg.org/#document-element\nbo",
          "new_api": null,
          "old_text": "wg.org/#document-element\nbo",
          "new_text": null,
          "old_line_content": "    return document().target_element() == this;",
          "new_line_content": "bool Element::is_target() const",
          "content_same": false
        },
        {
          "line": 857,
          "old_api": "st\nbool El",
          "new_api": null,
          "old_text": "st\nbool El",
          "new_text": null,
          "old_line_content": "    return parent() == &document();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 872,
          "old_api": "w_root);\n    if (m_shadow_root)",
          "new_api": null,
          "old_text": "w_root);\n    if (m_shadow_root)\n",
          "new_text": null,
          "old_line_content": "        m_shadow_root->set_host(nullptr);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 873,
          "old_api": ">set_host(this);",
          "new_api": null,
          "old_text": ">set_host(this);\n",
          "new_text": null,
          "old_line_content": "    m_shadow_root = move(shadow_root);",
          "new_line_content": "    if (m_shadow_root)",
          "content_same": false
        },
        {
          "line": 876,
          "old_api": "for_bindings",
          "new_api": null,
          "old_text": "for_bindings()\n{\n ",
          "new_text": null,
          "old_line_content": "    invalidate_style();",
          "new_line_content": "    if (m_shadow_root)",
          "content_same": false
        },
        {
          "line": 882,
          "old_api": "return m_inline_style;\n}\n\n// https://dom.spec.whatwg.org/#",
          "new_api": null,
          "old_text": "  return m_inline_style;\n}\n\n// https://dom.spec.whatwg.org/#",
          "new_text": null,
          "old_line_content": "        m_inline_style = CSS::ElementInlineCSSStyleDeclaration::create(*this, {}, {});",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 890,
          "old_api": "ml_uppercased_qualified_na",
          "new_api": null,
          "old_text": "ml_uppercased_qualified_na",
          "new_text": null,
          "old_line_content": "    if (namespace_uri() == Namespace::HTML && document().document_type() == Document::Type::HTML)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 891,
          "old_api": "_name = qualifie",
          "new_api": null,
          "old_text": "_name = qualifie",
          "new_text": null,
          "old_line_content": "        m_html_uppercased_qualified_name = MUST(Infra::to_ascii_uppercase(qualified_name()));",
          "new_line_content": "    // This is allowed by the spec: \"User agents could optimize qualified name and HTML-uppercased qualified name by storing them in internal slots.\"",
          "content_same": false
        },
        {
          "line": 899,
          "old_api": "ax.html#voi",
          "new_api": null,
          "old_text": "ax.html#voi",
          "new_text": null,
          "old_line_content": "    return queue_a_task(source, HTML::main_thread_event_loop(), document(), JS::create_heap_function(heap(), move(steps)));",
          "new_line_content": "HTML::TaskID Element::queue_an_element_task(HTML::Task::Source source, Function<void()> steps)",
          "content_same": false
        },
        {
          "line": 905,
          "old_api": "e, HTML::TagNames::br, HTML::TagNames::col, HTML::TagNames::embed, HTML::TagNames::hr, HTML::TagNames::img, HTML::TagNames::input, HTML::TagNames::link, HTML::TagNames::meta, HTML::TagNames::param, HTML::TagNames::source, HTML::TagNames::track, HTML::TagNames::wbr);\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#seri",
          "new_api": null,
          "old_text": "e, HTML::TagNames::br, HTML::TagNames::col, HTML::TagNames::embed, HTML::TagNames::hr, HTML::TagNames::img, HTML::TagNames::input, HTML::TagNames::link, HTML::TagNames::meta, HTML::TagNames::param, HTML::TagNames::source, HTML::TagNames::track, HTML::TagNames::wbr);\n}\n\n// https://html.spec.whatwg.org/multipage/parsing.html#seri",
          "new_text": null,
          "old_line_content": "    return local_name().is_one_of(HTML::TagNames::area, HTML::TagNames::base, HTML::TagNames::br, HTML::TagNames::col, HTML::TagNames::embed, HTML::TagNames::hr, HTML::TagNames::img, HTML::TagNames::input, HTML::TagNames::link, HTML::TagNames::meta, HTML::TagNames::param, HTML::TagNames::source, HTML::TagNames::track, HTML::TagNames::wbr);",
          "new_line_content": "bool Element::is_void_element() const",
          "content_same": false
        },
        {
          "line": 911,
          "old_api": ":bgsound, HTML::TagNames::frame, HTML::TagNames::keygen);\n}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-getboun",
          "new_api": null,
          "old_text": ":bgsound, HTML::TagNames::frame, HTML::TagNames::keygen);\n}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-getboun",
          "new_text": null,
          "old_line_content": "    return is_void_element() || local_name().is_one_of(HTML::TagNames::basefont, HTML::TagNames::bgsound, HTML::TagNames::frame, HTML::TagNames::keygen);",
          "new_line_content": "bool Element::serializes_as_void() const",
          "content_same": false
        },
        {
          "line": 918,
          "old_api": "Rect object whose",
          "new_api": null,
          "old_text": "Rect object whose ",
          "new_text": null,
          "old_line_content": "    auto list = get_client_rects();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 921,
          "old_api": "_impl",
          "new_api": null,
          "old_text": "_impl(realm(),",
          "new_text": null,
          "old_line_content": "    if (list->length() == 0)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 922,
          "old_api": "rors",
          "new_api": null,
          "old_text": "rors();",
          "new_text": null,
          "old_line_content": "        return Geometry::DOMRect::construct_impl(realm(), 0, 0, 0, 0).release_value_but_fixme_should_propagate_errors();",
          "new_line_content": "    // 2. If the list is empty return a DOMRect object whose x, y, width and height members are zero.",
          "content_same": false
        },
        {
          "line": 926,
          "old_api": "if (r",
          "new_api": null,
          "old_text": "\n        if (r",
          "new_text": null,
          "old_line_content": "    for (auto i = 0u; i < list->length(); ++i) {",
          "new_line_content": "    // 3. If all rectangles in list have zero width or height, return the first rectangle in list.",
          "content_same": false
        },
        {
          "line": 927,
          "old_api": "!= 0) {",
          "new_api": null,
          "old_text": "!= 0) {\n     ",
          "new_text": null,
          "old_line_content": "        auto const& rect = list->item(i);",
          "new_line_content": "    auto all_rectangle_has_zero_width_or_height = true;",
          "content_same": false
        },
        {
          "line": 934,
          "old_api": "describing th",
          "new_api": null,
          "old_text": "describing th",
          "new_text": null,
          "old_line_content": "        return JS::NonnullGCPtr { *const_cast<Geometry::DOMRect*>(list->item(0)) };",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 938,
          "old_api": "x",
          "new_api": null,
          "old_text": "x(), first_re",
          "new_text": null,
          "old_line_content": "    auto const* first_rect = list->item(0);",
          "new_line_content": "    // 4. Otherwise, return a DOMRect object describing the smallest rectangle that includes all of the rectangles in",
          "content_same": false
        },
        {
          "line": 939,
          "old_api": "; ++i) {\n        aut",
          "new_api": null,
          "old_text": "; ++i) {\n        aut",
          "new_text": null,
          "old_line_content": "    auto bounding_rect = Gfx::Rect { first_rect->x(), first_rect->y(), first_rect->width(), first_rect->height() };",
          "new_line_content": "    //    list of which the height or width is not zero.",
          "content_same": false
        },
        {
          "line": 955,
          "old_api": "it was inv",
          "new_api": null,
          "old_text": "it was inv",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 959,
          "old_api": "m",
          "new_api": null,
          "old_text": "m(), move(rec",
          "new_text": null,
          "old_line_content": "    if (!layout_node())",
          "new_line_content": "    // 1. If the element on which it was invoked does not have an associated layout box return an empty DOMRectList",
          "content_same": false
        },
        {
          "line": 960,
          "old_api": "SVG layout",
          "new_api": null,
          "old_text": " SVG layout",
          "new_text": null,
          "old_line_content": "        return Geometry::DOMRectList::create(realm(), move(rects));",
          "new_line_content": "    //    object and stop this algorithm.",
          "content_same": false
        },
        {
          "line": 973,
          "old_api": "igable",
          "new_api": null,
          "old_text": "igable();\n",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "    // FIXME: - Replace each anonymous block box with its child box(es) and repeat this until no anonymous block boxes",
          "content_same": false
        },
        {
          "line": 974,
          "old_api": "_offset = navigable->v",
          "new_api": null,
          "old_text": "_offset = navigable->v",
          "new_text": null,
          "old_line_content": "    auto navigable = document().navigable();",
          "new_line_content": "    //          are left in the final list.",
          "content_same": false
        },
        {
          "line": 979,
          "old_api": "Gfx:",
          "new_api": null,
          "old_text": "\n\n    Gfx:",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_paint_and_hit_testing_properties_if_needed();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 983,
          "old_api": "intable_box",
          "new_api": null,
          "old_text": "intable_box()) {\n",
          "new_text": null,
          "old_line_content": "    auto const* paintable = this->paintable();",
          "new_line_content": "    Gfx::AffineTransform transform;",
          "content_same": false
        },
        {
          "line": 986,
          "old_api": "_block = paintable->contai",
          "new_api": null,
          "old_text": "_block = paintable->contai",
          "new_text": null,
          "old_line_content": "        transform = Gfx::extract_2d_affine_transform(paintable_box->transform());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 992,
          "old_api": "map",
          "new_api": null,
          "old_text": "med_rect = transform.map(absolute_rect.tr",
          "new_text": null,
          "old_line_content": "        auto absolute_rect = paintable_box->absolute_border_box_rect();",
          "new_line_content": "        }",
          "content_same": false
        },
        {
          "line": 993,
          "old_api": ".to_type",
          "new_api": null,
          "old_text": "                         .to_type",
          "new_text": null,
          "old_line_content": "        auto transformed_rect = transform.map(absolute_rect.translated(-paintable_box->transform_origin()).to_type<float>())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 998,
          "old_api": "is<Painting::InlinePaintable>(*p",
          "new_api": null,
          "old_text": " is<Painting::InlinePaintable>(*p",
          "new_text": null,
          "old_line_content": "        rects.append(Geometry::DOMRect::create(realm(), transformed_rect.to_type<float>()));",
          "new_line_content": "                                    .translated(-scroll_offset)",
          "content_same": false
        },
        {
          "line": 999,
          "old_api": "inline_paintable = static_cast<Painting:",
          "new_api": null,
          "old_text": " inline_paintable = static_cast<Painting:",
          "new_text": null,
          "old_line_content": "    } else if (paintable && is<Painting::InlinePaintable>(*paintable)) {",
          "new_line_content": "                                    .translated(-viewport_offset);",
          "content_same": false
        },
        {
          "line": 1009,
          "old_api": "Ensure that",
          "new_api": null,
          "old_text": "Ensure that",
          "new_text": null,
          "old_line_content": "    return Geometry::DOMRectList::create(realm(), move(rects));",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1015,
          "old_api": "sociated C",
          "new_api": null,
          "old_text": "sociated C",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1018,
          "old_api": "d value of the",
          "new_api": null,
          "old_text": "d value of the ",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1024,
          "old_api": "}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientl",
          "new_api": null,
          "old_text": "}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientl",
          "new_text": null,
          "old_line_content": "    return paintable_box()->computed_values().border_top().width.to_int();",
          "new_line_content": "    //    plus the height of any scrollbar rendered between the top padding edge and the top border edge,",
          "content_same": false
        },
        {
          "line": 1031,
          "old_api": "sociated C",
          "new_api": null,
          "old_text": "sociated C",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1034,
          "old_api": "d value of the",
          "new_api": null,
          "old_text": "d value of the ",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1040,
          "old_api": "}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientw",
          "new_api": null,
          "old_text": "\n}\n\n// https://drafts.csswg.org/cssom-view/#dom-element-clientw",
          "new_text": null,
          "old_line_content": "    return paintable_box()->computed_values().border_left().width.to_int();",
          "new_line_content": "    //    plus the width of any scrollbar rendered between the left padding edge and the left border edge,",
          "content_same": false
        },
        {
          "line": 1051,
          "old_api": "this) && document().in_quir",
          "new_api": null,
          "old_text": "this) && document().in_quir",
          "new_text": null,
          "old_line_content": "    if ((is<HTML::HTMLHtmlElement>(*this) && !document().in_quirks_mode())",
          "new_line_content": "    //    or if the element is the HTML body element and the elements node document is in quirks mode,",
          "content_same": false
        },
        {
          "line": 1052,
          "old_api": "width",
          "new_api": null,
          "old_text": "ect().width().to_int();\n   ",
          "new_text": null,
          "old_line_content": "        || (is<HTML::HTMLBodyElement>(*this) && document().in_quirks_mode())) {",
          "new_line_content": "    //    return the viewport width excluding the size of a rendered scroll bar (if any).",
          "content_same": false
        },
        {
          "line": 1057,
          "old_api": "ated CSS l",
          "new_api": null,
          "old_text": "ated CSS l",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1060,
          "old_api": "e padding edge",
          "new_api": null,
          "old_text": "e padding edge ",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1065,
          "old_api": "https://drafts.csswg.org/cssom-view/#dom-element-clientheigh",
          "new_api": null,
          "old_text": " https://drafts.csswg.org/cssom-view/#dom-element-clientheigh",
          "new_text": null,
          "old_line_content": "    return paintable_box()->absolute_padding_box_rect().width().to_int();",
          "new_line_content": "    // 3. Return the width of the padding edge excluding the width of any rendered scrollbar between the padding edge and the border edge,",
          "content_same": false
        },
        {
          "line": 1076,
          "old_api": ") && document().in_quirks_m",
          "new_api": null,
          "old_text": ") && document().in_quirks_m",
          "new_text": null,
          "old_line_content": "    if ((is<HTML::HTMLHtmlElement>(*this) && !document().in_quirks_mode())",
          "new_line_content": "    //    or if the element is the HTML body element and the elements node document is in quirks mode,",
          "content_same": false
        },
        {
          "line": 1077,
          "old_api": "height",
          "new_api": null,
          "old_text": ").height().to_int();\n    }\n",
          "new_text": null,
          "old_line_content": "        || (is<HTML::HTMLBodyElement>(*this) && document().in_quirks_mode())) {",
          "new_line_content": "    //    return the viewport height excluding the size of a rendered scroll bar (if any).",
          "content_same": false
        },
        {
          "line": 1082,
          "old_api": "CSS layou",
          "new_api": null,
          "old_text": " CSS layou",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1085,
          "old_api": "adding edge exc",
          "new_api": null,
          "old_text": "adding edge exc",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1090,
          "old_api": "tps://drafts.csswg.org/cssom-view/#dom-element-currentcsszoom",
          "new_api": null,
          "old_text": "tps://drafts.csswg.org/cssom-view/#dom-element-currentcsszoom\n",
          "new_text": null,
          "old_line_content": "    return paintable_box()->absolute_padding_box_rect().height().to_int();",
          "new_line_content": "    // 3. Return the height of the padding edge excluding the height of any rendered scrollbar between the padding edge and the border edge,",
          "content_same": false
        },
        {
          "line": 1096,
          "old_api": "void Element::inserted()\n{\n    Base::inserted();",
          "new_api": null,
          "old_text": "\n\nvoid Element::inserted()\n{\n    Base::inserted();\n\n ",
          "new_text": null,
          "old_line_content": "    dbgln(\"FIXME: Implement Element::current_css_zoom()\");",
          "new_line_content": "double Element::current_css_zoom() const",
          "content_same": false
        },
        {
          "line": 1102,
          "old_api": "with_id_was_adde",
          "new_api": null,
          "old_text": "with_id_was_adde",
          "new_text": null,
          "old_line_content": "    Base::inserted();",
          "new_line_content": "void Element::inserted()",
          "content_same": false
        },
        {
          "line": 1105,
          "old_api": "ue",
          "new_api": null,
          "old_text": "ue())\n        document().element_with_name_was_",
          "new_text": null,
          "old_line_content": "        document().element_with_id_was_added({}, *this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1108,
          "old_api": "ved_from",
          "new_api": null,
          "old_text": "ved_from(Node* node)\n{\n    Base::removed_from(nod",
          "new_text": null,
          "old_line_content": "        document().element_with_name_was_added({}, *this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1113,
          "old_api": "element_with_id_was_remo",
          "new_api": null,
          "old_text": "element_with_id_was_remo",
          "new_text": null,
          "old_line_content": "    Base::removed_from(node);",
          "new_line_content": "void Element::removed_from(Node* node)",
          "content_same": false
        },
        {
          "line": 1116,
          "old_api": "alue",
          "new_api": null,
          "old_text": "alue())\n        document().element_with_name_was_",
          "new_text": null,
          "old_line_content": "        document().element_with_id_was_removed({}, *this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1119,
          "old_api": "ildren_changed",
          "new_api": null,
          "old_text": "ildren_changed()\n{\n    Node::children_changed();\n  ",
          "new_text": null,
          "old_line_content": "        document().element_with_name_was_removed({}, *this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1124,
          "old_api": "ent::set_pseudo_element_",
          "new_api": null,
          "old_text": "ent::set_pseudo_element_",
          "new_text": null,
          "old_line_content": "    Node::children_changed();",
          "new_line_content": "void Element::children_changed()",
          "content_same": false
        },
        {
          "line": 1125,
          "old_api": "adge<Layout::TreeBuilder>, C",
          "new_api": null,
          "old_text": "adge<Layout::TreeBuilder>, C",
          "new_text": null,
          "old_line_content": "    set_needs_style_update(true);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1130,
          "old_api": "_value",
          "new_api": null,
          "old_text": "_value() && !pseudo_element_node)\n",
          "new_text": null,
          "old_line_content": "    auto existing_pseudo_element = get_pseudo_element(pseudo_element);",
          "new_line_content": "void Element::set_pseudo_element_node(Badge<Layout::TreeBuilder>, CSS::Selector::PseudoElement::Type pseudo_element, JS::GCPtr<Layout::NodeWithStyle> pseudo_element_node)",
          "content_same": false
        },
        {
          "line": 1131,
          "old_api": "urn;\n\n    ensure_pseudo_element(pse",
          "new_api": null,
          "old_text": "urn;\n\n    ensure_pseudo_element(pse",
          "new_text": null,
          "old_line_content": "    if (!existing_pseudo_element.has_value() && !pseudo_element_node)",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1134,
          "old_api": "get_pseudo_element_node",
          "new_api": null,
          "old_text": "get_pseudo_element_node(C",
          "new_text": null,
          "old_line_content": "    ensure_pseudo_element(pseudo_element).layout_node = move(pseudo_element_node);",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1139,
          "old_api": "return nullptr;\n}\n\nbool",
          "new_api": null,
          "old_text": "return nullptr;\n}\n\nbool ",
          "new_text": null,
          "old_line_content": "    if (auto element_data = get_pseudo_element(pseudo_element); element_data.has_value())",
          "new_line_content": "JS::GCPtr<Layout::NodeWithStyle> Element::get_pseudo_element_node(CSS::Selector::PseudoElement::Type pseudo_element) const",
          "content_same": false
        },
        {
          "line": 1168,
          "old_api": "_pseudo_element_data)[i].layo",
          "new_api": null,
          "old_text": "_pseudo_element_data)[i].layo",
          "new_text": null,
          "old_line_content": "    for (size_t i = 0; i < m_pseudo_element_data->size(); ++i) {",
          "new_line_content": "    if (!m_pseudo_element_data)",
          "content_same": false
        },
        {
          "line": 1172,
          "old_api": "ing::formatted(\"::{}\", CSS:",
          "new_api": null,
          "old_text": "ing::formatted(\"::{}\", CSS:",
          "new_text": null,
          "old_line_content": "        auto object = MUST(children_array.add_object());",
          "new_line_content": "        if (!pseudo_element)",
          "content_same": false
        },
        {
          "line": 1173,
          "old_api": "add",
          "new_api": null,
          "old_text": "ject.add(\"type\"sv, \"pseudo-element\"));\n        MUS",
          "new_text": null,
          "old_line_content": "        MUST(object.add(\"name\"sv, MUST(String::formatted(\"::{}\", CSS::Selector::PseudoElement::name(static_cast<CSS::Selector::PseudoElement::Type>(i))))));",
          "new_line_content": "            continue;",
          "content_same": false
        },
        {
          "line": 1194,
          "old_api": "has_value",
          "new_api": null,
          "old_text": "e_index.has_value())\n        return default_tab_ind",
          "new_text": null,
          "old_line_content": "    auto maybe_table_index = Web::HTML::parse_integer(get_attribute_value(HTML::AttributeNames::tabindex));",
          "new_line_content": "i32 Element::tab_index() const",
          "content_same": false
        },
        {
          "line": 1197,
          "old_api": "ps://html.spec.whatwg.org",
          "new_api": null,
          "old_text": "ps://html.spec.whatwg.org",
          "new_text": null,
          "old_line_content": "        return default_tab_index_value();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1204,
          "old_api": "otentially-scrollable\nboo",
          "new_api": null,
          "old_text": "otentially-scrollable\nboo",
          "new_text": null,
          "old_line_content": "    MUST(set_attribute(HTML::AttributeNames::tabindex, MUST(String::number(tab_index))));",
          "new_line_content": "void Element::set_tab_index(i32 tab_index)",
          "content_same": false
        },
        {
          "line": 1211,
          "old_api": "dy element",
          "new_api": null,
          "old_text": "dy element",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document()).update_layout();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1214,
          "old_api": "the body element, the body element",
          "new_api": null,
          "old_text": "the body element, the body element ",
          "new_text": null,
          "old_line_content": "    VERIFY(is<HTML::HTMLBodyElement>(this) || is<HTML::HTMLFrameSetElement>(this));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1217,
          "old_api": "ements",
          "new_api": null,
          "old_text": "ements ",
          "new_text": null,
          "old_line_content": "    VERIFY(parent());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1222,
          "old_api": "t_node",
          "new_api": null,
          "old_text": "t_node()->com",
          "new_text": null,
          "old_line_content": "    return layout_node()",
          "new_line_content": "    // - bodys parent elements computed value of the overflow-x or overflow-y properties is neither visible nor clip.",
          "content_same": false
        },
        {
          "line": 1223,
          "old_api": "overflow_x",
          "new_api": null,
          "old_text": ").overflow_x() != CSS::",
          "new_text": null,
          "old_line_content": "        && (parent()->layout_node()",
          "new_line_content": "    // - bodys computed value of the overflow-x or overflow-y properties is neither visible nor clip.",
          "content_same": false
        },
        {
          "line": 1234,
          "old_api": "nd terminate the",
          "new_api": null,
          "old_text": "nd terminate the",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1237,
          "old_api": "cuments defaultView",
          "new_api": null,
          "old_text": "cuments defaultView",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1241,
          "old_api": "se steps.\n    if (!wind",
          "new_api": null,
          "old_text": "se steps.\n    if (!wind",
          "new_text": null,
          "old_line_content": "    auto* window = document.default_view();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1248,
          "old_api": "p-to-date before looking",
          "new_api": null,
          "old_text": "p-to-date before looking ",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1252,
          "old_api": "ot element return the value of scrollY on windo",
          "new_api": null,
          "old_text": "ot element return the value of scrollY on windo",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1255,
          "old_api": "f the element is the body e",
          "new_api": null,
          "old_text": "f the element is the body e",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1256,
          "old_api": "irks mode, and the",
          "new_api": null,
          "old_text": "irks mode, and the",
          "new_text": null,
          "old_line_content": "        return window->scroll_y();",
          "new_line_content": "    // 6. If the element is the root element return the value of scrollY on window.",
          "content_same": false
        },
        {
          "line": 1259,
          "old_api": "ement does not have any ass",
          "new_api": null,
          "old_text": "ement does not have any ass",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1260,
          "old_api": "rn zero and termin",
          "new_api": null,
          "old_text": "rn zero and termin",
          "new_text": null,
          "old_line_content": "        return window->scroll_y();",
          "new_line_content": "    // 7. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollY on window.",
          "content_same": false
        },
        {
          "line": 1263,
          "old_api": "ling area at th",
          "new_api": null,
          "old_text": "ling area at th",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1268,
          "old_api": "onst\n{\n    // 1. Let document be the elements n",
          "new_api": null,
          "old_text": "onst\n{\n    // 1. Let document be the elements n",
          "new_text": null,
          "old_line_content": "    return paintable_box()->scroll_offset().y().to_double();",
          "new_line_content": "    // 9. Return the y-coordinate of the scrolling area at the alignment point with the top of the padding edge of the element.",
          "content_same": false
        },
        {
          "line": 1274,
          "old_api": "erminate these s",
          "new_api": null,
          "old_text": "erminate these s",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1277,
          "old_api": "nts defaultView att",
          "new_api": null,
          "old_text": "nts defaultView att",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1281,
          "old_api": "teps.\n    if (!window)",
          "new_api": null,
          "old_text": "teps.\n    if (!window)\n",
          "new_text": null,
          "old_line_content": "    auto* window = document.default_view();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1288,
          "old_api": "-date before looking at m",
          "new_api": null,
          "old_text": "-date before looking at m",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1292,
          "old_api": "lement return the value of scrollX on window.",
          "new_api": null,
          "old_text": "lement return the value of scrollX on window.\n ",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1295,
          "old_api": "e element is the body eleme",
          "new_api": null,
          "old_text": "e element is the body eleme",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this)",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1296,
          "old_api": "mode, and the ele",
          "new_api": null,
          "old_text": " mode, and the ele",
          "new_text": null,
          "old_line_content": "        return window->scroll_x();",
          "new_line_content": "    // 6. If the element is the root element return the value of scrollX on window.",
          "content_same": false
        },
        {
          "line": 1299,
          "old_api": "t does not have any associa",
          "new_api": null,
          "old_text": "t does not have any associa",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1300,
          "old_api": "ero and terminate",
          "new_api": null,
          "old_text": "ero and terminate ",
          "new_text": null,
          "old_line_content": "        return window->scroll_x();",
          "new_line_content": "    // 7. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, return the value of scrollX on window.",
          "content_same": false
        },
        {
          "line": 1303,
          "old_api": "area at the al",
          "new_api": null,
          "old_text": " area at the al",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1308,
          "old_api": "iew/#dom-element-scrollleft\nvoid Element::set_sc",
          "new_api": null,
          "old_text": "iew/#dom-element-scrollleft\nvoid Element::set_sc",
          "new_text": null,
          "old_line_content": "    return paintable_box()->scroll_offset().x().to_double();",
          "new_line_content": "    // 9. Return the x-coordinate of the scrolling area at the alignment point with the left of the padding edge of the element.",
          "content_same": false
        },
        {
          "line": 1317,
          "old_api": "ment.\n    auto& document = this->doc",
          "new_api": null,
          "old_text": "ment.\n    auto& document = this->doc",
          "new_text": null,
          "old_line_content": "    x = HTML::normalize_non_finite_values(x);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1320,
          "old_api": ".\n    if (!docum",
          "new_api": null,
          "old_text": ".\n    if (!docum",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1323,
          "old_api": "aultView attribute.",
          "new_api": null,
          "old_text": "aultView attribute.\n",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1327,
          "old_api": "w)\n        return;",
          "new_api": null,
          "old_text": "w)\n        return;\n\n   ",
          "new_text": null,
          "old_line_content": "    auto* window = document.default_view();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1334,
          "old_api": "fore looking at metrics o",
          "new_api": null,
          "old_text": "fore looking at metrics o",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1338,
          "old_api": "nt invoke scroll() on window with x as first ar",
          "new_api": null,
          "old_text": "nt invoke scroll() on window with x as first ar",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1341,
          "old_api": "return;\n    }\n\n    // 9.",
          "new_api": null,
          "old_text": "  return;\n    }\n\n    // 9. ",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1342,
          "old_api": "cument is in quirk",
          "new_api": null,
          "old_text": "cument is in quirk",
          "new_text": null,
          "old_line_content": "        window->scroll(x, window->scroll_y());",
          "new_line_content": "    // 8. If the element is the root element invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.",
          "content_same": false
        },
        {
          "line": 1347,
          "old_api": ";\n    }\n\n    // 10. If the",
          "new_api": null,
          "old_text": ";\n    }\n\n    // 10. If the ",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1348,
          "old_api": "ciated box, the el",
          "new_api": null,
          "old_text": "ciated box, the el",
          "new_text": null,
          "old_line_content": "        window->scroll(x, window->scroll_y());",
          "new_line_content": "    // 9. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with x as first argument and scrollY on window as second argument, and terminate these steps.",
          "content_same": false
        },
        {
          "line": 1353,
          "old_api": "())\n        ret",
          "new_api": null,
          "old_text": "())\n        ret",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1356,
          "old_api": "lement has no overflow.\n\n    // 11. Scroll the elem",
          "new_api": null,
          "old_text": "lement has no overflow.\n\n    // 11. Scroll the elem",
          "new_text": null,
          "old_line_content": "    if (!paintable_box()->layout_box().is_scroll_container())",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1363,
          "old_api": "paintable_box()->set_scroll_",
          "new_api": null,
          "old_text": "    paintable_box()->set_scroll_",
          "new_text": null,
          "old_line_content": "    auto scroll_offset = paintable_box()->scroll_offset();",
          "new_line_content": "    // 11. Scroll the element to x,scrollTop, with the scroll behavior being \"auto\".",
          "content_same": false
        },
        {
          "line": 1364,
          "old_api": "void Element::set_scroll_top(do",
          "new_api": null,
          "old_text": "void Element::set_scroll_top(do",
          "new_text": null,
          "old_line_content": "    scroll_offset.set_x(CSSPixels::nearest_value_for(x));",
          "new_line_content": "    // FIXME: Implement this in terms of calling \"scroll the element\".",
          "content_same": false
        },
        {
          "line": 1373,
          "old_api": ".\n    auto& document = this->documen",
          "new_api": null,
          "old_text": ".\n    auto& document = this->documen",
          "new_text": null,
          "old_line_content": "    y = HTML::normalize_non_finite_values(y);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1376,
          "old_api": "if (!document.",
          "new_api": null,
          "old_text": "  if (!document.",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1379,
          "old_api": "View attribute.",
          "new_api": null,
          "old_text": "View attribute.\n    ",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1383,
          "old_api": "return;\n\n    //",
          "new_api": null,
          "old_text": "       return;\n\n    // ",
          "new_text": null,
          "old_line_content": "    auto* window = document.default_view();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1390,
          "old_api": "looking at metrics or sc",
          "new_api": null,
          "old_text": " looking at metrics or sc",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && document.in_quirks_mode())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1394,
          "old_api": "nvoke scroll() on window with scrollX on window",
          "new_api": null,
          "old_text": "nvoke scroll() on window with scrollX on window",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1397,
          "old_api": "turn;\n    }\n\n    // 9. If t",
          "new_api": null,
          "old_text": "turn;\n    }\n\n    // 9. If t",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1398,
          "old_api": "ument is in quirks",
          "new_api": null,
          "old_text": "ument is in quirks",
          "new_text": null,
          "old_line_content": "        window->scroll(window->scroll_x(), y);",
          "new_line_content": "    // 8. If the element is the root element invoke scroll() on window with scrollX on window as first argument and y as second argument, and terminate these steps.",
          "content_same": false
        },
        {
          "line": 1403,
          "old_api": "}\n\n    // 10. If the elem",
          "new_api": null,
          "old_text": "  }\n\n    // 10. If the elem",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1404,
          "old_api": "iated box, the ele",
          "new_api": null,
          "old_text": "iated box, the ele",
          "new_text": null,
          "old_line_content": "        window->scroll(window->scroll_x(), y);",
          "new_line_content": "    // 9. If the element is the body element, document is in quirks mode, and the element is not potentially scrollable, invoke scroll() on window with scrollX as first argument and y as second argument, and terminate these steps.",
          "content_same": false
        },
        {
          "line": 1409,
          "old_api": "return;",
          "new_api": null,
          "old_text": "        return;",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1412,
          "old_api": "nt has no overflow.\n\n    // 11. Scroll the element",
          "new_api": null,
          "old_text": "nt has no overflow.\n\n    // 11. Scroll the element ",
          "new_text": null,
          "old_line_content": "    if (!paintable_box()->layout_box().is_scroll_container())",
          "new_line_content": "        return;",
          "content_same": false
        },
        {
          "line": 1419,
          "old_api": "paintable_box",
          "new_api": null,
          "old_text": "paintable_box()->set_scroll_offs",
          "new_text": null,
          "old_line_content": "    auto scroll_offset = paintable_box()->scroll_offset();",
          "new_line_content": "    // 11. Scroll the element to scrollLeft,y, with the scroll behavior being \"auto\".",
          "content_same": false
        },
        {
          "line": 1420,
          "old_api": "ttps://drafts.csswg.org/cssom-v",
          "new_api": null,
          "old_text": "ttps://drafts.csswg.org/cssom-v",
          "new_text": null,
          "old_line_content": "    scroll_offset.set_y(CSSPixels::nearest_value_for(y));",
          "new_line_content": "    // FIXME: Implement this in terms of calling \"scroll the element\".",
          "content_same": false
        },
        {
          "line": 1428,
          "old_api": "se steps.\n    if",
          "new_api": null,
          "old_text": "se steps.\n    if",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1431,
          "old_api": "ing at metrics.",
          "new_api": null,
          "old_text": "ing at metrics.\n    ",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1435,
          "old_api": "viewport excluding the width of the scroll bar",
          "new_api": null,
          "old_text": " viewport excluding the width of the scroll bar",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1439,
          "old_api": "width",
          "new_api": null,
          "old_text": "size().width().to_int();\n\n    // 4. If th",
          "new_text": null,
          "old_line_content": "    auto viewport_width = document.viewport_rect().width().to_int();",
          "new_line_content": "    // 3. Let viewport width be the width of the viewport excluding the width of the scroll bar, if any,",
          "content_same": false
        },
        {
          "line": 1440,
          "old_api": "ocument is not in quirks mode\n    //    retur",
          "new_api": null,
          "old_text": "ocument is not in quirks mode\n    //    retur",
          "new_text": null,
          "old_line_content": "    auto viewport_scroll_width = document.navigable()->size().width().to_int();",
          "new_line_content": "    //    or zero if there is no viewport.",
          "content_same": false
        },
        {
          "line": 1444,
          "old_api": "f the element is the body",
          "new_api": null,
          "old_text": "f the element is the body",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && !document.in_quirks_mode())",
          "new_line_content": "    // 4. If the element is the root element and document is not in quirks mode",
          "content_same": false
        },
        {
          "line": 1445,
          "old_api": "t is in quirks mode and the element is not",
          "new_api": null,
          "old_text": "t is in quirks mode and the element is not",
          "new_text": null,
          "old_line_content": "        return max(viewport_scroll_width, viewport_width);",
          "new_line_content": "    //    return max(viewport scrolling area width, viewport width).",
          "content_same": false
        },
        {
          "line": 1449,
          "old_api": "If the element does not ha",
          "new_api": null,
          "old_text": " If the element does not ha",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "new_line_content": "    // 5. If the element is the body element, document is in quirks mode and the element is not potentially scrollable,",
          "content_same": false
        },
        {
          "line": 1450,
          "old_api": "box return zero and terminate these steps",
          "new_api": null,
          "old_text": " box return zero and terminate these steps",
          "new_text": null,
          "old_line_content": "        return max(viewport_scroll_width, viewport_width);",
          "new_line_content": "    //    return max(viewport scrolling area width, viewport width).",
          "content_same": false
        },
        {
          "line": 1453,
          "old_api": "return painta",
          "new_api": null,
          "old_text": "  return painta",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1457,
          "old_api": "view/#dom-element-scrollheight\nint Element::scroll_height() c",
          "new_api": null,
          "old_text": "view/#dom-element-scrollheight\nint Element::scroll_height() c",
          "new_text": null,
          "old_line_content": "    return paintable_box()->scrollable_overflow_rect()->width().to_int();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1464,
          "old_api": "teps.\n    if (!d",
          "new_api": null,
          "old_text": "teps.\n    if (!d",
          "new_text": null,
          "old_line_content": "    auto& document = this->document();",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1467,
          "old_api": "at metrics.\n    cons",
          "new_api": null,
          "old_text": "at metrics.\n    cons",
          "new_text": null,
          "old_line_content": "    if (!document.is_active())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1471,
          "old_api": "iewport excluding the height of the scroll bar,",
          "new_api": null,
          "old_text": "iewport excluding the height of the scroll bar,",
          "new_text": null,
          "old_line_content": "    const_cast<Document&>(document).update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1475,
          "old_api": "height",
          "new_api": null,
          "old_text": "ze().height().to_int();\n\n    // 4. If the ",
          "new_text": null,
          "old_line_content": "    auto viewport_height = document.viewport_rect().height().to_int();",
          "new_line_content": "    // 3. Let viewport height be the height of the viewport excluding the height of the scroll bar, if any,",
          "content_same": false
        },
        {
          "line": 1476,
          "old_api": "ment is not in quirks mode\n    //    return ma",
          "new_api": null,
          "old_text": "ment is not in quirks mode\n    //    return ma",
          "new_text": null,
          "old_line_content": "    auto viewport_scroll_height = document.navigable()->size().height().to_int();",
          "new_line_content": "    //    or zero if there is no viewport.",
          "content_same": false
        },
        {
          "line": 1480,
          "old_api": "the element is the body e",
          "new_api": null,
          "old_text": "the element is the body e",
          "new_text": null,
          "old_line_content": "    if (document.document_element() == this && !document.in_quirks_mode())",
          "new_line_content": "    // 4. If the element is the root element and document is not in quirks mode",
          "content_same": false
        },
        {
          "line": 1481,
          "old_api": "is in quirks mode and the element is not pot",
          "new_api": null,
          "old_text": "is in quirks mode and the element is not pot",
          "new_text": null,
          "old_line_content": "        return max(viewport_scroll_height, viewport_height);",
          "new_line_content": "    //    return max(viewport scrolling area height, viewport height).",
          "content_same": false
        },
        {
          "line": 1485,
          "old_api": "f the element does not have",
          "new_api": null,
          "old_text": "f the element does not have",
          "new_text": null,
          "old_line_content": "    if (document.body() == this && document.in_quirks_mode() && !is_potentially_scrollable())",
          "new_line_content": "    // 5. If the element is the body element, document is in quirks mode and the element is not potentially scrollable,",
          "content_same": false
        },
        {
          "line": 1486,
          "old_api": "ox return zero and terminate these steps.",
          "new_api": null,
          "old_text": "ox return zero and terminate these steps.\n  ",
          "new_text": null,
          "old_line_content": "        return max(viewport_scroll_height, viewport_height);",
          "new_line_content": "    //    return max(viewport scrolling area height, viewport height).",
          "content_same": false
        },
        {
          "line": 1489,
          "old_api": "eturn paintable",
          "new_api": null,
          "old_text": "eturn paintable",
          "new_text": null,
          "old_line_content": "    if (!paintable_box())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1493,
          "old_api": "page/semantics-other.html#concept-element-disabled\nbool Elemen",
          "new_api": null,
          "old_text": "page/semantics-other.html#concept-element-disabled\nbool Elemen",
          "new_text": null,
          "old_line_content": "    return paintable_box()->scrollable_overflow_rect()->height().to_int();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1504,
          "old_api": "FormAssociatedElement const*>(this)",
          "new_api": null,
          "old_text": "FormAssociatedElement const*>(this)",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLButtonElement>(this) || is<HTML::HTMLInputElement>(this) || is<HTML::HTMLSelectElement>(this) || is<HTML::HTMLTextAreaElement>(this)) {",
          "new_line_content": "    // - a select element that is disabled",
          "content_same": false
        },
        {
          "line": 1505,
          "old_api": "enabled",
          "new_api": null,
          "old_text": "  return !form_associated_element->enabled();\n    }\n\n ",
          "new_text": null,
          "old_line_content": "        auto const* form_associated_element = dynamic_cast<HTML::FormAssociatedElement const*>(this);",
          "new_line_content": "    // - a textarea element that is disabled",
          "content_same": false
        },
        {
          "line": 1512,
          "old_api": "// - an option element that is disa",
          "new_api": null,
          "old_text": "// - an option element that is disa",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLOptGroupElement>(this))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1513,
          "old_api": "TML::HTMLOptionElement>(this))\n        return",
          "new_api": null,
          "old_text": "TML::HTMLOptionElement>(this))\n        return",
          "new_text": null,
          "old_line_content": "        return has_attribute(HTML::AttributeNames::disabled);",
          "new_line_content": "    // - an optgroup element that has a disabled attribute",
          "content_same": false
        },
        {
          "line": 1516,
          "old_api": "abled",
          "new_api": null,
          "old_text": "abled();\n\n    // - a fieldset ele",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLOptionElement>(this))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1517,
          "old_api": "sabled fieldset\n    if (is<HTML::HTMLFieldSetElement>(this))",
          "new_api": null,
          "old_text": "sabled fieldset\n    if (is<HTML::HTMLFieldSetElement>(this))\n",
          "new_text": null,
          "old_line_content": "        return static_cast<HTML::HTMLOptionElement const&>(*this).disabled();",
          "new_line_content": "    // - an option element that is disabled",
          "content_same": false
        },
        {
          "line": 1520,
          "old_api": "is_disabled",
          "new_api": null,
          "old_text": ".is_disabled();\n\n    // FIXME: - a ",
          "new_text": null,
          "old_line_content": "    if (is<HTML::HTMLFieldSetElement>(this))",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1521,
          "old_api": "ustom element that is disabled\n    return false;\n}\n\n// https://htm",
          "new_api": null,
          "old_text": "ustom element that is disabled\n    return false;\n}\n\n// https://htm",
          "new_text": null,
          "old_line_content": "        return static_cast<HTML::HTMLFieldSetElement const&>(*this).is_disabled();",
          "new_line_content": "    // - a fieldset element that is a disabled fieldset",
          "content_same": false
        },
        {
          "line": 1534,
          "old_api": "// 3. Let new children",
          "new_api": null,
          "old_text": "\n    // 3. Let new children ",
          "new_text": null,
          "old_line_content": "    if (document().is_xml_document()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1535,
          "old_api": "t of invoking algorithm given markup, with context set t",
          "new_api": null,
          "old_text": "t of invoking algorithm given markup, with context set t",
          "new_text": null,
          "old_line_content": "        dbgln(\"FIXME: Handle fragment parsing of XML documents\");",
          "new_line_content": "    // FIXME: 2. If context's node document is an XML document, then set algorithm to the XML fragment parsing algorithm.",
          "content_same": false
        },
        {
          "line": 1539,
          "old_api": "a new DocumentFragment whose node document is context's node document.",
          "new_api": null,
          "old_text": "a new DocumentFragment whose node document is context's node document.\n    ",
          "new_text": null,
          "old_line_content": "    auto new_children = algorithm(*this, markup, HTML::HTMLParser::AllowDeclarativeShadowRoots::No);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1542,
          "old_api": "ld : new_c",
          "new_api": null,
          "old_text": "ld : new_c",
          "new_text": null,
          "old_line_content": "    auto fragment = realm().heap().allocate<DOM::DocumentFragment>(realm(), document());",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1547,
          "old_api": "e/dynamic-markup-insertion.htm",
          "new_api": null,
          "old_text": "e/dynamic-markup-insertion.htm",
          "new_text": null,
          "old_line_content": "        (void)TRY(fragment->append_child(*child));",
          "new_line_content": "    for (auto& child : new_children) {",
          "content_same": false
        },
        {
          "line": 1556,
          "old_api": "html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-outerhtml\nWebID",
          "new_api": null,
          "old_text": "html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-element-outerhtml\nWebID",
          "new_text": null,
          "old_line_content": "    return serialize_fragment(DOMParsing::RequireWellFormed::Yes, FragmentSerializationMode::Outer);",
          "new_line_content": "WebIDL::ExceptionOr<String> Element::outer_html() const",
          "content_same": false
        },
        {
          "line": 1565,
          "old_api": "nodes created",
          "new_api": null,
          "old_text": " nodes created",
          "new_text": null,
          "old_line_content": "    auto* parent = this->parent();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1572,
          "old_api": "ter HTML on document\"",
          "new_api": null,
          "old_text": "ter HTML on document\"",
          "new_text": null,
          "old_line_content": "    if (parent->is_document())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1573,
          "old_api": "t paren",
          "new_api": null,
          "old_text": "t paren",
          "new_text": null,
          "old_line_content": "        return WebIDL::NoModificationAllowedError::create(realm(), \"Cannot set outer HTML on document\"_fly_string);",
          "new_line_content": "    // 4. If parent is a Document, throw a \"NoModificationAllowedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 1576,
          "old_api": "mespace::HTML));\n\n    // 6. Le",
          "new_api": null,
          "old_text": "mespace::HTML));\n\n    // 6. Le",
          "new_text": null,
          "old_line_content": "    if (parent->is_document_fragment())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1577,
          "old_api": "he fragmen",
          "new_api": null,
          "old_text": "he fragmen",
          "new_text": null,
          "old_line_content": "        parent = TRY(create_element(document(), HTML::TagNames::body, Namespace::HTML));",
          "new_line_content": "    // 5. If parent is a DocumentFragment, set parent to the result of creating an element given this's node document, body, and the HTML namespace.",
          "content_same": false
        },
        {
          "line": 1580,
          "old_api": "replace_child",
          "new_api": null,
          "old_text": "s parent.\n    TRY(parent->replace_child(fragment, *",
          "new_text": null,
          "old_line_content": "    auto fragment = TRY(verify_cast<Element>(*parent).parse_fragment(value));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1583,
          "old_api": "namic-markup-insertion.html#the-insert",
          "new_api": null,
          "old_text": "namic-markup-insertion.html#the-insert",
          "new_text": null,
          "old_line_content": "    TRY(parent->replace_child(fragment, *this));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1597,
          "old_api": "itive_match",
          "new_api": null,
          "old_text": "itive_match(position, \"afterend\"sv)) {\n        // 1. Set context ",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(position, \"beforebegin\"sv)",
          "new_line_content": "    // - If position is an ASCII case-insensitive match for the string \"beforebegin\"",
          "content_same": false
        },
        {
          "line": 1598,
          "old_api": "parent",
          "new_api": null,
          "old_text": "rent.\n        context = this->parent();\n\n        // 2. If cont",
          "new_text": null,
          "old_line_content": "        || Infra::is_ascii_case_insensitive_match(position, \"afterend\"sv)) {",
          "new_line_content": "    // - If position is an ASCII case-insensitive match for the string \"afterend\"",
          "content_same": false
        },
        {
          "line": 1603,
          "old_api": "jacentHTML: context is",
          "new_api": null,
          "old_text": "jacentHTML: context is",
          "new_text": null,
          "old_line_content": "        if (!context || context->is_document())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1604,
          "old_api": "an ASCI",
          "new_api": null,
          "old_text": "an ASCI",
          "new_text": null,
          "old_line_content": "            return WebIDL::NoModificationAllowedError::create(realm(), \"insertAdjacentHTML: context is null or a Document\"_fly_string);",
          "new_line_content": "        // 2. If context is null or a Document, throw a \"NoModificationAllowedError\" DOMException.",
          "content_same": false
        },
        {
          "line": 1608,
          "old_api": "tive_match",
          "new_api": null,
          "old_text": "tive_match(position, \"beforeend\"sv)) {\n        // Set context to",
          "new_text": null,
          "old_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"afterbegin\"sv)",
          "new_line_content": "    // - If position is an ASCII case-insensitive match for the string \"afterbegin\"",
          "content_same": false
        },
        {
          "line": 1609,
          "old_api": "context = this;\n    }\n    // Otherwise\n    else {\n        //",
          "new_api": null,
          "old_text": "   context = this;\n    }\n    // Otherwise\n    else {\n        //",
          "new_text": null,
          "old_line_content": "        || Infra::is_ascii_case_insensitive_match(position, \"beforeend\"sv)) {",
          "new_line_content": "    // - If position is an ASCII case-insensitive match for the string \"beforeend\"",
          "content_same": false
        },
        {
          "line": 1616,
          "old_api": "an Ele",
          "new_api": null,
          "old_text": " an Ele",
          "new_text": null,
          "old_line_content": "        return WebIDL::SyntaxError::create(realm(), \"insertAdjacentHTML: invalid position argument\"_fly_string);",
          "new_line_content": "    else {",
          "content_same": false
        },
        {
          "line": 1623,
          "old_api": "&& static_cast<Elem",
          "new_api": null,
          "old_text": "  && static_cast<Elem",
          "new_text": null,
          "old_line_content": "    if (!is<Element>(*context)",
          "new_line_content": "    //    - context's local name is \"html\", and",
          "content_same": false
        },
        {
          "line": 1624,
          "old_api": "local_name",
          "new_api": null,
          "old_text": "context).local_name() == \"html\"sv\n ",
          "new_text": null,
          "old_line_content": "        || (context->document().document_type() == Document::Type::HTML",
          "new_line_content": "    //    - context's namespace is the HTML namespace;",
          "content_same": false
        },
        {
          "line": 1631,
          "old_api": "list:\n\n    // - If position is an ASCII case-insensi",
          "new_api": null,
          "old_text": " list:\n\n    // - If position is an ASCII case-insensi",
          "new_text": null,
          "old_line_content": "    auto fragment = TRY(verify_cast<Element>(*context).parse_fragment(string));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1636,
          "old_api": "insert_before",
          "new_api": null,
          "old_text": "s's parent before this.\n        parent()->insert_before(fragment,",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(position, \"beforebegin\"sv)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1642,
          "old_api": "before its first child.\n        insert_before(fragment, first_c",
          "new_api": null,
          "old_text": " before its first child.\n        insert_before(fragment, first_c",
          "new_text": null,
          "old_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"afterbegin\"sv)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1648,
          "old_api": "TRY(append_child(fragment));\n    }\n\n    // - If position",
          "new_api": null,
          "old_text": "       TRY(append_child(fragment));\n    }\n\n    // - If position",
          "new_text": null,
          "old_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"beforeend\"sv)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1654,
          "old_api": "parent before this's next sibling.\n        parent()->insert_b",
          "new_api": null,
          "old_text": " parent before this's next sibling.\n        parent()->insert_b",
          "new_text": null,
          "old_line_content": "    else if (Infra::is_ascii_case_insensitive_match(position, \"afterend\"sv)) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1665,
          "old_api": "If elements parent is null, return null.\n        if (!parent",
          "new_api": null,
          "old_text": " If elements parent is null, return null.\n        if (!parent",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"beforebegin\"sv)) {",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1668,
          "old_api": "ode into",
          "new_api": null,
          "old_text": "ode into",
          "new_text": null,
          "old_line_content": "        if (!parent())",
          "new_line_content": "        // -> \"beforebegin\"",
          "content_same": false
        },
        {
          "line": 1672,
          "old_api": "// -> \"a",
          "new_api": null,
          "old_text": "  // -> \"a",
          "new_text": null,
          "old_line_content": "        return JS::GCPtr<Node> { TRY(parent()->pre_insert(move(node), this)) };",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1675,
          "old_api": "n the result of pre-inserting node into element before elemen",
          "new_api": null,
          "old_text": "n the result of pre-inserting node into element before elemen",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"afterbegin\"sv)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1678,
          "old_api": "> \"beforeend\"",
          "new_api": null,
          "old_text": "> \"beforeend\"",
          "new_text": null,
          "old_line_content": "        return JS::GCPtr<Node> { TRY(pre_insert(move(node), first_child())) };",
          "new_line_content": "        // -> \"afterbegin\"",
          "content_same": false
        },
        {
          "line": 1681,
          "old_api": "e result of pre-inserting node into element before null.",
          "new_api": null,
          "old_text": "e result of pre-inserting node into element before null.\n   ",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"beforeend\"sv)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1684,
          "old_api": "// -> \"af",
          "new_api": null,
          "old_text": " // -> \"af",
          "new_text": null,
          "old_line_content": "        return JS::GCPtr<Node> { TRY(pre_insert(move(node), nullptr)) };",
          "new_line_content": "        // -> \"beforeend\"",
          "content_same": false
        },
        {
          "line": 1687,
          "old_api": "s parent is null, return null.\n        if (!parent())",
          "new_api": null,
          "old_text": "s parent is null, return null.\n        if (!parent())\n     ",
          "new_text": null,
          "old_line_content": "    if (Infra::is_ascii_case_insensitive_match(where, \"afterend\"sv)) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1690,
          "old_api": "to eleme",
          "new_api": null,
          "old_text": "to eleme",
          "new_text": null,
          "old_line_content": "        if (!parent())",
          "new_line_content": "        // -> \"afterend\"",
          "content_same": false
        },
        {
          "line": 1694,
          "old_api": "rror::create(r",
          "new_api": null,
          "old_text": "rror::create(r",
          "new_text": null,
          "old_line_content": "        return JS::GCPtr<Node> { TRY(parent()->pre_insert(move(node), next_sibling())) };",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1699,
          "old_api": "where)));\n}\n\n// https://dom.spec.whatwg.org/#dom-element-insertadjacentelement\nWebIDL::ExceptionOr<JS::GCPtr<Element>> Ele",
          "new_api": null,
          "old_text": "where)));\n}\n\n// https://dom.spec.whatwg.org/#dom-element-insertadjacentelement\nWebIDL::ExceptionOr<JS::GCPtr<Element>> Ele",
          "new_text": null,
          "old_line_content": "    return WebIDL::SyntaxError::create(realm(), MUST(String::formatted(\"Unknown position '{}'. Must be one of 'beforebegin', 'afterbegin', 'beforeend' or 'afterend'\"sv, where)));",
          "new_line_content": "    // -> Otherwise",
          "content_same": false
        },
        {
          "line": 1706,
          "old_api": "JS::GCPtr<Element> { verify_cas",
          "new_api": null,
          "old_text": "JS::GCPtr<Element> { verify_cas",
          "new_text": null,
          "old_line_content": "    auto returned_node = TRY(insert_adjacent(where, element));",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1709,
          "old_api": "ceptionOr<void> Element::insert_adja",
          "new_api": null,
          "old_text": "ceptionOr<void> Element::insert_adja",
          "new_text": null,
          "old_line_content": "    return JS::GCPtr<Element> { verify_cast<Element>(*returned_node) };",
          "new_line_content": "    if (!returned_node)",
          "content_same": false
        },
        {
          "line": 1716,
          "old_api": "nothing be",
          "new_api": null,
          "old_text": "nothing be",
          "new_text": null,
          "old_line_content": "    auto text = heap().allocate<DOM::Text>(realm(), document(), data);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1720,
          "old_api": "-into-view\nstatic ErrorOr<vo",
          "new_api": null,
          "old_text": "-into-view\nstatic ErrorOr<vo",
          "new_text": null,
          "old_line_content": "    (void)TRY(insert_adjacent(where, text));",
          "new_line_content": "    // 2. Run insert adjacent, given this, where, and text.",
          "content_same": false
        },
        {
          "line": 1730,
          "old_api": "&& ancestor->p",
          "new_api": null,
          "old_text": " && ancestor->p",
          "new_text": null,
          "old_line_content": "    auto ancestor = target.parent();",
          "new_line_content": "    // direction position block, and an inline base direction position inline, means to run these steps for each ancestor",
          "content_same": false
        },
        {
          "line": 1733,
          "old_api": "parent",
          "new_api": null,
          "old_text": " = ancestor->parent();\n    }\n\n    for (auto& scrolla",
          "new_text": null,
          "old_line_content": "        if (ancestor->paintable_box() && ancestor->paintable_box()->has_scrollable_overflow())",
          "new_line_content": "    Vector<DOM::Node&> scrollable_nodes;",
          "content_same": false
        },
        {
          "line": 1734,
          "old_api": "ollable_nodes) {\n        if (!scro",
          "new_api": null,
          "old_text": "ollable_nodes) {\n        if (!scro",
          "new_text": null,
          "old_line_content": "            scrollable_nodes.append(*ancestor);",
          "new_line_content": "    while (ancestor) {",
          "content_same": false
        },
        {
          "line": 1739,
          "old_api": "continue;\n        }",
          "new_api": null,
          "old_text": "      continue;\n        }\n\n  ",
          "new_text": null,
          "old_line_content": "        if (!scrollable_node.is_document()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1746,
          "old_api": "initial containing block\n        CS",
          "new_api": null,
          "old_text": "initial containing block\n        CS",
          "new_text": null,
          "old_line_content": "        if (target.document().origin() != scrollable_node.document().origin()) {",
          "new_line_content": "        // 1. If the Document associated with target is not same origin with the Document",
          "content_same": false
        },
        {
          "line": 1751,
          "old_api": "e return value of invoking Elements",
          "new_api": null,
          "old_text": "e return value of invoking Elements\n     ",
          "new_text": null,
          "old_line_content": "        CSSPixelRect scrolling_box = scrollable_node.document().viewport_rect();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1756,
          "old_api": "on of scrolling box, and",
          "new_api": null,
          "old_text": "on of scrolling box, and\n        ",
          "new_text": null,
          "old_line_content": "        auto target_bounding_border_box = target.get_bounding_client_rect();",
          "new_line_content": "        //    getBoundingClientRect(), if target is an Element, or Ranges getBoundingClientRect(),",
          "content_same": false
        },
        {
          "line": 1761,
          "old_api": "ng box edge B be the ending edge",
          "new_api": null,
          "old_text": "ng box edge B be the ending edge ",
          "new_text": null,
          "old_line_content": "        CSSPixels element_edge_a = CSSPixels::nearest_value_for(target_bounding_border_box->top());",
          "new_line_content": "        //    let element edge A be target bounding border boxs edge on the same physical side as that of",
          "content_same": false
        },
        {
          "line": 1762,
          "old_api": ", and let\n        /",
          "new_api": null,
          "old_text": ", and let\n        /",
          "new_text": null,
          "old_line_content": "        CSSPixels scrolling_box_edge_a = scrolling_box.top();",
          "new_line_content": "        //    scrolling box edge A.",
          "content_same": false
        },
        {
          "line": 1767,
          "old_api": "olling box edge C be the beginning e",
          "new_api": null,
          "old_text": "olling box edge C be the beginning e",
          "new_text": null,
          "old_line_content": "        CSSPixels element_edge_b = CSSPixels::nearest_value_for(target_bounding_border_box->bottom());",
          "new_line_content": "        //    element edge B be target bounding border boxs edge on the same physical side as that of scrolling",
          "content_same": false
        },
        {
          "line": 1768,
          "old_api": "g box, and\n        //",
          "new_api": null,
          "old_text": "g box, and\n        // ",
          "new_text": null,
          "old_line_content": "        CSSPixels scrolling_box_edge_b = scrolling_box.bottom();",
          "new_line_content": "        //    box edge B.",
          "content_same": false
        },
        {
          "line": 1773,
          "old_api": "box edge D be the ending edge in",
          "new_api": null,
          "old_text": " box edge D be the ending edge in ",
          "new_text": null,
          "old_line_content": "        CSSPixels element_edge_c = CSSPixels::nearest_value_for(target_bounding_border_box->left());",
          "new_line_content": "        //    let element edge C be target bounding border boxs edge on the same physical side as that of scrolling",
          "content_same": false
        },
        {
          "line": 1774,
          "old_api": "and let element",
          "new_api": null,
          "old_text": "and let element\n    ",
          "new_text": null,
          "old_line_content": "        CSSPixels scrolling_box_edge_c = scrolling_box.left();",
          "new_line_content": "        //    box edge C.",
          "content_same": false
        },
        {
          "line": 1778,
          "old_api": "eight be the distance between eleme",
          "new_api": null,
          "old_text": "eight be the distance between eleme",
          "new_text": null,
          "old_line_content": "        CSSPixels element_edge_d = CSSPixels::nearest_value_for(target_bounding_border_box->right());",
          "new_line_content": "        // 6. Let scrolling box edge D be the ending edge in the inline base direction of scrolling box, and let element",
          "content_same": false
        },
        {
          "line": 1779,
          "old_api": "els element_height =",
          "new_api": null,
          "old_text": "els element_height = ",
          "new_text": null,
          "old_line_content": "        CSSPixels scrolling_box_edge_d = scrolling_box.right();",
          "new_line_content": "        //    edge D be target bounding border boxs edge on the same physical side as that of scrolling box edge D.",
          "content_same": false
        },
        {
          "line": 1794,
          "old_api": "element edge A with scrolling box edge A.\n            if (block == Bindings::ScrollLogicalPosition::Start) {\n                y = element_edge_a;\n            }\n            // 2. Otherwise, if block is \"end\", then align element edge B with scrolling box edge B.\n            else if (block == Bindings::ScrollLogicalPosition::End) {\n                y = element_edge_a + element_height - scrolling_box_height;\n            }\n            // 3. Otherwise, if block is \"center\", then align the center of target bounding border box with the center of scrolling box in scrolling boxs block flow direction.\n            else if (block == Bindings::ScrollLogicalPosition::Center) {\n                y = element_edge_a + (element_height / 2) - (scrolling_box_height / 2);\n            }\n            // 4. Otherwise, block is \"nearest\":\n            else {\n                // If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n                if (element_edge_a <= 0 && element_edge_b >= scrolling_box_height) {\n                    // Do nothing.\n                }\n                // If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n                else if ((element_edge_a <= 0 && element_height < scrolling_box_height) || (element_edge_b >= scrolling_box_height && element_height > scrolling_box_height)) {\n                    // Align element edge A with scrolling box edge A.\n                    y = element_edge_a;\n                }\n                // If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n                else if ((element_edge_b >= scrolling_box_height && element_height < scrolling_box_height) || (element_edge_a <= 0 && element_height > scrolling_box_height)) {\n                    // Align element edge B with scrolling box edge B.\n                    y = element_edge_a + element_height - scrolling_box_height;\n                }\n            }\n\n            if (inline_ == Bindings::ScrollLogicalPosition::Nearest) {\n                // If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n                if (element_edge_c <= 0 && element_edge_d >= scrolling_box_width) {\n                    // Do nothing.\n                }\n                // If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n                else if ((element_edge_c <= 0 && element_width < scrolling_box_width) || (element_edge_d >= scrolling_box_width && element_width > scrolling_box_width)) {\n                    // Align element edge C with scrolling box edge C.\n                    x = element_edge_c;\n                }\n                // If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n                else if ((element_edge_d >= scrolling_box_width && element_width < scrolling_box_width) || (element_edge_c <= 0 && element_width > scrolling_box_width)) {\n                    // Align element edge D with scrolling box edge D.\n                    x = element_edge_d + element_width - scrolling_box_width;\n                }\n            }\n\n            return CSSPixelPoint { x, y };\n        }();\n\n        // FIXME: 12. If position is the same as scrolling boxs current scroll position, and scrolling box does not\n        //",
          "new_api": null,
          "old_text": " element edge A with scrolling box edge A.\n            if (block == Bindings::ScrollLogicalPosition::Start) {\n                y = element_edge_a;\n            }\n            // 2. Otherwise, if block is \"end\", then align element edge B with scrolling box edge B.\n            else if (block == Bindings::ScrollLogicalPosition::End) {\n                y = element_edge_a + element_height - scrolling_box_height;\n            }\n            // 3. Otherwise, if block is \"center\", then align the center of target bounding border box with the center of scrolling box in scrolling boxs block flow direction.\n            else if (block == Bindings::ScrollLogicalPosition::Center) {\n                y = element_edge_a + (element_height / 2) - (scrolling_box_height / 2);\n            }\n            // 4. Otherwise, block is \"nearest\":\n            else {\n                // If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n                if (element_edge_a <= 0 && element_edge_b >= scrolling_box_height) {\n                    // Do nothing.\n                }\n                // If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n                else if ((element_edge_a <= 0 && element_height < scrolling_box_height) || (element_edge_b >= scrolling_box_height && element_height > scrolling_box_height)) {\n                    // Align element edge A with scrolling box edge A.\n                    y = element_edge_a;\n                }\n                // If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n                // If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n                else if ((element_edge_b >= scrolling_box_height && element_height < scrolling_box_height) || (element_edge_a <= 0 && element_height > scrolling_box_height)) {\n                    // Align element edge B with scrolling box edge B.\n                    y = element_edge_a + element_height - scrolling_box_height;\n                }\n            }\n\n            if (inline_ == Bindings::ScrollLogicalPosition::Nearest) {\n                // If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n                if (element_edge_c <= 0 && element_edge_d >= scrolling_box_width) {\n                    // Do nothing.\n                }\n                // If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n                else if ((element_edge_c <= 0 && element_width < scrolling_box_width) || (element_edge_d >= scrolling_box_width && element_width > scrolling_box_width)) {\n                    // Align element edge C with scrolling box edge C.\n                    x = element_edge_c;\n                }\n                // If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n                // If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n                else if ((element_edge_d >= scrolling_box_width && element_width < scrolling_box_width) || (element_edge_c <= 0 && element_width > scrolling_box_width)) {\n                    // Align element edge D with scrolling box edge D.\n                    x = element_edge_d + element_width - scrolling_box_width;\n                }\n            }\n\n            return CSSPixelPoint { x, y };\n        }();\n\n        // FIXME: 12. If position is the same as scrolling boxs current scroll position, and scrolling box does not\n        //  ",
          "new_text": null,
          "old_line_content": "        auto position = [&]() -> CSSPixelPoint {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1856,
          "old_api": "atic_cast<DOM::Document&>(scr",
          "new_api": null,
          "old_text": "atic_cast<DOM::Document&>(scr",
          "new_text": null,
          "old_line_content": "        if (scrollable_node.is_document()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1867,
          "old_api": "iated with an ele",
          "new_api": null,
          "old_text": "iated with an ele",
          "new_text": null,
          "old_line_content": "            position.set_y(position.y() + scrolling_box.y());",
          "new_line_content": "            // NOTE: Since calculated position is relative to the viewport, we need to add the viewport's position to it",
          "content_same": false
        },
        {
          "line": 1868,
          "old_api": "se {\n            // FIXME: Perform a scroll of the element",
          "new_api": null,
          "old_text": "se {\n            // FIXME: Perform a scroll of the element",
          "new_text": null,
          "old_line_content": "            document.navigable()->perform_scroll_of_viewport(position);",
          "new_line_content": "            //       before passing to perform_scroll_of_viewport() that expects a position relative to the page.",
          "content_same": false
        },
        {
          "line": 1893,
          "old_api": "rollIntoViewOptions>().behavior;",
          "new_api": null,
          "old_text": "rollIntoViewOptions>().behavior;\n",
          "new_text": null,
          "old_line_content": "    if (arg.has_value() && arg->has<ScrollIntoViewOptions>()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1898,
          "old_api": "rollIntoViewOptions>().inline_;",
          "new_api": null,
          "old_text": "rollIntoViewOptions>().inline_;\n ",
          "new_text": null,
          "old_line_content": "        block = arg->get<ScrollIntoViewOptions>().block;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1901,
          "old_api": "&& arg->has<bool>() && arg->get<",
          "new_api": null,
          "old_text": " && arg->has<bool>() && arg->get<",
          "new_text": null,
          "old_line_content": "        inline_ = arg->get<ScrollIntoViewOptions>().inline_;",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1904,
          "old_api": "ted box, or is n",
          "new_api": null,
          "old_text": "ted box, or is n",
          "new_text": null,
          "old_line_content": "    else if (arg.has_value() && arg->has<bool>() && arg->get<bool>() == false) {",
          "new_line_content": "    }",
          "content_same": false
        },
        {
          "line": 1909,
          "old_api": "roll the element into view",
          "new_api": null,
          "old_text": "roll the element into view",
          "new_text": null,
          "old_line_content": "    document().update_layout();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1910,
          "old_api": "ior, block, a",
          "new_api": null,
          "old_text": "ior, block, a",
          "new_text": null,
          "old_line_content": "    if (!layout_node())",
          "new_line_content": "    // 6. If the element does not have any associated box, or is not available to user-agent features, then return.",
          "content_same": false
        },
        {
          "line": 1914,
          "old_api": "rings the element to the users attention.\n}\n\nvoid Element::",
          "new_api": null,
          "old_text": "rings the element to the users attention.\n}\n\nvoid Element::",
          "new_text": null,
          "old_line_content": "    TRY(scroll_an_element_into_view(*this, behavior, block, inline_));",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1927,
          "old_api": "e following elemen",
          "new_api": null,
          "old_text": "e following elemen",
          "new_text": null,
          "old_line_content": "    invalidate_style();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1936,
          "old_api": "on is conditi",
          "new_api": null,
          "old_text": "on is conditi",
          "new_text": null,
          "old_line_content": "    if (!layout_node())",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 1941,
          "old_api": "luded from the ac",
          "new_api": null,
          "old_text": "luded from the ac",
          "new_text": null,
          "old_line_content": "    auto role = role_or_default();",
          "new_line_content": "    // Elements with none or presentation as the first role in the role attribute. However, their exclusion is conditional. In addition, the element's descendants and text content are generally included. These exceptions and conditions are documented in the presentation (role) section.",
          "content_same": false
        },
        {
          "line": 1970,
          "old_api": "g:\n    // Elements that are curre",
          "new_api": null,
          "old_text": "g:\n    // Elements that are curre",
          "new_text": null,
          "old_line_content": "    if (exclude_from_accessibility_tree())",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1974,
          "old_api": "have an expl",
          "new_api": null,
          "old_text": "have an expl",
          "new_text": null,
          "old_line_content": "    if (is_focused())",
          "new_line_content": "    // Elements that are not hidden and may fire an accessibility API event, including:",
          "content_same": false
        },
        {
          "line": 1981,
          "old_api": "via a WAI-ARI",
          "new_api": null,
          "old_text": "via a WAI-ARI",
          "new_text": null,
          "old_line_content": "    if ((role_or_default().has_value() || has_global_aria_attribute()) && aria_hidden() != \"true\")",
          "new_line_content": "    // NOTE: The spec says only explicit roles count, but playing around in other browsers, this does not seem to be true in practice (for example button elements are always exposed with their implicit role if none is set)",
          "content_same": false
        },
        {
          "line": 1993,
          "old_api": "ions_stack = custom_data->c",
          "new_api": null,
          "old_text": "ions_stack = custom_data->c",
          "new_text": null,
          "old_line_content": "    auto& relevant_agent = HTML::relevant_agent(*this);",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 1994,
          "old_api": "then:\n    if (reactions_sta",
          "new_api": null,
          "old_text": " then:\n    if (reactions_sta",
          "new_text": null,
          "old_line_content": "    auto* custom_data = verify_cast<Bindings::WebEngineCustomData>(relevant_agent.custom_data());",
          "new_line_content": "    // 1. Let reactionsStack be element's relevant agent's custom element reactions stack.",
          "content_same": false
        },
        {
          "line": 1998,
          "old_api": "append",
          "new_api": null,
          "old_text": "backup_element_queue.append(*this);\n\n        /",
          "new_text": null,
          "old_line_content": "    if (reactions_stack.element_queue_stack.is_empty()) {",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2011,
          "old_api": "Bindings::WebEngineCu",
          "new_api": null,
          "old_text": "Bindings::WebEngineCu",
          "new_text": null,
          "old_line_content": "        HTML::queue_a_microtask(&document(), JS::create_heap_function(relevant_agent.heap(), [this]() {",
          "new_line_content": "        // 4. Queue a microtask to perform the following steps:",
          "content_same": false
        },
        {
          "line": 2012,
          "old_api": "auto& reactions_stack",
          "new_api": null,
          "old_text": "     auto& reactions_stack ",
          "new_text": null,
          "old_line_content": "            auto& relevant_agent = HTML::relevant_agent(*this);",
          "new_line_content": "        // NOTE: `this` is protected by JS::SafeFunction",
          "content_same": false
        },
        {
          "line": 2017,
          "old_api": "up element queue flag.\n            reactions_stack.processing_the_backup_elemen",
          "new_api": null,
          "old_text": "up element queue flag.\n            reactions_stack.processing_the_backup_elemen",
          "new_text": null,
          "old_line_content": "            Bindings::invoke_custom_element_reactions(reactions_stack.backup_element_queue);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2027,
          "old_api": "-upgrade-reaction\nvoid Element::enqueue_a_custom_e",
          "new_api": null,
          "old_text": "-upgrade-reaction\nvoid Element::enqueue_a_custom_e",
          "new_text": null,
          "old_line_content": "    custom_data->current_element_queue().append(*this);",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2034,
          "old_api": "/ 2. Enqueue an element on the appropriate element queue given element.\n    enqueue_an_element_on_the_appropriate_element_queue();\n}",
          "new_api": null,
          "old_text": "/ 2. Enqueue an element on the appropriate element queue given element.\n    enqueue_an_element_on_the_appropriate_element_queue();\n}\n\n",
          "new_text": null,
          "old_line_content": "    ensure_custom_element_reaction_queue().append(CustomElementUpgradeReaction { .custom_element_definition = custom_element_definition });",
          "new_line_content": "{",
          "content_same": false
        },
        {
          "line": 2037,
          "old_api": "ame, JS::MarkedVector<JS::Value> arguments)\n{\n    //",
          "new_api": null,
          "old_text": "ame, JS::MarkedVector<JS::Value> arguments)\n{\n    // ",
          "new_text": null,
          "old_line_content": "    enqueue_an_element_on_the_appropriate_element_queue();",
          "new_line_content": "",
          "content_same": false
        },
        {
          "line": 2046,
          "old_api": "end",
          "new_api": null,
          "old_text": "ifecycle_callbacks().end())\n        return;\n\n    if (",
          "new_text": null,
          "old_line_content": "    auto callback_iterator = definition->lifecycle_callbacks().find(callback_name);",
          "new_line_content": "",
          "content_same": false
        }
      ]
    },
    "api_summary": {
      "total_replacements": 118,
      "total_additions": 461,
      "total_deletions": 461,
      "total_api_changes": 1040
    },
    "non_api_changes": {
      "has_non_api_changes": true,
      "evidence": {
        "total_diff_lines": 6,
        "api_related_lines": 1040,
        "non_api_lines": 1,
        "non_api_line_numbers": [
          574
        ]
      }
    },
    "api_calls_before": 1246,
    "api_calls_after": 1246,
    "diff_info": {
      "added_lines": 5,
      "removed_lines": 3,
      "total_diff_lines": 29
    }
  }
}